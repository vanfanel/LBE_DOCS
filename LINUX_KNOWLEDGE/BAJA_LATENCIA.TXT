LO MÁS BÁSICO
==============

Empezamos consiguiendo los privilegios para establecer prioridad de tiempo real en nuestros procesos.
Tienes que tener en /etc/security/limits.conf:
@audio   -  rtprio     99
@audio   -  memlock    unlimited
@audio   -  nice    -20
pi   -  rtprio     99
pi   -  memlock    unlimited
pi   -  nice       -20

Puedes comprobar que tienes los límites quitados haciendo:
ulimit -r -l
Nos tiene que salir algo como:
real-time priority (-r) 99
max locked memory (kbytes, -l) unlimited
¡¡¡CUIDADO!!!! COMPRUEBA ESTO EN LOCAL Y NO POR SSH, porque POR SSH PUEDE NO FUNCIONAR Y SÍ EN LOCAL.

Para aprovechar esto,  usaremos una de las dos políticas de REALTIME de LINUX:

-SCHED_FIFO: Usa "chrt -f 99", que le da prioridad realtime y no suelta la CPU porque no hay otra aplicación con la misma o superior prioridad que la pida
(o sea, es FIFO de máxima prioridad), asi que MIENTRAS NO ACABE, COMO LLEGÓ ANTES, NO SUELTA LA CPU ni a palos.

-SCHED_RR: Hay ROUND ROBBIN de máxima prioridad también, con lo cual se reparten rodajas de tiempo de un tamaño determinado continuamente. Esto se haría 
con "chrt -r 99". 
CUIDADO: ROUND ROBBIN produce más interrupciones del scheduler, por lo que -f es más estable, los programas bailan menos entre una CPU y otra, y claro, al generarse
menos interrupciones del scheduler, las cosas que yo suelo ejecutar van mejor. Cuidado, porque un RR 99 produce cuelgues incluso si estás ejecutando lo que sea con esa
prioridad en CPUs aisladas.

PARA TENER TAREAS CON GARANTÍAS DE TIEMPO REAL, ESTO ES, QUE NO SERÁN INTERRUMPIDAS Y SACADAS DE UNA CPU POR OTRAS TAREAS,
NO HACE FALTA RECOMPILAR EL KERNEL, YA QUE LO QUE PERMITE CONFIGURAR EL KERNEL ES SI EL PROPIO KERNEL ES PREEMTIBLE (MÁS PREEMPTIBLE EN FULL RT QUE EN VOLUNTARY, 
POR EJEMPLO), PERO ESTO A NOSOTROS NOS DA IGUAL (CON TAL DE QUE SEA UN KERNEL PREEMPTIBLE HASTA CIERTO PUNTO, QUE YA LO ES POR DEFECTO). LO QUE NOS INTERESA
ES PODER AISLAR CPUs PARA QUE SÓLO SE EJECUTEN EN ELLAS TAREAS DETERMINADAS, ES DECIR, CREAR CPUs PRIVILEGIADAS.
PARA ELLO, simplemente añade a los parámetros del kernel:
isolcpus=1-3
Se le puede pasar un rango de CPUs separado por un guión, tal que: isolcpus=1-3 aislaría las CPUs del 1 al 3 y dejaría la 0 para housekeeping. A las 1,2 y 3, si no les pasamos nada
con taskset no se ejecuta nada en ellas.
..para que el scheduler no elija esas CPUs para cosas del kernel ni para ninguna otra tarea multithread (como compilar con -jn), excepto que yo le diga específicamente que las use
mediante taskset.

Y luego cargas el programa, por ejemplo, con taskset -c 2 <mombre_programa> para que se ejecute en la CPU 2, que está "aislada" de procesos del kernel, y listo.
O con taskset -c 2,3, si quieres elegir varias (si el proceso es multithread) y ya.
¡¡¡¡MUCHO OJO!!!!: PARA QUE EL PROGRAMA REALMENTE USE LAS CPUs DE LA LISTA QUE LE PASAS A TASKSEL, TIENES QUE CAMBIAR LA POLÍTICA DE SCHEDULING DEL PROCESO, O SI NO
SÓLO ELEGIRÁ LA PRIMERA DE LA LISTA (esto es porque la política de scheduling por defecto, SCHED_OTHER, sólo elige la primera CPU, así que usamos SCHED_RR) . Así que haríamos:
chrt -f 99 taskset -c 1-3 <programa>

Por ejemplo: pogamos que tenemos aisladas las CPUs 1,2 y 3, y queremos compilar un programa usando esas tres CPUs: pues haríamos
chrt -f 99 tasksel -c 1,2,3 make -j4
(o bien chrt -f 99 tasksel -c 1-3 make -j4, que es lo mismo sólo que pasando la lista de CPUs separaga por un guión)

Los emuladores, como no suelen usar varios threads, con mandarlos a una CPU aislada basta, en plan:
taskset -c 3 <emulador>

Para ver mejor estas cosas en TOP, a parte de activar que se vea la CPU (F y luego darle a D sobre la opción), puedes poner un periodo más pequeño pusaldo D directamente y
metiendo algo como 0.1.
¡¡¡¡OJO!!!! : Un proceso con prioridad -80 tiene prioridad de tiempo real: LAS PRIORIDADES NEGATIVAS SON DE TIEMPO REAL, ES DECIR, LAS MÁS ALTAS QUE EL KERNEL PUEDE
OFRECER (hasta donde su preemptiveness lo permita, claro: cuando más preemtivable es un kernel, más puede garantizar que, al menos él, no va a interrumpir a la tarea de
prioridad de tiempo real).

EL RESÚMEN QUE SIGUE ES TODO LO QUE TIENES QUE SABER:
EN RESÚMEN: HABIENDO AISLADO LAS CPUs DEL 1 al 3 CON "isolcpus=1-3" EN CMDLINE.TXT: 
-Para lanzar algo como un emulador que no son multithread:
taskset -c 3 ./retroarch
-Para lanzar algo MUY multithread (y que por tanto puede aprovechar varios cores) como el GZDOOM:
chrt -f 99 taskset -c 1-3 ./gzdoom
Yo uso -f 50, o -f 99..., que es SCHED_FIFO: los programas pillan la CPU y no la sueltan hasta que no acaban. La alternativa, -r, es SCHED_RR, que reparte rodajas de un tamaño
determinado toooodo el rato, con lo que se generan más interrupciones de scheduling y no nos interesa tanto. ASÍ QUE USA -f mejor.
CUIDADO con el -r 99: se producen cuelgues.

SOBRE EL PARÁMETRO DEL KERNEL nohz_full, LAS CPUs TICKLESS, ETC... (OJO!! PASA DE ÉL: EXPLICACIÓN AL FINAL DE ESTA SECCIÓN)
Para comprobar las interrupciones que han sufrido las CPUs desde el inicio del sistema:
watch -n1 -d 'cat /proc/interrupts'
Lo de -n1 es para que lo muestre actualizado a cada segundo, y -d para que marque los cambios.
Se supone que nohz_full=<grupo de cpus> hace que no reciban su dosis de interrupciones por los ticks del kernel, pero NO HACE FALTA QUE USES ESO PORQUE:
1- Es para situaciones donde, en la CPU totalmente tickless, sólo tienes un proceso que sólo tiene un thread, y ningún emulador o juego nativo es así.
2- Habría que compilar el kernel con opciones especiales, porque si lo usas con un kernel normal no sale en DMESG lo de NO_HZ: Full dynticks CPUs: 2-3 (o el rango que sea).
3- De todos modos, si miras watch -n1 -d 'cat /proc/interrupts', verás que las CPUs aisladas no van recibiendo interrupciones: se quedan en 11 o así, paradas, hasta que
     ejecutamos algo en ellas y sólo entonces se incrementa el número de interrupciones que les llegan. Te interesa la fila de REESCHEDULING INTERRUPTS, que verás
     que no se mueve hasta que ejecutas algo en las CPUs aisladas.
LAS CPUs AISLADAS NO RECIBEN INTERRUPCIONES DEL SCHEDULER CUANDO NO SE LAS USA, Y CUANDO SE LAS USA SÍ RECIBEN INTERRUPCIONES DE REESCHEDULING
(a parte de montones de interrupciones por la propia ejecución del programa!!), PERO ES NORMAL QUE RECIBAN INTERRUPCIONES DE REESCHEDULING PORQUE LOS 
PROGRAMAS QUE TÚ EJECUTAS SON MULTITHREAD, ASÍ QUE EL SCHEDULER TIENE QUE REPARTIR ESOS THREADS ENTRE LAS DISTINTASCPUs DEL GRUPO DE CPUs AISLADAS.
SÓLO PODRÍAS ESPERAR QUE UNA CPU NO RECIBIERA INTERRUPCIONES DE REESCHEDULING SI SÓLO EJECUTASES UN PROGRAMA CON UN SÓLO THREAD EN ÉL, Y ESO NO
PASA CON NADA DE LO QUE EJECUTAS. 
ASÍ QUE NO TE RAYES CON ESTO, PASA DE nohz_full. Que te sirva para entender mejor el scheduler y ya.

Luego hay cosillas para disminuir el jittering sin recompilar el kernel. Las pistas las he sacado de aquí:
http://highscalability.com/blog/2015/4/8/the-black-magic-of-systematically-reducing-linux-os-jitter.html
Un resúmen con instrucciones específicas:
-De las Transparent Huge Pages me olvido, porque al hacer "sudo sysctl -a | grep hugepage" veo que no hay de eso en mi sistema. En caso de haberlas, mira esto:
 https://unix.stackexchange.com/questions/99154/disable-transparent-hugepages
-Desactivamos el swappiness poniendo en el /etc/rc.local:
echo 0 > /proc/sys/vm/swappiness

PREFACIO
=========

https://www.kernel.org/doc/Documentation/kernel-per-CPU-kthreads.txt
https://www.kernel.org/doc/Documentation/timers/NO_HZ.txt
https://access.redhat.com/sites/default/files/attachments/201501-perf-brief-low-latency-tuning-rhel7-v1.1.pdf

Se trata de dejar todos los threads del kernel que podamos en UNA sola CPU, que llamaremos "housekeeping CPU", y el resto de CPUs quedarán libres de jittering ya que estos hilos
no corren en ellas.

Los kthreads de RCU podrian no existir si compilamos con CONFIG_PREEMPT=n, pero claro, eso NO interesa para tiempo real, lo dice uno de los docs.

PARTE 1: Los TICKS de sistema
==========================

Esto es para que no se le manden a todos los cores ticks de manera contínua. Esto es bueno para tener cores donde sólo se ejecuta UN y sólo UN programa, y un core de housekeeping
donde mandamos todos los theads del kernel. 

En GENERAL SETUP->TIMERS SUBSYSTEM, elegimos
Full dynticks system (tickless)
y también 
Full dynticks system on all CPUs by default (except CPU 0)

Eso ya nos condiciona a que la única CPU que va a tener TICKS periódicos (que son para proporcionar hora del sistema y cosas así) es sólo la 0.
Las demás serán con ticks dinámicos o DYNTICS, que es mejor para realtime.

(sacado de https://www.kernel.org/doc/Documentation/timers/NO_HZ.txt)
"The CONFIG_NO_HZ_FULL=y Kconfig option causes the kernel to avoid
sending scheduling-clock interrupts to CPUs with a single runnable task,
and such CPUs are said to be "adaptive-ticks CPUs".  This is important
for applications with aggressive real-time response constraints because
it allows them to improve their worst-case response times by the maximum
duration of a scheduling-clock interrupt."

PARTE 2: Los RCU
===============

En GENERAL SETUP->RCU SUBSYSTEM, elegimos
Offload RCU callback processing from boot-selected CPUs,
de manera que el procesado de callbacks del kernel se mande a hilos tipo rcu* que podemos mover a la CPU de housekeeping.

No build_forced no-CBs CPUs, 
de  manera que no haya una CPU libre de threads rcu* sino que luego movamos nosotros esos hilos a la CPU de housekeeping.

Pulsa "?" sobre "Offload RCU callback processing from boot-selected CPUs" y lee sobre los nombres de los threads de control que se van a crear
a partir de ahora, y que puedes mover a la CPU que quieras.
Se puede usar el parámetro del kernel rcu_nocbs=... para especificar qué CPUs descargar de callbacks en tiempo de arranque, por ejemplo con rcu_nocbs=1,2,3
se dejan las CPUs 1, 2 y 3 sin RCU callbacks y todas irán en la 1. 
También se pueden mover los threads RCU después de arrancar a una CPU concreta, como vamos a ver a continuación, en este caso la 0, con:

for i in `pgrep rcuo` ; do taskset -pc 0 $i ; done

Si lo has hecho bien (con que le pases rcu_nocbs=1,2,3 vale, si tienes las opciones correctas en el kernel), en TOP tienes que ver que, por ejemplo, los threads
rcuop/2
rcuob/2
rcuos/2
rcuop/3
rcuob/3
rcuos/3
...tienen que estar en la CPU 0, a pesar de que son de la 2 y la 3 (para mirarlo, ahí abajo tienes apuntes de TOP de cómo se mira en qué CPU corrió el thread por última vez).

PARTE 3: ISOLCPUS
================

Vamos a decirle al scheduler que no elija ciertos cores para ejecutar cosas. Le pasamos al kernel el parámetro:
isolcpus=1,2,3
para que sólo elija el core 0 a la hora de pasarle "trabajo".

Además, en combinacion, cogemos y lanzamos nuestro programa "delicado" pegado a una CPU concreta, de las que tenemos aisladas, así:
taskset -c 3 <nombre_programa>

Puede ser una lista de cpus:
taskset -c 1,2,3 <nombre_programa>

OTRAS COSAS
============

En GENERAL SETUP, deshabilitamos el PROFILING SUPPORT (lo que se lleva por delante el oprofile).
Quedaría mirar lo de compilar sin governor, en CPU POWER MANAGEMENT -> CPU FREQUENCY SCALING, y luego poner la velocidad de la CPU a mano.
Mírate "man 2 sched_setaffinity" si quieres controlar que un thread determinado tenga afinidad a una CPU.

CÓMO COMPROBAR EN QUÉ CPU CORRE CADA PROCESO
==================================================

En TOP, pulsamos F mientras estamos ejecutándolo. En el menú que nos sale, podemos pulsar D sobre lo que queramos que se vea / que no se vea, elegimos que se vea
el campo "P       = Last Used Cpu (SMP)", y le damos a ESCAPE, de manera que podemos ver en qué CPU corre cada cosa.
