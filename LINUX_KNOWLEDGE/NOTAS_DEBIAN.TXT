FINETUNING THE SYSTEM
=====================

Una vez que hemos arrancado nativamente, tenemos mucho que hacer.

-Para configurar la WIFI una vez arrancado el sistema sin escritorio, en Debian es editando /etc/network/interfaces,
y en Raspbian es usando el raspi-config.

-Para que no se quede esperando al apagar el sistema cuando no tenemos WIFI, crea el fichero
/etc/systemd/system/networking.service.d/override.conf
con el contenido:
[Service]
ExecStop=
...Alternativamente con este contenido también funciona:
[Service]
TimeoutStopSec=1s
...La idea es simplemente que NO se quede esperando para tirar el interface WIFI cuando ni siquiera lo pudo levantar.
La primera manera es simplemente no intentar tirarlo siquiera, y la segunda ponerle un timeout de 1s. No pongas 0s porque es infinito.
...Y para aplicar los cammbios sin reiniciar: systemctl daemon-reexec

-RECUERDA que para poder logearte por SSH como ROOT tienes que editar /etc/ssh/sshd_config y: 
	-Poner "PermitRootLogin" a "yes"
	-Ya que estás, deja comentada la línea:
		#AcceptEnv LANG LC_*
	...lo que nos ahorra errores de LOCALES cuando usamos APT-GET por SSH.
	
-SI AÚN ASÍ SIGUES TENIENDO PROBLEMAS CON LOS LOCALES POR SSH:
--Usa "dpkg-reconfigure locales" para generar el locale "en_US.UTF-8" y sólo ese.
--Edita /etc/default/locale y déjalo así:
LANG=en_US.UTF-8                                                                                               
LC_ALL=en_US.UTF-8                                                                                             
LC_TIME=en_US.UTF-8                                                                                            
LC_MONETARY=en_US.UTF-8                                                                                        
LC_ADDRESS=en_US.UTF-8                                                                                         
LC_TELEPHONE=en_US.UTF-8                                                                                       
LC_NAME=en_US.UTF-8                                                                                            
LC_MEASUREMENT=en_US.UTF-8                                                                                     
LC_IDENTIFICATION=en_US.UTF-8                                                                                  
LC_NUMERIC=en_US.UTF-8                                                                                         
LC_PAPER=en_US.UTF-8                                                                                           
LANG="C"	

-Conexión por SSH con mucho lag: Edita /etc/network/interfaces y añade al final:
wireless-power off

-Ponemos el governor a PERFORMANCE.

OPCIÓN 1 (RECOMENDADO): Lo más sencillo es añadir a la línea de comandos del kernel: cpufreq.default_governor=performance
Y si estás en la raspberry Pi (en Debian normal de X86 no hace falta), deshabilita el servicio raspi-config,
por si establece otro valor contradictorio.
OPCIÓN 2 (EN LA RASPBERRY PI Y NO RECOMENDADO): Edita /etc/init.d/raspi-config y en la línea de CPU_DEFAULT_GOVERNOR cambiar "ondemand" por "performance". Luego obviamente NO deshabilites el servicio "raspi-config.service" porque es el que aplica el governor.
EN AMBOS CASOS, PUEDES COMPROBARLO CON:
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor

-Crear el usuario pi:
sudo adduser pi
sudo adduser pi sudo
sudo adduser pi audio
sudo adduser pi video
(Esto último es importante, porque has estado dando vueltas y el kernel sí reconocía el audio interno y la hifiberry (cat /proc/asound/cards)
pero aplay -L no listaba los dispositivos...¡porque no estabas en el grupo audio!)

-DESINSTALAMOS loggers y cosas raras, que se llevan por delante servicios que no usamos:
apt-get purge triggerhappy rsyslog cron dphys-swapfile bluetooth avahi-* fake-hwclock
(NOTA: fake-hwclock no se usa porque en su lugar uso systemd-timesyncd que sincroniza la hora al conectarase a la red
 y guarda la hora en disco al reiniciar, con lo que fake-hwclock es redundante.)

-EN RASPBIAN: Deshabilitamos estos servicios:
systemctl mask e2scrub_all.timer
systemctl mask e2scrub_reap.service
systemctl mask man-db.service
systemctl mask man-db.timer
systemctl mask rc-local.service
systemctl mask rpcbind.service
systemctl mask rpcbind.socket
systemctl mask rpi-eeprom-update.service
systemctl mask run-rpc_pipefs.mount
systemctl mask sys-fs-fuse-connections.mount
systemctl mask sys-kernel-debug.mount
systemctl mask sys-kernel-tracing.mount
systemctl mask systemd-rfkill.service
systemctl mask systemd-rfkill.socket

-EN DEBIAN: Deshabilitamos estos servicios:
systemctl mask apparmor.service
systemctl mask e2scrub_all.service
systemctl mask e2scrub_all.timer
systemctl mask fstrim.timer
systemctl mask apt-daily.service
systemctl mask apt-daily.timer
systemctl mask apt-daily-upgrade.service
systemctl mask apt-daily-upgrade.timer
systemctl mask bluetooth.target
systemctl mask dpkg-db-backup.service
systemctl mask dpkg-db-backup.timer
systemctl mask sys-fs-fuse-connections.mount
systemctl mask logrotate.service
systemctl mask logrotate.timer
systemctl mask man-db.service
systemctl mask man-db.timer
systemctl mask sys-kernel-debug.mount
systemctl mask sys-kernel-tracing.mount
systemctl mask systemd-rfkill.service
systemctl mask systemd-rfkill.socket
systemctl mask systemd-update-utmp-runlevel.service
systemctl mask rc-local.service
systemctl mask remote-fs.target
systemctl mask swap.target
systemctl mask dev-sda3.swap  

(OJO: Servicios que NO DEBES DESHABILITAR:
	-NetworkManager, que se usa para conectarse a la Wifi usando raspi-config y que deja las redes conocidas
	 en /etc/NetworkManager/system-connections, en lugar de en /etc/wpa_supplicant/wpa_supplicant.conf
	-systemd-journald, que lo usaremos para ver los mensajes de inicio del kernel y los servicios con el comando "journalctl"
	-systemd-logind, que lo usaremos para que libseat sepa que estamos logueados sin tener que usar el servicio seatd
	 (seatd lo usaremos en sistemas embedidos sin systemd). Esto sirve para poder levantar Wayland compositors.
	-El servicio raspi-config.service, porque aplica los settings del governor de la CPU que configuramos en /etc/init.d/raspi-config
	-Los servicios que preparan o limpian las tmpfiles, aunque mandes todo eso a RAM
	-El servicio system-getty.slice, que sirve para gestionar los recursos de GETTY en las TTYs,
	aunque nos spawnee una getty por cada TTY del 1 al 6.
	Si lo deshabilitas, el autologin en la TTY funciona, pero el servicio no respawnea al hacer un logout escribiendo "exit".
	El truco es dejar system-getty.slice vivo, editar /etc/systemd/logind.conf y poner NAutoVTs a 1 o 2,
	dependiendo si quieres autologin en una TTY o en dos, o vamos, en las que vayas a usar concretamente.
	De ese modo nos funciona el autologin en las TTYs que queramos, y ademas funciona el respawn al escribir "exit".
)

-Para eliminar el error de "automount point not supported", simplemente haz:
sudo depmod -a
Y reinicia. Ya no debería salir más.

-Ponemos autologin en tty1 y tty2:
	-Creamos los ficheros: 
	/etc/systemd/system/getty@tty1.service.d/autologin.conf
	/etc/systemd/system/getty@tty2.service.d/autologin.conf
	-Metemos en ambos ficheros esto:
		[Service]
		ExecStart=
		ExecStart=-/sbin/agetty --autologin root --noclear --skip-login --nonewline %I $TERM
		TTYVTDisallocate=no
	-Activamos los servicios:
		systemctl enable getty@tty1.service
		systemctl enable getty@tty2.service	
	-Si queremos que la consola no se limpie al acabar el inicio del sistema o al hacer logout, creamos
	/etc/systemd/system/getty@tty1.service.d/noclean.conf
	con el contenido:
		[Service]
		TTYVTDisallocate=no

-Si después de hacer lo del autologin no puedes cambiar a TTY2 (ctrl+alt+f2), es porque no has activado el servicio. Haz:
sudo systemctl enable getty@tty2.service
Y ya podrás cambiar de TTY1 a TTY2!!!

-PARA ACTIVAR EL AUTOCOMPLETION COMO ROOT:
Editamos /etc/bash.bashrc y descomentamos la sección correspondiente (busca "completion" y lo ves enseguida).

***BLOQUE ALSA****
-PARA INSTALAR ALSA:
Instalamos alsa-utils, pero NO desde el entorno chrooted sino nativamente.
Si no tienes red en la Pi, puedes descargar los paquetes en el entorno chrooted, y luego instalarlos en nativo, o sea, en dos pasos, mira:
1) En el entorno chrooted:
sudo apt-get clean (para que no haya lios con otros paquetes en /var/cache/apt/archives)
sudo apt-get install --download-only alsa-utils
2) En el entorno nativo, es decir, en la Pi sin red:
cd /var/cache/apt/archives
sudo dpkg -i *
AHORA PASA A CREAR /etc/asound.conf, cuyo contenido varía si usas la HIFIBERRY o si no la usas:

-Si usas la hifiberry, acuérdate que en config.txt tienes que tener para que funcione:
dtoverlay=hifiberry-dacplus
Y la línea del audio interno comentada, para que el kernel sólo cargue la hifiberry:
#dtparam=audio=on

ESTO ES IMPORTANTE: Para que siempre se elija la hifiberry como tarjeta por defecto, crea este /etc/asound.conf:
pcm.!default {
    type hw
    card sndrpihifiberry
}

ctl.!default {
    type hw    
    card sndrpihifiberry
}

-Ahora ajusta los niveles en ALSAMIXER, que se van a quedar como los dejes porque vamos a quitar los servicios que los guardan y los restauran

-Y ahora quita los servicios que guardan y restauran los niveles de ALSA:
sudo systemctl mask alsa-state.service 
sudo systemctl mask alsa-restore.service

Y ya van a quedar así para siempre los niveles. Si los quieres cambiar, pues unmaskeas los servicios state y restore, los cambias, reinicias y los vuelves a maskear.

****FIN BLOQUE ALSA****

-Crear el /usr/bin/netup con:
sudo ifconfig eth0 up
sudo ip addr add 192.168.5.8/24 dev eth0
sudo ip route add default via 192.168.5.7
sudo systemctl start dropbear
(OJO: dropbear ya no arranca a mano con '/etc/init.d/dropbear start')

-Instalar dropbear, generar sus claves y quitarlo del arranque sin maskearlo, porque si no luego no arranca desde mi script netup.
(Esto además instala fuentes, setup de la consola y todo eso, que nos va a hacer falta)
apt-get install dropbear
dropbearkey -t rsa -f /etc/dropbear/dropbear_rsa_host_key
sudo systemctl disable dropbear
(CUIDADO QUE SIN LAS CLAVES NO FUNCIONA!!!)

-Configuramos la consola, el teclado y los locales (NO LO HAGAS POR SSH, o fallará por culpa de los LOCALE de la máquina
desde la que te conectas y perderás un buen rato):
sudo apt-get install locales console-setup console-data keyboard-configuration
sudo dpkg-reconfigure console-setup
sudo dpkg-reconfigure locales
(Elegimos que se generen en_US.UTF8 y es_ES.UTF, y dejamos puesto en_US.UTF8. ESTO nos quita errores de teclado a través de SSH,
ya que necesitamos los LOCALES de la máquina cliente también).
sudo dpkg-reconfigure keyboard-configuration
Tras reiniciar (sí, hay que reiniciar), ya tendría que ir la Ñ, los acentos y todo eso.

Otra manera más sencilla de evitar esos errores por SSH es editar /etc/ssh/sshd_config y comentar:
	# Allow client to pass locale environment variables
	# AcceptEnv LANG LC_*
Si lo haces así no necesitas regenerar es_ES.utf8, con en_US.utf8 vale.	

Si queremos cambiar la distribución del teclado de nuevo (porque cambiamos de sistema y/o teclado) basta con volver a hacer:
sudo dpkg-reconfigure keyboard-configuration
Eso sí, asegúrate antes de que el comando "locale" nos dice que está todo a en_US.UTF-8.

-Vamos quitando los servicios con:
sudo systemctl mask <sevcio>

-Para que funcione el teclado, ratón y joystick con las SDL2, creamos /etc/udev/rules.d/99-evdev.rules con el contenido:
KERNEL=="event*", NAME="input/%k", MODE="666"
Y reiniciamos.

-SI QUITAS systemd-journald (NO RECOMENDADO)
---Para quitar el error de DMESG: "Failed to connect stdout to the journal socket"
Edita /etc/systemd/system.conf y pon LogTarget=null.
---Para quitar el error: "Failed to listen on journal socket"
Mira a ver qué sockets están activos con:
systemctl | grep socket
...Y le haces un "systemctl mask" a los que queden.
También hazle "systemctl mask" a sockets.target.
Algunos ejemplos:
systemctl mask systemd-journald.socket
systemctl mask systemd-journald-dev-log.socket
systemctl mask systemd-rfkill.socket

-Para ocultar los mensajes de systemd en el inicio, pon en cmdline.txt:
systemd.show_status=false

-Para evitar errores en el inicio relacionados con systemd-journald-audit.socket (que nosotros NO tenemos), pon en cmdline.txt:
audit=0

-Para evitar parones (stalls) en el vídeo de los juegos debido al i/o scheduler, pon en cmdline.txt:
elevator=noop

-En .bashrc, descomenta para tener el prompt en color:
force_color_prompt=yes

-El mensaje que quieras que se vea en el inicio, ponlo en /etc/issue

-PARA USUARIOS NORMALES SOLAMENTE:
TENEMOS QUE QUITAR LOS RLIMITS, o los emuladores se empezarán a quejar al llegar al 80% de uso de la CPU!
Para ello, editamos /etc/security/limits.conf, añadiendo unas cosillas para quitar ciertas limitaciones a los miembros de ese grupo:

@audio   -  rtprio     99
@audio   -  memlock    unlimited
@audio   -  nice    -20
pi   -  rtprio     99
pi   -  memlock    unlimited
pi   -  nice       -20

De este modo, no hay límites para el usuario Pi ni para nadie del grupo audio, como jackd.
Comprobamos que tenemos quitados esos límites con:
ulimit -r -l
Nos tiene que salir algo como:
real-time priority (-r) 99
max locked memory (kbytes, -l) unlimited
¡¡¡CUIDADO!!!! COMPRUEBA ESTO EN LOCAL Y NO POR SSH, porque POR SSH PUEDE NO FUNCIONAR Y SÍ EN LOCAL.

-Para configurar el audio con el driver de audio HDMI del lado de ARM (que es como lo venimos haciendo ahora):
	PREVIO: En el momento en que usamos el sistema KMS (dtoverlay=vc4-kms-v3d) obtenemos el dispositivo ALSA de audio llamado vc4hdmi,
	que mete los frames de audio en los periodos de blanking del vídeo.
	Al usar KMS, el kernel se encarga del vídeo y de meter esos frames de audio en el blanking de vídeo, así que el audio del lado del
	firmware (es decir, el audio bcm2835) NO PUEDE FUNCIONAR CON KMS.

	-Para usar el vídeo KMS, tenemos que tener en config.txt:
		dtoverlay=vc4-kms-v3d
		#dtparam=audio=on <---SE DEBE deshabilitar la carga de bcm2835.
		(Si quisiéramos desactivar el dispositivo de audio vc4hdmi a la vez que usamos KMS, usaríamos esto: dtoverlay=vc4-kms-v3d,noaudio
		 PERO OLVÍDATE de tener KMS y a la vez audio del lado del firmware (bmc2835) cargando manualmente el módulo snd_bcm2835
		 o si usamos el init por defecto descomentando la línea "dtparam=audio=on", PORQUE combinar KMS con el audio bcm2835
		 es imposible como ya se ha dicho: SI USAMOS KMS, NO PODEMOS USAR EL AUDIO BMC2835, SÓLO EL AUDIO VC4HDMI.)
	 RECUERDA que ninguno de los parámetros hdmi_* de config.txt funciona en modo KMS! El modo de vídeo, por ejemplo,
	 se establecería añadiendo a cmdline.txt algo como:
	 video="HDMI-A-1:1280x720@60"
	-Si falla speakertest, mira que tengas en /usr/share/alsa/cards/vc4-hdmi.conf la última versión que siempre está disponible
	 en: https://github.com/alsa-project/alsa-lib/blob/master/src/conf/cards/vc4-hdmi.conf
	-Si falla algo, pregunta a dom en el foro de Raspberry Pi.
     Y YA. CON ESTO TIENE QUE FUNCIONAR SÍ O SÍ. 

-Si el guardado y restauración de los valores de alsamixer falla a veces, tienes DOS opciones:

	1) LA MÁS RECOMENDABLE AHORA MISMO, Y LA QUE MÁS CONTROL TE DA: Modificar el servicio alsa-restore.service.
	   No está roto el servicio en sí, sino que cuando es lanzado, el mezclador aún no está accesible porque el driver está mal y hasta que un 
	   programa no reproduce audio, no aparece disponible el mezclador (lo puedes comprobar porque alsamixer no muestra controles hasta que
	   un programa ha reproducido algo).
	   Para "parchear" el problema, edita así el servicio de manera que no se sobreescriban los cambios en las acltualizaciones:
	
	   sudo systemctl edit --full alsa-restore.service

	   Y lo dejas con este contenido (o sea, pasas de usar "alsactc restore" y lo que haces es reproducir un sonido y a continuación
	   restauras el volúmen que te de la gana):
	   
[Unit]
Description=Restore volume

[Service]
Type=oneshot
RemainAfterExit=false
ExecStartPre=-/usr/bin/aplay /dev/zero -s 1 -q
ExecStart=-/usr/bin/amixer set PCM 230 -q
       
       El valor 230 NO se corresponde linealmente con un volúmen de 0 a 100, es 80%. Ya sabes, las cosas del audio.

       CADA VEZ que quieras ajustar el volúmen guardado, te toca hacer: sudo systemctl edit --full alsa-restore.service
       Pero vamos, que lo controlas tú todo a tu gusto.
       Puedes crearte un script en /usr/local/bin/volume con el contenido:
       sudo systemctl edit --full alsa-restore.service

	2) (Actualmente no válido porque falla "alsactl restore"). Deshabilitar el servicio alsa-restore.service (sudo systemctl mask alsa-restore.service), pon los controles a tu gusto en alsamixer, y guarda la configuración con:
		alsactl store -f /etc/asound.state
		Prueba a cargar la configuración con:
		sudo alsactl restore -f /etc/asound.state
		Si todo va bien, ALSA va a restaurar esos valores en cada arranque, leyéndolos de /etc/asound.state, sin que hagas nada y sin ningún servicio.
		Si quieres, puedes aniadir lo de alsactl restore al .profile		

	-CÓMO USAR LA HIFIBERRY: Se supone que funciona siempre porque aunque el ordering de las tarjetas puede cambiar entre arranques,
		estamos espeficicando la tarjeta por defecto en /etc/asound.conf con el contenido:
	    	pcm.!default {
    			type hw
    			card sndrpihifiberry
			}
			
			ctl.!default {
    			type hw    
    			card sndrpihifiberry
			}					
		Deshabilita el servicio alsa-restore.service, y pon en .profile:
		amixer set Digital 85% -q
		Esto lo que hace es que te pone el control llamado Digital a 55 (no a 85 como podría parecer).
		Puedes ver los controles con "amixer scontrols".
		Vamos, que esto lo que hace es que pongas a mano el valor que quieras para cada control de la tarjeta por defecto
		(también se puede elegir tarjeta y tal, mira "man amixer" si ves que te hace falta).

	-EXPERIMENTAL, NO FUNCIONA: Sería la más recomemdada: soluciona los problemas de ordering, porque tienes dos tarjetas. Para ello, crea /etc/modprobe.d/alsa-base.conf con:
		options snd_soc_hifiberry_dacplus index=0
		options vc4 index=1
	 De esta manera, el servicio de restauración de ALSA (alsa-restore.service) no debería fallar nunca, porque la primera tarjeta es siempre la hifiberry y aplicaría los
	 valores guardados correctos para cada tarjeta en el arranque, ya que el ordering de las tarjetas no cambiaría nunca.
            
Recuerda mirar las mierdas que lanza systemd en el arranque antes de ocultarlo, y mira los targets con
sudo systemctl | grep <loquesea>
Luego los vas quitando, al igual que los services, con systemctl mask <monbre service o target>
Si metes la pata y el sistema no arranca más, elimina cosas de /etc/systemd/system, que es donde pone los links a /dev/null correspondientes a los services o targets que hayas eliminado
sin deber hacerlo...

-Para conectarte automaticamente a una WIFI, lo mejor es tener activado el servicio NetworkManager y meter la red/contraseña en raspi-config,
en la seccion system->wireless lan.
Las redes conocidas quedan guardadas en /etc/NetworkManager/system-connections, en lugar de en /etc/wpa_supplicant/wpa_supplicant.conf

-Si PING te da el error "ping: socket: Address family not supported by protocol", simplemente haz:
sudo chmod 4755 /bin/ping
Y ya te irá perfectamente.

Teclado en español y con la tilde (~) en la Ñ sin tener que darle dos veces
===========================================================================

Editamos /etc/default/keyboard, y lo dejamos así:

XKBMODEL="pc105"                                                                                               
XKBLAYOUT="es"                                                                                                 
XKBVARIANT="deadtilde"                                                                                        
XKBOPTIONS=""                                                                                                  
BACKSPACE="guess"

Sin lo de "deadtilde", tenemos que darle a la Ñ dos veces para sacar la tilde, y es una mierda eso.

ACTUALIZAR EL KERNEL SIN COMPLICARNOS NADA
==========================================

Usamos el kernel XenMod. Las instrucciones proceden de aquí: https://xanmod.org/
Y son para Debian 12 Bookworm. Para nuevas versiones de Debian, habrá que actualizarlas.

-Instalamos dependencias previas: apt-get install gpg
-Nos bajamos la clave pública del repo:
wget -qO - https://dl.xanmod.org/archive.key | sudo gpg --dearmor -vo /usr/share/keyrings/xanmod-archive-keyring.gpg
-Añadimos el repo a nuestros sources de APT:
echo 'deb [signed-by=/usr/share/keyrings/xanmod-archive-keyring.gpg] http://deb.xanmod.org releases main' | sudo tee /etc/apt/sources.list.d/xanmod-release.list
-Actualizamos e instalamos el nuevo kernel:
sudo apt update && sudo apt install linux-xanmod-x64v3

ACTUALIZAR RASPBERRY PI OS SIN ACTUALIZAR EL KERNEL
===================================================

Útil para cuando tenemos un kernel especial instalado, como por ejemplo el kernel realtime de: https://github.com/kdoren/linux/releases/

Se hace poniendo el paquete raspberrypi-kernel en "hold", tal que así:

-Actualizamos el índice de paquetes como siempre:
sudo apt-get update

-Ponemos el paquete del kernel en hold:
sudo apt-mark hold raspberrypi-kernel

-Actualizamos los paquetes normalmente. Como el paquete del kernel está en holdo, no se actualizará:
sudo apt-get upgrade

Opcionalmente, si quieres, puedes quitar el hold del paquete del kernel al acabar, haciendo:
sudo apt-mark unhold raspberrypi-kernel

GUARDAR TODOS LOS LOGS EN RAM
=============================

Lo primero es desisntalar rsyslog
apt-get purge rsyslog
(RECUERDA: con systemd-journald nos vale para que nos guarde los logs de sistema,
puedes usar el comando "journalctl" sin mas para ver los mensajes de inicio/parada del kernely los servicios).

Ahora borra los logs de disco:

rm -R /tmp/* 
rm -R /var/tmp/*
rm -R /var/log/*
rm -R /var/spool/* 

Ahora, añade estas lineas a /etc/fstab:

# Added 4 lines to use RAM instead of SSD for temp and log files
tmpfs /tmp tmpfs defaults,noatime,mode=1777 0 0
tmpfs /var/tmp tmpfs defaults,noatime,mode=1777 0 0
tmpfs /var/log tmpfs defaults,noatime,mode=0755 0 0
tmpfs /var/spool tmpfs defaults,noatime,mode=1777 0 0

¡¡¡CUIDADO!!! NUNCA mandes /var a RAM, porque ahi guardan apt-get y otros programas importantes sus datos.
SOLO puedes mandar a RAM esos subdirectorios de /var que te he dicho.
Y NUNCA borres el contenido de /var, solo el contenido de esos subdirectorios que te he dicho.

SACAR EL VÍDEO Y EL AUDIO SÓLO POR HDMI-0 O SÓLO POR HDMI-1
===========================================================

dtoverlay=vc4-kms-v3d,nohdmi0

o bien

dtoverlay=vc4-kms-v3d,nohdmi1

INSTALAR MESA
=============

NOCIONES PREVIAS DE APIS, DEPENDENCIAS, Y SOPORTE DE OPENGL COMPLETO (NO GLES)

Para tener OpenGL "completo" (no GLES), Mesa se puede compilar con GLX (lo que conlleva un cojón de dependencias de X11 y es un asco), o con GLVND (libglvnd, una librería muy ligera de NVIDIA que es libre).
Compilar MESA con OpenGL completo para GLX nos produce libGL.so, y compilar MESA con OpenGL completo para GLVND nos produce libOpenGL.so  

Si compilas con OpenGL completo mediante GLVND, las SDL2 deberían ya detectar y usar libOpenGL.so en vez de libGL.so, y los programas de SDL2
que usen OpenGL completo funcionarán.
Aún así, si algún programa intenta linkar con -lGL, no lo va a encontrar, así que cambia -lGL por -lOpenGL y ya linkará sin problemas.
Si algún programa linka contra -lGLU, elimínalo y ya. No se necesita nada de ahí.

Si MESA te da un error de que no encuentra GL/glxproto.h, reinstala el paquete x11proto-dev

FIN NOCIONES PREVIAS

¡¡¡OJO!!! LO PRIMERO EN DEBIAN SI ESTÁS CON UN USUARIO NORMAL, AÑADE AL USUARIO "pi" AL GRUPO RENDER,
O TE VOLVERÁS LOCO PORQUE GLES NO IRÁ PERO DRM SÍ (o sea, modetest funciona pero MESA no puede cargar GLES). PARA ELLO, HAZ:
sudo usermod -a -G render pi

Empezamos con libDRM:

Elimimanos el libDRM del sistema, que es viejo siempre:
apt-get purge libdrm*
Instalamos estas dependencias previas:

sudo apt-get install meson xsltproc libpciaccess-dev xutils-dev libtool make cmake automake pkg-config \
gcc g++ python3-setuptools xz-utils --no-install-recommends

(libgbm NO TENEMOS QUE INSTALARLO ni nada, se compila e instala con MESA automáticamente)
Bajamos la última versión estable de:
https://dri.freedesktop.org/libdrm/
mkdir b4
cd b4

CONFIGURAMOS DRM con esto:

PARA X86_64 CON GPU AMD:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson setup -Dudev=true -Dvc4=disabled -Dintel=disabled -Dvmwgfx=disabled -Dradeon=disabled -Damdgpu=enabled -Dnouveau=disabled \
-Dfreedreno=disabled -Detnaviv=disabled \
-Dinstall-test-programs=true ..

PARA X86_64 CON GPU INTEL XE
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson setup -Dudev=true -Dvc4=disabled -Dintel=enabled -Dvmwgfx=disabled -Dradeon=disabled -Damdgpu=disabled -Dnouveau=disabled \
-Dfreedreno=disabled -Detnaviv=disabled \
-Dinstall-test-programs=true ..

PARA RASPBERRY PI 4/5:

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson setup -Dudev=true -Dvc4=enabled -Dintel=disabled -Dvmwgfx=disabled -Dradeon=disabled -Damdgpu=disabled -Dnouveau=disabled \
-Dfreedreno=disabled -Detnaviv=disabled \
-Dinstall-test-programs=true ..

Compilamos e instalamos:
ninja -j4
sudo ninja install

En este punto, puedes probar si libdrm te funciona bien haciendo:
modetest -s 32:1280x720
(donde 32 es un ID de conector válido: puedes ver los conectores con "modetest|grep connected").
O bien, en X86_64 con AMD, usa: modetest -s 93:1280x720
O bien, en X86_64 con Intel, usa: modetest -s 236:1280x720

¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡ATENCIÓN, ATENCIÓN!!!!!!!!!!!!!!!!!!!!!!!!!!!
SI ESTÁS EN X86_64:
1) Como NINJA/MESON instala las librerías en /usr/local/lib64, y como CMAKE y PKG-CONFIG no buscan
en /usr/local/lib64 por defecto (sólo en /usr/local/lib), creamos el fichero /etc/profile.d/custom.sh con el contenido:
export CMAKE_LIBRARY_PATH=/usr/local/lib64
export PKG_CONFIG_PATH=/usr/local/lib64/pkgconfig
ESTO ES MUY MUY MUY MUY IMPORTANTE HACERLO SIEMPRE. 
2) Añade al final de /etc/ld.so.conf.d/libc.conf la línea:
/usr/local/lib64

CUIDADO: LA ALTERNATIVA A ESTAS DOS COSAS SERÍA, ANTES DE EMPEZAR A INSTALAR NINGUNA LIBRERÍA COMPILADA POR MI,
CREAR /usr/local/lib64 COMO UN SYMLINK DE /usr/local/lib, PERO NO ES BUENA IDEA: ES UN HACK QUE PODRÍA DAR PROBLEMAS.
ASÍ QUE HAZ LAS DOS COSAS QUE ACABO DE DECIRTE.

(NOTA: Todo este lio viene porque MESON instala las cosas en /usr/local/lib64, que se supone que es el sitio correcto,
 y CMAKE las instala en /usr/local/lib.
 Queda pendienden entender por qué, o si esto cambia en futuras versiones de Debian, o qué pasa).

¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡

				DEPENDENCIAS PREVIAS DE MESA

SI QUIERES OPENGL NECESITAS ESTAS DEPENDENCIAS:
apt-get install --no-install-recommends \
    flex bison python3-mako python3-setuptools python3-yaml \
    libexpat1-dev libudev-dev gettext \
    ca-certificates xz-utils \
    zlib1g-dev pkg-config

SI ADEMÁS QUIERES VULKAN NECESITAS ESTAS DEPENDENCIAS:
apt-get install libvulkan-dev libvulkan1 vulkan-tools glslang-tools --no-install-recommends

SI ADEMÁS QUIERES OPENGL COMPLETO SOBRE LIBGLVND, TIENES QUE INSTALAR LIBGLVND:
Bajamos la última estable de aquí:
https://gitlab.freedesktop.org/glvnd/libglvnd/-/tags
Y configuramos con:
CFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Dglx=disabled -Dx11=disabled ..

SI QUIERES QUE MESA FUNCIONE SOBRE WAYLAND, VE E INSTALA WAYLAND AHORA (Mira en el fichero de notas de Wayland).

#####
DEPENDENCIAS EXCLUSIVAS PARA GRÁFICOS INTEL (los números de versión son para Debian 12, pueden cambian en Debian 13 y posteriores):

PARA DEBIAN 13:
apt-get install python3-ply libclang-common-18-dev libllvmspirvlib-18-dev llvm-18-dev libclang-cpp18-dev libclang-18-dev libclc-18 libclc-18-dev

SI AÚN ESTÁS EN DEBIAN 12:
apt-get install python3-ply libclang-common-15-dev libllvmspirvlib-15-dev llvm-15-dev libclang-cpp15-dev libclang-15-dev libclc-15 libclc-15-dev

¡¡¡OJO!!! ES MUY IMPORTANTE QUE COINCIDA EL NÚMERO DE VERSIÓN DE TODO. SI NO, NO COMPILARÁ Y LOS ERRORES SERÁN IMPOSIBLES DE ENTENDER.
#####

NO TE OLVIDES DE AÑADIR AL USUARIO AL GRUPO RENDER:
sudo adduser manuel render
(Si ves un error como "MESA-LOADER: failed to open kms_swrast", es porque no lo has hecho).

					COMPILACIÓN DE MESA COMO TAL

Bajamos los últimos estables de:
https://mesa.freedesktop.org/archive/

--CONFIGURAMOS COMO LO VENIMOS HACIENDO AHORA, CON GLES, GLES2, OPENGL COMPLETO MEDIANTE GLVND Y VULKAN:

PARA X86_64 CON GRÁFICOS AMD (No necesita LLVM, usa el compilador ACO, por eso no hemos instalado LLVM y lo desactivamos aquí):
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson setup -Dbuildtype=release -Dglx=disabled -Dplatforms=wayland \
-Dvulkan-drivers=amd -Dgallium-drivers=radeonsi,zink -Dglvnd=enabled -Dllvm=disabled -Damd-use-llvm=false \
-Dgallium-va=enabled -Dvideo-codecs=h264dec,h265dec,vc1dec ..

PARA X86_64 CON GRÁFICOS INTEL IRIS (=UHD,XE, etc):
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson setup -Dbuildtype=release -Dglx=disabled -Dplatforms=wayland \
-Dvulkan-drivers=intel -Dgallium-drivers=iris,zink -Dglvnd=enabled ..

PARA PI4/5:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson setup -Dbuildtype=release -Dglx=disabled -Dplatforms=wayland -Dllvm=disabled \
-Dvulkan-drivers=broadcom -Dgallium-drivers=v3d,vc4,zink -Dglvnd=enable ..

(Si no quieres soporte para Wayland, usa -Dplatforms='')

(Si quisieras soporte para X11, haríamos "-Dplatforms=wayland" e instalaríamos estas dependencias antes:
 apt-get install libxcb1-dev libxcb-randr0-dev libx11-xcb-dev libxcb-dri3-dev libxcb-present-dev libxcb-shm0-dev libxshmfence-dev libxrandr-dev)

SI QUISIERAS GLES, GLES2 Y OPENGL COMPLETO MEDIANTE GLVND:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson -Dglx=disabled -Dglvnd=true -Dplatforms=wayland -Dllvm=disabled -Dvulkan-drivers='' -Ddri-drivers='' -Dgallium-drivers=vc4,v3d,kmsro -Dbuildtype=release ..

SI QUISIERAS SÓLO GLES Y GLES2, SIN OPENGL COMPLETO:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson -Dglx=disabled -Dplatforms=wayland -Dllvm=disabled -Dvulkan-drivers='' -Ddri-drivers='' -Dgallium-drivers=vc4,v3d,kmsro -Dbuildtype=release ..

COPIAR ARCHIVOS DESDE UN SISTEMA ANTIGUO
=========================================

Lo puedes hacer con rsync -av <origen> <destino>
Ambos sistemos deben tener instalado rsync, y se puede usar por red como scp.

INSTALAR SDL2
=============

Instalamos dependencias previas:

apt-get install libudev-dev libasound2-dev libvorbis-dev libflac-dev libmpg123-dev libmodplug-dev \
libpng-dev libjpeg-dev libfreetype6-dev libsamplerate0-dev --no-install-recommends

Añadimos "export SDL_VIDEO_DOUBLE_BUFFER=1" en /etc/profile.d/custom.sh

Bajamos la última versión estable de:
https://github.com/libsdl-org/SDL/releases

Ahora, para configurar:

CON GLES, GLES2, OPENGL COMPLETO, VULKAN Y AUDIO SOBRE PIPEWIRE SOLAMENTE, COMO LO HACEMOS AHORA:

CFLAGS="-march=native -mtune=native -O2 -DEGL_NO_X11" \
CXXFLAGS="-march=native -mtune=native -O2 -DEGL_NO_X11" \
./configure --enable-video-kmsdrm --disable-video-x11 --disable-dbus --disable-diskaudio --disable-oss --disable-pulseaudio --disable-video-rpi --disable-dummyaudio --disable-video-dummy --enable-video-offscreen --enable-video-opengles --enable-video-opengl --enable-video-vulkan --enable-libudev --disable-esd --disable-ime --disable-fcitx --disable-alsa --enable-pipewire

(PARA SISTEMAS EMBEDIDOS O CON MUY POCA POTENCIA, PODEMOS PASARLE --diable-libsamplerate, QUE HACE QUE SDL2 RESAMPLEE USANDO SUS ALGORITMOS INTERNOS
 QUE SON DE MENOR CALIDAD Y METEN MÁS RUIDO PERO SON MUCHO MÁS RÁPIDOS).

(LO DE -DMESA_EGL_NO_X11_HEADERS LO HEMOS SACADO DE /usr/lib/pkgconfig/egl.pc. Como el viejo buildsystem de las SDL2 basado en configure y make no usa pkgconfig para saber qué flags tiene que pasar cuando
se compile eglplatform.h, parte de EGL de MESA, que es donde  MESA_EGL_NO_X11_HEADERS evita intentar incluir las headers de X11, pues se lo tenemos que pasar nosotros a mano. El buildsystem de las SDL2 basado en CMAKE sí
pasa correctamente el  -DMESA_EGL_NO_X11_HEADERS de /usr/lib/pkgconfig/egl.pc, porque usa pkconfig para saber qué flags tiene que pasar cuando compila los headers de EGL).

CON CMAKE SERÍA:
mkdir b4
cd b4

cmake .. -DCMAKE_C_FLAGS="-march=native -mtune=native" -DCMAKE_BUILD_TYPE=Release \
-DSDL_3DNOW=OFF -DSDL_DISKAUDIO=OFF -DSDL_DUMMYAUDIO=OFF -DSDL_DUMMYVIDEO=OFF -DSDL_OSS=OFF -DSDL_WAYLAND_QT_TOUCH=OFF

OTRAS NOTAS IMPORTANTES:

--No te olvides de añadir en /etc/profile:
export SDL_VIDEO_DOUBLE_BUFFER=1
Luego puedes comprobarlo con echo $<nombre_variable>, en plan:
echo $SDL_VIDEO_DOUBLE_BUFFER

--Si te da un error "No available video device", y cumplas estos requisitos:
tienes libdrm instalada en /usr/local/lib/<nombre_arquitectura>/,
tienes libgbm que es instalada por MESA también en /usr/local/lib/<nombre_arquitectura>/,
tienes al usuario pi añadido al grupo "render",
...pues regenera la caché de LDD, como siempre que una librería está en un sitio, la estás viendo, pero LD no la ve:
sudo rm /etc/ld.so.cache
sudo ldconfig

--Y si tienes un mando que no es detectado por las SDL2 como gamecontroller (lo sabrás porque no funciona con el Prince...),
saca su cadena de mapping de la SDL2 Gamepad Tool (http://www.generalarcade.com/gamepadtool),
y la añades en /etc/profile usando la variable de entorno SDL_GAMECONTROLLERCONFIG, tal que así:
SDL_GAMECONTROLLERCONFIG="030000009b2800000800000001010000,raphnet.net Dreamcast to USB,a:b10,b:b9,x:b2,y:b1,back:b0,guide:b3,start:b8,dpup:b4,dpdown:b5,dpleft:b6,dpright:b7,platform:Linux,"

Para SDL2_Mixer:
-Instalar antes estas dependencias: apt-get install libmpg123-dev libogg-dev libflac-dev libmodplug-dev libxmp-dev
-Instalar antes fluidsynth (tienes instrucciones en LINUX_KNOWLEDGE para instalarlas manualmente sin depender de X11)
-Nos bajamos la última versión estable de: https://github.com/libsdl-org/SDL_mixer/releases 
-Configuramos con:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure --disable-music-midi-timidity --enable-music-midi-fluidsynth

Para SDL2_Image:
-Dependencias previas: apt-get install libwebp-dev
-Nos bajamos la última versión estable de: https://github.com/libsdl-org/SDL_image/releases 
-Configuramos con:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure

Para SDL2_ttf:
-Nos bajamos la última versión estable de: https://github.com/libsdl-org/SDL_ttf/releases
-Configuramos con:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure --without-x --disable-freetype-builtin --disable-harfbuzz

Para SDL2_net:
-Nos bajamos la última versión estable de: https://github.com/libsdl-org/SDL_net/releases 
-Configuramos con:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure

INSTALAR RETROARCH
===================

Instalamos dependencias previas:
apt-get install libasound-dev glslang-dev glslang-tools spirv-tools

INNECESARIO (ya que usamos el driver "GLCORE"): Si queremos que el driver "GL" use OpenGL de escritorio en lugar de GLES,
editamos qb/config.libs.sh, y cambiamos "-lGL" por "-lOpenGL".
(Esto es para que el driver GL use OpenGL en lugar de GLES2, cosa que es necesaria para que HARD SYNC funcione con el driver GL,
 ya que si te fijas en Makefile.common y en gfx/drivers/gl2.c, resulta que HAVE_GL_SYNC sólo se activa si NO usamos GLES,
 así que si queremos que la opción del backen OPENGL llamada "Hard GPU Sync" haga lo que se supone que hace, tenemos que usar OpenGL y no GLES.
 "Hard GPU Sync" equivale a max_swapchain puesto a 2: recuerda que no puedes configurar el max_swapchain si usas el backend OpenGL en Wayland,
 en Wayland sólo puedes configurar max_swapchain si usas el backend Vulkan).
TODO ESTO INNECESARIO porque el driver GLCORE va sobre GL3 o GLES3 y ya soporta HARD SYNC directamente.

Ahora, para configurar RetroArch con soporte de OPENGL, VULKAN y audio PIPEWIRE, como lo venimos haciendo:

CFLAGS="-march=native -mtune=native -O2 -DEGL_NO_X11" \
CXXFLAGS="-march=native -mtune=native -O2 -DEGL_NO_X11" \
./configure --disable-ibxm --disable-vg --disable-x11 --disable-sdl2 --disable-al --disable-cheevos --disable-ffmpeg \
--disable-netplaydiscovery --enable-udev --enable-pipewire --disable-sdl --disable-pulse --disable-oss \
--disable-freetype --disable-7zip --disable-imageviewer --disable-rjpeg --disable-rbmp --disable-rtga --disable-flac \
--disable-qt --disable-materialui --disable-xmb --enable-rgui --enable-ozone --disable-gfx_widgets --disable-langextra --disable-discord \
--disable-cdrom --disable-accessibility --disable-tinyalsa --disable-rpiled --disable-v4l2 \
--enable-egl --disable-glx --enable-opengl_core --enable-vulkan

(NO le pases --enable-neon ni --enable-floathard, o fallará el configure porque dlopen() no va bien)
(NO le pases --disable-builtinglslang, porque entonces fallará la compilación de shaders al cargar un segundo juego sin salir de RetroArch)
(Lo de "--enable-opengl_core" es para que use OpenGL moderno, en vez de GL1/GL2)

(Si quisieras OpenGL_ES, en lugar de "--enable-opengl --disable-glx" pásale "--enable-opengles --enable-opengles3",
en realidad OpenGL de escritorio no es imprescindible porque el driver GLCORE (GL3, GLES3) soporta HARD SYNC,
PERO es más compatible por defecto con cores que tiran de OpenGL en vez de GLES a no ser que los compiles contra GLES,
como es el caso del core de N64).

(NO le pasamos "--disable-networking" ni "--disable-libretrodb" porque si lo hacemos no tendremos el "Online Updater"
que es lo que nos permite que se descarguen automáticamente los thumbnails para las playlist. Hacerlo a mano es horroroso.)

PARA COMPILAR CUALQUIER CORE:

CFLAGS="-march=native -mtune=native -fomit-frame-pointer -DALIGN_LONG" \
CXXFLAGS="-march=native -mtune=native -fomit-frame-pointer -DALIGN_LONG" make -j4

		CONFIGURACIÓN ÓPTIMA DE RETROARCH EN WAYLAND

-VÍDEO
NOTA PREVIA: Aunque tengamos un monitor con AdaptiveSync/FreeSync/VRR,
no vamos a usar nunca "SYNC TO EXACT CONTENT FRAME" porque nunca va a ser tan suave como usar sólo VSYNC,
así que lo que hacemos es poner por defecto un modo de vídeo de 120Hz en el compositor, y usar VSYNC,
lo que nos va a permitir tener VSYNC de juegos de sistemas de ~60Hz sobe un modo de 120Hz con un refresco perfectamente suave
y sin el input lag inducido por el VSYNC al estar en 120Hz.
EN SETTINGS->VIDEO, ACTIVA "VSYNC" y DESACTIVA "SYNC TO EXACT CONTENT FRAME" Y PON "VIDEO->SYNCHRONIZATION->VSYNC SWAP INTERVAL" a "AUTO"
EN SETTINGS->VIDEO->OUTPUT, DEJA QUE SE DETECTE LA FRECUENCIA CORRECTA Y ESTABLÉCELA.
EN SETTINGS->AUDIO->SYNCHRONIZATION, PON "MAXIMUM TIMING SKEW" A UN VALOR ELEVADO COMO "0.300".

AUDIO: driver ALSATHREAD, 48000 Hz, 32ms, resampler quality normal
(IMPORTANTE!!! Si tienes VRR/AdaptiveSync, recuerda desactivar "Synchronization"!!!)
(Si usas otra frecuencia de audio, modifícalo también en las opciones del core FBNeo)

SCALING: "Integer Scale" a "ON", con "Integer Scale Scaling" a "Smart".
(De lo contrario hay patrones en las scanlines que sólo se ven en fondos azulados o blancos, etc).

SHADER:
Opción 1: CRT-CONSUMER con "Pre-Scale Sharpening" a 1.00, "Convergence X" a 0.40, todo lo de curvatura quitado,
          "Scanlines dark" a 1.20, "Scanlines bright" a 0.80, "Mask Type" a 4.00,
          "Vignette on/off" a 1.00, "Vignette Power" a 0.10, "Vignette Strength" a 20.00.
Opción 2: LOTTES

LATENCY: RunAhead con 1 frame y "second instance" activado.

Si no quieres shimmering en las letras del RGUI, tienes que irte a SETTINGS->USER INTERFACE->APPEARANCE
y activar LINEAR FILTERING.

Si quieres que aparezcan las opciones de SAVE/LOAD STATE, tienes dos opciones:
-Activar la opción settings->core->"bypass core info save states"
-O bien instalar los core info files, que se hace así:
	--Clonamos el repo: git clone --depth 1 https://github.com/libretro/libretro-core-info.git
	--Copiamos los .info a ~/.config/retroarch/cores, junto con los cores (suponiendo que tengamos ese directorio puesto
	  como path para los core info, es la ruta por defecto).

Si quieres que te salgan iconos en el menú OZONE o XMB, en lugar de cuadrados negros,
necesitas los assets de aquí: git clone --depth 1 https://github.com/libretro/retroarch-assets.git
Copia los directorios "ozone", "fonts" y "xmb" (aunque no vayas a usar el XMB, cópialo o te faltarán cosas) a ~/.config/retroarch/assets/ 

Si quieres que RetroArch te ofrezca con qué emulador quieres correr una ROM, tienes que clonar este repo:
git clone --depth 1 https://github.com/libretro/libretro-super.git
Creamos el directorio ~/.config/retroarch/info
Copiamos el contenido del directorio libretro-super/dist/info a ~/.config/retroarch/info
cp -R libretro-super/dist/info/* ~/.config/retroarch/info/
Editamos ~/.config/retroarch/retroarch.cfg, y ponemos la variable "libretro_info_path" asi:
libretro_info_path = "~/.config/retroarch/info"
Por ultimo: Eliminamos el archivo "core_info.cache" (busca en todo .config/retroach) para que se recree el nuevo, o no funciona.
Ahora en RetroArch, en Settings->User Interface->File Browser, desactiva todo y activa "Filter Unknows Extensions"

Para añadir juegos de CONSOLA a una PLAYLIST:
-Las ROMs deben estar en un directorio cuyo nombre coincida con el nombre del sistema en no-intro.
 Puedes sacar los nombres correctos de los directorios de https://github.com/libretro/libretro-database
-Los nombres de las ROMs deben coincidir con los nombres de las ROMs de no-intro, o no se identificarán correctamente al construir la playlist,
y luego no se encontrarán los thumbnails para ellas desde el Online Updater.
-Clonamos este repo: git clone --depth 1 https://github.com/libretro/libretro-database
y metemos el contenido del directorio "rdb" en ~/.config/retroarch/databases/rdb/
-Vamos a IMPORT CONTENT->MANUAL SCAN y ahí:
 -En CONTENT DIRECTORY, seleccionamos el directorio que queremos escanear
 -En SYSTEM NAME elegimos "Content Directory"
 -En DEFAULT CORE elegimos el core que queramos usar para esa playlist.
 ...Y una vez que lo tenemos todo le damos a START SCAN abajo del todo y esperamos.

Para añadir juegos ARCADE a una PLAYLIST, lo vamos a ver con los juegos arcade de FBNeo como ejemplo.
Vamos a IMPORT CONTENT->MANUAL SCAN y ahí:
-En CONTENT DIRECTORY, seleccionamos el directorio que queremos escanear
-En SYSTEM NAME elegimos "FBNeo - Arcade Games"
-En DEFAULT CORE elegimos "Arcade (Final Burn Neo)"
-En ARCADE DAT FILE elegimos la última versión del fichero "Final Burn Neo (ClrMame Pro XML, Arcade only)" que nos podemos bajar de:
https://github.com/libretro/FBNeo/tree/master/dats
(Yo suelo meter el DAT en /storage/roms/Downloads)
...Y una vez que lo tenemos todo le damos a START SCAN abajo del todo y esperamos.
Esto tenemos que hacerlo contra ROMs descargadas de https://www.retroroms.info, yéndonos a "FBNeo" y luego a "currentroms",
ya que son las más actuales y se supone que son contra las que se ha creado el DAT.

Para tener carátulas (thumbnails) debes hacer que RetroArch añada los juegos a una PLAYLIST (lo acabo de explicar),
y luego desde dentro de RetroArch, vamos a Main Menu->Online Updater->Playlist Thumbnail Updater para que se descarguen solas
las carátulas de la playlist que queramos.
(Hacer esto depende de que tengamos las funcionalidades de "networking" y "libretrodb" compiladas en RetroArch:
Libretrodb para que se hagan correctamente las playlists identificándose los juegos, y networking para tener el Online Updater).

Si quieres configurar un tema del XMB o del RGUI, tienes que irte a SETTINGS->USER INTERFACE->APPEARANCE.
En RGUI, para que se ponga el tema que elijas con CUSTOM THEME PRESET, tienes que poner MENU COLOR THEME en CUSTOM.
En XMB, puedes desactivas el lazo de fondo en SETTINGS->USER INTERFACE->APPEARANCE si quieres.
Para XMB, un buen tema es el Systematic ("SETTINGS->USER INTERFACE->APPEARANCE->MENU ICON THEME")

PARA CUALQUIER PROBLEMA de librerías no encontradas pero que sí están instaladas, RECUERDA REGENERAR LA CACHE DE LDD:
sudo rm /etc/ld.so.cache
sudo ldconfig

Si quieres filtros por software, entra en gfx/video_filters y haz make, y copias los .so y los .filt a ~/.config/retroarch/filters/video/
y luego los seleccionas en retroarch.

INSTRUCCIONES GENERALES PARA COMPILAR EL KERNEL DEBIAN
======================================================

-Instalamos dependencias previas:
apt-get install build-essential libncurses-dev bison flex libssl-dev libelf-dev

-Nos descargamos los sources del kernel en uso:
apt-get source linux

-Entramos en el directorio raiz de los sources:
cd linux-$(uname -r)

-Le ponemos la configuración del kernel en uso:
cp /boot/config-$(uname -r) .config

-Adelgazamos el kernel (ver BLOQUE OPCIONAL DE ADELGAZAMIENTO DEL KERNEL MÁS ABAJO)

-Entramos en la configuración y ajustamos lo que queramos:
---Desativamos las mitigations
---Nos aseguramos de tener activadas estas opciones que son imprescindibles para que funcionen los discos USB externos:
"Device Drivers->SCSI device support->SCSI disk support"
"Device Drivers->USB support->USB Mass Storage support"
"Device Drivers->USB support->USB Mass Storage support->USB Attached SCSI"
---En "Processor type and features" activamos esto (ayuda luego a gestionar la velocidad de la CPU):
"/dev/cpu/*/msr - Model-specific register support"
---Para evitar depender de la herramienta "pahole", deshabilitamos:
Kernel hacking  --->
    Compile-time checks and compiler options  --->
        [*] Provide BPF Type Format (BTF) debug info
--Nos vamos a "Device Drivers->X86 Platform Specific Device Drivers" y desactivamos todo lo que veamos de marcas (DELL, HP, etc)
y sobre todo desactivamos "Intel Platform Monitoring Technology (PMT) Telemetry Driver".
--Para poder montar imágenes de disco (ISOs, etc), nos aseguramos de tener activadas estas dos opciones:
Device Drivers->Block devices->Loopback device support
File systems->CD-ROM/DVD Filesystems->ISO 9660 CDROM file system support

--En "General Setup" desactivamos:
----Todo en "BPF Subsystem"
----"Memory placement aware NUMA scheduler"
(Las máquinas NUMA son servidores en los que cada CPU tiene una memoria distinta, ni tienes ni vas a tener nada así en la vida).
----"Checkpoint/restore support" (Pa ké kieres saber eso? jaja salu2)
----"Profiling support"
--En "Processor type and features" desactivamos:
----"Enable MPS table"
----"Intel Low Power Subsystem Support"
----"Linux guest support"
----"Old AMD GART IOMMU support"
----"Enable Maximum number of SMP Processors and NUMA Nodes"
----"Cluster scheduler support"
----"Reroute for broken boot IRQs"
----"Intel MCE features" (si estás en AMD) o "AMD MCE features" (si estás en Intel)
----"IOPERM and IOPL Emulation"
----"Enable 5-level page tables support"
----"AMD Secure Memory Encryption (SME) support"
----"NUMA Memory Allocation and Scheduler Support"
----"Software Guard eXtensions (SGX)"
----"X86 userspace shadow stack"
----"Kernel Live Patching"

--En "General architecture-dependent options" desactivamos:
----"Stack Protector buffer overflow detection"
----"Kprobes"

--En "Memory Management options" desactivamos:
----"Memory hotplug"
----"Transparent Hugepage Support"

--En "Enable the block layer" desactivamos todos los "IO Schedulers",
ya que para discos sólidos el "noop" o "none" es lo mejor.

--MUY IMPORTANTE PARA JUEGOS:
General Setup->Preemption model->Preemptible Kernel (Low-Latency Desktop)
...Y desactivamos "Preemption behaviour defined on boot"
Processor Type and Features->Timer Frequency->300Hz
...Y también activamos como módulo:
Device Drivers->Input device support->Joysticks/Gamepads->Xbox gamepad support
...Y nos aseguramos de tener activado esto para WINE si queremos juegos de 32bits usando WOW64:
Binary Emulations->IA32 Emulation
(NO HACE FALTA que actives el resto de opciones de "Binary Emulations", sólo esa, las demás NO aportan NADA).
...Y desactivamos estas cosas para evitar picos de uso de la CPU:
Memory Management options->Support for paging of anonymous memory (swap)
Memory Management options->Defer initialisation of struct pages to kthreads
Memory Management options->Slab allocator options->(Todo lo que hay ahí)

-Compilamos el kernel y los módulos:
make -j10

-Instalamos los módulos (para desinstalarlos, simplemente borramos el directorio "/lib/modules/6.x.x"):
make INSTALL_MOD_STRIP=1 modules_install

-Instalamos el kernel (para desinstalarlo, borramos de /boot/ todo lo correspondiente a esa versión del kernel):
make install

-Actualizamos grub para que añada el nuevo kernel a su lista:
update-grub

CUIDADO!!! NO REINICIES SIN PONER UN TIMEOUT DISTINTO DE 0 EN /etc/default/grub PARA LANZAR EL NUEVO KERNEL DESDE EL MENÚ DE GRUB!!!
UNA VEZ QUE YA HAYAS COMPROBADO QUE FUNCIONA TODO BIEN, PUEDES PONERLO COMO KERNEL POR DEFECTO CON "GRUB_DEFAULT=..." EN /etc/default/grub
SI ESO NO FUNCIONA, PON "GRUB_SAVEDEFAULT=true" y "GRUB_DEFAULT=saved", eliges desde el menú el kernel nuevo, y pones el TIMEOUT a 0.

################################################################## 
#BLOQUE OPCIONAL DE ADELGAZAMIENTO DEL KERNEL USANDO MODPROBED-DB#
##################################################################

(La información está adaptada de: https://wiki.archlinux.org/title/Modprobed-db)
--Clonamos su repo: git clone --depth 1 https://github.com/graysky2/modprobed-db.git
--Entramos en el directorio de los sources y simplemente hacemos "make && make install" y ya se instala,
es un script y no tiene que compilar nada. (Para desinstalarlo simplemente se usa "make uninstall" y ya).
--Ejecutamos "modprobed-db" y se nos creará el archivo "~/.config/modprobed-db.conf"
Este archivo nos permite añadir módulos que NO queremos que se tengan en cuenta aunque estén cargados, para lo cual
añadiríamos en él una línea estilo "IGNORE=(nvidia vboxdrv..."
--Ejecutamos "modprobed-db store" y se nos creará el archivo "~/.config/modprobed.db", que es donde quedan reflejados los módulos
que tenemos cargados en nuestro kernel actual. Podemos consultar qué módulos tenemos cargados con "modprobed-db list".
--Nos vamos al directorio de los sources del kernel (que ya tenemos configurados de antes) y hacemos:
make LSMOD=~/.config/modprobed.db localmodconfig
(Te preguntará cosas: dile a todo que NO, no nos interesa, gracias).
(OJO!!! Si te pregunta algo como "Additional X.509 keys for default system keyring (SYSTEM_TRUSTED_KEYS)", dale al intro sin más,
 NO se te ocurra poner una "n" ahí o intentará crear un certificado llamado "n" y fallará la compilación!!!)
--Hacemos "make menuconfig" y nos aseguramos de tener activadas estas opciones que son para que funcionen los discos USB externos:
"Device Drivers->SCSI device support->SCSI disk support"
"Device Drivers->USB support->USB Mass Storage support"
"Device Drivers->USB support->USB Mass Storage support->USB Attached SCSI"
--Podemos aprovechar para volver a hacer "make menuconfig" y aligerar funcionalidades internas del kernel,
como desactivar "Mitigations for speculative execution vulnerabilities",
quitar todo lo que puedas de "Security Options", en Device Drivers los "Multiple devices driver support (RAID and LVM)"
y los "Macintosh Device Drivers",
En "Enable the block layer->Partition Types" quitamos todas las particiones que no necesitamos.
En "Drivers->Network device support->Ethernet driver support" y "Drivers->Network device support->Wireless LAN"
quitamos todo el hardware que no tengamos (habremos hecho "lscpi" antes para averiguar cuál sí necesitamos).
En INTEL: Activamos "Device Drivers->Graphics support->Intel Xe Graphics", que no lo detecta modprobed-db.
Usando "/", buscamos ANDROID, AMAZON, MICROSOFT, GOOGLE... Y nos aseguramos de que todas las opciones están desactivadas,
¡nos dice cómo llegar a cada opción!.
Cuidado: no andes quitando cosas de "Kernel Hacking" o los schedulers externos no funcionarán.
--(OPCIONAL PARA NO NECESITAR UN INITRAMFS) metemos en el kernel (incluidos en el kernel, o sea con el [*], no como módulos con la [M])
las cosas necesarias para que el propio kernel pueda montar el rootfs, es decir, los drivers de dispositivo y el filesystem EXT4,
que en un sistema actual de 2024 con NVME son:
----"File Systems->The Extended 4 (ext4) filesystem"
----"Device Drivers->Memory Technology Device (MTD) support"
----"Device Drivers->NVME Support->NVM Express block device"

(EN INTEL: NO DESACTIVES el DEBUGFS o no compilará el driver gráfico de Intel)
(RECUERDA que si en un submenú no encuentras una opción que debería estar ahí, puedes darle a Z y te aparecerá para poder darle a "?" sobre ella
 y así averiguar de qué depende).
(RECUERDA que puedes usar "/" para buscar la opción que quieras, te dice cómo llegar a cada opción).

###################################################### 
#FIN DEL BLOQUE OPCIONAL DE ADELGAZAMIENTO DEL KERNEL#
######################################################

KERNEL CACHYOS Y SCHEDULER LAVD EN DEBIAN (NO APORTA NADA, ES PARA TENER MÁS FPS MIENTRAS COMPILAS O ALGO ASÍ EN SEGUNDO PLANO)
===============================================================================================================================

PREVIO: Antes de hacer estos experimentos, edita /etc/default/grub, pon un timeout distinto de 0, y ejecuta "update-grub",
para que si un nuevo kernel no arranca, seas capaz de arrancar el kernel original del sistema y desinstalar el nuevo.

	###PARTE 1: INSTALACIÓN DE UN KERNEL QUE SOPORTE SCX (SCHED-EXT): EL KERNEL CACHYOS###

-Instalamos una dependencia previa que es necesaria para compilar el kernel con la opción "Generate BTF typeinfo" (CONFIG_DEBUG_INFO_BTF)
 activada: apt-get install pahole
-Usamos un script que nos descarga el kernel y nos permite pre-configurarlo (hay que activar SCHED_CLASS_EXT a mano antes de compilar):
 Clonamos su repo: git clone --depth 1 https://github.com/CachyOS/linux-cachyos-deb
(No te olvides de poner el governor a PERFORMANCE en las opciones que nos presenta el script!)
(NO COMPILAMOS EL KERNEL AÚN, lo vamos a hacer después a mano con "make", ya que tenemos que activar CONFIG_SCHED_CLASS_EXT).
-Hacemos "make menuconfig" y hacemos estos cambios (RECUERDA que si una opción no aparece, puedes darle a la Z
 para que aparezca y poder ponerte sobre ella y darle a la "?" para ver qué tienes que tener activado/desactivado para que aparezca): 
	--Activamos "General Setup->Extensible Scheduling Class" (esto activa lo más importante: CONFIG_SCHED_CLASS_EXT).
	--Activamos "Kernel hacking->Compile-time checks and compiler options->Generate BTF type information"
	(Para lo cual tenemos que tener "Debug Information" puesto a "Rely on the toolchain's implicit default DWARF version")
	--Activamos "Device Drivers->Sound card support->Advanced Linux Sound Architecture -> HR-timer backend support"
	--Activamos "General Setup->Some kernel tweaks by CachyOS"
¡¡RECUERDA que usando "/" puedes localizar la opción que quieras!!

-Ahora ya sí: Compilamos el kernel y los módulos con "make -j6".

-Instalamos los módulos del kernel (para desinstalarlos, simplemente borramos el directorio "/lib/modules/6.9.0"):
cd linux-6.9.0
make INSTALL_MOD_STRIP=1 modules_install

-Instalamos el kernel en sí (RECUERDA que hay que instalar los módulos antes, cosa que hemos hecho en el paso anterior,
ya que esto nos crea el initramfs del kernel que lleva dentro módulos necesarios para el arranque del kernel):
make install
update-grub
(Si no necesitas el initramfs porque tienes las funcionalidades necesarias para montar el rootfs metidas en el kernel [*] en vez de como módulos [M],
 simplemente borra /boot/initramfs-6.9.0 antes de ejecutar "update-grub".
 Busca ahí arriba en "OPCIONAL PARA NO NECESITAR UN INITRAMFS" para saber cuáles son en un sistema actual de 2024 con disco duro NVME)

-(PASOS NORMALMENTE NO NECESARIOS: NORMALMENTE AL INSTALAR EL KERNEL ESTAS COSAS SE HACEN SOLAS)
--Creamos un initramfs para el nuevo kernel:
update-initramfs -c -k 6.9.0
--Actualizamos grub para que tenga localizado el nuevo kernel: update-grub
Y editamos /etc/default/grub para poner el TIMEOUT a un valor distinto de 0, de manera que nos presente el menú de arranque.
--Reiniciamos, y en el menú de arranque de GRUB entramos en "Advanced Options" y elegimos el nuevo kernel y arrancamos.
(La próxima ver que arranquemos, GRUB recordará esta opción y arrancará en el nuevo kernel).

	###PARTE 2: INSTALAR LOS SCHEDULERS EXTERNOS###

--Previo: Para evitar problemas y confusiones luego, asegúrate antes de seguir de que estas opciones
las tienes todas así en el .config del kernel:
CONFIG_BPF=y
CONFIG_SCHED_CLASS_EXT=y
CONFIG_BPF_SYSCALL=y
CONFIG_BPF_JIT=y
CONFIG_BPF_JIT_ALWAYS_ON=y
CONFIG_BPF_JIT_DEFAULT_ON=y
CONFIG_DEBUG_INFO_BTF=y

--Previo: Instalamos el buildsystem que necesita.
----Instalamos rust desde su repositorio (si usamos el apt-get nos instalará una versión demasiado antigua, como siempre)
Según las instrucciones de https://www.rust-lang.org/tools/install, se hace así:
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
----Instalamos clang desde su repositorio (si usamos el apt-get nos instalará una versión demasiado antigua, como siempre)
apt install lsb-release wget software-properties-common gnupg
bash -c "$(wget -O - https://apt.llvm.org/llvm.sh)"
ln -s /usr/bin/clang-18 /usr/bin/clang
--Previo: Instalamos dependencias previas:
apt-get install jq libzstd-dev

VAMOS CON SCHED_EX EN SÍ...
--Bajamos la última release de: https://github.com/sched-ext/scx/releases
--Configuramos y compilamos con:
mkdir b4
cd b4

CFLAGS="-O2 -march=native -mtune=native" \
CXXFLAGS="-O2 -march=native -mtune=native" \
meson setup -Dbuildtype=release ..

ninja -j6
ninja install

--Para lanzar el LAVD y que no nos maree con estadísticas, editamos el fichero /etc/default/scx y lo dejamos así:
SCX_SCHEDULER=scx_lavd
SCX_FLAGS='-s 0'

--Activamos el servicio scx:
systemctl enable scx.service
systemctl start scx.service
...Comprobamos que está corriendo correctamente con:
systemctl status scx.service

--Alternativamente, sin habilitar/lanzar ninigún servicio, podemos lanzar a mano el scheduler externo que queramos:
escribe "scx" y dale al tabulador para ver los que hay disponibles.
Si no quieres que te esté mareando con información todo el rato, pásale el parámetro "-s0".

AUTOLOGIN EN DEBIAN CON ESCRITORIO LXQT
=======================================

Creamos el archivo /etc/sddm.conf.d/autologin.conf (hay que crear el directorio /etc/sddm.conf.d) con el contenido:
# autologin
[Autologin]
User=manuel
Session=lxqt.desktop

Y ya. Reiniciar y listo.

INSTALAR PIPEWIRE EN DEBIAN
===========================

--Instalamos los paquetes necesarios:
apt-get install pipewire libpipewire-0.3-dev wireplumber pipewire-alsa --no-install-recommends

NOTA: Al instalar "pipewire-alsa", ya no nececesitas un /etc/asound.conf:
todo el sonido de ALSA ya sale por Pipewire porque automáticamente el dispositivo ALSA por defecto pasa a ser Pipewire,
y para confirmarlo, puedes ver que en "aplay -L" tienes:
pipewire
    PipeWire Sound Server
default
    Default ALSA Output (currently PipeWire Media Server)

		BLOQUE NO RECOMENDADO, PIPEWIRE ESTÁ PENSADO PARA FUNCIONAR COMO USUARIO NORMAL.
Para que funcione como root, editamos los fichreos del servicio y el socket de pipewire
y comentamos en cada uno de ellos la línea "ConditionUser=!root":
vim /usr/lib/systemd/user/pipewire.service
vim /usr/lib/systemd/user/pipewire.socket
(NOTA: En realidad, deberíamos usar overrides para esto, pero no se puede porque por política los overrides no pueden modificar
una "Condition" del fichero base de un servicio... Así que de momento hacemos esto, aunque en teoría se perderán las modificaciones
con cada actualización).
		FIN BLOQUE NO RECOMENDADO

--Lanzamos el servicio sin reiniciar así:
systemctl --user start pipewire.service

--Para comprobar que el servicio pipewire está funcionando, hacemos "systemctl --user status pipewire.service"
Si nos sale que sí está rulando, los programas que hayamos compilado con soporte de pipewire (SDL2 y RetroArch lo soportan,
en RetroArch debemos elegirlo como audio output y en SDL2 como SDL_AUDIODRIVER o compilar sin soporte ALSA para que lo use por defecto)
deberían ya sonar sin problemas.

--Para evitar problemas de audio durante los primeros segundos de RetroArch sobre Pipewire (distorsión en el core Nestopia),
creamos el fichero /etc/modprobe.d/audio_disable_powersave.conf con el contenido:
options snd_hda_intel power_save=0
options snd_hda_intel power_save_controller=N

--Para subir y bajar el volúmen de forma relativa (se queda guardado solo sin hacer nada):
wpctl set-volume @DEFAULT_AUDIO_SINK@ 50%+

			NOTAS AUDIO DE BAJA LATENCIA CON PIPEWIRE

--Creamos el archivo /usr/share/pipewire/pipewire.conf.d/lowlatency.conf con este contenido, que es una configuración especial para juegos:
(NOTA: La explicación de cada valor viene en https://docs.pipewire.org/page_man_pipewire_conf_5.html)

context.properties = {
    # Con esto le decimos que si un programa pide 44100 y sólo está sonando ese programa,
    # el reloj maestro se pone a 44100 y la salida final se resamplea a 44100.
    # El resto de frecuencias que no estén en "allowed-rates" se reproducirá pero resampleadas siempre:
    # que una frecuencia esté en "allowed-rates" sólo significa que el reloj maestro de Pipewire
    # se puede poner a esa frecuencia si un programa la pide.
    # Pero si hay varios programas sonando a la vez, el reloj maestro estará a la frecuencia del 1er programa que entró.
    default.clock.allowed-rates = [44100 48000]

    # Quantum pequeños para baja latencia
    default.clock.quantum = 512			# Por defecto cuando el programa no especifica.
    default.clock.min-quantum = 32		# Mínimo que un programa puede obtener.
    default.clock.max-quantum = 512		# Máximo que un programa puede obtener.
    default.clock.quantum-limit = 2048  # Máximo permitido para condiciones anómalas.
}

			PIPEWIRE CON PRIORIDAD REALTIME

--NOTA INICIAL PARA ENTENDER LO QUE VAMOS A HACER: La prioridad RT la da el módulo "libpipewire-module-rt".
  Este módulo sólo aplica política real si los permisos del sistema (RLIMIT_RTPRIO) lo permiten.
  NO ES NECESARIO USAR EL MÓDULO "libpipewire-module-rtkit", NO ES EL MODO CORRECTO DE HACERLO Y EVITA TODA EXPLICACIÓN QUE USE ESE MÓDULO.

--Comprobamos que el módulo "libpipewire-module-rt" está cargado con:
pw-cli list-objects | grep module.name | grep module-rt

--Nos aseguramos de que nuestro usuario esté en el grupo "audio" con "groups <usuario>"
  Si no lo está, le añadimos con "sudo usermod -aG audio <usuario>"

--Comprobamos que rtkit está funcionando porque es lo que le va a dar prioridad realtime a pipewire, con "systemctl status rtkit-daemon".

--Comprobamos que PIPEWIRE está con prioridad realtime con "ps -eLo pid,cls,rtprio,ni,cmd | grep pipewire"
que nos debería mostrar "FF" o "RR" en la segunda columna (es la columna "CLS" si te fijas en lo que le estás pidiendo a "ps").
Si nos muestra "TS", es que NO está en modo realtime sino en "NORMAL TIME SHARING".	
En la columna "RTPRIO", que es la tercera, veremos un número que debería ser lo más alto posible,
pero que al parecer lo normal es que sea 20 como máximo para usuarios normales.

--Metemos a nuestro usuario en el grupo "audio" (creamos el grupo antes)
sudo usermod -a -G audio $USER
MUY IMPORTANTE: REINICIAMOS SESIÓN DE USUARIO Y COMPROBAMOS QUE HA SIDO AÑADIDO AL GRUPO "audio" CON EL COMANDO "groups".

--Creamos /etc/security/limits.d/99-audio.conf con el contenido:
@audio - rtprio 99
@audio - memlock unlimited
@audio - nice -11
MUY IMPORTANTE: REINICIAMOS SESIÓN de USUARIO (MUY IMPORTANTE!!) y comprobamos que los rlimits se han aplicado con "ulimit -a"

--Comprobamos que PIPEWIRE tiene al fin prioriad realtime, con "ps -eo pid,user,comm,rtprio,ni | grep pipewire".
  Nos tiene que salir que tiene FF o RR, pero NO TS porque eso es SCHED_OTHER.

--También podemos ver la prioridad de los hilos que se crean mientras ejecutamos cosas con audio, usando:
watch -n 0.5 'ps -eLo pid,tid,comm,policy,rtprio,ni | grep pipewire'

			EXPLICACIÓN TÉCNICA DE LOS VALORES
	
Un quantum de 512 significa que "el audio se ejecuta cada 512 samples". Es decir, que pipewire recoje el audio del cliente cada 512 samples.
Una frecuencia de 48000 Hz significa que el audio se reproduce a 48000. Es decir, que haya lo que haya en el buffer de audio
se reproduce a 48000 samples por segundo.

O sea, tenemos 512 "samples / ejecución", y tenemos 48000 "samples / segundo".
Para saber cada cuánto se está ejecutando pipewire, nos interesa conocer "segundos / ejecución".
Como queremos "segundos" arriba y "ejecución" abajo, multiplicamos en cruz (que es como se dividen fracciones):

 samples     samples     samples * segundo
--------- X --------- = ---------------------
ejecución    segundo     samples * ejecución

Samples con samples se van, y nos queda: "segundos / ejecución", que es lo que queremos.

Para no tener que ponerlo como fracciones, nos basta con invertir la segunda fracción (samples/segundo) para que sea como multiplicar en cruz,
con lo que nos queda que en el ejemplo concreto, (512) * (1/48000) = 512 / 48000 = 0.010666 = 10.666 ms de retardo de audio. 

	BLOQUE OPCIONAL (NO SE NOTA LA DIFERENCIA Y PIERDES EL SOFTWARE MIXING CON LO QUE SÓLO PUEDE REPRODUCIR UN STREAM A LA VEZ...)

--Activamos el modo Pro-Audio (esto se hace en WirePlumber).
Para ello, creamos el fichero /usr/share/wireplumber/wireplumber.conf.d/proaudio.conf con el contenido:

monitor.alsa.rules = [
  {
    matches = [
      {
        device.name = "alsa_card.pci-0000_6e_00.1"
      }
    ]
    actions = {
      update-props = {
        device.profile = "pro-audio"
        #api.alsa.period-size = 128,
        #api.alsa.period-num = 3,
      }
    }
  }
]

--El device.name ("alsa_card.pci-0000_6e_00.1") lo hemos sacado así:
-----Con el comando "wpctl status" sacamos el número del dispositivo en Audio->Devices.
-----Con el comando "wpctl inspect <número_de_dispositivo>" sacamos el nombre del dispositivo mirando el campo "device.name".
-----El "period-size" viene de los valores del quantum que hemos puesto en Pipewire, pero no parece hacer falta.

--Al usar el perfil pro-audio, ahora establecemos el dispositivo por defecto (importante en modo pro-audio, o no se oirá nada):
----Listamos los números de nodo con "wpctl status"
----Establecemos el nodo por defecto con "wpctl set-default <NÚMERO_DE_ID>". Por ejemplo, en el X600 es con "wpctl set-default 47"
----Esto podemos añadirlo a ~/.config/labwc/autostart (o al autostart del compositor que usemos).
Si lo pones en /etc/profile.d/ no funcionará ya que al ejecutarse tiene que estar todo lo de Pipewire listo y si lo pones ahí no lo estará.

--En algunos programas podríamos elegir el nodo manualmente, como en RetroArch.
Listamos los nodos reales, que sólo aparecen en modo pro-audio, con "pw-top". Nos saldrán nodos del estilo:
  alsa_output.pci-0000_6e_00.1.pro-output-3
  alsa_output.pci-0000_6e_00.1.pro-output-7
  alsa_output.pci-0000_6e_00.1.pro-output-8
  alsa_output.pci-0000_6e_00.1.pro-output-9
  ...que sólo salen en modo pro-audio.
Para saber cuál es el que nos interesa (porque llevará el nombre del monitor en el campo "mode.nick")
ejecutamos "pw-cli ls Node" y nos aparece más info de cada nodo.

NOTAS INFORMATIVAS ADICIONALES:

--Para comprobar el sonido de pipewire, hacemos:
pw-play /usr/share/sounds/alsa/Front_Center.wav
Y si queremos especificar el nodo (recuerda que los nodos se sacan de "pw-top" y que salen más nodos si estás en modo pro-audio):
pw-play /usr/share/sounds/alsa/Front_Center.wav --target alsa_output.pci-0000_6e_00.1.pro-output-8

--Para comprobar que Pipewire tiene prioridad RT, hacemos:
ps -eLo pid,rtprio,cmd | grep pipewire
...Y aunque el máximo es 95, nos saldrá con 88 o así ya que 95 se lo reserva para situciones críticas.

--Para que una regla en un .conf se aplique a todos los dispositivos de audio, usaríamos: device.name = "~alsa_card.*"

KERNEL REALTIME EN DEBIAN
=========================

Lo primero que debes saber es que ya no hace falta un kernel RT especial: la funcionalidad de RT está en el kernel vanilla 6.x.

--Comprobamos que el kernel que tenemos está preparado. Para ello, hacemos: cat /boot/config-$(uname -r) |grep PREEMPT
Nos interesa tener "CONFIG_PREEMPT_DYNAMIC=y"
--Añadimos a la línea de comandos del kernel:
  "threadirqs preempt=full nohz_full=1-3 cpufreq.default_governor=performance mitigations=off audit=0"
--Reiniciamos, hacemos "dmesg | grep Preempt" y comprobamos que vemos: "Dynamic Preempt: full"
--Añadimos nuestro usuario al grupo "audio": usermod -a -G audio <nombre_usuario>
--Podemos comprobar qué CPUs tenemos en modo tickless con: cat /sys/devices/system/cpu/nohz_full

--Ahora vamos con la prueba definitiva del desempeño realtime de nuestro equipo, usando "rtcqs". Para instalar "rtcqs":
	--Nos vamos a https://codeberg.org/rtcqs/rtcqs/releases y nos bajamos el último binario release estable.
	--Le damos permisos con "chmod +x" y lo ejecutamos.
	  Debería salirnos todo en verde. Podemos ignorar el fallo sobre el kernel "tickless" (se supone que nohz_full=1-3 se encarga de eso,
	  pero el test no se ha actualizado y comprueba otro parámetro del kernel que no es necesario tener activado).

OPTIMIZACIONES PARA JUEGOS
==========================

La información procede de: https://wiki.archlinux.org/title/Gaming#Improving_performance
La idea es mejorar el desempeño y la latencia sin instalar un kernel especial.

-(OJO!! Esto hace que dejen de funcionar emuladores que necesitan links simbólicos a librerías de GLX, como PCSX2,
  así que en el script de carga del PCSX2 haz "unset LD_BIND_NOW" antes de lanzar el emulador)
Para que nunca se cargue código durante la ejecución de un juego, sino que todas las funciones de las librerías estén precargadas,
añadimos en /etc/profile.d/custom.sh:

LD_BIND_NOW=1

-Confirmamos que nuestro clock source es TSC, ya que HPET o ACPI_PM son mucho más lentos y no sirven para NADA en juegos:
cat /sys/devices/system/clocksource/clocksource*/current_clocksource

-Creamos el fichero "/etc/tmpfiles.d/consistent-response-time-for-gaming.conf" con el contenido:

#    Path                  Mode UID  GID  Age Argument
w /proc/sys/vm/compaction_proactiveness - - - - 0
w /proc/sys/vm/watermark_boost_factor - - - - 1
w /proc/sys/vm/min_free_kbytes - - - - 1048576
w /proc/sys/vm/watermark_scale_factor - - - - 500
w /proc/sys/vm/swappiness - - - - 10
w /sys/kernel/mm/lru_gen/enabled - - - - 5
w /proc/sys/vm/zone_reclaim_mode - - - - 0
w /sys/kernel/mm/transparent_hugepage/enabled - - - - madvise
w /sys/kernel/mm/transparent_hugepage/shmem_enabled - - - - advise
w /sys/kernel/mm/transparent_hugepage/defrag - - - - never
w /proc/sys/vm/page_lock_unfairness - - - - 1
w /proc/sys/kernel/sched_child_runs_first - - - - 0
w /proc/sys/kernel/sched_autogroup_enabled - - - - 1
w /proc/sys/kernel/sched_cfs_bandwidth_slice_us - - - - 3000
w /sys/kernel/debug/sched/base_slice_ns  - - - - 3000000
w /sys/kernel/debug/sched/migration_cost_ns - - - - 500000
w /sys/kernel/debug/sched/nr_migrate - - - - 8

Reiniciamos, y hacemos algo como: cat /proc/sys/vm/compaction_proactiveness
...que nos tiene que dar 0 porque acabamos de establecer su valor en ese fichero (por defecto viene a 20).
