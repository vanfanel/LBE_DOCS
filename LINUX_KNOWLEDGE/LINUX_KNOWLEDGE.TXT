============================================================================================================================================
LANZAR programas en sus propias CPUs (realtime, nada más puede ejecutarse ahí: garantia total probada con uso masivo de CPU
de housekeeping simultáneo)
============================================================================================================================================
MÁS SOBRE MEJORAR LA LATENCIA: https://rigtorp.se/low-latency-guide/
https://github.com/redno2/Application-latency-optimization-Linux

HABIENDO AISLADO LAS CPUs DEL 1 al 3 CON "isolcpus=1-3 nohz_full=1-3" EN CMDLINE.TXT: 
-Para lanzar algo no multithread:
taskset -c 3 ./retroarch
-Para lanzar algo MUY multithread (y que por tanto puede aprovechar varios cores):
chrt -f 80 taskset -c 1-3 ./gzdoom
CUIDADO con el -f 99: si se te cuelgan cosas bájalo a 80, a 50... 80 va bien y es lo que uso ahora.
Con la otra política de tiempo real (SCHED_RR, que se usa pasando -r en lugar de -f pero que nos conviene menos porque reparte
rodajas de tiempo de manera continua y nos conviene más que los threads pillen la CPU y no la suelten hasta que acaben,
es decir, SCHED_FIFO, que es lo que usamos con -f), pasar -r 99 es un peligro y hay cuelgues.

PARA CONSEGUIR LO MISMO EN UN SISTEMA EN EJECUCIÓN:
-Instalamos este paquete: apt-get install cpuset
-Creamos un shield para proteger las CPUs 0 y 1:
cset shield --cpu=0-1 --kthread=on
NOTA: Al hacer esto, te saldrá que algunas tareas no se pueden sacar de esas CPUs (se supone que son tareas del kernel).
En teroría, eso es porque hay que aislar esas CPUs antes de arrancar, mira esto: https://www.codeblueprint.co.uk/2020/05/03/reducing-jitter-on-linux-with-task-isolation.html
-Mandamos ahí a correr el programa que queramos:
cset shield --exec -- <programa con sus argumentos>
-Podemos ver qué hay corriendo en nuestro shield con:
cset shield -s -v
-Para saber más: man cset-shield

PARA VER QUÉ PARÁMETROS DEL SCHEDULER PODEMOS AJUSTAR:
sysctl -A |grep sched

******Establecer una variable de entorno globalmente en el arranque*****************************************************

Aunque hasta ahora lo has hecho de las más peregrinas maneras, el modo "correcto" es en /etc/environment
Basta con poner "export, el nombre de la variable y el valor. Si no pones "export", aparece con echo pero no funciona.
export SDL_VIDEO_DOUBLE_BUFFER=1
Luego puedes comprobarlo con echo $<nombre_variable>, en plan:
echo $SDL_VIDEO_DOUBLE_BUFFER

*******Teclado en español y con la tilde (~) en la Ñ sin tener que darle dos veces***************************************

Editamos /etc/default/keyboard, y lo dejamos así:

XKBMODEL="pc105"                                                                                               
XKBLAYOUT="es"                                                                                                 
XKBVARIANT="nodeadkeys"                                                                                        
XKBOPTIONS=""                                                                                                  
BACKSPACE="guess"

Sin lo de "nodeadkeys", tenemos que darle a la Ñ dos veces para sacar la tilde, y es una mierda eso.

*******Visualizar los scancodes de las teclas desde la consola TTY*******************************************************

Con el comando showkeys

******Añadir un modo de vídeo con xrandr*********************************************************************************

gtf 1366 768 50
Y con el resultado de esto hacemos:
xrandr --newmode "1366x768_50.00" 69.92 1368 1424 1568 1768 768 769 772 791  -HSync +Vsync

xrandr --addmode eDP "1366x768_50.00"
xrandr --output eDP --mode "1366x768_50.00"

******IMPRIMIR DESDE UN MAKEFILE*****************************************************************************************

Se hace simplemente con:
@echo "hola mundo!"

PERO OJO: Si te da un error de "missing separator" métele un tabulador delante.

******Actualizar el firmware de un dispositivo 8bitdo (y de dispositivos en general) en GNU/Linux**********************

Se toma como ejemplo el 8BitDo Arcade Stick.
Información procedente de: https://ladis.cloud/blog/posts/firmware-update-8bitdo.html

Lo primero es instalar FWUPD: sudo apt-get install fwupd
Ahora conectamos el mando, y lo encendemos con START+SELECT presionados para entrar en modo UPDATE.
Ahora localizamos su DEVICE ID con: sudo fwupdmgr get-devices

Ahora localizamos el firmware que necesitamos. Para ello:
-Miramos en la tabla que está en: https://ladis.cloud/blog/posts/firmware-update-8bitdo.html
 Ahí averiguamos que el TYPE del 8BitDo Arcade Stick es el 34.
-Localizamos la ruta del fichero de firmware que tenemos que descargar. Para ello, hacemos:
curl -X POST -H 'Type: 34' -H 'Beta: 1' http://dl.8bitdo.com:8080/firmware/select
Ahí nos va a dar un chorro de texto en formato JSON, del que nos interesa lo que pone a continuación de "filePathName".
En "filePathName" pone "/firmwareFile/upload/1a70f919-b88e-4a07-b56b-a65524233caf.dat", así que lo unimos al dominio
de las descargas de 8BitDo, y nos queda que para descargar el firmware hacemos:
curl -X GET -O http://dl.8bitdo.com:8080/firmwareFile/upload/1a70f919-b88e-4a07-b56b-a65524233caf.dat
-Por último, flasheamos el firmware usando el "DEVICE ID" y el fichero de firmware que hemos descargado:
sudo fwupdtool install-blob 1a70f919-b88e-4a07-b56b-a65524233caf.dat 301046452a49d84af6356d23e43a684b8f10660f

******Hacer que se lean los diagnostics del bootloader de la Raspberry Pi 4 incluso cuando arranca correctamente*******

Editamos los parámetros de configuración del bootloader con:
rpi-eeprom-config --edit

Y añadimos ahí:
HDMI_DELAY=0

Más info sobre parámetros del bootloader aquí:
https://gitee.com/jikexianfeng/documentation/blob/master/hardware/raspberrypi/bcm2711_bootloader_config.md#/jikexianfeng/documentation/blob/master/hardware/raspberrypi/boot_diagnostics.md

******Conectar a una red WIFI desde Raspberry Pi OS con SystemD (forma recomendada)************************************

-Para conectarte automaticamente a una WIFI, lo mejor es tener activado el servicio NetworkManager y meter la red/contraseña en raspi-config,
en la seccion system->wireless lan.
Las redes conocidas quedan guardadas en /etc/NetworkManager/system-connections, en lugar de en /etc/wpa_supplicant/wpa_supplicant.conf

******Conectar a una WIFI desde Debian usando nmcli********************************************************************

-Activamos la WIFI
nmcli r wifi on

-Escaneamos las redes WIFI
nmcli dev wifi

-Nos conectamos a una red WIFI
nmcli dev wifi connect "wifi_name" password "wifi_password"

******Conectar a una red WIFI desde la Raspberry PI usando el WIFI interno*********************************************

PUEDE QUE NECESITES BAJAR MANUALMENTE EL FIRMWARE DEL WIFI SI AL HACER MODPROBE AL brcmfmac NO TE CREA EL INTERFACE WLAN0.
Si es así, tienes que bajarte los archivos:
brcmfmac43430-sdio.bin
brcmfmac43430-sdio.txt
Que están en:
https://github.com/RPi-Distro/firmware-nonfree/blob/master/brcm
Y meterlos en:
/lib/firmware/brcm/

Instalamos wpasupplicant así:
sudo apt-get install wpasupplicant --no-install-recommends

AHORA VAMOS A POR EL SCRIPT PARA LEVANTAR LA RED:

Lo primero es cargar el módulo del kernel que hace falta:
sudo modprobe brcmfmac

Ahora levantamos el interface wlan0
sudo ifconfig wlan0 up

Ahora tenemos que dejar /etc/wpa_supplicant/wpa_supplicant.conf así:

ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network={
        ssid="MOVISTAR_7A40"
        psk="E3UHR3Ca3FYgJ4e7elee"
}

Ahora conectamos con la base, pasándole al wpa_supplicant nuestra configuración:
sudo wpa_supplicant -d -Dnl80211 -iwlan0 -c/etc/wpa_supplicant/wpa_supplicant.conf -B
(El parámetro -B es para que corra en modo daemon, de fondo, retornando al prompt inmediatamente... ¡sin eso, se queda esa consola para él solo!)

OPCION 1 (recomendada)
Nos damos nosotros mismos una IP del rango del router y un gateway:
sudo ip addr add 192.168.1.12/24 dev wlan0
sudo ip route add default via 192.168.1.1

OPCIÓN 2
Obtenemos una IP para wlan0:
sudo dhclient wlan0
Ahora nos damos un gateway, que es la dirección del router en la red a la que acabamos de conectarnos:
sudo ip route add default via 192.168.1.1

...Comprobamos que en /etc/resolv.conf tenemos:
nameserver 8.8.8.8

Y ya deberíamos ser capaces de hacer ping al router en la 192.168.1.1, a la dns de google en 8.8.8.8, y a google.com si nos da la gana.

******Convertir CUE/BIN a CHD*********************************************************************************************************

Instalamos chdman:
sudo apt-get install mame-tools --no-install-recommends

Y para comprimir de CUE/BIN a CHD:
chdman createcd -i image.cue -o image.chd

Y para comprimir todos los CUE/BIN de un directorio a CHD:
for i in *.cue; do chdman createcd -i "$i" -o "${i%.*}.chd"; done

Y para extraer todos los CHD de un directorio a CUE/BIN:
for i in *.chd; do chdman extractcd -i "$i" -o "${i%.*}.cue"; done

Y para extraer de CHD a CUE/BIN:
chdman extractcd -i image.chd -o image.cue -ob image.bin

******Descargar desde ARCHIVE.ORG desde la línea de comandos usando un download manager***********************************************

(!!!!)NOTA: Lo más práctico y rápido NO para descargar de Archive NO es hacerlo desde la línea de comandos, sino descargar desde el navegador
(!!!!)usando un DOWNLOAD MANAGER. El más recomendable es "Turbo Download Manager" que es una extensión para Firefox.
PERO vamos, que si te quieres complicar, sigue leyendo...

Normalmente se podría usar WGET, pero como hay items que sólo se pueden descargar estando logueado, y como archive.org usa HTTPS y no es posible
loguearse por HTTPS con WGET, pues al final con muchos items no funciona WGET y nos da el famoso error 403: "forbidden".

Así que usamos la librería de python llamada "internearchive", una herramienta de Internet Archive.
Instalamos la librería "internetarchive":

pip install internetarchive

Ahora configuramos la librería ia, para darle nuestro user/pass:

ia configure

Y AHORA instalamos el script downloader en python también que vamos a usar:
(Con ia se puede descargar, pero NO soporta resume así que no me vale).

git clone --depth 1 https://github.com/john-corcoran/internetarchive-downloader.git
sudo cp ia_downloader.py /usr/local/bin/ia_downloader
sudo chmod +x /usr/local/bin/ia_downloader
 
Descargamos tal que así. Para bajarnos una colección completa al directorio actual...:

ia_downloader download -i no-intro_romsets ./

Para bajarnos sólo unos ítems concretos de una colección (por ejemplo los romsets completos de SNES y Megadrive):

ia_downloader download -i no-intro_romsets ./ -f Super\ Nintendo Megadrive

Y para continuar si se cortó la bajada anterior:

ia_downloader download -i no-intro_romsets ./ -f Super\ Nintendo Megadrive -r

Y como lo venimos haciendo ahora, para descargar con una sola línea todos los romsets que solemos usar:

ia_downloader download -i no-intro_romsets ./ -f Super\ Nintendo Mega\ Drive Nintendo\ Entertainment\ System Game\ Boy\ \(2022 Game\ Boy\ Color Game\ Gear Master\ System 32X Lynx PC\ Engine Atari\ -\ 2600 Atari\ -\ 5200 Atari\ -\ 7800 Jaguar WonderSwan ColecoVision Virtual\ Boy SG-1000 -r

******Descargar vídeos de RTVE A LA CARTA*********************************************************************************************

INFO PROCEDENTE DE: https://obiwan2208.wordpress.com/2018/05/23/videos-rtve-2018/
(Válida a Enero de 2023)

Entramos en la página de la peli o lo que sea que queremos bajar.
En un área vacía de la pagina hacemos clic derecho y seleccionamos Inspect.
Hacemos clic en la pestaña Network, subpestaña XHR.
En ese momento, le damos a que empieze a reproducirse el vídeo, y esperamos a que empiezen a aparecer líneas ahi en la tabla.
Clicamos en una de esas líneas, y le damos a la subpestaña Headers: y ahí tenemos una URL del vídeo. La copiamos hasta el ".mp4"
y ya lo podemos descargar alegremente con WGET.

******Descargar contenidos de ITunes desde Linux sin ITunes***************************************************************************

El programa se llama tunesviewer.
Si te da un error y no te deja buscar, dale a view y desactiva Request HTM5 Mode.
Cambia la búsqueda a Podcast Search.

*******Eliminar la BASURA de repositorios de Micro$oft de Raspbian/RaspberryPiOS*****************************************************

sudo rm /etc/apt/sources.list.d/vscode.list
sudo rm /etc/apt/trusted.gpg.d/microsoft.gpg
sudo apt update

******Hacer que lo que conectamos en un puerto USB siempre aparezca en un nodo de /dev determinado***************************

Mediante UDEV rules. Por ejemplo, para joysticks compatibles con XBOX360 (como el 8bitdo SN30Pro), hacemos esto.

1- Obtenemos la información que necesitamos ejecutando: 

udevadm info --name=/dev/input/js0 --attribute-walk

Mirando el segundo device (es decir, el segundo bloque "looking at parent device...", nos interesan estas cosas:

ATTRS{phys}=="usb-0000:01:00.0-1.3/input0"
ATTRS{name}=="Microsoft X-Box 360 pad"

También nos interesa el SUBSYSTEM, que vemos que es "input".

2) Creamos /etc/udev/rules.d/80-joysticks.rules con un contenido como así:
 
SUBSYSTEMS=="input", ATTRS{name}=="Microsoft X-Box 360 pad", ATTRS{phys}=="usb-0000:01:00.0-1.3/input0", NAME="input/js8"

Recargamos las UDEV RULES sin reiniciar, así:

udevadm control --reload-rules && udevadm trigger

Podemos monitorear los eventos de UDEV con:
udevadm monitor -p

******Probar los dispositivos de audio con speaker-test**********************************************************************

Puedes ver los dispositivos disponibles con: aplay -L
Tiene que ser -L mayúscula.

Ten en cuenta que cada dispositivo puede tener una o varias tarjetas.
Le puedes pasar el dispositivo que quieras a speaker-test en formato dispositivo:tarjeta_que_quieras_de_ese_dispositivo

Por ejemplo, en la Pi4, verás uno de los primeros así:

hw:CARD=vc4hdmi0,DEV=0
    vc4-hdmi-0, MAI PCM i2s-hifi-0
    Direct hardware device without any conversions

Pues puedes pasárselo a speaker-test así:
speaker-test -D default:vc4hdmi0
Donde estás diciéndole a speaker-test que use el dispositivo "default" (la definición específica de "default" para el device
vc4hdmi está en /usr/share/alsa/cards/vc4-hdmi.conf) y que dentro de ese dispositivo "default" use la tarjeta "vc4hdmi0".

Podríamos INTENTAR usar directamente el dispositivo "hw", por ejemplo:
speaker-test -D hw:vc4hdmi0
...Pero "hw" es directamente "Direct hardware device without any conversions", sin DMIX, y sólo acepta un formato
llamado IEC958_SUBFRAME_LE, así que no funciona directamente con speaker-test porque speaker-test
no puede generar audio en formato IEC958_SUBFRAME_LE. De hecho, ningún programa, en general, puede hacer eso.

******Ver los modos soportados de una pantalla/monitor (EDID)****************************************************************

Se puede volcar y ver con:
cat /sys/class/drm/card1-HDMI-A-0/edid | edid-decode

******Sangre roja en el Metal Slug de Neo Geo*********************************************************************************

En QUICK MENU->OPTIONS, ponemos NEO-GEO MODE a UNIBIOS.
Ahora, una vez dentro del juego, mantenemos pulsado START y nos sale un menú donde podemos activar varias cosas,
entre ellas la sangre roja o poner el juego en idiomas locos.

******Legend of Zelda: A Link to the Past (ZELDA3) nativo en GNU/Linux*******************************************************

Clonamos el repositorio:
git clone --depth 1 https://github.com/snesrev/zelda3.git

(ARREGLO TEMPORAL HASTA QUE MERGEEN MIS CAMBIOS)
-Editamos opengl.c y dejamos la línea:
viewport_width = viewport_height * g_draw_width / g_draw_height;  // limit width
como:
viewport_width = viewport_height * 4 / 3;  // limit width
(Podríamos también editar main.c y dejar la línea:
SDL_RenderSetLogicalSize(renderer, g_snes_width, g_snes_height);
como:
SDL_RenderSetLogicalSize(renderer, 4, 3);
...pero no es necesario porque usaremos el renderer OpenGL, NO el SDL, así que no nos aporta nada).

(PASO INNECESARIO: tienes los datos ya extraidos como zelda3_assets.dat en el disco de backup, sólo es meterlos en "~/zelda3/tables"):
--Si NO tenemos los datos extraidos
	-Instalamos las dependencias necesarias para extraer los datos de la ROM:
	python3 -m pip install -r requirements.txt
	-Copiamos la ROM USA a tables/zelda3.sfc, para que se extraigan los datos al compilar.

--Si ya tenemos los datos extraidos, para que NO se intenten extraer los datos sino sólo generar el ejecutable:
Editamos Makefile y dejamos la parte:
all: $(TARGET_EXEC) tables/zelda3_assets.dat
como:
all: $(TARGET_EXEC)

Compilamos con:

CFLAGS="-O3 -fomit-frame-pointer -march=native -mtune=native" make -j4

Ahora, mete el ejecutable resultante "zelda3", el "zelda3.ini" y tables/zelda3_assets.dat en ~/zelda3
(O sea, los datos tienen que quedar en ~/zelda3/assets/zelda3_assets.dat)

Nos metemos en el directorio ~/zelda3, y clonamos los shaders allí:

git clone --depth 1 https://github.com/snesrev/glsl-shaders

Editamos zelda3.ini y ponemos "Fullscreen" a 1, "OutputMethod" a OpenGL, "LinearFiltering" a 1, "DisableFrameDelay" a 1,
"EnhancedMode7" a 0, y "Shader" a "glsl-shaders/crt/fakelottes.glslp".

******WipeOut nativo en GNU/Linux********************************************************************************************

Clonamos su repo:
git clone --depth 1 https://github.com/phoboslab/wipeout-rewrite.git

Instalamos GLEW (mira en la sección de cómo instalar GLEW de este mismo documento) y SDL2.

Compilamos con:
USER_CFLAGS="-march=native -mtune=native -fomit-frame-pointer" GL_VERSION=GLES2 make sdl -j4

Necesitamos los datos de:
https://phoboslab.org/files/wipeout-data-v01.zip
(LOS TIENES EN EL DISCO DE BACKUP, POR SI DESAPARECE EL LINK)

Creamos el directorio ~/wipeout, y ahí metemos el ejecutable "wipegame" y creamos el subdirectorio "wipeout" donde metemos
los datos del juego.

******Blood y Exhumed nativos en Linux***************************************************************************************

(OJO!!! NO FUNCIONA CON OPENGL, PARECE NECESITAR OPENGL 3 O ALGO ASÍ, NO SOPORTA GLES TAMPOCO).

Clonamos su repo:

git clone --depth 1 https://github.com/nukeykt/NBlood.git

Compilamos con:
make rednukem -j3 RELEASE=1 WITHOUT_GTK=1 USE_OPENGL=1 USE_LIBVPX=0 LTO=1 OPTOPT="-march=native -mtune=native -O3"

Podríamos compilar sólo el blood, o sólo el exxhumed, etc.. así:
make blood
make pcexhumed
make rednukem

Para quitar el autorun es con BLOQ. MAYUS, y para quitar la mirilla es con "i".

******Cargar juegos de GameMaker (GM) de Android en GNU/Linux****************************************************************

OJO!!! Se tiene que hacer con un Linux de 32bits (armhf).
De momento no es compatible con Linux de 64bit (como aarch64) y cuando lo sea, sólo se podrán usar juegos que funcionen sobre
un GMLoader de 64bit, con lo que no será compatible con juegos de GameMaker versión 2.x como el Maldita Castilla.

Instalamos dependencias previas:
sudo apt-get install libbz2-dev libzip-dev

TAMBIÉN se necesita OpenAL, que tiene su sección en este documento para compilarla e instalarla rápidamente.

Bueno, vamos al lio.
Clonamos el repo:
git clone --depth 1 https://github.com/JohnnyonFlame/droidports.git
git submodule update --init --recursive

Editamos "ports/gmloader/sdl2_media.c" y:
-Añadimos justo antes de la llamada a SDL_CreateWindow() el típico "SDL_ShowCursor(SDL_DISABLE);"
-Añadimos SDL_WINDOW_FULLSCREEN_DESKTOP a las flags de SDL_CreateWindow().

Creamos el directorio de compilación, configuramos y compilamos:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

Para que las scanlines se vean bien y para quitar las mitigations, etc, añade a cmdline.txt:
video="HDMI-A-1:1152x864@60" mitigations=off audit=0 fsck.mode=skip
(La resolución original del Maldita Castilla es 256x224, y coincide que el monitor de la PICADE soporta 1152x864 como modo preferido,
que tiene el mismo número de líneas que 4x224. ¡Genial!).

Ahora es tan simple como cargar el Maldita Castilla con:
./gmloader Maldita_Castilla.apk
(Se usa la versión para Ouya que está en la página de Locomalito)

Para cargarlo en la PICADE, donde hay que establecer el volúmen al empezar tras activar softvol mediante /etc/asound.conf,
lo cago así:

aplay /dev/zero -s 1 -q
amixer set Master 120 -q
SDL_VIDEO_DOUBLE_BUFFER=1 ./gmloader maldita.apk

####SI VAS A USARLO EN LA PICADE:#####
-Para poder controlar el volúmen, tienes que activar softvol. Tienes varias soluciones en el fichero de documentación NOTAS_ALSACONF.TXT
Pero vamos, que tienes que poner /etc/asound.conf como:

pcm.hifiberry {
    type softvol
    slave.pcm "plughw:0"
    control.name "Master"
    control.card 0
}

pcm.!default {
    type             plug
    slave.pcm       "hifiberry"
}

Y luego cargar el juego como:
aplay /dev/zero -s 1 -q
amixer set Master 230 -q
./gmloader maldita.apk

-Para arreglar los controles, tienes dos opciones:
1) (RECOMENDADA) Configurar la Picade para que los botones y palanca envíen los códigos que usa el juego, que se mueve con las flechas del teclado
y las teclas Z y X. Para ello, en config.txt, en la línea de "dtoverlay=picade" haríamos:
dtoverlay=picade,button5=44,button6=45
(Los valores 44 y 45 los sacamos de pulsar X y Z mientras "showkey" está ejecutándose.

2) (MÁS ROLLO PORQUE HAY QUE EDITAR EL CÓDIGO DEL JUEGO) Poner el valor de button1 y button 2 en el juego para que se usen los valores UTF8
de CRTL y ALT (que son las teclas que envían los botones que sueles usar de la Picade) son
[164] = "L Alt";
[162] = "L Control";
(Sacado de https://forum.yoyogames.com/index.php?threads/how-do-i-convert-key-code-to-its-correct-key.76372/,
en el post #6 tienes la lista de todos los códigos de las teclas).
Puedes metérselos a la sección gml_Object_obj_control_Other_2 del código del juego: para editar el código del juego,
tienes que hacerlo con el UndertaleModTool: tienes notas sobre esto más abajo.

####FIN SECCIÓN PICADE####

Para Metroid am2r, tenemos que bajarnos la versión 1.1 y parchearla a la última versión que haya en ese momento:

-Instalamos el parcheador xdelta: sudo apt install python xdelta3

-Descargamos el AM2R versión original 1.1 de aquí: https://archive.org/details/am2r1.1
y lo guardamos dentro del directorio AM2R-Autopatcher-Linux como AM2R-Autopatcher-Linux/AM2R_11.zip
(OJO: Bájalo por Torrent, ya sabes que todo lo de Archive se corta si te bajas el .zip directamente)

-Clonamos el repo de la última versión del auto-parcheador: git clone --depth 1 https://github.com/AM2R-Community-Developers/AM2R-Autopatcher-Linux

-Bajamos la última versión del parche de GITHUB:
https://github.com/AM2R-Community-Developers/ProfessorG64/releases
De ahí copiamos el archivo "droid.xdelta" a "AM2R-Autopatcher-Linux/data/droid.xdelta"
y "AM2RWrapper.apk" a "AM2R-Autopatcher-Linux/data/android/AM2RWrapper.apk".

-Parcheamos así:

cd AM2R-Autopatcher-Linux
python patcher.py

(Te preguntará por el tipo de parche: responde Android. Y no hace falta que instales el pack de sonido de alta calidad porque
ocupa MUCHO más.)

NOTA: Si hemos instalado el juego en JELOS usando PORTMASTER y no nos va el audio, editamos AM2R.sh y añadimos estas dos líneas al principio:
export SPA_PLUGIN_DIR="/usr/lib32/spa-0.2"
export PIPEWIRE_MODULE_DIR="/usr/lib32/pipewire-0.3/" 

******EDITAR Y CAMBIAR COSAS EN JUEGOS GML COMO EL MALDITA CASTILLA**********************************************************

Por ejemplo, vamos a ver cómo activar en el juego la interpolación bilineal para evitar el shimmering.

Bajamos la versión 0.3.5.8 del Undertale Tool de aquí:
https://github.com/krzys-h/UndertaleModTool/releases

NO usamos la última versión porque se cuelga al salvar archivos de juego después de editarlos.

Instalamos la versión de .NET que nos pida. Por ejemplo, para la versión 0.3.5.8 nos pide .NET 4.6.2 que además DEBE ser
la de 32bits, así que hacemos:
sudo rm -R ~/.wine
WINEPREFIX="$HOME/.wine" WINEARCH=win32 wine wineboot
winetricks dotnet462
(OJO: No es un proceso desatendido, te pedirá varias veces que reinicies, NO LO HAGAS).

Ejecutamos el UndertaleTool.exe con wine.

Abrimos el archivo assets/game.droid.

PARA CAMBIAR COSAS, desplegamos la categoría CODE, y allí hacemos doble click en el fichero de código que queramos cambiar.
Nos aparecerá la vista DECOMPILED del fichero, que es la que tiene código legible que podemos editar a nuestro gusto.
Entonces nos vamos a a la vista DISSASEMBLY, y CONFIRMAMOS que se ha generado el código equivalente a la línea que hemos añadido.
OJO!!! HASTA QUE NO VAYAMOS A DISSASEMBLY, NO SE GUARDAN LOS CAMBIOS!!!

PARA SABER QUÉ NOS INTERESA CAMBIAR, LO PRIMERO EXPORTAMOS EL CÓDIGO PARA LUEGO PODER BUSCAR EN ÉL (DESDE EL UndertaleModTool NO SE PUEDE).
Para ello, nos vamos a SCRIPTS->BUILTIN SCRIPTS->EXPORT ALL CODE, y una vez exportado ya podemos buscar.
A CONTINUACIÓN, NOTAS DE COSAS QUE YA HEMOS BUSCADO, PARA DEJAR CIERTOS ASPECTOS DEL JUEGO COMO QUERAMOS:

-EDITAMOS "gml_Script_scr_initial_values", y ahí ponemos "global.is_ouya" a 0.
 Eso hace que en "gml_Object_obj_old_tv_Draw_64", se vaya por la ruta de arriba (la del "if (!global.is_ouya)"),
 así que quitamos todos las llamadas a "texture_set_interpolation()" menos la primera, que la ponemos a "true".
 (Esto hace que todo vaya interpolado, naturalmente, y si se activa el overlay irá interpolado también, que dentro
 de lo que cabe queda mejor).
-EDITAMOS "gml_Object_obj_control_Other_2", y ahí podemos desactivar poner el "speedrun" a 0,
configurar los controles (para usar los botones típicos de la PICADE, que envían las pulsaciones LCTRL y LALT,
debes poner button1 a 164 y button2 a 162), etc.
También podríamos poner el "overlay" a 0, pero no lo recomiendo porque el juego se ve mejor con overlay si ponemos
una resolución adecuada.

Salvamos, sobreescribiendo el archivo .droid, y reempaquetamos el .APK comprimiendo el directorio del juego con ZIP,
PERO SIN COMPRIMIR, SÓLO "STORE". Si lo haces desde la consola, es:
cd <directorio_del_APK_descomprimido>
zip -0 -r maldita.apk *
(¡¡¡OJO!!!: Hay que hacerlo exactamente así, entrando en el directorio del juego descomprimido, NO pasándole el directorio a zip,
porque no funcionará).

Para comprimirlo con sólo store y guardando los archivos y directorios como se debe, entramos en el directorio donde tenemos
descomprimido el APK y hacemos:
zip -r -0 maldita.apk *

TIENES UN APK LISTO EN EL DISCO DURO DE BACKUP, CON TODAS LAS MODIFICACIONES A TU GUSTO.

PARA QUE SE VEA BIEN EL OVERLAY:
COMO la imágen que se usa para las scanlines, (CURIOSIDAD: está en SPRITES y se llama "spr_old_tv"), es de 576x432,
tenemos que poner una resolución en cmdline.txt cuya altura (número de líneas) sea múltiplo de 432.
O sea que con una resolución que tenga una altura de 864, ya se ve bien.
PERO además nos interesa que sea 864 de altura y que tenga un ratio de 16:9, por lo que la anchura será 1536.
Los detalles para establecer un modo de vídeo de 1536x864 y con el aspect ratio correcto, los he sacado de:
https://wiki.archlinux.org/title/kernel_mode_setting#Early_KMS_start
El parámetro "video=..." de la línea de parámetros del kernel quedaría así:
video="HDMI-A-1:1536x864@60"


*****CÓMO CARGAR OTROS JUEGOS DE GAME MAKER (GML) CON EL GMLOADER***********************************************************

PARA CARGAR OTROS JUEGOS HECHOS CON GML, LA IDEA BÁSICA SERÍA COGER EL APK DE UN JUEGO ("donor apk"),
DESCOMPRIMIRLO, COPIAR LOS DATOS DEL NUEVO JUEGO A "assets", RENOMBRAR "data.win" A "game.droid", Y RECONSTRUIR EL APK.

PERO OJO! El APK que usas de "donante" tiene que tener una versión del runner que coincida con la versión
que el data.win/data.droid espera.
Así que para saber qué versión del runner espera el data.win/game.droid, lo cargamos con el UnderTaleModTool (UTMT) y
en la caja de texto de la parte de abajo del todo, escribimos una de estas:
Data.GMS2_2_2_302
Data.GM2_2_3
Data.GM2_2_3_1
Data.GM2_2_3_2
(Cuando coincida la versión te dirá TRUE, y cuando no coincida te dirá FALSE).
(Si quieres ver qué más heurustics hay para averiguar la versión, mira en el código fuente del UTMT, aquí:
https://github.com/krzys-h/UndertaleModTool/blob/4b52cb69c0939c4ccf6392838eee2eb5d8b2cfc8/UndertaleModLib/UndertaleData.cs#L60 )
(Si con una de esas te dice algo de "UndertaleData' does not contain a definition for...", significa que necesitas
una versión del UTMT más moderna, que conozca los heuristics de esa versión. EL PROBLEMA ES QUE LAS VERSIONES MODERNAS DE UTMT
PETAN EN LINUX, Y NO SE PUEDE USAR NATIVAMENTE PORQUE USA CIERDA MIERDA QUE LO HACE EXCLUSIVO DE WINDOWS, ASÍ QUE ES WINE O NADA).

CON ESO QUE TE ACABO DE EXPLICAR, DEBERÍAS SER CAPAZ DE AVERIGUAR QUÉ APK PUEDES USAR COMO DONANTE PARA UN data.win/game.droid DETERMINADO.

******RetroArch en Android***************************************************************************************************

Instálalo desde FDroid. Viene sin cores. Para instalar los cores, lo primero ve a "Online Updater -> Update Core Info Files",
y después ya puedes ir a "Online Updater->Core Downloader" y descargar los cores que quieras de la lista.

Para que no estén cambiamos los botones de OK y CANCELAR del mando, ve a "Settings->Input->Menu Controls->Swap OK and Cancel Buttons"
y desactívalo.

Para poder usar el teclado, ve a "Settings->Input->Select Physical Keyboard" y selecciónalo.

Para meterle juegos a saco, los puedes copiar en:
/media/manuel/<nombre_partición_grande>/media/0/Roms (tienes que crear "Roms")
y las BIOS van en /media/manuel/<nombre_partición_grande>/media/0/RetroArch/system

******PPSSPP, el emulador de PSP en Raspberry Pi 4***************************************************************************

Clonamos su repo:

git clone --depth 1 https://github.com/hrydgard/ppsspp.git
git submodule update --init --recursive

Configuramos y compilamos:
mkdir b4
cd b4

Para compilar una versión LIBRETRO:

mkdir b4
cd b4
cmake .. -DLIBRETRO=ON -DUSE_VULKAN_DISPLAY_KHR=ON -DUSE_WAYLAND_WSI=OFF -DUSING_X11_VULKAN=OFF \
-DCMAKE_BUILD_TYPE=Release -DUSING_GLES2=ON -DUSE_DISCORD=OFF \
-DCMAKE_C_FLAGS="-DEGL_NO_X11 -march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-DEGL_NO_X11 -march=native -mtune=native"

¡¡¡OJO!!! Tenemos que copiar el contenido del directorio "assets" que viene con los sources a ~/.config/retroarch/system/PPSSPP/
o si no, el Ridge Racers se nos quedará en una pantalla en gris después del menú principal."

Es un core con sonido 44100Hz, así que configura los settings de audio así y guarda los core overrides.

Para evitar el micro-stuttering, ve a Core Options->Video, y allí activa "Duplicate Frames in 30Hz games".

PARA WAYLAND:
cmake .. -DCMAKE_BUILD_TYPE=Release -DUSE_WAYLAND_WSI=ON -DUSE_VULKAN_DISPLAY_KHR=OFF -DUSING_X11_VULKAN=OFF -DUSING_GLES2=OFF -DUSE_DISCORD=OFF \
-DCMAKE_C_FLAGS="-DEGL_NO_X11 -march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-DEGL_NO_X11 -march=native -mtune=native"

PARA KMSDRM:
cmake .. -DCMAKE_BUILD_TYPE=Release -DUSE_WAYLAND_WSI=OFF -DUSE_VULKAN_DISPLAY_KHR=ON -DUSING_X11_VULKAN=OFF -DUSING_GLES2=OFF -DUSE_DISCORD=OFF \
-DCMAKE_C_FLAGS="-DEGL_NO_X11 -march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-DEGL_NO_X11 -march=native -mtune=native"

Si nos da un error al linkar relacionado con ffmpeg, tenemos que recompilar ffmpeg interno que trae, lo cual se hace con esta
secuencia de comandos:

pushd ../ffmpeg
./linux_arm64.sh
popd

(Ese error ocurre porque, por defecto, intenta usar un FFMPEG que trae PRE-compilado contra otras libc.. normal que de error!)

Ahora copiamos el directorio "assets" al mismo directorio del ejecutable PPSSPP

*******Compilar el core libretro Yabause***********

Clonamos su repo:

git clone --depth 1 -b kronos https://github.com/libretro/yabause.git

entramos en yabause/src/libretro

make -j4

La bios tiene que ir en ~/.config/retroarch/system/saturn_bios.bin o ~/.config/retroarch/system/kronos/saturn_bios.bin

(OJO: Tienes que tener puesto el driver de vídeo en GLCORE, o en SETTINGS->CORE, permitir que los cores hagan el cambio de driver de vídeo).
(OJO: requiere OpenGL 4.1 o algo así, y NO FUNCIONA CON VULKAN, GLES, GLES2 ni GLES3, así que olvídate de que funcione en la Raspberry Pi 4).

*******Compilar el core Beetle-Saturn********************************

git clone --depth 1 https://github.com/libretro/beetle-saturn-libretro.git

CFLAGS="-march=native -mtune=native" CXXFLAGS="-march=native -mtune=native" make -j4

La BIOS tiene que ir en ~/.config/retroarch/system/mpr-17933.bin

Si estás en un sistema con PERFORMANCE CPUs y EFFICIENCY CPUs, debes asignarle un par de PERFORMANCE CPUs al RetroArch así:
taskset -c 0-1 retroarch -L ~/.config/retroarch/cores/mednafen_saturn_libretro.so roms/Sega\ -\ Saturn/Virtua\ Fighter\ Remix\ \(USA\).chd
Esto es así porque el core oscila muy rápido en el uso de la CPU: cuando usa poca es asignado a una CPU de tipo EFFICIENCY y luego
cuando de repente usa mucha se ralentiza porque el scheduler no llega a tiempo de pasarlo a una CPU de tipo PERFORMANCE.

*******Compilar el core DOSBOX-CORE**********************************

Este sí sincroniza el vídeo bien (al fin).
(OJO! ¡¡Si estás haciendo experimentos en una TTY con RetroArch en KMS/DRM, mientras tienes las X11 corriendo en otra TTY,
haz de vez en cuando un EXIT en la TTY en la que corres RetroArch, o empezará a ir todo a tirones al cabo de unas cuantas
ejecuciones del RetroArch, y TE VOLVERÁS LOCO BUSCANDO LA EXPLICACIÓN!!)

Clonamos su repo:

git clone --depth 1 https://github.com/realnc/dosbox-core.git

SI QUEREMOS QUE NO AJUSTE EL RATIO (lo cual causa pausas de audio...) editamos libretro/src/libretro.cpp
y comentamos entero el contenido de la función update_gfx_mode()
Si decidimos hacer esto, luego es posible ajustar el ratio de ciertos juegos como el JAZZ (16:10) usando los overrides.

Entramos en el directorio "libretro" y compilamos así:

COMMONFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
make -j6 platform=unix WITH_FAKE_SDL=1 STATIC_LIBCXX=1 \
WITH_FLUIDSYNTH=0 BUNDLED_AUDIO_CODECS=0 BUNDLED_GLIB=0 BUNDLED_LIBSNDFILE=0 WITH_PINHACK=0 WITH_VOODOO=0 WITH_BASSMIDI=0

(Desactivo FLUIDSYNTH porque compila un montón de mierdas como libsndfile y demás que consumen CPU,
 con la emulación de GRAVIS vas que chutas en DOS).
(También desactivo la emulación de tarjetas Voodoo, el PINHACK que es para ver completas las mesas de pinball sin scroll, etc).

Para que todo vaya suave, en OPTIONS del core:
En TIMING->FRAME TIMING MODE elegimos "EXTERNAL".
Para evitar que el sonido vaya ralentizaaaaaado en los juegos de 70Hz, ponemos "TIMING->OVERRIDE EMULATED VIDEO REFRESH RATE" a 60.
Y para que los juegos a 70HZ también vayan suaves, "SETTINGS->AUDIO->SYNCHRONIZATION->MAXIUM TIMING SKEW" a 20% o más,
para que resamplee de los 70HZ a los ~60HZ de nuestro monitor.

La configuración general (ciclos, emulación de la CPU usada, tarjetas de vídeo y audio, etc) se hace desde las OPTIONS del core.
Y luego, para que en el inicio monte un directorio y se meta en él, debes pasarle un .conf que sólo haga eso, así:

[autoexec]
mount c: ~/root/dos/superfrog
sf.exe
exit

PARA QUE FUNCIONE EL TECLADO, la idea es usar el "GAME FOCUS", para lo cual
NO DEBEMOS TENER ACTIVADO el "HOTKEY ENABLE", ya que son dos funcionalidades que se solapan
y si tuvieses ambas la "HOTKEY ENABLE" no funcionaría al tener activo el "GAME FOCUS" que dedica todas las teclas al core.
Así que hacemos esto:
-En Settings->Input, pon "Auto Enable Game Focus" a "Detect".
-En Settings->Input->Hotkeys, pon en "Game Focus (Toggle)" la tecla Windows ("lsuper" se llama).
-En Settings->Input->Hotkeys, NO PONGAS NINGUNA TECLA en "Hotkey Enable".

PARA QUE EL PAD NO SE QUEDE ATASCADO EN UNA DIRECCIÓN AL SALTAR EN LOS JUEGOS:
-En "QUICK MENU->CONTROLS->PORT 1 CONTROLS", usa "Joystick" como "DEVICE TYPE", y pon así los controles direccionales:
D-Pad UP: Left Analog Y-
D-Pad UP: Left Analog Y+
D-Pad UP: Left Analog X-
D-Pad UP: Left Analog X+

PARA EL ASPECT RATIO: Lo de siempre para todos los cores en general: en SETTINGS->VIDEO se pone en 4:3 para todo y fuera.  

PARA EVITAR PANTALLA NEGRA al principio del SUPERFROG si se usa el driver de vídeo VULKAN: desactiva el "FRAME DUPING" en las opciones del core.
(Sólo ocurre con el driver del vídeo VULKAN).

PARA EVITAR QUE SE QUEDE EN EL MENÚ DE RETROARCH AL SALIR, desactiva SETTINGS->CORE->LOAD DUMMY CORE ON CORE SHUTDOWN.

PARA TENER UN PC EQUIVALENTE A UN 386 a 33MHz, pon 7800 ciclos (busca "dosbox cycles equivalent" en google para ver otras equivalencias).

PARA CARGAR EL Might & Magic 2, antes tienes que ejecutar LOADFIX (es un comando del propio DOSBOX), para que no se queje de la memoria.

PARA EVITAR el error de que no encuentra /dev/snd/seq, pues cargar el módulo "snd_seq", o ignorar el error.

#######################
# EMPIEZA EL DOS.CONF #
#######################

[autoexec]

mount c: /home/manuel/dos/juegos
c:

#####################
# ACABA EL DOS.CONF #
#####################

El tema del teclado: para que las teclas se lean todas desde DOS, sin liarse con las hotkeys de RETROARCH,
debes tener un "HOTKEY ENABLE" en "SETTINGS->INPUT"
(yo tengo puestas las comillas simples) para que así al pulsar las teclas no se activen cosas del RetroArch a no ser que pulses
el "HOTKEY ENABLE" que tengas configurado.
PARA QUE NO SE ATASQUEN LAS TECLAS DE DIRECCIÓN MIENTRAS JUEGAS CON TECLADO: Vete a "QUICK MENU->CONTROLS->PORT 1 CONTROLS"
y pon el DEVICE TYPE a "KEYBOARD+MOUSE", y dale a "SAVE CORE REMAP FILE".

Juegos de DOS para bajar: te enganchas el TORRENT y bajas sólo los que vayas queriendo: https://www.retro-exo.com/exodos.html

NOTAS JUEGOS DOSBOX

--Lemmings se puede iniciar el modo high-performace sin tener que elegir nada con: lemvga /v /o
--Wizardry necesita, para sonar bien, usar el Nuked OPL3. Menos mal que con pocos ciclos el juego va bien...
--PsychoPinball tiene que estar en C:\PSYCHO, o sea que tienes que meterlo en ~/dos/psycho/psycho
y luego montar ~/dos/psycho como C: en DOSBOX. Si no, se queda colgado en el DOS4GW.

******Compilar QT6***********************************************************************************************************

Las instrucciones básicas las he sacado de: https://wiki.qt.io/Building_Qt_6_from_Git

VERSION ESTABLE (RECOMENDADO):
wget https://download.qt.io/official_releases/qt/6.6/6.6.0/submodules/qtbase-everywhere-src-6.6.0.tar.xz

ALTERNATIVA BAJANDO LA VERSIÓN ESTABLE Y LOS SUBMÓDULOS DE GITHUB (NO RECOMENDADO):
Clonamos su repo:
git clone https://code.qt.io/qt/qt5.git qt6
Nos vamos a la versión tagged LTS actual:
git switch 6.6.0
Inicializamos los módulos que vamos a usar
(puedes ver los módulos disponibles editando el archivo ".gitmodules"):
(qttools es necesario para tener el componente LinguistTools, que es necesario para compilar PCSX2)
./init-repository --module-subset=qtbase,qttools

CONFIGURACIÓN: 
Puedes deshabilitar features de esos módulos con "-no-feature-loquesea". Y para saber qué cosas le ponemos pasar,
miramos en "CMakeCache.txt". Por ejemplo, entras en "CMakeCache.txt" y buscas "html" y ya ves qué cosas relacionadas con el html puedes
deshabilitar.
Y NO DESHABILITES nada nuevo, que luego el PCSX2 no compila.

PARA KMSDRM:
mkdir b4
cd b4
cmake .. -GNinja -DCMAKE_BUILD_TYPE=Release -DQT_FEATURE_eglfs_egldevice=ON -DQT_FEATURE_eglfs_gbm=ON \
-DQT_BUILD_EXAMPLES=OFF -DQT_BUILD_TESTS=OFF

COMPILACIÓN:
cmake --build . --parallel 12

INSTALACIÓN:
cmake --install .

PARTE 2: MÓDULOS DE QT6 NECESARIOS PARA LOS EMULADORES

---WAYLAND (Necesario para PCSX2)---

wget https://download.qt.io/official_releases/qt/6.6/6.6.0/submodules/qtwayland-everywhere-src-6.6.0.tar.xz

mkdir b4
cd b4
cmake .. -GNinja -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH="/usr/local/Qt-6.6.0/lib/cmake"
cmake --build . --parallel 12
cmake --install .

---TOOLS (Necesario para PCSX2)---

wget https://download.qt.io/official_releases/qt/6.6/6.6.0/submodules/qttools-everywhere-src-6.6.0.tar.xz

mkdir b4
cd b4
cmake .. -GNinja -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH="/usr/local/Qt-6.6.0/lib/cmake"
cmake --build . --parallel 12
cmake --install .

---SVG (Necesario para Dolphin)---

wget https://download.qt.io/official_releases/qt/6.6/6.6.0/submodules/qtsvg-everywhere-src-6.6.0.tar.xz

mkdir b4
cd b4
cmake .. -GNinja -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH="/usr/local/Qt-6.6.0/lib/cmake"
cmake --build . --parallel 12
cmake --install .

******Compilar PCSX2 standalone**********************************************************************************************

Instalamos dependencias previas:
apt-get install --no-install-recommends extra-cmake-modules liblzma-dev libpcap-dev libaio-dev

También se necesita tener en el sistema una versión de QT6 con lo módulo TOOLS.
En la sección de cómo compilar QT6 tienes también cómo compilar e instalar este módulo.

Clonamos su repo:
git clone --depth 1 https://github.com/PCSX2/pcsx2.git --recurse

Editamos common/CMakeLists.txt y borramos "X11:X11" y "X11::Xrandr". 

Configuramos y compilamos (asegúrate de que la ruta de instalación de QT6 que le pasas en "-DCMAKE_PREFIX_PATH=..." es la correcta):

mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DX11_API=OFF \
-DCMAKE_PREFIX_PATH="/usr/local/Qt-6.6.0/lib/cmake" \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native"

Creamos un directorio ~/ps2, y copiamos allí el ejecutable "pcsx2-qt" que está en el directorio "bin", 
y los directorios "resources" y "translations"

NOTAS DE CONFIGURACIÓN:
-En EMULATION, activa "Optimal Frame Pacing" y "Scale to Host Refresh Rate", y pon "Affinity Control" a "EE > GS > VU"
-En GRAPHICS
--En la pestaña principal, pon "Renderer" a "Software", o bien a "Vulkan" pero en ese caso activa "Spin CPU during readbacks"
--En la pestaña "DISPLAY" desactiva "Anti-Blur"
--En la pestaña "RENDERING" pon "Software Rendering Threads" al número de CPUs que tengas -2, sin pasarte de 6.
--En la pestaña "RECORDING" desactiva "Capture Video" y "Capture Audio"
--En la pestaña "OSD" desactiva "Show OSD Messages" y pon el "OSD Scale" al 200%, por si activas "Show Speed Percentages"
--En la pestaña "Post Processing" pon el "TV Shader" a "Scanline Filter"

*******Compilar DOLPHIN standalone***********************************
OJO!! LA VERSIÓN NOGUI NO SOPORTA MÁS QUE X11 Y FBDEV, Y LA VERSIÓN NORMAL AUNQUE FUNCIONA SOBRE QT6 NO SOPORTA WAYLAND,
ASÍ QUE DALE UN AÑO O DOS PARA MEJORAR, NO PIERDAS EL TIEMPO.

git clone --depth 1 https://github.com/dolphin-emu/dolphin.git dolphin-emu
cd dolphin-emu
git submodule update --init --recursive

mkdir b4
cd b4

Para compilar sólo la versión NOGUI:
cmake .. -DCMAKE_BUILD_TYPE=Release -DENABLE_QT=OFF -DENABLE_X11=OFF -DENABLE_NOGUI=ON -DUSE_MGBA=OFF -DUSE_DISCORD_PRESENCE=OFF \
-DENABLE_SDL2_VIDEO=ON

Para compilar contra QT6 (PUAJ!!!)
cmake .. -DCMAKE_BUILD_TYPE=Release -DENABLE_X11=OFF -DUSE_MGBA=OFF -DUSE_DISCORD_PRESENCE=OFF \
-DCMAKE_PREFIX_PATH="/usr/local/Qt-6.6.0/lib/cmake" -DQt6Svg_DIR=/usr/local/lib/cmake/Qt6Svg

Para seleccionar el platform plugin al lanzar el emu:
QT_QPA_PLATFORM=eglfs Binaries/dolphin-emu

*******Compilar el core libretro Swanstation (Duckstation)***********

(OJO: en el repo oficial de ducktstation tienes cores ya compilados, pero NO funcionan cuando Retrorch funciona sobre KMSDRM.
NO te molestes en reportarlo, porque el autor de duckstation es un poco gilipollas.)

Clonamos el repo donde mantienen la versión no oficial:
git clone --depth 1 https://github.com/libretro/swanstation.git

Editamos src/libretro/libretro_host_interface.cpp y comentamos el contenido de la función
LibretroHostInterface::UpdateGeometry(), dejándola inutilizada por completo.
(Esto evita las ralentizaciones cuando el WipeOut hace el efecto de terremoto de pantalla al sufrir un ataque enemigo).
OJO!!! RECUERDA que debes poner en las opciones del core el ratio a 4:3 porque al comentar UpdateGeometry() no se puede establecer
bien automáticamente.

mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

ACUÉRDATE DE PONER EL RENDERER DEL CORE EN "SOFTWARE" (No le eches la culpa al shader si hay audio dropouts)
Y EL "CPU EXECUTION MODE" A "CACHED INTERPRETER" (Contrariamente a lo que parece, es más rápido que "RECOMPILER"),
Y EL "CD-ROM SEEK SPEED UP" PON "INFINITE/INSTANTANEOUS"
A PARTE, EN "SETTINGS->AUDIO->OUTPUT" PON "ALSA" CON UN "AUDIO LATENCY" DE 32.

********CROSSCOMPILAR el core libretro Duckstation************

Puede ser interesante porque no compila en Pi3 con 1GB ni con swap. Crosscompilamos en local.

-Instalamos los paquetes:
sudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu

-Copiamos el rootfs a /opt/DEBIAN_ROOT, excluyendo home, con:
sudo rsync -av --progress /media/manuel/DEBIAN_ROOT /opt/ --exclude DEBIAN_ROOT/home/pi

-Bajamos la última release estable de aquí:
https://github.com/kivutar/swanstation/releases

-Creamos en el raiz de los sources (o donde nos de la gana) el cmake toolchain file, donde le especificamos todo lo necesario
para crosscompilar para aarch64.
Yo lo he llamado toolchain.cmake, con el contenido:

# Target system
SET(CMAKE_SYSTEM_NAME Linux)
SET(CMAKE_SYSTEM_PROCESSOR aarch64)

SET(CMAKE_SYSROOT /opt/DEBIAN_ROOT)
#set(CMAKE_FIND_ROOT_PATH /opt/DEBIAN_ROOT)

# Cross compiler
SET(CMAKE_C_COMPILER   aarch64-linux-gnu-gcc)
SET(CMAKE_CXX_COMPILER aarch64-linux-gnu-g++)
SET(CMAKE_LIBRARY_ARCHITECTURE aarch64-linux-gnu)
SET(CMAKE_PREFIX_PATH /opt/DEBIAN_ROOT/usr/lib/aarch64-linux-gnu)

SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
SET(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)

-Ahora creamos el directorio de compilación y nos movemos a él:

mkdir build
cd build

-Configuramos pasándole el cmake toolchain file así:
cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_LIBRETRO_CORE=ON -DENABLE_CHEEVOS=OFF -DENABLE_DISCORD_PRESENCE=OFF \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2" \
-DCMAKE_TOOLCHAIN_FILE=../toolchain.cmake ..

-Compilamos con make, y comprobamos el ejecutable, que sea aarch64:
file duckstation_libretro.so

¡¡Y listo!! Menuda aventura macho....

NOTAS ADICIONALES para el core:

SI DUCKSTATION DA SEGFAULT AL SELECCIONAR VULKAN, VE A SETTINGS->VIDEO->OUTPUT Y EN "OUTPUT" SELECCIONA "VULKAN"

******Crosscompilar el 64doom de N64-****************************************************************************************

--Nos bajamos el último .deb de la toolchain de N64 para x86_64 (compilador, librerías, etc) de aquí: https://github.com/DragonMinded/libdragon/releases/tag/toolchain-continuous-prerelease
Lo instalamos con: sudo dpkg -i gcc-toolchain-mips64-x86_64.deb
Quedará todo en /opt/libdragon.

--Exportamos esta varable de entorno:
export N64_INST=/opt/libdragon

--Nos bajamos la última versión del código del branch UNSTABLE de las libdragon:
git clone --depth 1 -b unstable https://github.com/DragonMinded/libdragon.git 
Las compilamos e instalamos simplemente entrando en su directorio principal y ejecutando build.sh,
con lo cual acabarán también instaladas en /opt/libdragon.
Ahora nos bajamos la versión del código de branch TRUNK de las libdragon, y la compilamos e instalamos sin desinstalar la UNSTABLE:
git clone --depth 1 -b trunk https://github.com/DragonMinded/libdragon.git 

--Nos bajamos la última versión del 64doom:
git clone --depth 1 https://github.com/jnmartin84/64doom.git

--Compilamos con:
IWAD_DIRECTORY="~/doom" IWAD_PREFIX="DOOM" make -j8
Donde IWAD_DIRECTORY es el directorio donde guardamos nuestros .WAD (que deben tener nombres todo en mayúsculas)
e IWAD_PREFIX es el identificador de juego: DOOM, DOOM2, DOOMU, etc.

******Compilar DUCKSTATION versión NOGUI (directo a KMSDRM!)*****************************************************************

Clonamos duckstation:

git clone --depth 1 https://github.com/stenzek/duckstation.git

Instalamos dependencias previas:

sudo apt-get install libevdev-dev --no-install-recommends
Y si vas a compilar con soporte para wayland, también esto:
sudo apt-get install extra-cmake-modules --no-install-recommends

Configuramos con:

cmake .. \
-DCMAKE_C_FLAGS="-march=native -mtune=native -DEGL_NO_X11" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -DEGL_NO_X11" \
-DCMAKE_BUILD_TYPE=Release -DENABLE_CHEEVOS=OFF -DENABLE_DISCORD_PRESENCE=OFF -DUSE_X11=OFF -DUSE_DRMKMS=ON \
-DBUILD_NOGUI_FRONTEND=ON -DBUILD_QT_FRONTEND=OFF -DHAVE_EGL=ON -DUSE_WAYLAND=ON -DUSE_SDL2=ON ..

(Hay que dejar el soporte de SDL2 porque EVDEV no implementa aún los ejes de los mandos)

Copia todo el contenido de bin a ~/psx. No copies sólo el ejecutable, o te dará un segfault cuando lo ejecutes.

Si  el ejecutable resultante te da un error con que no puede abrir card1, edita src/common/drm_display.h y cambia card = 1 por card = 0.

La BIOS va en ~/.local/share/duckstation/bios/

PARA LANZAR LOS JUEGOS tienes que pasarle la ruta COMPLETA del .cue, no vale que le pases una ruta relativa a donde estás,
ni que empiezes la ruta en home con ~/, etc. RUTA COMPLETA.

******Compilar el core SameBoy (GB/GBC) para Raspberry Pi 4**********

Lo primero, clona este repo PERO usa la versión 0.5.2 porque la actual no funciona:

git clone https://github.com/gbdev/rgbds.git
git fetch --tags
git checkout v0.5.2
make -j4

Ahora copia a mano a /usr/local/bin los ejecutables generados: rgbasm, rgbgfx y rgblink.

Ahora clona el repo del SameBoy upstream:

git clone --depth 1 https://github.com/LIJI32/SameBoy.git

Y entramos en el directorio "libretro" y compilamos con:

make platform=rpi4_64 -j4

******Compilar FLYCAST STANDALONE en GNU/Linux*******

Instalamos una dependencia previa rara:
apt-get install libcurl4-openssl-dev

git clone --depth 1 --recurse-submodules https://github.com/flyinghead/flycast.git

Configuramos y compilamos con:

mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DUSE_VULKAN=ON -DUSE_OPENGL=OFF \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

Ponemos la BIOS, llamada "dc_boot.bin", en ~/.local/share/flycast

Ahora lanza un juego (basta con pasarle un .CHD al flycast) y salte del emulador (para poder salir, entra en el menú usando TAB, o Select en el pad,
y verás que hay un ENORME botón en el que pone EXIT) con lo que se nos creará un ~/.config/flycast/emu.cfg completo,
que puedes configurar a tu gusto: como mínimo, pon el modo del vídeo a 1920x1080, y pon "aica.DSPEnabled" a "yes" (si no activas el DSP,
el motor del coche en Crazy Taxi no se oye).

Entra en Settings->General, y pon "Cable" a "VGA", de esa manera tendrás scanlines en los juegos de baja resolución.

Entra en Settings->Video, desactiva el VSYNC si estás en Wayland+Vulkan, pon "Transparent Sorting" a "Per Pixel"
y activa "Native Depth Interpolation", o si no tendrás errores en el Daytona y en el REZ.
Lo de "Native Depth Interpolation" es necesario para gráficos Intel y AMD, y no consume más recursos ni nada según el autor del emulador.

Entra en Settings->Audio y pon el driver a ALSA y si el dispositivo "auto" no funciona, elige el del ordenador donde estés.

Si quieres puedes configurar la tecla de EXIT asignándola a ESC, en settings->controls->keyboard->map

ARREGLO PARA EL FRAMERATE, SÓLO WAYLAND (RECUERDA QUE EN WAYLAND+VULKAN EL VSYNC DEBE ESTAR DESACTIVADO!!!):
Ponemos la resolución interna a 2x (es decir, 1280x960), y creamos este script en /usr/local/bin/dreamcast para lanzar el emulador:

wlr-randr --output HDMI-A-1 --custom-mode 1280x960@59.94
/usr/local/bin/flycast "$1"
wlr-randr --output HDMI-A-1 --custom-mode 1920x1080@60

ARREGLO PARA EL FRAMERATE, SÓLO PARA KMS/DRM:
Editamos core/deps/SDL/src/video/kmsdrm/SDL_kmsdrmvulkan.c y en la función KMSDRM_Vulkan_CreateSurface() comentamos el bloque de:
"for (i = 0; i < mode_count; i++) {"
y de:
"if (mode_found &&" y de ""
y de esa manera obligamos a que cree un modo de vídeo que nosotros queramos, y para que ese modo sea a 59.94Hz, cambiamos la línea:
new_mode_parameters.refreshRate = window->fullscreen_mode.refresh_rate * 1000;
por
new_mode_parameters.refreshRate = 59940;
(Para los juegos de NAOMI es igual).

******Compilar el core FLYCAST LIBRETRO en GNU/Linux (EL AUDIO VA MAL Y NO HAY SOLUCIÓN: USA EL EMULADOR STANDALONE)********

Clonamos su repo:
git clone --depth 1 --recurse-submodules https://github.com/flyinghead/flycast.git

Configuramos y compilamos:

mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DLIBRETRO=ON -DUSE_VULKAN=ON -DUSE_OPENGL=OFF \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

make -j2
(OJO!! -j4 agota hasta la RAM de las Pi4 con 2GB!!)

NOTA INNECESARIA: Si quisiéramos compilarlo con soporte de OpenGL, a parte de pasarle -DUSE_OPENGL=ON en vez de -DUSE_OPENGL=OFF,
tenemos que editar CMakeLists.txt y cambiar la línea:
set(OpenGL_GL_PREFERENCE LEGACY)
por
set(OpenGL_GL_PREFERENCE GLVND)

Ahora ponemos la BIOS, llamada "dc_boot.bin", en ~/.config/retroarch/system/

Para que no de segfault al iniciarse desde la TTY, tienes que poner al final de la línea de retroarch: < /dev/null
Y ya podemos lanzar juegos en GDI, CDI o CHD.

Este es un core con audio de 44100Hz, así que configura RetroArch con esta frecuencia y sálvalo en Overrides->Save Core Overrides 

(NO FUNCIONA) ARREGLAR LOS CORTES DE AUDIO DEL CORE ENTRE ESCENAS (COMO CUANDO PULSAS START EN EL SOUL CALIBUR):
https://github.com/flyinghead/flycast/issues/1211
Lee el hilo completo para entenderlo, pero dice esto el autor:
There's no easy way to fix this but there are at least 2 workarounds: disable "Performance > Threaded Rendering"
or enable "Video > Full Framebuffer Emulation." In both cases it adds a new synchronization source.

******Compilar core MOJOZORK libretro***************************************************

git clone --depth 1 https://github.com/icculus/mojozork.git

mkdir b4
cd b4

cmake .. -DMOJOZORK_MULTIZORK=OFF \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2" \
-DCMAKE_C_FLAGS="-march=native -mtune=native -O2"

*************Compilar MAME standalone con drivers selectos**********************************************************************

Clonamos su repo:
git clone -b mame0260 --depth 1 https://github.com/mamedev/mame.git mame0260

Editamos 3rdparty/bgfx/3rdparty/khronos/EGL/eglplatform.h, buscamos la línea:

#elif defined(__unix__) || defined(USE_X11)

y cambiamos lo que hay ahí dentro por esto:

typedef struct gbm_device  *EGLNativeDisplayType;                                                              
typedef struct gbm_bo      *EGLNativePixmapType;                                                               
typedef void               *EGLNativeWindowType;

Editamos scripts/src/osd/modules.lua, y borramos "input_x11.cpp" y todo lo que hay junto a eso relacionado con X11.

Editamos src/osd/modules/lib/osdobj_common.cpp y borramos estas dos líneas que no van seguidas:
REGISTER_MODULE(m_mod_man, LIGHTGUN_X11)
REGISTER_MODULE(m_mod_man, JOYSTICKINPUT_XINPUT);

Ahora, editamos "makefile" (en minúsculas) y añadimos la lista de los .cpp de los drivers que queremos que se incluyan, tal que así:
SOURCES = src/mame/sega/model1.cpp,src/mame/sega/model2.cpp,src/mame/namco/namcos11.cpp,src/mame/namco/namcos21.cpp,src/mame/namco/namcos21_c67.cpp,src/mame/namco/namcos22.cpp

Ahora ya ponemos compilar así (lo de REGENIE es para que se regenere la configuración o algo así):

CFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
CXXFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
make REGENIE=1 NO_X11=1 NO_USE_XINPUT=1 NO_USE_PULSEAUDIO=1 -j12

MAME tiene un sonido nativo de 48000Hz.

(+)MÁS INFO DE REFERENCIA:

Un hilo sobre el asunto con la solución para compilar sólo un driver:
http://forum.arcadecontrols.com/index.php?topic=162794.0

This is actually spelled out in the mame documentation:

https://docs.mamedev.org/initialsetup/compilingmame.html

Quote:

    You can do driver specific builds by using SOURCES=<driver> in your make statement. For instance, building Pac-Man by itself would be:
    "make SOURCES=src/mame/drivers/pacman.cpp REGENIE=1"
    including the necessary REGENIE for rebuilding the settings

USAR MAME (a palo seco)
=======================

Va contra las SDL2 y usa el renderer que usen las SDL2.
Primero creamos un .ini en el directorio actual:
mame -createconfig
Lo editamos a nuestro gusto, y le pasamos a MAME la ruta del .ini para cargarlo:
mame -inipath /home/manuel/mame ridgerac
Uno de los sitios donde busca por defecto los .zip de las ROMs es en $HOME/mame/roms, pero pedemos espeficar otras rutas en el .ini

******Compilar MAME libretro con soporte sólo para unos ciertos drivers************

git clone --depth 1 https://github.com/libretro/mame.git

Ahora, editamos "makefile" (en minúsculas) y añadimos la lista de los .cpp de los drivers que queremos que se incluyan, tal que así:
SOURCES = src/mame/sega/model1.cpp,src/mame/sega/model2.cpp,src/mame/namco/namcos11.cpp,src/mame/namco/namcos21.cpp,src/mame/namco/namcos21_c67.cpp,src/mame/namco/namcos22.cpp

Ahora ya ponemos compilar así (lo de REGENIE es para que se regenere la configuración o algo así):
CFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
CXXFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
make REGENIE=1 -f Makefile.libretro -j4

MAME es un core con sonido de 48000Hz, así que configura el audio en Settings->Audio->Output para esta frecuencia,
y guárdalo para este core en Quick Menu->Overrides->Save Core Overrides

******KILLER INSTINCT en core MAME LIBRETRO*******************

En el mismo directorio donde tengas el kinst.zip, crea un directorio kinst donde meterás el .chd, quedando así:
/kinst.zip
/kinst/kinst.chd
Ahora lánzalo pasándole el directorio donde está el CHD:
retroarch -L .config/retroarch/cores/mame_libretro.so emulation/MAME/kinst

******Compilar DOLPHIN standalone en GNU/Linux****************

Dependencias previas:
sudo apt-get install libevdev-dev

git clone --depth 1 https://github.com/dolphin-emu/dolphin.git
git submodule update --init

cmake .. -DCMAKE_BUILD_TYPE=Release \
-DENABLE_QT=OFF -DENABLE_PULSEAUDIO=OFF -DENABLE_LLVM=OFF -DENABLE_TESTS=OFF -DUSE_DISCORD_PRESENCE=OFF \
-DUSE_MGBA=OFF -DENABLE_AUTOUPDATE=OFF -DUSE_UPNP=OFF -DENABLE_ANALYTICS=OFF -DENCODE_FRAMEDUMPS=OFF \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

******Compilar core PCSX2 libretro****************************

Instalamos dependencia previa:
sudo apt-get install liblzma-dev

git clone --depth 1 https://github.com/libretro/pcsx2.git
git submodule update --init

Editamos CMakeLists.txt y borramos las líneas:
set(CMAKE_C_COMPILER_LAUNCHER ccache)
set(CMAKE_CXX_COMPILER_LAUNCHER ccache)

Configuramos y compilamos con:

mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

******Space Cadet pinball en GNU/Linux*********

Bajamos los últimos sources estables de aquí:

https://github.com/k4zmu2a/SpaceCadetPinball/releases

Configuramos y compilamos con:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
make -j4

Copiamos el ejecutable y los datos del juego (que los tienes ya preparados en el disco duro de backup) y a jugar.
Puedes ajustar la configuración (fullscreen, uncapped framerate, etc..) usando ~/.local/share/SpaceCadetPinball/imgui_pb.ini

******Juegos JAVA que usan GL/GLES en GNU/Linux*********************************************************************

Lo primero sería compilar esta librería:
https://github.com/LWJGL/lwjgl3

******TIC-80 FANTASY CONSOLE para Raspberry Pi como core libretro***************************************************

Clonamos su repo:
git clone --recursive https://github.com/nesbox/TIC-80 --depth 1

Configuramos con:
cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_LIBRETRO=ON -DBUILD_SDL=OFF -DDISABLE_NETWORKING=TRUE \
-DCMAKE_C_FLAGS="-march=native -mtune=native" ..

Los juegos están en:
https://tic80.com/play?cat=0

******Error tonto: ACLOCAL is missing on your system********

No te falta nada realmente. Sencillamente, hazle un touch a:
aclocal.m4
configure
Makefile.am
Makefile.in

Y ya debería solucionarse. Sin instalar nada.

******Llaves en LibreOffice**********

Antes de esto, aprende a trabajar con marcos de texto, de manera que puedas luego moverlos dentro de las laves y tal sin andar jugando con tabulaciones.
Los marcos de texto se crean con Insert->Text Box. Así de fácil.
Ahora ya, lo de las llaves va así:

1)Abrimos el programa de libreoffice
2)Clickeamos en barra de herramientas opción "ver".
3)Luego de entrar en la opción "ver" continuamos clickeando en "barra de herramientas"
4)Después ingresamos a la opción dibujo para lograr aparecer "la tabla de dibujo".
5)Tocamos en las formas de símbolos (una carita sonriente).
6)Clickeamos en la llave de apertura.
7)Para darle color, forma y espesor clickeamos en la llave con el botón derecho en la opción línea.
8)Cada cual elige como desea su llave.
9)Para rotarla se debe tocar con el botón derecho, posición y tamaño y en el mismo rotación.
10)Y luego cada uno elige la predeterminación que desea.
11)Llave finalizada.

******Overclockear la Raspberry Pi 4*******************************

[pi4]
# Run as fast as firmware / board allows
arm_boost=1

[all]
over_voltage=4
arm_freq=1800
gpu_freq=600
force_turbo=1

(NO ES NECESARIO ningún valor de overvoltage, el firmware ajusta el voltaje automáticamente desde hace tiempo).
(gpu_freq a 600 es necesario para que los shaders funcionen fullspeed en 1080p).

******Vigilar la temperatura del SOC de la Raspberry Pi************

watch -n 0.5 'cat /sys/class/thermal/thermal_zone0/temp'

(Nos da la temperatura en milésimas de grados centígrados, así que con que mires las dos primeras cifras vale,
y nos la mide cada 0.5 segundos.
La Pi4 empieza a hacer throttling a los 80 grados, y hace full throttling a los 85).

******Medir velocidad de la CPU en Raspberry Pi**********

sudo cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq

*****SDL2 en hardware genérico con mi driver KMSDRM******

Lo primero, borra la versión del sistema.
sudo rm -R /usr/lib/libSDL*
sudo rm -R /usr/include/SDL*

VAMOS A DEJAR QUE SE INSTALE EN /usr/local/lib Y /usr/local/include, ASÍ QUE NO LE PASAMOS --prefix=/usr

Antes de compilar, instalamos estas dependencias:
sudo apt-get install libudev-dev libasound2-dev libvorbis-dev libpng-dev libjpeg-dev libfreetype6-dev xsltproc libpciaccess-dev xutils-dev libtool make automake pkg-config gcc g++ --no-install-recommends
(libgbm NO TENEMOS QUE INSTALARLO ni nada, se compila e instala con MESA automáticamente, si es que instalas MESA compilándolo por tu cuenta. Si no, pues sí, hace falta libgbm-dev si usas un MESA precocinado.)
(Si has compilado SDL2 con soporte para kmsdrm pero te da el error "not available video device", es porque compilaste sin tener instalado libgmb-dev junto con un MESA precocinado, y no te ha avisado... Instala ese paquete y recompila, anda.)

Clonamos:
git clone --depth 1 https://github.com/libsdl-org/SDL.git

Ahora ya configuramos:
./configure --enable-video-x11 --disable-video-wayland --disable-dbus --disable-diskaudio --disable-oss \
--disable-pulseaudio --disable-dummyaudio --disable-video-dummy --enable-video-opengles --enable-video-opengl \
--enable-libudev --disable-dbus --disable-ime --enable-video-kmsdrm

Fíjate que en el resúmen al acabar del configure, te tiene que indicar que el soporte KMSDRM está activado, para ello se requiere que las librerías necesarias estén en el sistema (libgbm y libdrm).
Ahora borra las librerías libSDL2* que vienen instaladas en la mayoría de las distros en /usr/lib/x86_64-linux-gnu/, e instala las que acabas de compilar, que acabarán en /usr/lib.

Si quieres debugear las SDL, añade antes de ./configure: CFLAGS="-O0 -ggdb"

******SDLPop : el clon open source y libre de Prince of Persia para GNU/Linux*********

Bajamos la última release estable de aquí:
https://github.com/NagyD/SDLPoP/tags

Entramos en el directorio "src", y compilamos con:
CFLAGS="-march=native -mtune=native" CPPFLAGS="-march=native -mtune=native" make -j4

******Cambiar la región de un juego de MegaDrive y Master System*****************

PARA IR A UNA DIRECCIÓN CONCRETA EN HEXEDIT: PULSA ENTER Y TE PIDE LA DIRECCIÓN, Y ALLÁ VAMOS.
Editamos el juego con el hexedit. Nos vamos a la dirección $1F0. Pulsamos TAB para ir al texto. Cambiamos la E por una U, o por una J, como queramos.
Salimos y salvamos con CTRL+X.
Si el juego así alterado nos da un pantallazo rojo o negro, es que nos hemos cargado el checksum, pero sería muy raro. Hay programas para repararlo, anyway.

Para juegos de Master System, buscamos $7FFF, que ya sé que está muy avanzada, pero es esa, y cambiamos el valor correspondiente a los primeros 4 bits de esa dirección , 
si es PAL vendrá un 4, pones un 3 donde el 4 SIN CAMBIAR al texto con TAB, sino directamente en los valores en HEX, y ya.
y ya tienes JAP.
Míralo aquí mejor si no lo pillas: http://www.smspower.org/Development/ROMHeader#ProductCode7ffc25Bytes

******Emulando la NES con FBNeo*********************************************

OJO: NO TE COMPLIQUES CON TODO LO DE ABAJO SI PUEDES EVITARLO. LAS ROMS DE FBNEO ESTÁN TODAS EN:
www.retroroms.info

RAINBOW ISLANDS necesita, a parte de la última ROM de retroroms, la BIOS cchip.zip.

El emu de NES de FBNeo es el más exacto, pero requiere un A72 (Pi4) como mínimo.

Las ROMS además hay que prepararlas antes.
Lo más fácil es irte a 
www.retroroms.info
y bajarlas de ahí. O preguntarle a dink por privado en https://neo-source.com/index.php?action=pm#msg14377

Pero por si tuvieras que prepararlas "a mano", aquí tienes cómo hacerlo.
Veamos como ejemplo cómo preparar el romset de NES:
-Cogemos la parte de NES del ROMSET de FBNeo, o el ROMSet no-intro de NES si no tenemos otra cosa
(con el no-intro te van a faltar muchas cosas, mejor usa el ROMSet de NES de FBNeo, tienes romsets de FBNeo en archive.org).
-Cogemos el DAT de aquí:
https://github.com/libretro/FBNeo/blob/master/dats/FinalBurn%20Neo%20(ClrMame%20Pro%20XML%2C%20NES%20Games%20only).dat
Cogemos el CLRMAME de aquí (bajamos el último ZIP para Windows, NO HAY versión Linux):
https://mamedev.emulab.it/clrmamepro/#downloads
Lanzamos el CLRMAME con WINE, en el profiler simplemente le damos a "Add DatFile", y le damos el DAT que acabamos de bajar.
Ahora al volver al profiler le damos a Load/Update y ya nos sale el menú de dibujitos del CLRMAME.
Ahí nos vamos a REBUILDER. En rebuilder, dejamos todo como está menos esto:
-En el menú principal marcamos "non-merged sets" y elegimos como orígen el directorio donde tenemos el romset no-intro,
y destino el que queramos.
-En Advanced nos aseguramos de que "Separated BIOS sets" está sin marcar.
Pues ya está, le damos a Rebuild.

Ahora, para cargar la rom que queramos tenemos que pasar el parámetro --subsystem, así:
retroarch -L ~/.config/retroarch/cores/fbneo_libretro.so --subsystem=nes nes/mario.zip

O bien en el RetroArch, nos vamos a "load core", cargamos el core FBNeo, y luego vamos a "load content" y nos aparecerá
"subsystem", allí elegimos NES, y luego volvemos a "subsystem" y le damos a "start content" y elegimos otra vez NES.

Si quieres emular FDS, necesitas fdsbios.zip que contiene disksys.rom.
PERO no te compliques: usa www.retroroms.info, o en los torrents de ROMsets de FBNeo viene todo lo de FDS listo.

******MSX en el core FBNEO***************************************************************************************

Los juegos los podemos bajar de aquí, que ya están preparados para el core FBNeo: www.retroroms.info
Los metemos en un directorio junto con el msx.zip que lleva las BIOS del MSX.

Ahora, para cargar la rom que queramos tenemos que pasar el parámetro --subsystem, así:
retroarch -L ~/.config/retroarch/cores/fbneo_libretro.so --subsystem=msx msx/pengadv.zip

O bien en el RetroArch, nos vamos a "load core", cargamos el core FBNeo, y luego vamos a "load content" y nos aparecerá
"subsystem", allí elegimos MSX, y luego volvemos a "subsystem" y le damos a "start content" y elegimos otra vez MSX.

RECUERDA que para poder salvar (o cargar!) los mapeos de teclado que se aplican sólo a lo que tengas en el directorio de
los juegos de MSX (SAVE CONTENT DIRECTORY REMAP FILE), tienes que pasar la ruta de la ROM o bien completa o bien con ./ al menos, en plan:
msx1 ./msx/penguin.zip
Si haces: msx1 msx/penguin.zip, se salvará un .RMP con nombre de archivo corrupto.

RECUERDA QUE TIENES QUE TENER EN SETTINGS->INPUT->MAXIMUM USERS MÍNIMO 3, YA QUE EL TECLADO VA EN EL PLAYER 3.

PARA QUE FUNCIONE EL TECLADO, la idea es usar el "GAME FOCUS", para lo cual
NO DEBEMOS TENER ACTIVADO el "HOTKEY ENABLE", ya que son dos funcionalidades que se solapan
y si tuvieses ambas la "HOTKEY ENABLE" no funcionaría al tener activo el "GAME FOCUS" que dedica todas las teclas al core.
Así que hacemos esto:
-En Settings->Input, pon "Auto Enable Game Focus" a "Detect".
-En Settings->Input->Hotkeys, pon en "Game Focus (Toggle)" la tecla Windows ("lsuper" se llama).
-En Settings->Input->Hotkeys, NO PONGAS NINGUNA TECLA en "Hotkey Enable".

******LA ABADÍA DEL CRIMEN, nativo en LINUX**********************************************************************

Copiamos su repo:
git clone --depth 1 https://github.com/Samuel85/Abbey.git

Creamos el directorio de compilación y compilamos:
mkdir b4
cd b4
cmake ..
make -j4

Creamos el directorio donde va a ir el juego, por ejemplo ~/abadia
Y ahí copiamos los directorios "roms", "fonts" y "res" que vienen con los sources en su directorio "build".
Copiamos también el ejecutable "abbey", y ya debería ir. No necesitas nada más externo.

******Compilando OpenBOR*********************************************************************

Dependencias previas: sudo apt-get install libvpx-dev

Clonamos los sources de:
git clone --depth 1 https://github.com/DCurrent/openbor.git

Entramos en openbor/engine
Editamos Makefile y:
-Quitamos el -Werror para que no trate los warnings como errores.
-Comentamos la línea de STRIP debajo de "ifdef BUILD_LINUX"
-Quitamos el -g de la segunda línea de CFLAGS que hay al inicio de la sección Compiler Flags
-Para que cuando compilemos veamos los flags, nos vamos a la sección "Rules to manage Files and Libraries for SDL"
 y debajo del "@echo Compiling" de los .c, metemos: "@echo $(CC) $(CFLAGS) -c $<"

Antes de compilarlo, ejecutamos version.sh para que nos cree version.h

Entramos en el directorio "engine" y hacemos:

-En la Raspberry Pi:
CFLAGS="-O2 -march=native -mtune=native" \
CXXFLAGS="-O2 -march=native -mtune=native" \
make BUILD_LINUX_LE_arm=1 GCC_TARGET=64 -j4

-En el PC:
CFLAGS="-O2 -march=native -mtune=native" \
CXXFLAGS="-O2 -march=native -mtune=native" \
make BUILD_LINUX_LE_x86_64=1 GCC_TARGET=64 -j4

Para meter los juegos:
La primera vez que ejecutas OpenBOR, te crea entre otros un directorio llamado Paks. Mete los .pak ahí, y listo.

El mítico juego de HE-MAN lo tienes en su página oficial: https://gamejolt.com/games/he-man/19434
EN LAS OPCIONES DEL HE-MAN:
NO TE OLVIDES de dejar SOFTWARE RENDERER a SIMPLE 2X y el HARDWARE RENDERER a BILINEAR, activar la pantalla completa y el vsync.

Para lanzarlo sin pasar por el lanzador:
./OpenBOR Paks/HE-MAN.PAK

NO HAY opciones "generales", cada juego gestiona las suyas desde su menú. Son todos parecidos, anyway.

Puedes lanzar los juegos desempaquetados, pero no hay ventaja en ello. Para hacerlo:
Extrae el juego con borpak, una utilidad que viene en las tools de OpenBOR y que te tienes que compilar. Simplemente es hacer "borpak juego.pak" y te lo deja descomprimido en el directorio en el que estés. Sólo te interesa el directorio "data", TODOS los juegos tienen uno.
Pilla el directorio "data" del juego, y lo copias en el mismo directorio donde tengas el ejecutable del OpenBOR.
Crea un archivo de 0 bytes llamado bor.pak, y lo metes en Packs.
Total, que tienes que tener:
OpenBOR
Paks/bor.pak (0 bytes)
data (del juego que sea)
Y ya puedes hacer "./OpenBOR Paks/bor.pak" y te lanzará el juego desempaquetado.

******Another World GNU/Linux******************************************************

Clonamos su repo: git clone --depth 1 https://github.com/cyxx/rawgl.git

-En el Makefile:
	-Cambiamos -lGL por -lOpenGL en la línea de SDL_LIBS, 
	-Añadimos los CXXFLAGS que son: -O2 -march=native -mtune=native
Y añade la línea de optimiación agresiva debajo de la original de CFLAGS:
CXXFLAGS += -flto
(NO se puede mezclar -fwhole-program con -flto: una o la otra. Y como tenemos más de una unidad de compilación, -fwhole-program no va aquí).

-En mixer.cpp, ajusta el tamaño del buffer de 4096 a 1024
-En systemstub_sdl.cp:
	-Descomenta el SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, 1) y ponlo como SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear")
	-Añade SDL_RENDERER_PRESENTVSYNC a la llamada de SDL_CreateRenderer()

Si queremos renderer por software, lanzamos con:
./rawgl --language=us --render=software --fullscreen-ar --datapath=data_dos
(usar --render=original provoca errores como tiras en las piernas de los enemigos en lugar de ser sólidas).

Si queremos renderer por OpenGL, lanzamos con:
./rawgl --language=us --render=gl --fullscreen-ar --datapath=data_dos

******FLASHBACK en la Rasberry Pi*********

Bajamos los sources de:
http://cyxdown.free.fr/reminiscence/

Instalamos
apt-get install libmodplug-dev --no-install-recommends

Editamos el Makefile y quitamos las librerías de OGG y VORBIS, tocando las líneas:
 #TREMOR_LIBS  := -lvorbisidec -logg <--- Esta la comentamos.
CXXFLAGS += -Wall -MMD $(SDL_CFLAGS) -DUSE_MODPLUG -DUSE_ZLIB -O2 -march=native -mtune=native

Editamos systemstub_sdl.cpp y cambiamos:
desired.samples = 2048;
por
desired.samples = 512;
Y también añadimos SDL_RENDERER_PRESENTVSYNC a la llamada de SDL_CreateRenderer()

Creamos el directorio data y allí metemos los datos de la versión MS-DOS.
Dentro de data creamos music y ahí metemos los MODs de:
http://wiibrew.org/w/images/2/2b/Flashbackmods.zip
(NO, no sirven los ficheros de música de AMIGA directamente).

Lanzamos con:
./rs --datapath=./data --fullscreen

********Supaplex en la Pi con OpenSupaplex********************************************************************

Clonamos su repo:

git clone --depth 1 https://github.com/sergiou87/open-supaplex.git

Editamos src/sdl2/video.c y:
-Dejamos SDL_WINDOW_FULLSCREEN como SDL_WINDOW_FULLSCREEN_DESKTOP, y quitamos el #ifdef donde está contenido,
 de manera que se aplique ese flag a TODAS las plataformas.
-Cambiamos todas las demás ocurrencias de SDL_WINDOW_FULLSCREEN por SDL_WINDOW_FULLSCREEN_DESKTOP. 
-Añadimos antes de la llamada a SDL_CreateRenderer(): SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");

Entramos en el directorio linux, editamos Makefile y añadimos a los CFLAGS:

-O2 -march=native -mtune=native -O2

Compilamos con make -j4

Copiamos el contenido del directorio resources, tal cual, a ~/supaplex, junto con el ejecutable.


********Instalando ROCKBOX en un Sony NWZ 383 (Walkman MP3)***************************************************

Los archivos que necesitamos están en este hilo:
http://forums.rockbox.org/index.php/topic,43630.0.html

Y las instrucciones confusas aquí
http://www.rockbox.org/wiki/SonyNWZE370Port

PERO para que no tengas que volver a perder tiempo, la solución es esta: 
El bootloader es el mismo para todos los NZW 37x y los 38x. El ROCKBOX en sí, igual: el mismo para todos los modelos.
-Bájate el bootloader, que es el archivo que se llama sonynwze370_rb_firmware.sb. Lo metes en la raíz del dispositivo RENOMBRÁNDOLO a firmware.sb
-Bájate el Rockbox en sí, que es el archivo que se llama rockbox-sonynwze370.zip, y lo descomprimes en la raiz del dispositivo. Te creará el directorio .rockbox
-Resetea el dispositivo, si hace falta a base de meter algo en el agujero de reset que tiene detrás (a mi no me hizo falta pero tuve que conectarlo por USB para que se "despertara"
porque no se encendía tras meter el bootloader y el ROCKBOX en la raíz), y se iniciará en ROCKBOX, o deberia.

******Copiar y pegar usando GNU/Screen***************************************************************

Hacemos CTRL+A y [ , con lo que nos ponemos en modo copia. Ahora nos ponemos donde queramos empezar a copiar, le damos al espacio, seleccionamos el texto a copiar,
le damos al espacio otra vez cuando acabemos y al intro para acabar. Ya tenemos el texto copiado a un buffer. Lo pegamos con CTRL+A y luego ] . 

******Cosas a borrar después de actualizar el firmware en una Raspberry Pi...************************

/lib/modules.bak
/boot.bak

******GRAFX2 en GNU/Linux****************************************************************************

Si tenemos SDL2 instalado y funcionando, podemos tener este increíble programa de dibujo en 2D que se usa para sprites y gráficos raster!
Tenemos que tener también SDL2_image con soporte para JPG, PNG y TIFF, así que comprueba que tienes esos formatos soportados al configurar SDL2_image.
Tendrás que instalar para ello libtiff-dev.

Clonamos su repo:
git clone --depth 1 https://gitlab.com/GrafX2/grafX2.git

Editamos src/sdlscreen.c y cambiamos:
SDL_WINDOW_FULLSCREEN
por
SDL_WINDOW_FULLSCREEN_DESKTOP
Y antes de SDL_CreateWindow aniadimos:
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");

Compilamos con:
make API=sdl2 NOTTF=1 NOLUA=1 -j4

Si queremos que busque los init, skin y demás en el mismo directorio donde tengamos el ejecutable, editamos src/setup.c y tocamos las funciones:
Set_data_directory() : Dejamos sólo la primera línea, "strcpy(data_dir,program_dir);" Comentamos lo demás.
Set_config_directory() : Deejamos sólo una línea que diga: "strcpy(config_dir,program_dir);" Comentamos todo lo demás.

...Y ahora copiamos. al mismo directorio que el ejecutable:
gfx2def.ini
skings
...tienes ambas cosas en share
..Y ahora, editamos gfx2def.ini y cambiamos  el Skin_file, para evitar el error "Error in skin file: Was looking right from 254,139 for a 'mouse cursor', and reached the edge of the image":
Skin_file = skin_modern.png

Lanzamos con:
./grafx2-sdl2 -mode 640x360

******EtherTherm, un emulador de terminal gráfica para GNU/Linux*******

Instalamos dependencias previas:
apt-get install libssh-dev libyaml-cpp-dev --no-install-recommends

Clonamos su repo:
git clone --depth 1 https://github.com/M-griffin/EtherTerm.git

Nos vamos al directorio linux y compilamos:

cd linux

CFLAGS="-O2 -march=native -mtune=native -O2" \
CXXFLAGS="-O2 -march=native -mtune=native -O2" \
make -j4

******Compilar VICE en GNU/Linux*********

Necesitaremos tener instalados los paquetes flex y bison durante la configuración.
Configuramos con:

./configure --disable-sdlui --enable-sdlui2 -v --enable-arch=arm --disable-debug --disable-debug-code --disable-ipv6 --disable-ethernet --disable-rs232 --disable-realdevice --disable-shared-ffmpeg \
--disable-static-ffmpeg --disable-external-ffmpeg --without-oss --without-sdlsound --disable-midi --without-png --without-pulse 

(El -v es porque queremos que compile de modo verbose.)

Nos copiamos el directorio data, que viene con los fuentes, a donde tengamos instalado el ejecutable, x64

Luego le podemos indicar los parámetros de las roms que necesita así:

./x64 -kernal data/C64/kernal -sounddev alsa -basic data/C64/basic -chargen data/C64/chargen -dos1541 data/DRIVES/dos1541

O simplemente pasándole el directorio donde están las ROMs de ese sistema:

./x64 -directory data/C64 -sounddev alsa

Se entra en el menú con F12

******Grabar WIFISLAX moderno en un pendrive de arranque************************************************************************

Extraemos los dos directorios de la ISO, wifislax y boot, a nuestro disco duro.
Formateamos el pen a FAT32. Esto no nos va a dejar ejecutar cosas por temas de permisos de los que carece FAT32, así que ya verás lo que hay que hacer.
Copiamos ambos directorios al pen en FAT32 (el script de instalación, bootinst.sh, va a buscar el LILO en el pendrive, no en la copia de nuestro disco duro).
Copiamos boot/bootinst.sh al disco duro. Está pensado para ejecutarse desde el pen, pero como el pen está en FAT32 no podemos, así que lo editamos y dejamos las líneas
de declaración de ciertas variables así:

TARGET="/dev/sdb1"
MBR=""
MYMNT="/media/manuel/WLX"

Comentamos entero el bloque "# Find out which partition or disk are we using": entero.
Ejecutamos bootinst.sh desde nuestro disco duro, y listo. Si se queja de que no encuentra archivos para instalar el bootloader, lo mandas a la copia local del directorio boot
de la ISO y lo ejecutas desde allí.

*******Aplicar parches ips en Linux***************************************************************************************

Lo hacemos con el UIPS, un parcheador hecho en C de Neil Corlett (sí, el traductor del Seiken Densetsu 2, la gente es la hostia!) de hace mil años.
Clonamos este repo: https://github.com/chungy/cmdpack.git
Compilamos y a correr.

******Aplicar parches BPS en Linux****************************************************************************************

Usamos el FLIPS.
Clonamos su repo, lo compilamos y lo instalamos:
git clone --depth 1 https://github.com/Alcaro/Flips.git
make -j4
sudo cp flips /usr/local/bin

Se aplica con:
flips -a <parche> <ROM original>

*******Cambiar las fuentes de tamaño en Debian/Lubuntu cuando dpkg-reconfigure console-setup falla************************
El problema es que /lib/udev/console-setup-tty está jodido.
Si hacemos strace /lib/udev/console-setup-tty fbcon, vemos que está buscando un fichero de fuente en /etc/console-setup que no existe, y además lo busca en PSF y nosotros
los tenemos en .psf.gz. Así que ajustamos cosas en /etc/default/console-setup para que busque una fuente que tengamos en /etc/console-setup y se la ponemos ahí.
Intercambia la altura y anchura, descomprime la fuente con gzip.. así hasta que la encuentre.
Fuente: http://unix.stackexchange.com/questions/198791/how-do-i-permanently-change-the-console-tty-font-type-so-it-holds-after-reboot

*******Nos faltan las tildes en algunos programas en Lubuntu, a pesar de tener el teclado puesto en español****************

Regenera las LOCALES con:
sudo dpkg-reconfigure locales
Y ahí activa solo en_US.UTF8 y es_ES.UTF8, dejando por defecto en_US.UTF8, y arreglado.

*******Escritorio Lubuntu sin tearing**************************************************************************************

Sacado de https://wiki.archlinux.org/index.php/Intel_graphics#Tear-free_video

Para GPUs INTEL:

Creamos /usr/share/X11/xorg.conf.d/20-intel.conf con el contenido:

Section "Device"
   Identifier  "Intel Graphics"
   Driver      "intel"
   Option      "AccelMethod"  "sna"
   Option      "TearFree"    "true"
EndSection

Si no te funcinona glxgears, cambia "sna" por "uxa".

Para GPUs AMDGPU:

Creamos /usr/share/X11/xorg.conf.d/20-amdgpu.conf con el contenido:

Section "Device"
   Identifier  "AMD Graphics"
   Driver      "amdgpu"
   Option      "TearFree"  "true"
EndSection

Reiniciamos el servidor gráfico. Magia!

*******Eliminar accesos directos en el menu de Lubuntu*******************************************************************

Borra los que quieras de ~/.local/share/applications/

*******Comprimir un ZIP partiéndolo en varias partes*********************************************************************

Con esto creamos varios volúmenes de 1990 MB cada uno:

zip -r -s 1990m pi4.zip pi4.img

*******Comprimir un PDF*********

gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/ebook -dNOPAUSE -dQUIET -dBATCH -sOutputFile=xenon2-compressed.pdf Downloads/Xenon.2-Manual.pdf

******Arrancar e instalar una instalación de Linux en un Toshiba C50-B (o en cualquier cagarro de PC moderno con UEFI)*********

Entramos en el menú UEFI manteniendo presionado F2 al encender. Ponemos como primera unidad de arranque el USB.
Cambiamos el modo de arranque a CSM.
Instalamos y arrancamos desde el disco duro. Si hemos instalado en modo CSM, debería arrancar.
Ya que estás, desactiva SECUREBOOT.
Miseria y muerte a Microsoft y a todos los malnacidos que trabajan en ella.

*******Mantener una sesión de IRSSI y conectarse a ella por SSH******************************************************************

Lanzamos IRSSI bajo SCREEN, ya sea en local o por SSH, así:

screen irssi

Nos logueamos normalmente, abrimos los canales que queramos, etc

Y ahora podemos recuperar la sesión abierta haciendo:

screen -R -A -DD

*******Guardar LOG de una ventana en el IRSSI********

/lastlog -file <archivo>.log

*******DOSBOX STAGING en la Pi***************************************************************************************************

Clonamos su repo:
git clone --depth 1 https://github.com/dosbox-staging/dosbox-staging.git

Instalamos unas dependencias previas:
sudo apt-get install libopusfile-dev --no-install-recommends

mkdir b4
cd b4

Configuramos con:
CFLAGS="-O2 -march=native -mtune=native -O2" \
CXXFLAGS="-O2 -march=native -mtune=native -O2" \
meson .. -Dbuildtype=release -Duse_opengl=false -Duse_sdl2_net=false

Compilamos con:
ninja -j4

Copia al directorio ~/dos tanto el ejecutable dosbox como el subdirectorio subprojects tal cual.
Cuando lo ejecutes te genera un .conf en ~/.config/dosbox. Cópialo a ~/dos, y se lo puedes pasar a dosbox con:
./dosbox -conf dosbox.conf

JUEGOS DE JAVA DE MÓVIL CON FREEJ2ME
====================================

Instalamos dependencias previas (nos instalará la máquina virtual de JAVA, openjdk, en versión headless, que es necesaria
porque es la que va a correr los juegos JAVA realmente):
sudo apt-get install ant

Nos bajamos los últimos sources:
git clone --depth 1 https://github.com/hex007/freej2me.git

Entramos en freej2me y simplemente escribimos:
ant
Se nos generará build/freej2me-sdl.jar, build/freej2me-lr.jar, etc
Dependiendo de si vamos a compilar la versión LIBRETRO o la versión SDL2, copiamos
el freej2me-sdl.jar o freej2me-lr.jar que acabamos de generar a ~/.config/retroarch/system

Creamos ~/j2me, y ahí meteremos los juegos que nos bajemos en .jar

COMPILAR VERSIÓN LIBRETRO

cd src/libretro

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2"
make -j4

cp freej2me_libretro.so ~/.config/retroarch/cores

COMPILAR VERSIÓN SDL2

Entramos en freej2me y simplemente escribimos:
ant
Se nos generará build/freej2me-sdl.jar.
Creamos el directorio ~/j2me, y copiamos el freej2me-sdl.jar que acabamos de generar a ~/java
y metemos ahí los juegos que nos bajemos en .jar

Ahora generamos el interface de gráficos SDL, llamado sdl_interface. Para ello, entramos en src/sdl2, y hacemos:
make -j4
sudo make install
Esto simplemente nos mandará el interface de gráficos sdl_interface a /usr/local/bin

Ejecutamos el juego que queramos con:
java -jar freej2me-sdl.jar DoomRPG.jar 240 320 -i linear
Piensa que los juegos son verticales, por eso doy una anchura de 240 y una altura mayor, de 320.

CORE PUAE LIBRETRO, EMULADOR DE AMIGA BASADO EN SOURCES ACTUALIZADOS DE WINUAE
==============================================================================

Se compila como los demás cores.

No hace falta andar con HDFs, carga los .info de las carpetas que contengan juegos de WHDInstall,
o los .slave de los juegos WHDLinstall, o directamente los .lha que contengan juegos de WHDInstall.

Tienes todos los juegos instalados con los últimos slaves de WHDLoad listos para usar en:
https://gamesnostalgia.com/whdownload

Para pasarle parámetros CUSTOM de WHDLoad:
Mantén presionados los botones RED y BLUE del mando de CD32 (que normalmente son el A y el B de un mando de SNES)
y te aparecerá el README del WHDInstall del juego y a continuación podrás meter los CUSTOM que quieras y se quedarán guardados.
(Para el segundo botón del Toki hay que pasarle "CUSTOM2=1", y para el Shadow of the Beast "CUSTOM4=2" para el segundo botón
y "CUSTOM1=1" para saltar la intro).

FS-UAE (FSUAE), EMULADOR DE AMIGA BASADO EN SOURCES ACTUALIZADOS DE WINUAE
==========================================================================

INSTRUCCIONES ESPECÍFICAS PARA PI4 QUE NO DEBES PERDER DE VISTA:
https://github.com/FrodeSolheim/fs-uae/blob/master/docs/raspberry-pi-4.md

Instalamos dependencias previas:
sudo apt-get install gettext --no-install-recommends

Clonamos su repo:
git clone --depth 1 https://github.com/FrodeSolheim/fs-uae.git

Ejecutamos el script bootstrap incluido con los sources, y ya podemos ejecutar ./configure

Configuramos con:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure --without-x11 --with-alsa --without-midi --without-libmpeg2 --without-openal --disable-x86 --disable-qemu-cpu --disable-drivesound --disable-netplay --disable-slirp

Editamos src/fsemu-background.c y comentamos la línea:
#define FSEMU_WITH_BACKGROUND 1

Creamos el directorio ~/amiga, y ahí copiamos el ejecutable fs-uae, fs-uae.dat y los directorios "data" y "fsemu" que viene con los sources.

Tenemos una configuración mínuma de referencia que viene con los docs, en docs/examples/example.conf
Podemos copiarla como ~/amiga/configs/amiga500.conf y se la pasamos al emulador como:

./fs-uae configs/amiga500.conf

Configuración de Amiga 500 que tengo:

[config]
amiga_model = A500
kickstart_file = ../roms/kick13.rom
floppy_drive_0 =  ../disks/enchanted.adf
fullscreen = 1 
fullscreen_mode = fullscreen

Podemos por ejemplo correr fs-uae con una configuración de un 1200 con:
./fs-uae configs/1200.fs-uae --fullscreen=1

OJO! Queda mucho por hacer en la versión 4 del emulador y muchas opciones de vídeo son ignoradas por ahora.
Por ejemplo, para tener 50Hz, el monitor debe soportar 1080P a 50Hz que es lo que el emulador intenta establecer en
fsemu/src/fsemu-sdlwindow.c, en la función fsemu_sdlwindow_find_mode(). Puedes hacer que ponga un modo de 720p a 50Hz
mientras tanto, si lo necesitas.

Puedes ver otras opciones de vídeo que le puedes pasar como parámetro al ejecutable en:
https://fs-uae.net/video-options

JUEGOS Y DEMOS DE AMIGA
=======================

https://ftp2.grandis.nu/turran/FTP/

CORE DOSBOX PURE
================

Clonamos su repo:

git clone --depth 1 https://github.com/libretro/dosbox-pure.git

Compilamos con make -j4 sin más.

Para que no nos molesten las hotkeys de RetroArch al teclear palabras, tenemos que poner una tecla para el HOTKEY ENABLE en:
Settings -> Input -> Hotkeys -> Hotkey Enable
Al tener configurada una tecla para HOTKEY ENABLE, las hotkeys NO están activas a no ser que pulses esa tecla, y así no molestan.
Y recuerda que puedes quitar todas las hotkeys una a una poniéndote encima de ellas en Settins -> Input -> Hotkeys y presionando la tecla DELETE.

Los juegos que se usan (en ZIP) son los de la colección EXODOS, que está aquí:
https://exodos.the-eye.us/

CORE DOSBOX RETROARCH: ACTIVAR DYNREC
=======================================

Hay que pasarle los flags de dynrec, unaligned memory y tal en el Makefile.libretro. Las platform definitions para la Pi2 están así:

# Raspberry Pi 2
else ifeq ($(platform), rpi2)
   TARGET := $(TARGET_NAME)_libretro.so
   LDFLAGS += -shared -Wl,--version-script=libretro/link.T
   fpic = -fPIC

   ENDIANNESS_DEFINES := -DLSB_FIRST
   COMMONFLAGS += -DARM
   COMMONFLAGS += -mfloat-abi=hard
   COMMONFLAGS += -marm -mtune=cortex-a7 -mfpu=neon-vfpv4 -mfloat-abi=hard -fstrict-aliasing
   COMMONFLAGS += -DDISABLE_EXCEPTIONS
   COMMONFLAGS += -DC_DYNREC -DC_TARGETCPU="ARMV7LE" -DC_UNALIGNED_MEMORY
   IS_X86 := 0
   NEED_BPP := 16


Luego nos vamos a

libretro/dosbox.cpp

Buscamos el bloque:

const char* cores[] = { "auto",
#if (C_DYNAMIC_X86) || (C_DYNREC)
		"dynamic",
#endif
		"normal", "simple",0 };
Pstring = secprop->Add_string("core",Property::Changeable::WhenIdle,"auto");

Y lo dejamos así:

const char* cores[] = { 
                "dynamic"};
Pstring = secprop->Add_string("core",Property::Changeable::WhenIdle,"dynamic");

Compilamos con:

make -f Makefile.libretro -j8 platform=rpi2

*******OpenXComm, el UFO para la Pi***********************************************

Clonamos su repo:
git clone --depth 1 https://github.com/OpenXcom/OpenXcom.git
(...no está listo para compilar contra SDL2 aún).

*******jfduke3d, el port güeno del duke3d para Pi*********************************

Es el port original en el que colabora Ken Silverman!
Clonamos su repo de:
git clone --depth 1 --recurse-submodules https://github.com/jonof/jfduke3d.git

Editamos jfaudiolib/src/driver_sdl.c, y dejamos spec.samples a 1024, comentando el while que hay debajo.
Editamos jfbuild/src/sdlayer2.c, y cambiamos, justo antes de SDL_CreateRenderer(), en la llamada a SDL_SetHint(), "nearest" por "linear".
Editamos jfaudiolib/Makefile, y eliminamos el "-g" ese que hay ahí perdido.

Compilamos con:

PARA PC:
CFLAGS="-march=native -mtune=native -fomit-frame-pointer" CXXFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
make -j4 WITHOUT_GTK=1 RELEASE=1 USE_POLYMOST=1 USE_OPENGL=USE_GL3

PARA RASPBERRY PI:
CFLAGS="-march=native -mtune=native -fomit-frame-pointer" CXXFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
make -j4 WITHOUT_GTK=1 RELEASE=1 USE_POLYMOST=1 USE_OPENGL=USE_GLES2

Mete el duke3d.grp en el mismo directorio que el ejecutable.
Para tener música con .ogg: Mete un zip con la música en el mismo directorio donde tengas el duke3d.grp.
Y lanzaríamos el juego con:
./duke3d -g<nombre_archivo_zip_música>
RECUERDA: entre el -g y el nombre de archivo NO hay ningún espacio. Va todo seguido. 
Por ahora, usamos este: https://sc55.duke4.net/

Si quisieras música en MIDI, podrías meter un .sf2 en el mismo directorio donde tengas el duke3d.grp.

LOS CONTROLES CON 8BitDo SN30 Pro
--LOS EJES--
LEFT X - STRAFING - 50
LEFT Y - MOVING - 50
RIGHT X - TURNING - 12
RIGHT Y - LOOKINGUPANDOWN - (-12)
RIGHT TRIGGER - (+)FIRE
--LOS BOTONES--
A - JUMP
B - OPEN
X - INVENTORY
Y - JETPACK
LEFTSTICK - CROUCH
LEFTSHOULDER - PREVIOUS WEAPON
RIGHTSHOULDER - NEXT WEAPON
BACK - MAP
START - SHOW MENU

*******StarControl 2 (Ur-Quan Masters o UQM) en la Pi**********************************

Lo primero, vamos con una dependencia previa que tiene: libmikmod. La versión que viene incluida suena a rata en la Pi,
instalar libmikmod-dev nos arrastra dependencias de pulseaudio, X11 y la hostia, etc. Así que sólo nos queda instalar
nuestra propia build de libmikmod.
Para ello, clonamos su repo, configuramos, compilamos e instalamos así:

git clone --depth 1 https://github.com/sezero/mikmod.git
cd libmikmod
mkdir b4
cd b4
cmake -DCMAKE_BUILD_TYPE=Release -DENABLE_PULSE=0 -DENABLE_OSS=0 -DENABLE_DOC=0 \
-DCMAKE_C_FLAGS="-march=native -mtune=native" ..
sudo make install

Y AHORA VAMOS A POR EL UQM EN SÍ:

Bajamos los últimos sources estables de:
https://sourceforge.net/projects/sc2/files/UQM/

Descomprimimos los sources, y ejecutamos:
./build.sh uqm config
Activamos y desactivamos lo que queramos, sobre todo estas cosas:
-Compilar una RELEASE en vez de una versión DEBUG.
-Usar libmikmod del sistema, NO el libmikmod incluido que como ya hemos dicho suena mal en la Pi.

Ahora editamos build.vars, y ahí buscamos el "-O3" y añadimos las CFLAGS y CXXFLAGS al lado:
-march=native -mtune=native

Ahora editamos src/libs/graphics/sdl/sdl2_pure.c, y en la llamada de SDL_CreateRenderer(), metemos los flags:
SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC

Ahora editamos src/libs/sound/mixer/sdl/audiodrv_sdl.c, y cambiamos todas las ocurrencias de:
desired.samples = 4096;
por:
desired.samples = 1024;

Compilamos con:
./build.sh uqm

Ahora creamos:
~/sc2
Y copiamos ahí el ejecutable "uqm" que acabamos de obtener.
Ahora copiamos el directorio "content" que viene con los sources a ~/sc2, tal cual el directorio con todo lo que tiene dentro.
Ahora creamos:
~/sc2/content/packages
Descargamos los datos del mismo sitio que los sources (con uqm-content.uqm es suficiente) y los metemos en:
~/sc2/content/packages

Y ya está.
Para que no nos mande mensajes a la consola, lo podemos ejecutar con:
./uqm --logfile=/dev/null
Se sale del juego con F10 o F12.

Como mejor se ve es en poniendo la resolución del juego en su menú a 640x480, con filtro bilineal y con scanlines,
y a su vez usando wlr-randr para poner un modo de pantalla de 1280x960 (ya que 960 es justo el doble de 480 y así no se nos forman patrones
en las scanlines).

*******vkQuake en la Pi***********************************************************

Bajamos la última estable de:
https://github.com/Novum/vkQuake/releases

cd Quake

Editamos Makefile y quitamos -lX11, y ponemos MP3LIB=mad a MP3LIB=mpg123 (para no tener que instalar libmad!)

make -j4

CFLAGS="-march=native -mtune=native -O2" make -j4

*******Quakespasm en la Pi*******************************************************

Clonamos su repo:
git clone --depth 1 https://github.com/sezero/quakespasm.git

Entramos en el directorio Quake, editamos Makefile para cambiar -lGL por -lOpenGL, y compilamos con:

CFLAGS="-march=native -mtune=native -O2" make -j4 USE_SDL2=1 USE_CODEC_MP3=0 USE_CODEC_WAVE=0

En engine guarda su configuración en el subdirectorio id1 de donde tengas el ejecutable!
Los pak0.pak y pak1.pak van en ./id1
La música en OGG y con nombres de archivo como track01.ogg.. track11.ogg, va en ./id1/music

Si quieres agua transpatente, es con "r_novis 1" y "wateralpha 0.6"

*******Core TYRQUAKE en RetroArch************

Copia el core a ~/.config/retroarch/cores
Los datos del juego (los .PAK) van en un subir llamado id1, así en minúsculas. La música, en ogg, va en id1/music.

Se lanza con:
retroarch -L ~/.config/retroarch/cores/tyrquake_libretro.so id1

Pon en "Options" el "Frame Rate" a 60.

Nada más empezar, los controles no te responderán. Para arreglarlo, ve a "controls->port 1 controls"
y "Device Type" ponlo a "Gamepad Classic", y dale a "save core remap file".
O puedes tener controles tipo HALO: para ello, pon "Device Type" a "Gamepad Modern" y luego en "Options" activar el "Invert Y Axis".

Y para cambiar cosas del juego y que se conserven los cambios, mételos en id1/autoexec.cfg.
Por ejemplo, con esto queda muy a mi gusto el tamaño de pantalla, escalado de texturas, animaciones suaves, volúmen...

viewsize 120 
r_lerpmodels 1.00
r_lerpmove 1.00
dither_filter 1.00
gamma 0.90
bgmvolume "0.500000"
volume "0.200000"
bind F1 ""

Y desactiva lo de "load dummy core on shutdown", dentro de settings->core, si no quieres que al darle a quit en el menú del Quake
te mande al menú de RA.

--PARA CARGAR A CUJO--

Te puedes bajar la última versión (cujo14.zip) de aquí: https://github.com/Jason2Brownlee/QuakeBotArchive/tree/main/bin
El mod de Cujo es un sencillo archivo pak0.pak. Copia el pak0.pak a id1/pak2.pak, y ya se carga automáticamente al cargar el core.
Ahora, para llamar a Cujo y encender su luz apretando los analógicos del mando hacia abajo, pon esto en id1/autoexe.cfg
(Sí, aunque parezca raro hay que hacer unbind, wait, unbind, wait... y luego ya bind. Cosas que pasan).

unbind "JOY_L3"
unbind "JOY_R3"
wait
unbind "JOY_L3"
unbind "JOY_R3"
wait
bind "JOY_R3" "IMPULSE 100"
bind "JOY_L3" "IMPULSE 105"

Hilos de interés de cómo cargar mods en el core tyrquake (por si quieres cargar algún día las expansiones oficiales, que
a parte de un pak0.pak traen su propia música y tal):
https://www.psx-place.com/threads/tyrquake-mods-for-retroarch.9539/
https://forums.libretro.com/t/tyquake-qauke-mods-how/15631
https://docs.libretro.com/library/tyrquake/

*******TYRQUAKE standalone en GNU/Linux****************************************************************************************************

clonamos su repo:
git clone --depth 1 git://disenchant.net/tyrquake

Editamos el Makefile y cambiamos:
GL_LIBS     += GL
por:
GL_LIBS     += OpenGL

Compilamos con:
make USE_SDL=Y OPTIMIZED_CFLAGS=Y DEBUG=N -j4

POR DEFECTO compila tanto el motor software como el modotor GL, pero podemos compilar sólo uno de ellos:
-Si sólo quisiéramos el motor por software, haríamos:
make bin/tyr-quake USE_SDL=Y OPTIMIZED_CFLAGS=Y DEBUG=N -j4
-Si sólo quisiéramos el motor GL haríamos:
make bin/tyr-glquake USE_SDL=Y OPTIMIZED_CFLAGS=Y DEBUG=N -j4

*******EN RASPBIAN NO PUEDO DEBUGEAR PROGRAMAS EN C++ QUE HAN SIDO COMPILADOS CON DISTCC*********************************************************

Da todo el rato "no symbol <loquesea> in current context".
Hay que actualizar gdb...

Desisntalamos nuestro viejo gdb, el que viene con Raspbian. No tiene dependencias graves, sólo debería ser ese paquete y ya:

sudo apt-get purge gdb

Instalamos texinfo y libncurses5-dev:

sudo apt-get install texinfo libncurses5-dev

Bajamos los últimos sources de http://ftp.gnu.org/gnu/gdb/. La versión 7.9.1 va perfectamente.
Hacemos

./configure --prefix="/usr"
make -j8
sudo make install -j8

Y listo. Con el nuevo gdb ya podemos debugear cosas compiladas con el distcc, ya que encuentra los debug simbols sin problemas y podemos ir línea a línea y todo eso.

*******Profiling de programas usando OPROFILE*********

Puede que necesitemos activado el soporte de Oprofile en el kernel: PARA PROGRAMAS NORMALES NO PARECE HACER FALTA ESTO.
General Options, casi abajo del todo, Profiling y dentro de eso Oprofile.

Hay que bajar los sources y compilarlos. Pide ciertas librerías:
libiberty está en libiberty-dev. 
bfd está en binutils-dev.
Las demás librerías que va pidiendo se ve bien su nombre de paquete.

Lo normal es hacer el profiling según lanzamos el programa:

operf <ejecutable>

Para hacer el profiling de un programa en ejecución, 

operf --pid=<PID_DEL_PROGRAMA>

Luego, cuando acabemos de usar el programa, usaríamos opereport para leer el informe que hemos generado (http://oprofile.sourceforge.net/examples/):

opreport --demangle=smart --symbols `which scummvm`

Si te salen cosas como 
138941   69.8828  libc-2.19.so             /lib/arm-linux-gnueabihf/libc-2.19.so
eso quiere decir que el 69% de la CPU se está usando en una función de libc, pero como no tienes los debug symbols de libc instalados, no te la muestra.
Así que instala libc6-dbg y te saldrán todas las llamadas.

*******Añadir username, hostname  y ruta actual al prompt del bash************************************************
Añade esto a .bash_profile:

PS1="\u@\H\w$ "

******Quitar versión de kernel y lastlogin************************************************************************

Editamos /etc/pam.d/login y comentamos:

#session    optional     pam_motd.so  motd=/run/motd.dynamic
#session    optional     pam_motd.so noupdate
#session    optional     pam_mail.so standard noenv # [1]
#session	optional	 pam_lastlog.so

Editamos 
/etc/pam.d/sshd y comentamos:

#session    optional     pam_motd.so  motd=/run/motd.dynamic
#session    optional     pam_motd.so noupdate
#session    optional     pam_mail.so standard noenv # [1]

*******El comando IP**********************************************************************************************

Fuente: http://www.tecmint.com/ip-command-examples/

Añadir una IP fija:
ip addr add 192.168.5.10/24 dev eth0

Para confirmar:
ip addr show

Ahora añadimos el gateway:
ip route add default via 192.168.5.7

Probamos que podemos salir a internet:
ping 8.8.8.8

Lo único que nos faltaría es poner un servidor DNS en /etc/resolv.conf, para poder hacer ping a google y demás.
nameserver 8.8.8.8

También es posible desconectar el cable, etc

*******Mantener más o menos en hora sistemas que no tienen reloj interno (Rpi, Cubie2...)*********************************************
en Debian, instala el paquete "fake-hwclock", pon el sistema en hora y reinicia. Ya guarda la hora del último aparago y más o menos nos vale para evitar clock skews.

*******Ver los modos de vídeo disponibles usando el interface KMS/DRM*****************************************************************

modetest |grep -50 modes |more

*******Cambiar el modo con xrandr*****************************************************************************************************

Listar modos de vídeo: xrandr -q
Cambiar el modo de vídeo: 
xrandr --output LVDS1 --mode 640x480

*******Acceso a piratebay cuando la bloqueen desde europa********************************************************************************************

No hace falta ni TOR

Haced un ping o un nslookup a thepiratebay.se, tendreis la IP, los filtros de las operadoras suelen ser por nombres y no por IPs

Sustituid la IP que os salga por la URL en el navegador y ya ;) muahahahaha... 

*******Imágenes de CD: cambios de formato, etc**********

Para pasar de una combinación CUE+WAV+ISO a CUE+BIN, usamos el CDMage en Wine. Es un programa MUY antiguo, pero funciona. 
Simplemente abrimos el CUE del combo CUE+WAV+ISO, y luego le damos a SAVE AS... y el programa lo guarda como CUE/BIN!!

Para hacer lo contrario, ripear de CUE/BIN a CUE+WAV+ISOS, usamos otro programa de Windows: el BINCHUNK.EXE.
Viene en el parche del Castlevania Rondo of Blood al inglés.

*******Las tildes de Libreoffice no funcionan tras cambiar entre libreoffice y otro programa********

Instala el paquete libreoffice-gtk, y arreglado.
Recuerda: libreoffice-gtk. Es un paquete de integración.

*******Ver la configuración del kernel en ejecución****************

Para que nos aparezca /proc/config.gz, hacemos:

modprobe configs

Ahora ya podemos buscar con ZGREP directamente:

zgrep PREEMPT /proc/config.gz

*******Deshabilitar el three-finger salute (ctrl-alt-sup)**********

En algunos casos puede ser importante por seguridad, o porque arrancas con un script mínimo custom, sin sistema init.
En ese caso el kernel no sabe hacer nada a parte de "botonazo" al recibir la señal: normalmente el tratamiento
de de la señal se especifica en /etc/inittab pero sin un proceso init ese fichero no lo lee ni el gato, por lo que hacer
ctrl-alt-sup implica un reinicio inmediato sin sincronizar los discos.

Para ello, podemos ver el estado de las variables de configuración del kernel con: sysctl -a
Podemos ver el estado de la variable que nos interesa: sysctl kernel.ctrl-alt-del
Y ahora, podemos deshabilitar el ctrl-alt-sup así: sysctl -w kernel.ctrl-alt-del=0

TAMBIÉN PODRÍAMOS editar /etc/sysctl.conf y añadir allí kernel.ctrl-alt-del=0, o incluso hacer:
echo 0 > /proc/sys/kernel/ctrl-alt-del

OJO: Al deshabilitarlo, en un sistema sin init es probable que tengamos kernel panic al matar el proceso con PID1 (es decir,
al acabar nuestro script de inicio). Supongo que porque el kernel usa el mismo vector para el ctrl-alt-sup que para reiniciar
mediante el comando reboot. Ni idea.

*******Preparar el portátil como router para salir a internet desde la Raspberry Pi u otra placa conectada a él por ethernet************

Al router (el portátil, por ejemplo, que es el que se conecta a internet) le ponemos una IP fija en el mismo rango que el cliente.
En Lubuntu es tan fácil como crear una conexión ethernet nueva en el gestor de redes. 
CUIDADO!!! CUIDADO!!! NO LE PONGAS un gateway o puerta de enlace, porque LA CONEXIÓN WIFI DEJARÁ DE FUNCIONAR AL PONER EL CABLE SI LO HACES.

<BLOQUE DEBIAN> 

En DEBIAN con LXQT, que usa connman (con su GUI llamada Connman UI), hacemos lo mismo pero a mano, así:
Averiguamos el nombre que le da connman a nuestra conexió ethernet:
connmanctl services
...vemos este, que es el cableado: ethernet_3822e2bae00a_cable 

AHORA, creamos la conexión con IP estática así:
connmanctl config ethernet_3822e2bae00a_cable --ipv4 manual 192.168.1.27 255.255.255.0
...Esta conexión quedará guardada automáticamente en /var/lib/connman/ethernet_3822e2bae00a_cable/settings

<FIN BLOQUE DEBIAN>

Ahora editamos /etc/sysctl.conf y descomentamos la línea
#net.ipv4.ip_forward=1
Añadimos el binding a las IPtables:
sudo iptables -t nat -A POSTROUTING -o wlo1 -j MASQUERADE
Donde digo wlo1, me refiero al interface con el que el servidor se conecta a internet.
Antes de la 14.04 de Lubuntu, la wifi era eth1, luego fue un tiempo wlan0... así que fíjate bien.
Si queremos que estas cosas empiezen a funcionar sin reiniciar, hacemos
echo 1 > /proc/sys/net/ipv4/ip_forward
Ahora salvamos las IPtables:
sudo iptables-save | sudo tee /etc/iptables.sav
Y nos aseguremos de que se carguen al reiniciar. Para ello, editamos el crontab así:
sudo crontab -e
Y le añadimos la línea:
@reboot /usr/sbin/iptables-restore < /etc/iptables.sav
Recuerda crear una conexión en el servidor que sea del mismo rango que la IP fija del cliente,
y en el cliente poner como gateway la IP del servidor (también en RISC OS!!!),
añadir el servidor dns en /etc/resolv.conf (sólo en LINUX, claro) si hace falta, etc...
Lo típico de /etc/network/interfaces, que tienes más abajo en varios sitios.

*******Un servicio de systemd para levantar la red**************************************************************************************************

Nos interesa que no se reinicie al salir (por eso NO le ponemos "Restart=always"),
que se ejecute una sola vez (por eso ponemos "Type=oneshot")
y que permanezca activo tras ejecutarse (por eso "RemainAfterExit=yes").
Así que queda así nuestro /etc/systemd/system/wifiup.service:

[Unit]
Description=WIFI network upbringring

[Service]
Type=oneshot
User=root
Group=root
PAMName=login
ExecStart=
ExecStart=-/usr/local/bin/wifiup
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target

Lo activamos con: "systemctl enable wifiup"
(Lo único que hace es crear un symlink en /etc/systemd/system/multi-user.target.wants, ya que es ese target el que depende de nuestro script
para ser alcanzado).

Recuerda que nuestro script "wifiup" debe tener al principio la cadena:
#!/bin/bash
...O no funcionará lanzarlo desde la UNIT que acabamos de crear, porque por defecto considera que es un binario, no un script.

*******No tengo rc.local! Dónde añado cosas al inicio??*********************************************************************************************

En las versiones actuales de Debian/Ubuntu, el servicio rc-local, que leía comandos de /etc/rc.local, no viene ya, así que tenemos dos opciones:

OPCIÓN 1: Añadir cosas al crontab. Es la opción más simple.

Editamos el crontab
sudo crontab -e
Y ahí al final le añadimos la línea del comando que queramos, pero con la ruta completa donde está el comando. Además, si queremos que
lo que sea se ejecute al inicio, le ponemos delante @reboot. Así:
@reboot <COMANDO CON SU RUTA COMPLETA>

OPCIÓN 2: Crearnos un servicio rc-local

sudo vim /etc/systemd/system/rc-local.service
..con el contenido:
[Unit]
Description=/etc/rc.local Compatibility
ConditionPathExists=/etc/rc.local

[Service]
Type=forking
ExecStart=/etc/rc.local start
TimeoutSec=0
StandardOutput=tty
RemainAfterExit=yes
SysVStartPriority=99

[Install]
WantedBy=multi-user.target

Ahora creamos /etc/rc.local con este contenido:
#!/bin/sh -e
#
# rc.local

exit 0

Ahora lo hacemos ejecutable:
sudo chmod +x /etc/rc.local

Ahora metemos en él lo que necesitemos, antes del exit 0, lógicamente. Habilitamos el servicio, lo lanzamos, y comprobamos su status:
sudo systemctl enable rc-local

sudo systemctl start rc-local.service
sudo systemctl status rc-local.service

... y ya debería ejecutarse lo que hayamos puesto en /etc/rc.local

*******Averiguar IP externa***********************************************************************************************************************

curl ipecho.net/plain ; echo

*******Conocer la IP de un equipo de casa en todo momento desde fuera, mediante un email cada vez que cambia**************************************

Para linuxeros en general: Recibir un correo con la IP de tu equipo de casa (sólo Linux):

INSTALAR PAQUETES
sudo apt-get install curl mutt ssmtp

CONFIGURAR SERVICIO DETECTA IP
sudo nano /root/notify-ip
######################################
#!/bin/bash
email=USERNAME@gmail.com
if [ ! -e /tmp/ip ]; then
curl -s ifconfig.me > /tmp/ip
fi
curl -s ifconfig.me > /tmp/ip2
newip=$(diff /tmp/ip /tmp/ip2 | wc -l)
if [ $newip -gt 0 ]; then
mv -f /tmp/ip2 /tmp/ip
cat /tmp/ip | mail -s "CAMBIO DE IP DINAMICA" $email
else
rm /tmp/ip2
fi
######################################
sudo chmod +x /root/notify-ip

CONFIGURAR SERVIDOR DE CORREO
sudo nano /etc/ssmtp/ssmtp.conf
root=USERNAME@gmail.com
mailhub=smtp.gmail.com:587
rewriteDomain=
hostname=USERNAME@gmail.com
UseSTARTTLS=YES
AuthUser=USERNAME
AuthPass=PASSWORD
FromLineOverride=YES

CONFIGURAR PLANIFICADOR DE TAREAS (cada 30 mins)
sudo crontab -e
30 * * * * /root/notify-ip | date >> /tmp/notify-ip.log

sudo service cron restart 

*******Captura de pantalla en Linux y apertura automática con el PINTA*****************************************************************************

Creamos un script, captura, con permisos de ejecución y el siguiente contenido:

gnome-screenshot --file=captura.png
pinta captura.png

Lo enviamos a /usr/bin

Ahora editamos ~/.config/openbox/lubuntu-rc.xml (NO editamos /etc/xdg/openbox... porque ESO LO IGNORA), y buscamos Print.
Vemos que viene la combinación A-Print (Alt+Print screen) para capturar la pantalla. La dejamos sólo como Print, y entre <Command> y </Command>
ponemos simplemente captura. Listo.

*******Whatsapp en Linux**************************************************************************************************************************

Más fácil que mear en pared.
Nos bajamos el plugin para pidgin de aquí:  http://davidgf.net/nightly/whatsapp-purple/
O de github si lo queremos compilar (https://github.com/davidgfnet/whatsapp-purple), pero vamos, que desde la página de binarios va bien.
PARA COMPILARLO necesitamos tener instalados los paquetes libpurple-dev y libfreeimage-dev, o nos faltarán cabeceras.

Una vez que tenemos el binario, bajado o compilado por nosotros, lo mandamos a /usr/lib/purple-2, que es donde todos los programas basados en libpurple, incluído pidgin,
buscan los plugins.

Pero claro, necesitamos un user y pass. El user será el número de teléfono con el 34 delante. El pass lo tenemos que hacer registrándonos.
Para ello, usamos yowsup-cli del paquete yowsup: https://github.com/tgalal/yowsup
Clonamos el repo, instalamos python-dateutil, y damos permisos de ejecución al script yowsup-cli en python que está en src.
INstalamos esto: sudo apt-get install python-dateutil
Ahora hacemos:

./yowsup-cli registration --requestcode sms --phone 34620626230 --cc 34

Y nos llegará un mensaje al móvil con un código para registrarnos. Así que hacemos:

./yowsup-cli registration --register 396-299 --phone 34620626230 --cc 34

Sustituimos 396-299 por el código, obviamente.
Al acabar este último comando, nos dará un password. Ese password lo podemos meter en nuestro fichero config, y/o lo podemos usar ya
directamente en el plugin de pidgin como password de la cuenta, de tal manera que mi cuenta es:

login: 34620626230
pw: ymcAunpgwsfsdDFHK4FSHPHJqxM=

Ahora ya podemos agregar contactos de whatsapp con normalidad!

Si tienes problemas de conectividad, edita ~/.purple/accounts.xml y busca el servidor, versión de android, puerto...

*********DISCORDO, un cliente de discord para GNU/Linux en consola******************

Instalamos el compilador de go:

sudo apt-get install golang
(HAY una versión de gcc que compila lenguaje GO, pero no soporta la última versión del lenguaje y falla).

Clonamos el repo del DISCORDO:

git clone --depth 1 https://github.com/ayntgl/discordo.git

Compilamos con:

make build -j4

Se ejecuta directamente con: ./discordo
El pass es el que acaba en 5555.

SI ENTRAS Y NO SE VEN LOS SERVIDORES Y CANALES, entra desde la web y muévelos un poco, moviendo unos arriba y otros abajo, etc.
Y curiosamente ya se verán.

También podríamos pasarle un token de identificación con:
discordo --token <nuestro_token_de_autentificación>

*********Evitar desconexión de red WIFI cuando la batería está baja*****************

Editamos este fichero:

sudo vim /etc/NetworkManager/conf.d/default-wifi-powersave-on.conf

y ponemos
wifi.powersave = 2
(Viene puesto a 3, que es "default", y lo ponemos a 2 que es "disable").

Reiniciamos el sistema o hacemos:

systemctl restart NetworkManager

..Y listo.

*************HACER FUNCIONAR PINCHO WIFI con MT7601U en Linux********************

El kernel trae ya los módulos necesarios, pero hay que bajarse el firmware:

wget wget -c 'http://git.kernel.org/cgit/linux/kernel/git/firmware/linux-firmware.git/plain/mt7601u.bin'

...Y meterlo en su sitio:

cp mt7601u.bin /lib/firmware/

Si por alguna razón no tienes wlan0, mira dmesg.

Este driver sí soporta el modo nl80211, así que la línea de wpa_supplicant queda así:

wpa_supplicant -iwlan0 -D nl80211 -c/etc/wpa_supplicant/wpa_supplicant.conf -B

*************HACER FUNCIONAR PINCHO WIFI con RTL8188EU en Linux******************

Instalamos dependencias previas:
apt-get install build-essential linux-headers-amd64 git

Clonamos el repo:
git clone --depth 1 https://github.com/lwfinger/rtl8188eu.git

Instalamos el nuevo módulo:
make
make install
cp rtl8188eu/rtl8188eufw.bin /lib/firmware/rtlwifi/

depmod -a

update-initramfs -u

modprobe 8188eu

Ten en cuenta que el chip rtl8188eu NO SOPORTA el driver nl80211, así que en el script WIFIUP,
vez de poner -D nl80211, tiene que poner -D wext, que es el driver viejo.
Total, que la llamada a wpa_supplicant queda así:

wpa_supplicant -iwlan0 -D wext -c/etc/wpa_supplicant/wpa_supplicant.conf -B

*********NO funciona la conexión con una tarjeta de broadcom (módulo b43)***********

Si miras 
dmesg | grep err
verás queSE QUEJA DE QUE LE FALTAN LOS FICHEROS DEL FIRMWARE. Tendrías que instalar el b43-fwcutter... pero claro, no tienes internet. (Si tienes internet, simplemente
instala firmware-b43-installer
Vale, la solución es descargar a mano desde otro ordenador con conexión:
http://mirrors.kernel.org/ubuntu/pool/main/b/b43-fwcutter/b43-fwcutter_015-9_amd64.deb
http://www.lwfinger.com/b43-firmware/broadcom-wl-5.100.138.tar.bz2

Ahora descomprime, recorta el hardware y déjalo instalado:

sudo dpkg -i b43-fwcutter_015-9_amd64.deb
tar xfvj broadcom-wl-5.100.138.tar.bz2
sudo b43-fwcutter -w /lib/firmware broadcom-wl-5.100.138/linux/wl_apsta.o

Instrucciones sacadas de:
https://askubuntu.com/questions/730799/installing-firmware-b43-installer-offline

*********Conexión WIFI lenta con BCM4313*********************************************
Para arreglarlo, líbrate de los drivers b43 que son una mierdaca.

sudo apt-get install bcmwl-kernel-source
sudo modprobe -r b43 ssb wl
sudo modprobe wl

reboot and ejoy! :)

Si no tienes wifi en absoluto, instala el paquete firmware-b43-installer y reinicia, a ver si hay suerte.

********Establecer el niceness de un programa siendo usuario******************************************************************************************

Editamos /etc/security/limits.conf y añadimos la fila:
pi 	-	nice	-20

Ahora podemos lanzar el programa con nice -n -10 <nombre_programa>

********DOSBOX en ARM**************************************************************************************************************

Nos bajamos el archivo svn de aquí: http://www.dosbox.com/wiki/BuildingDOSBox
Si queremos el ARM dynarec, tras ejecutar el ./configure tenemos que editar el config.h y añadir:
#define C_DYNREC 1
#define C_TARGETCPU ARMV7LE
#define C_UNALIGNED_MEMORY 1
Cuidado, que estos valores ya estarán undef en otras partes de fichero o con valores distintos.
La info de cómo habilitar el dynanrec ARM viene de aquí: http://www.vogons.org/viewtopic.php?f=31&t=37651&p=333227#p333318

Para compilar SDL1.2.15:

Añadimos la llamada a: 

ioctl(console_fd, FBIO_WAITFORVSYNC, 0);

en src/video/fbcon/SDL_fbvideo.c, función FB_WaitVBL().

Configuramos con:

CFLAGS="-march=native -mtune=native -O2" ./configure --disable-video-opengl --enable-video-fbcon --disable-video-kms --disable-video-directfb --disable-oss --disable-alsatest --disable-pulseaudio --disable-pulseaudio-shared --disable-arts --disable-nas --disable-esd --disable-nas-shared --disable-diskaudio --disable-dummyaudio --disable-mintaudio --disable-video-x11

Si se queja el DOSBOX de que falta el ratón, usa la variable de entorno SDL_NOMOUSE=1
Si se queja de que las SDL no tienen soporte para CDROM, pues te toca recompilar las SDL.

********DESHABILITAR EL CURSOR QUE PARPADEA MIENTRAS ARRANCA EL KERNEL*********************************************************

Añadimos a cmdline.txt:
vt.global_cursor_default=0

********Hacer que el cursor de la consola deje de parpadear********************************************************************

echo -e '\033[?17;0;0c' > /dev/tty1

********Buscar un fichero a partir de parte de su nombre***************************************************************************************
find ./ -iname gl*
find ./ -name gl*

Lo de iname es para ignorar las mayúsculas o minúsculas.

******************Compilar QEMU en la Pi4**************************************************************************************************

-Clonamos su repo:

git clone --depth 1 https://gitlab.com/qemu-project/qemu.git

-Configuramos con:

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
configure --disable-gtk --disable-tpm --disable-pa --disable-oss --disable-vnc --disable-png --disable-sdl --disable-sdl-image \
--disable-selinux --disable-opengl --disable-qom-cast-debug --disable-dbus-display --target-list=m68k-softmmu

******************Actualizar a de DEBIAN WHEEZY a DEBIAN JESSIE****************************************************************************

Podemos usar el generador de sources.list que está en http://debgen.simplylinux.ch, o directamente dejar el /etc/apt/sources.list así:

deb http://ftp.es.debian.org/debian testing main contrib non-free
deb-src http://ftp.es.debian.org/debian testing main contrib non-free

deb http://ftp.debian.org/debian/ jessie-updates main contrib non-free
deb-src http://ftp.debian.org/debian/ jessie-updates main contrib non-free

deb http://security.debian.org/ jessie/updates main contrib non-free
deb-src http://security.debian.org/ jessie/updates main contrib non-free

Ahora hacemos sudo apt-get update, apt-get --download-only dist-upgrade, apt-get dist-upgrade. Y cruza los dedos ^_^"

********Crear nuestro propio rootfs de Debian ARM********************************************************************************************

Se usa para ello debootstrap. Tenemos una guía aquí: http://linux-sunxi.org/Bootable_SD_card#Using_debootstrap_-_Debian.2FUbuntu_based_distributions
Y nos hace falta tener instalado qemu-user-static en el sistema que usemos para prepararlo todo.

********Instalar DOTNET 472 en WINE***********************************************************************************************************

Creamos un WINEPREFIX de 32bits:

rm -R ~/.wine
WINEARCH=win32 winecfg 

Actualizamos Winetricks a la última versión:

sudo winetricks --self-update

Instalamos:

winetricks dotnet472

********Biblioteca de San José****************************************************************************************************************

La base de datos está en un PC con IP fija (ahora mismo, 192.168.1.128) y se comparte mediante SAMBA. El fichero de configuración de SAMBA en 
el servidor está en /etc/samba/smb.conf
La entrada para servir el biblio, que está al final del smb.conf, es esta:

[biblio]
    comment = Biblio Database
    path = /home/biblioteca/.wine/drive_c/Biblio
    browsable = yes
    guest ok = yes
    read only = no

En los clientes, el directorio compartido se monta mediante un script en el directorio .wine/drive_c/Biblio/bibio.sh, que contiene un directorio "fakebase"
donde se montará el directorio completo de Biblio del servidor (Biblio por tanto NO se instala en los clientes sino que se ejecuta la misma copia
del servidor, locamente).
Dicho script, biblio.sh, tiene el siguiente contenido:

#!/bin/bash
set -o noclobber
sudo mount -t cifs -o username=biblioteca,password=giner //192.168.1.128/biblio fakebase/
cd ~/.wine/drive_c/Biblio/
wine ./Biblio.exe

El acceso directo del escritorio tiene este contenido:

[Desktop Entry]
Name=Biblio
Exec=sh /home/pikar/.wine/drive_c/Biblio/biblio.sh
Type=Application
Comment=Biblio
Path=/home/pikar/.wine/drive_c/Biblio
Icon=accessories-dictionary
Terminal=false
StartupNotify=false 

El usuario/contraseña del servidor es biblioteca/giner, y se puede entrar por ssh.

*********Túnel SSH***************************************************************************************************************************

ssh manuel@108.15.38.135 -L 5900:127.0.0.1:5900 -N

**********Hago un blacklist a un módulo pero sigue cargando************************************************************************************

Tienes que poner "blacklist <nombre_módulo>" en /etc/modprobe.d/blacklist.conf

Y luego, hacer un:

sudo update-initramfs -u


**********Establecer un modo de video físico en el arranque en sistemas con KMS****************************************************************

Habría que pasarle una línea de este estilo al kernel:

video=HDMI-A-1:1360x768@60

En la Raspberry Pi, eso se añadiría a cmdline.txt (antes se hacía con parámetros hdmi_* en config.txt, pero esos parámetros
son ignorados en modo KMS).

**********Cuestiones de modo de vídeo en plataformas con KMS (IFC6413, etc)********************************************************************

Miramos cual es el conector activo, mirando en
/sys/class/drm/card0-*
cuál tiene "connected" en el status. 

Editamos /etc/default/grub, añadimos lo que nos interese de estas cosas a la linea de los parámetros del kernel, por ejemplos:

video="HDMI-A-1:800x600"  

video=DVI-I-1:1024x768@60

y luego hacemos un update-grub.

Información completa en:
http://nouveau.freedesktop.org/wiki/KernelModeSetting/

Comprobar resolción y movidas:
/sys/devices/platform/omapdrm.0/drm/card0

Para quitar el salvapantallas a negro:
consoleblank=0 (en el boot.scr, claro)

**********Deshabilitar el polling de KMS, que causa parpadeos y movidas en ciertos sistemas***************************************************

En :
/etc/modprobe.d/modprobe.conf:
Añadimos:
options drm_kms_helper poll=0

**********Notas instalación DEBIAN************************************************************************************************************

--Nos puede pedir firmware para hardware de red cuyo firm es non-free. Nos bajamos el archivo "firmware-ralink_0.28+squeeze1_all.deb" o el que sea que
necesitemos, pero NO nos bajamos otra ISO para esto, se hace desde un pequeño DEB, lo descomprimimos con:

ar vx mypackage.deb
tar xvzpf data.tar.gz

y mandamos los .bin al directorio raíz de un pendrive, tal cual, los .bin tirados ahí.
Y ya lo debería de detectar la instalación cuando nos pide un "removable media" con el firmware que le falta.

--Le ponemos una IP fija editando /etc/networks/interfaces y dejándo exactamente así:

auto lo eth0

iface lo inet loopback
#iface eth0 inet dhcp

iface eth0 inet static
address 192.168.5.9
netmask 255.255.255.0
gateway 192.168.5.7

Ya deberíamos poder hacer ping al equipo servidor (el portátil).
Sin embargo, nos faltaría ponerle algunos servidores dns en resolv.conf:

nameserver 208.67.222.222 
nameserver 8.8.8.8

--Deshabilitamos el MTA (Mail Transport Agent):

insserv -r exim4

---ANTES de poder instalar ningún paquete, tenemos que poner a punto el /etc/sources.list. Si no, nos pedirá el CD ROM de netinstall!
Tenemos que dejar el sources.list más o menos así:

deb http://http.debian.net/debian wheezy main
deb-src http://http.debian.net/debian wheezy main

deb http://http.debian.net/debian wheezy-updates main
deb-src http://http.debian.net/debian wheezy-updates main

deb http://security.debian.org/ wheezy/updates main
deb-src http://security.debian.org/ wheezy/updates main

y a continuación hacer un apt-get update y si queremos un apt-get upgrade. Tras eso, ya ponemos empezar a instalar paquetes.
Instalamos sudo, añadimos el usuario a la lista de sudoers. Para ello, como root hacemos:

visudo -f /etc/sudoers

y bajo la línea
root    ALL=(ALL) ALL

añadimos 
manuel   ALL=(ALL) ALL

Y abajo del todo del fichero, añadimos:

manuel ALL = NOPASSWD : ALL

Salvamos y listo.

Quitamos el IPV6:

echo 'blacklist ipv6' >> /etc/modprobe.d/blacklist

Instalamos los buil-essential:

sudo apt-get install build-essential


Ahora ya sigue la guía rápida de configuración de raspbian, porque es todo igual. 

**********Sustituir todas las ocurrencias de una cadena por otra en un directorio*******************************************************************

find ./ -type f -exec sed -i 's/apple/orange/g' {} \;

Y si simplemente queremos borrar una línea que contenga cierta cadena, sed '/pattern to match/d'

Para aplicarlo sobre un fichero:

sed -i 's/apple/orange/' <nombre_archivo>

**********Formatear FAT32 con tamaño de cluster a 32K******************************************************************************************

sudo mkfs.msdos -s 64 /dev/sdb1

ya que el tamaño de bloque es de 512bytes y -s expresa el tamaño de un sector (cluster) en bloques.

**********Seleccionar columnas en VIM*********************************************************************************************************

Esto es la hostia. Usa CTRL+V para entrar en VISUAL BLOCK MODE y seleccionar columnas. Ya las puedes borrar o hacer lo que quieras con ellas.

**********Search and replace (buscar y sustituir) en VIM******************************************************************************************

Se hace con el comando:
:%s/cadena_original/nueva_cadena/g

Y si la cadena que buscas o por la que sustituyes lleva un punto, como es un caracter especial que significa "cualquier caracter", tienes que "escaparlo", o sea,
poner un backslash antes. Por ejemplo, si quieres sustituir la cadena 1.0f por 0.5f, harías:

:%s/1\.0f/0\.5f/g

Para confirmar cada ocurrencia, usamos gc en lugar de g:
:%s/cadena_original/nueva_cadena/gc

**********Desactivar números de línea en vim****************************************************************************************************

:set nu!

**********Secuencia de debugeo rápido mediante logs*******************************************************************************************
FILE *fp;
fp = fopen("SDL_log.txt","w");
fprintf (fp,"\nSetColors() Función completada con éxito!!\n");
fclose (fp);

**********Crear un parche para que la gente pueda aplicar nuestros cambios sobre sources originales************************************************

Lo primero es conseguir el directorio con los sources originales.

Ahora, comprobamos qué ficheros están solo en los sources modificados, y qué ficheros, estando en ambos, han cambiado. Para ello hacemos:

diff -rq originales modificados

Ahora, sabiendo eso, es muy fácil saber qué ficheros borrar, es decir, los que no nos interesa que se incluyan en el parche,
tales como los generados por los buildsystems, ya que habremos estado haciendo pruebas y compilando mientras desarrollábamos.
Una vez eliminado lo que sobra, ya sí, sacamos el parche:

diff -rupN originales modificados > parche.patch

Como ves, es muy sencillo!

El parche que hemos generado, se debería poder aplicar simplemente copiándolo en el raíz de los sources originales y haciendo un
patch -p1 < parche.patch

APÉNDICE: Si sólo queremos crear un parche para un archivo (que es algo menos común):

diff -u original.c modificado.c > parche.patch

**********Parchear el kernel y el scummvm*******************************************************************************************************

Ponemos el parche en el directorio raiz de los sources, y hacemos

patch -p1 < parche.diff

Y para revertir los cambios, hacemos:

patch -R -p1 < parche.diff

**********Usar FIND correctamente**************************************************************************************************************

find . -name 'openmsx'

***********ERRROR: Programa no encuentra librería en tiempo de ejecución, pero sí la encuentra en tiempo de linkado (no hay undefined symbols)******

LO PRIMERO es hacer un ldd al ejecutable y confirmar que dicha librería aparece como NOT FOUND.
Esto es porque, aunque le pases con -L<ruta> la librería que quieres que encuentre en linkado, para que la encuentre en tiempo de ejecución necesitarías
pasarle "-Wl,-rpath,<ruta>".
Aunque lo normal es que no tengas que hacer esto tampoco, sino que la librería esté en una ubicación donde el sistema busque por defecto.
Para asegurarnos de esto, hacemos "ldconfig --verbose", y se actualizarán los directorios donde se buscan las librerias que usan los programas.
Así que si has instalado una librería pero no la encuentra un programa en tiempo de ejecuciçon, puedes pasarle el -rpath o hacer un ldconfig y listo.

***********ACCEDER A ESCRITORIO REMOTO POR VNC USANDO TIGHTVNC**************************************************************************

Se usa tightvnc porque es el cliente más ligero.
Se ha seguido este tutorial: https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-ubuntu-20-04-es

				---EN EL SERVIDOR---

Instalamos tightvnc server:
sudo apt-get install tightvncserver

Lo ejecutamos por primera vez. Nos pedirá un user/pass y un user para mirar solamente. Del user para mirar pasamos.
vncserver

Podemos levantar varios servers a la vez en el mismo ordenador, ejecutando vncserver varias veces.
Y luego podemos matarlos con:
vncserver -kill :1
vncserver -kill :2
vncserver -kill :3
..etc

Bueno, pues ahora ya podríamos conectarnos a las X remotamente, pero serían las X sin nada y no podríamos hacer nada de nada.
Así que tenemos que decirle al servidor vnc que ejecute unos comandos que lancen el escritorio en sí cuando nosotros lanzamos el servidor.
Así que matamos el servidor:
vncserver -kill :1
Hacemos una copia de seguridad de la secuencia de comandos que ejecuta el servidor al inicio:
mv ~/.vnc/xstartup ~/.vnc/xstartup.bak
Y creamos un nuevo fichero de secuencia de comandos del servidor vnc:
vim ~/.vnc/xstartup
Con el contenido (específico de lxqt, otros escritorios requerirán otras cosas):

!/bin/sh
# Uncomment the following two lines for normal desktop:
unset SESSION_MANAGER
#exec /etc/X11/xinit/xinitrc
exec openbox-session &
exec startlxqt &

Y ahora lanzamos el servidor otra vez:
vncserver

HEMOS DE SABER que el servidor vnc escucha en el puerto 5901, si lanzas otro servidor escuchará en 5902, el siguiente en 5903...
Puedes confirmarlo con netstat -pl, y ahí ves en qué puertos hay servidores vnc escuchando en la máquina.

					---EN EL CLIENTE---

Instalamos el vncviewer:

sudo apt-get install xtightvncviewer

Y ya podemos conectar al servidor con:

vncviewer <IP LOCAL>:PUERTO

Por ejemplo, si el servidor está en la 0.30 de rango local y tiene un servidor vnc escuchando en el 5901, conectamos con:

vncviewer 192.168.0.30:5901

					---CONECTAR A TRAVÉS DE UN TÚNEL SSH---
					
Una vez que tenemos el servidor VNC corriendo en el ordenador servidor, podemos mandar el tráfico de ese servidor a través de un túnel SSH:

ssh -L 59000:localhost:5901 -C -N -l <USUARIO> <IP DEL SERVIDOR>

El puerto 59000 es arbitrario: puedes poner el que te de la gana (que no tenga un servicio usándolo, claro).

En teoría, esto debeía permitir que el servidor salga a internet por un puerto abierto, para poder acceder remotamente a la máquina.
Pero eso lo dejo para más adelante. 

***********Montar un DSK de Mac antiguo, o un ADF de Amiga******************************************************************************

Para el DSK de MAC antiguo:

sudo mount -o loop disc_image.dsk directorio_montaje

Y para el ADF de Amiga:

sudo mount -t affs -o loop disc_image.adf directorio_montaje

Y para covertir un fichero de texto de MAC antiguo a Linux:

tr '\r' '\n' < macfile.txt > unixfile.txt

Y el proceso contrario:

tr '\n' '\r' < unixfile.txt > macfile.txt

***********Editar el AUTOEXEC.BAT de MSX en Linux**************************************************************************************

Se puede editar como cualquier otro fichero, pero debes guardarlo en formato DOS antes de salir, así:
:set ff=dos
:wq

***********Montar un archivo .toast de MAC***********************************************************************************************

mount -o loop -t hfsplus imagename.toast [mount point]

Y si da error prueba con hfs en lugar de hfsplus.

También sirve para montar img de diskettes de mac.

***********Quitar un servicio que no sabemos quién lo lanza********************************************************************************

Has mirado en /etc/init.d y has intentado que no se lance el script de inicio de un servicio: lo has intentado con
sudo update-rc.d -f <servicio> remove
Pero ahí sigue si haces un TOP.
Pues puedes hacer dos cosas: o desinstalas el paquete al que pertenece el servicio, o desactivas el servicio que a su vez lo está lanzando.
Y esto lo puedes hacer con un grep a todo lo de /etc/init.d, con el nombre del servicio.

***********CONEXIÓN SSH LENTA*************************************************************************************************************

Edita /etc/ssh/sshd_config y descomenta la línea "UseDNS no"

***********OTRAS NOTAS DE CONFIGURACION DE RASPEBBRY PI OS 11 (BULLSEYE)******************************************************************

-Ponemos la fuente de la consola: dpkg-reconfigure console-setup
-Ponemos los LOCALES con: dpkg-reconfigure locales. Elegimos que se generen en_US.UTF8 y es_ES.UTF, y dejamos puesto en_US.UTF8.
ESTO nos quita errores de teclado a través de SSH, ya que necesitamos los LOCALES de la máquina cliente también.
Otra manera más sencilla de evitar esos errores por SSH es editar /etc/ssh/sshd_config y comentar:
	# Allow client to pass locale environment variables
	# AcceptEnv LANG LC_*
Si lo haces así no necesitas regenerar es_ES.utf8, con en_US.utf8 vale.

-Ponemos el idioma del teclado con raspi-config, y expandimos el filesystem, overclocking y demás movidas. El layout del teclado no se cambia hasta reboot.

-Evitamos que se nos ponga la consola en negro poniendo esto en /boot/cmdline.txt:
consoleblank=0
-Para especificar el polling rate de los joysticks, para quitar latencia, con usbhid.jspoll=<polling rate>. Míratelo para entonces y añádelo.
 usbhid.jspoll=1 xpad.cpoll=1 es un buen valor, resultando en 1000Hz de polling rate... lo que ya está muy bien.
 Se puede comprobar una vez arrancado el sistema con evhz, un programa que se baja de aquí: git clone --depth 1 https://gitlab.com/iankelling/evhz
RECUERDA que tienes que poder PRIMERO quiet, y luego loglevel: EN ESE PRECISO ÓRDEN, o el valor de loglevel será IGNORADO. Tengo cmdline.txt así:
dwc_otg.lpm_enable=0 smsc95xx.turbo_mode=N console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=noop rootwait consoleblank=0 quiet loglevel=3 fastboot logo.nologo noswap

-Si tras reiniciar no podemos entrar por ssh es porque se han perdido las keys. Lo confirmamos con systemctl status ssh y vemos que no puede leer 
un archivo de claves. Para solucionarlo, las regeneramos. Hacemos:
sudo /usr/bin/ssh-keygen -A

-Repasamos los servicios activos. Podemos ver tooodas las units y su estado con:
	systemctl list-unit-files

-Desactivamos IPV6. Esto hay que hacerlo como root, así que primero establecemos una clave de root, que aún no la tenemos:
sudo passwd
su
echo 'blacklist ipv6' >> /etc/modprobe.d/blacklist
sed -i '/::/s%^%#%g' /etc/hosts

-Evitamos que se cargue el módulo de IPV6 añadiendo esto al principio de /etc/modprobe.d/ipv6.conf :
install ipv6 /bin/true
(Si te suena raro, es un fake install: como es un módulo cargado por el kernel, tenemos que hacerle creer que se carga, pero no).
Y ahora para acabar con IPV6 del todo hacemos : 
sudo sed -i '/::/s%^%#%g' /etc/hosts
-Hacemos lo mismo con otro módulo que no usamos, metiendo en /etc/modprobe.d/bcm2835_gpiomem.conf :
install bcm2835_gpiomem /bin/true
-Los módulos que necesitamos a parte de los del kernel los cargamos nosotros a mano. Sólo nos hace falta el del chip de audio. Para ello:
sudo systemctl mask systemd-modules-load
Y añadimos a rc.local:
modprobe snd_bcm2835

-Si queremos dejar que systemd gestione la carga de módulos (es lo último que suelo venir haciendo) pero queremos quitar el módulo uio y el uio_noséqué, creamos el fichero:
/etc/modprobe.d/uio_pdrv_genirq.conf
Con el contenido
blacklist uio_pdrv_genirq
Y hacemos
depmod -ae
update-initramfs -u
Reiniciamos y ya no debería estar.

También creamos /etc/modprobe.d/bcm2835_wdt.conf con el contenido:
blacklist bcm2835_wdt
Y hacemos
depmod -ae
update-initramfs -u
Reiniciamos y ya no debería estar.

-Borramos /etc/motd
-Para quitar el lastlogin, el motd, etc... editamos sudo vim /etc/pam.d/login y comentamos las líneas:
#session    optional     pam_motd.so  motd=/run/motd.dynamic
#session    optional     pam_motd.so noupdate
#session    optional     pam_mail.so standard noenv # [1]
-Para hacer lo mismo para cuando nos conectamos por ssh, editamos sudo vim /etc/pam.d/sshd y comentamos las líneas:
#session    optional     pam_motd.so  motd=/run/motd.dynamic
#session    optional     pam_motd.so noupdate
#session    optional     pam_mail.so standard noenv # [1]

En este mismo fichero, puedes quitar otros mensajes del login, como la versión del kernel y tal.
Para ello comenta las dos líneas siguientes a esta de lastlog.
-Para quitar el delay de login editamos /etc/pam.d/common-auth y añadimos a la línea de pam_unix el "nodelay",
 dejando la línea de pam_unix.so así:
auth        required      pam_unix.so nodelay
-Para quitar la frase donde dice la versión de DEBIAN y tal, borra /etc/issue o pon allí lo que quieras que salga.

-En config.txt desactivamos el watchdog:
dtparam=watchdog=off

************Acutualizar el kernel de la Raspberry Pi sin tener las herramientas de broadcom***************************************

Porque claro, eliminaste las mierdas binarias cerradas de broadcom con sudo apt-get purge libraspberrypi*
Así que esto debería de todos modos actualizar el kernel.

sudo apt-get update
sudo apt-get full-upgrade

************Actualizar la eeprom de la raspberry Pi 4 sin tener las herramientas de broadcom**************************************

Las instalas, actualizas y desinstalas.
sudo apt-get install rpi-eeprom
(Se instalan las libraspberrypi como dependencias).
sudo rpi-eeprom-update
(Volvemos a borrar las libraspberrypi....)
sudo apt-get purge libraspberrypi*

***********Scrips para levantar la red ETHERNET y la red WIFI manualmente****************************************************************

Ya no "se lleva" levantar la red ethernet desde rc.local, se hace cuando se va a usar:
En rc.local tendrás:

echo 1-1.1:1.0 > /sys/bus/usb/drivers/smsc95xx/unbind

...para que el sistema arranque con la ethernet desasctivada.

===bin/eth0-on===

sudo sh -c 'echo 1-1.1:1.0 > /sys/bus/usb/drivers/smsc95xx/bind'
sudo ifconfig eth0 up
sudo ip addr add 192.168.5.8/24 dev eth0
sudo ip route add default via 192.168.5.7
sudo /etc/init.d/dropbear start

===bin/eth0-off===

sudo /etc/init.d/dropbear stop
sudo ifconfig eth0 down
sudo sh -c 'echo 1-1.1:1.0 > /sys/bus/usb/drivers/smsc95xx/unbind'

===bin/wifi-on===

sudo ifconfig eth0 down
sudo modprobe brcmfmac
sudo ifconfig wlan0 up

sudo wpa_supplicant -d -Dnl80211 -iwlan0 -c/etc/wpa_supplicant/wpa_supplicant.conf -B

sudo ip addr add 192.168.1.12/24 dev wlan0
sudo ip route add default via 192.168.1.1
sudo /etc/init.d/dropbear start

(Los detalles sobre el fichero wpa_supplican.conf están en otra sección de este mismo documento donde explico cómo
gestionar la wifi a mano)

===bin/wifi-on, pero con DHCP en vez de IP estática===

sudo ifconfig eth0 down
sudo modprobe brcmfmac
sudo ifconfig wlan0 up

sudo wpa_supplicant -d -Dnl80211 -iwlan0 -c/etc/wpa_supplicant/wpa_supplicant.conf -B

sudo dhclient wlan0

sudo /etc/init.d/dropbear start

===bin/wifi-off===

sudo killall wpa_supplicant
sudo ifconfig wlan0 down
sudo rmmod brcmfmac
sudo /etc/init.d/dropbear stop

***********Hacer un volcado de un disco abarcando sólo el espacio usado por las particiones***********************************************

Miramos con FDISK dónde acaba la última partición, y el tamaño de unidad:

sudo fdisk -l /dev/sdb

Disk /dev/sdb: 58 GiB, 62277025792 bytes, 121634816 sectors
Disk model: Card  Reader    
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x4f2a38d0

Device     Boot  Start     End Sectors  Size Id Type
/dev/sdb1         8192  532479  524288  256M  c W95 FAT32 (LBA)
/dev/sdb2       532480 8519679 7987200  3,8G 83 Linux

AHÍ VEMOS que UNITS es: 512 bytes
AHÍ VEMOS que LA ÚLTIMA PARTICIÓN ACABA EN 8519679
PUES BIEN: A DD LE PASAMOS EL TAMAÑO DE UNIDAD (512) Y EL NÚMERO DE UNIDADES (LE SUMAMOS 1 A 8519679, Y NOS QUEDA 8519680) Y TEMEMOS:

sudo dd if=/dev/sdb of=dump.img bs=512 count=8519680 status=progress

Y ya tenemos nuestro volcado, que ocupa lo que ocupan las particiones, sin volcar el espacio extra al final del disco.

***********Extraer una partición de un IMG que contiene la imágen de un disco completo****************************************************

Fácil. Con fdisk vemos dónde empieza y cuánto mide la partición que queremos (en sectores nos lo da directamente, que es lo que nos interesa):
sudo fdisk -l Downloads/MSX3_sd.img

Device               			                   Start    End            Sectors       Size      Id Type
Downloads/MSX3_sd.img          					   2048     1982463        1980416       967M      e W95 FAT16 (LBA)

Vemos que sólo tiene una partición, que empieza en el sector 2048 y ocupa 1982563 sectores. Con eso ya ponemos hacer:
dd if=Downloads/MSX3_sd.img of=fat16_partition.img skip=2048 count=1980416

Puedes montar el resultado para ver si te deja y está todo bien:
sudo mount -o loop fat16_partition.img /mn/hdd

Ahora, podrías volcar esa partición a otro disco, empezando en el sector 2048 como en el disco original, con:
sudo dd if=fat16_partition.img of=/dev/sdb seek=2048
PERO ESO NO TENDRÍA SENTIDO, PORQUE NO SE VERÍA LA PARTICIÓN: TEN EN CUENTA QUE TIENES QUE CREAR LA PARTICIÓN ANTES, PARA QUE SE GUARDE EN LA
TABLA DE PARTICIONES, YA QUE AL VOLCAR LA PARTICIÓN SOLAMENTE NO QUEDA GUARDADA EN LA TABLA Y ES INVISIBLE!

Efectivamente, seek sirve para posicionarse en un sector del disco de salida, igual que skip nos sirvió para lo mismo en el disco de entrada.
Se podría haber hecho todo en el mismo comando combinando seek y skip, ambos a 2048 en el ejemplo:

dd if=Downloads/MSX3_sd.img of=/dev/sdb skip=2048 seek=2048 count=1980416

***********Montar una partición individual de una imágen completa de disco***************************************************************

RECUERDA: CUANDO SAQUES UNA IMÁGEN DE UNA SD COMPLETA, TODAS SUS PARTICIONES DEBEN ESTAR DESMONTADAS ANTES DE HACER LA IMÁGEN,
O LUEGO NO PODRÁS MONTAR LAS PARTICIONES DE LA IMÁGEN RESULTANTE.

Con parted vemos dónde empieza cada partición. Tenemos que verlo en bytes:

manuel@vader:~$ parted rpi_bck.img
(parted) unit                                                             
Unit?  [compact]? B                                                       
(parted) print                                                            
Model:  (file)
Disk /home/manuel/rpi_bck.img: 7948206080B
Sector size (logical/physical): 512B/512B
Partition Table: msdos

Number  Start      End          Size         Type     File system  Flags
 1      4194304B   67108863B    62914560B    primary  fat16        lba
 2      67108864B  7948206079B  7881097216B  primary  ext4

Ya tenemos la información que necesitamos, que es el offset de la segunda partición, que es la que queremos montar. Ahora simplemente hacemos:

sudo mount -o loop,rw,offset=67108864 rpi_bck.img /mnt/hdd

Y listo!!

Para raspbian más reciente:

sudo mount -o loop,rw,offset=70254592 raspbian_AUG2016.img /mnt/hdd

***********Montar una partición AMIGA dentro de una imágen RDB, o sea, un disco completo con cabecera RDB y una o varias particiones*****

Este es el tipo de HDF que se usa, por ejemplo, en el Minimig y demás implementaciones en FPGA. Es lo mismo casi que montar cualquier otra
partición que está dentro de una imágen completa de disco.
Recurrimos a parted para pillar el offset (primer valor) y el size (último valor):

manuel@vader:~$ parted /media/manuel/MINIMIG_V1/hdf_sys31.hdf 
WARNING: You are not superuser.  Watch out for permissions.
GNU Parted 3.2
Using /media/manuel/MINIMIG_V1/hdf_sys31.hdf
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) unit
Unit?  [compact]? B                                                       
(parted) print                                                            
Pralloc = 0, Reserved = 2, blocksize = 1, root block at 737478
Model:  (file)
Disk /media/manuel/MINIMIG_V1/hdf_sys31.hdf: 754974720B
Sector size (logical/physical): 512B/512B
Partition Table: amiga
Disk Flags: 

Number  Start            End                        Size                       File system        Name           Flags
1       258048B          754919423B                 754661376B                 affs1              DH0            boot

Ahora simplemente montamos con ambos parámetros y ¡funciona!

sudo mount -t affs -o loop,rw,offset=258048,sizelimit=754661376 /media/manuel/E94A-DA9D/amiga/hdf_sys31.hdf /mnt/hdd

Y para montar la imágen del disco laserdisc.hdf donde tienes los juegos de EAROK:
sudo mount -o loop,rw,offset=258048,sizelimit=1073479680 -t affs /media/manuel/E94A-DA9D/amiga/laserdisc.hdf /mnt/hdd

***********Montar una partición HFS dentro de una imágen completa de las que usa el core FPGA MACPLus************************************

La imágen que uso es la de 100MB de aquí: http://www.savagetaylor.com/downloads/
(Aunque ponga que es de IOMEGA Zip funciona perfectamente)

Como el Mini VMAC no funciona con imágenes en las que la partición HFS empieza con un offset, la extraemos primero tirando de la info de parted:

dd if=OS_608_100MB.vhd of=OS_608_100MB_HFS.vhd skip=49152 count=94306304 iflag=skip_bytes,count_bytes

Hacemos lo que sea y la volvemos a meter:

dd if=OS_608_100MB_HFS.vhd of=OS_608_100MB.vhd seek=49152 count=94306304 iflag=count_bytes oflag=seek_bytes

***********Encoger una partición de una imágen de disco***********************************************************************************

No es simplemente acceder con parted: se tiene que operar sobre un loop para esa imágen.

Pedimos el loop (siempre que loop0 esté libre, sino tenemos que pedir uno libre antes con sudo losetup -f o usar otro de los de /dev. Mira con df 
cuáles no aparecen y por tanto están libres):

sudo losetup /dev/loop0 myimage.img
sudo partprobe /dev/loop0

Ahora mira que tengas /dev/loop0p1, /dev/loop0p2, etc...

Y ya puedes hacer: 

sudo gparted /dev/loop0

...y te dejará encoger particiones EXT4 y demás.

***********Recortar una imágen de disco (tarjeta) para que no ocupe lo mismo que tiene como capacidad el dispositivo de donde se leyó*******

Lo primero es hacerle un fdisk -l a la imágen:

manuel@vader:~$ fdisk -l raspbian_RetroArch.img 

Disk raspbian_RetroArch.img: 7948 MB, 7948206080 bytes
255 heads, 63 sectors/track, 966 cylinders, total 15523840 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x0002c262

Device                                                   Boot                          Start         End              Blocks          Id            System
raspbian_RetroArch.img1                                             8192         122879       57344            c              W95 FAT32 (LBA)
raspbian_RetroArch.img2                                            122880     4218879     2048000     83            Linux

De aquí sacamos lo siguiente: que cada sector es de 512 bytes, y que la segunda partición acaba en el sector o bloque número 4218879.
Así que realmente sólo estamos 4218879 + 1 sectores (ya que el sector 0 obviamente existe).
Hacemos:

manuel@vader:~$ sudo truncate --size=$[(4218879+1)*512] raspbian_RetroArch.img

Y listo!

***********Extraer la pista de datos (ISO) y las pistas de audio de una imágen de CD en formato CloneCD (CCD+IMG+SUB)*********************

-Convierte el ccd a un CUE:
ccd2cue -i foo.img -o foo.cue foo.ccd

-Extrae las pistas de datos y audio con bchunck:
bchunk -w tomb.img tomb.cue track
(ojo que en el tomb raider las pistas de audio empiezan por track_, no por track, así que tendrías que poner track_ para que se llamasen como deben)

-La ISO de la primera pista la puedes montar y extraer sus archivos sin problemas

-Y ahora, puedes convertir todos los WAV del directorio a OGG y a MP3 con esto:
for f in *.wav; do ffmpeg -i "$f" -c:a libmp3lame -q:a 2 "${f/%wav/mp3}" -c:a libvorbis -q:a 4 "${f/%wav/ogg}"; done

-O sólo a OGG:
for f in *.wav; do ffmpeg -i "$f" -c:a libvorbis -q:a 4 "${f/%wav/ogg}"; done

***********CONVERTIR TODOS LOS FICHEROS DE UN DIRECTORIO DE WAV A FLAC*****************************************************************

Instalamos el paquete SOX:

sudo apt-get install sox

Convertimos:

for i in *.wav; do sox "$i" "${i%.*}.flac"; done

***********OpenLara, versión opensource del Tomb Raider********************************************************************************

PUEDES BAJARTE LOS DATOS DEL JUEGO SIMPLEMENTE DE:
http://xproger.info/projects/OpenLara/files/
...Y los pones donde tengas el ejecutable, y ya.
O te puedes complicar la vida con los siguientes consejos:

-Para extraer los archivos del juego, usa ISOBUSTER y extraelos en modo RAW!! (Esto es muy importante o los vídeos sonarán mal)
-Copia los directorios PSXDATA, DELDATA y FMV al directorio donde tengas el ejecutable.
-Las pistas de audio van en audio/1/_track*.ogg

***********ERROR: DISTCC no distribuye la compilación y no sé por qué, con otros proyectos sí lo hace****************************************

Posiblemente el Makefile está poniendo como compilador el cc.
Lo que compila con cc siempre puede compilar con gcc.
Así que la solución es MUY sencilla: nos vamos al directorio donde tenemos los tools del servidor para cross compiling, o sea, los binarios
(~/raspberrypi/tools.../bin) y hacemos "ln -s gcc cc".
Arreglado!

***********Compilación distribuida con distcc********************************************************************************************

ESTA PRIMERA OPCIÓN NO ES RECOMENDADA PARA LA PI!! Es más sencillo usar el cross compilador oficial y además tanto uno como otro tienen problemas
porque no soporta multiarch y no buscan los scripts .so para LD, librerías y haders donde deben, pero al menos al usar el oficial no tengo que pegarme con
la construcción del crosscompiler, y además ahora el crosscompiler oficial ya no produce binarios más lentos ni nada de eso.

PARTE 1-OPCIÓN A: CONSTRUYENDO NUESTRO PROPIO CROSS-COMPILER (NO recomendada en Octubre de 2015 porque podemos usar el cross-compilador oficial)
===============================================================
Empezamos en el servidor. 
Lo primero es tener la herramienta que nos permite a su ver crear el compilador cruzado. Para ello, clonamos el repo de github:
git clone --depth 1 https://github.com/crosstool-ng/crosstool-ng.git

Instalamos algunas cosas antes: gperf, flex, bison, libtool, libtool-bin, gawk, texinfo, libncurses5-dev, help2man...

Hacemos: bootstrap, configure, make, sudo make install
Ya deberíamos tener el comando ct-ng.
Ahora nos creamos ~/cross-rasp y entramos en él. 

Creamos nuestro propio .config desde cero con "ct-ng menuconfig", para ello, seguimos estas instrucciones:
http://elinux.org/RPi_Linaro_GCC_Compilation#Build_GCC_Linaro
Las adaptamos, eso sí, a la versión de EGLIBC y de las BINUTILS que tengamos. Tampoco elijas un compilador muy nuevo... un linaro 4.7 para la Pi1 está bien.
-Para la versión de BINUTILS, hacemos ld -v
-Para la versión de EGLIBC, hacemos ldd --version
-Pon el Number of Parallel jobs a 6 si estás en el PC de 4 cores.
-Si tienes los ficheros crt*.o (y otras librerías, como el script para LD libc.so) del sysroot de la raspberry pi en /opt/rpi_root/usr/lib/arm-linux-gnueabihf, 
 pues probablemente al pasarle --sysroot=/opt/rpi_root al compilador acabe buscando estas cosas en /opt/rpi_root/usr/lib y no las encontrará. Así que añade a los
 "gcc extra config" (en la sección "C compiler") esto: --enable-multiarch --target=arm-linux-gnueabihf. 
  Esto de --enable-multiarch --target=arm-linux-gnueabihf significa que <sysroot>/usr/lib/arm-linux-gnueabihf se añade a la lista de búsqueda.
-CUIDADO con no tener instalado svn antes de entrar en menuconfig, o tendrás un aviso de peligro en lo de la librería EGLIB.
-CUIDADO con EGLIBC, que está mal y trata de detectar versiones viejas del MAKE (la 3.69 o la 3.89, y yo tengo la 4.0), así que dará un error durante la construcción...
  Es una putada muy seria que se pare la construcción, pero hay solución. Editamos build.log y nos vamos al final. Vemos que nos ha dado un error con la versión de MAKE.
  Vale: pues editamos .build/src/eglibc-2_13/configure, buscamos donde detecta la versión de MAKE (buscando ac_prog_version sucesivas veces hasta que veamos que se está detectando
  la versión de MAKE y no de otra cosa), cambiamos para que detecte la nuestra (make --version en el PC) y listo. 
-SI TIENES ERRORES DE COMPILACIÓN de estos que parece que se ha corrompido la memoria por el calentón, es hora de borrar todo en ~/cross-rasp, menos .config, y volver a empezar.
Acuérdate de ajustar lo de la versión de make en  .build/src/eglibc-2_13/configure, que no existirá hasta que empiece a instalar las herramientas.

Hacemos "ct-ng build" y si este proceso se para es porque hemos elegido algo mal en el menuconfig.
Ahora, como en el config que hemos usado se especifica un directorio de destino, ya tenemos el cross compiler ARM en 
~/x-tools/arm-unknown-linux-gnueabi-gcc.

NOTA: Este proceso es muy dado a errores durante la construcción del compilador, librerías, etc.. Así que tira de leer el build.log, irte al final y pegar
el error en google, que a la gente también le pasan estas miserias.

NOTA: Para cambiar algo en la configuración, debes borrar totalmente el directorio cross-rasp y empezar de cero, o dará problemas
absurdos durante el proceso de building.

PARTE 1: OPCIÓN B (Recomendad en Octube de 2015)
================

Clonamos el repo de https://github.com/raspberrypi/tools.git y nos queda el cross-compiler en tools. Lo demás es igual sólo que la ruta de los ejecutables del compilador es:
/home/manuel/tools/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/bin
Y la tupla (para crosscompilar en local, lo que se llama host_alias en el scummvm que se cross-compila en local) es arm-linux-gnueabihf.

PARTE 2: CONFIGURANDO EL SERVIDOR Y EL CLIENTE CUANDO YA TENEMOS CROSS-COMPILER (Válido también para Rpi)
===============================================================================================

Tenemos el cross-compiler ya.
Si estamos en el caso en que estamos usando el cross-compiler oficial, habremos clonado el repo y tendremos el compilador para la Pi en:
~/tools/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/bin

PERO nos faltan los links simbólicos de nombres cortos a gcc, g++ y otras herramientas, ya que sólo tenemos
los archivos con nombres completos (o sea que tenemos "arm-unknown-linux-gnueabi-gcc"  o "arm-linux-gnueabihf-gcc" pero no tenemos "gcc" a secas).
Así que creamos el siguiente script, le damos 755 y lo ejecutamos estando dentro del directorio ~/tools/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/bin:

#!/bin/bash
for file in `ls`; do
        ln -s $file ${file#arm-linux-gnueabihf-}
done

Y ahora, ya deberíamos tener gcc, g++, etc. Compruébalo.

Ahora instalamos distcc en el cliente y en el servidor. Simplemente, sudo apt-get install distcc en ambos.

En el servidor, editamos /etc/default/distcc y ponemos:

STARTDISTCC="true"
ALLOWEDNETS="192.168.5.0/24 192.168.5.8"  <-----Esto es la IP de la red del cliente y del propio cliente, separadas por espacio.
LISTENER="192.168.5.7"
(quitamos LISTENER="127.0.0.1").

Ahora, también en el servidor, editamos /etc/init.d/distcc y en PATH añadimos delante el path donde tenemos los ejecutables de nuestro cross-compiler.
La línea en cuestión quedaría así si hemos construido nuestro cross compiler:

PATH=/home/manuel/tools/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

Lanzamos el servidor. Para ello, en un systema con systemd hacemos:

systemctl daemon-reload
systemctl start distcc
systemctl status distcc

Tienes que ver que te sale la línea en verde:
Active: active (running) since ...

Si no va, cambia lo que sea en los ficheros de configuración y a continuación haz:
systemctl stop distcc
systemctl daemon-reload
systemctl start distcc

En cambio, si estamos en un sistema viejo con sysvinit, 
Lanzamos el servidor con sudo /etc/init.d/distcc start --verbose

Ahora, en el cliente, editamos /etc/distcc/hosts, comentamos la línea de "+zeroconfig" y ponemos sin más la IP del servidor:
192.168.5.7

Ahora también en el cliente tenemos que exportar el path del compilador, que ya no queremos que sea el gcc local sino un link sombólico gestionado
por distcc. Así que dejamos así el path en ~/.profile:

# set PATH so it includes user's private bin if it exists
if [ -d "$HOME/bin" ] ; then
     PATH="/usr/lib/distcc:$HOME/bin:$PATH"
fi

Ahora en el cliente quitamos el distcc del inicio:

sudo systemctl disable distcc

...y creamos el directorio ~/.bin, que de todos modos nos va a venir bien.

Ahora comprobamos que todo está bien: 
-En el servidor, podemos confirmar que distcc escucha en el puerto 3632 de la IP 192.168.5.7, que es la der server. Para ello, haremos
sudo netstat -apn |grep 3632
Esto es lo que se llama el "binding" del servidor.
-También podemos comprobar si el puerto 3632 de server está abierto, de dos maneras: desde el cliente, con telnet 192.168.5.7 3632. Si la pantalla
sale en negro o con ASCII raros todo va bien, ya que telnet lee datos crudos por ese puerto.
O bien desde el propio servidor, o desde el cliente, con "nmap -p 3632 192.168.5.7". Nos tiene que salir que el puerto 3632 TCP está abierto. 

***********Las voces en OSMAND+ (osmand) en Android**********************************************************************************

Este tema siempre da algo de guerra.
Debes instalar un motor de TTS en el sistema, que las versiones libres de Android no suelen traerlo. Instala el AHOTTs de la Aurora Store (Clon libre de la PlayStore).
Elígelo como motor TTS en la configuración del teléfono, en accesibilidad. 
Ya te debería ir en OSMAND.

***********Actualizar gcc 4.6 a gcc 4.7 en raspbian****************************************************************************************

Tras hacer un apt-get update y un apt-get upgrade, y sin eliminar NADA, o sea, dejando gcc-4.6 ya que tiene muchas dependencias, hacemos
¡¡¡¡¡¡CUIDADO E INSTALA AMBOS!!!!!!
sudo apt-get install gcc-4.7
sudo apt-get install g++-4.7

Creamos el script /usr/bin/gcc-set-default-version con el contenido:

#!/bin/bash 
usage() {
        echo 
        echo Sets the default version of gcc, g++, etc
        echo Usage:
        echo 
        echo "    gcc-set-default-version <VERSION>"
        echo 
        exit
}
cd /usr/bin
if [ -z $1 ] ; then 
        usage;
fi 
set_default() {
        if [ -e "$1-$2" ] ; then 
                echo $1-$2 is now the default
                ln -sf $1-$2 $1
        else 
                echo $1-$2 is not installed
        fi
}
for i in gcc cpp g++ gcov gccbug ; do 
        set_default $i $1
done

Le damos permisos de ejecución (755 sirve), y hacemos:

sudo gcc-set-default-version 4.7

Y ya debería estar. Nos dirá que no tenemos instalado gccbug-4.7, pero eso no es importante.

Instalamos VIM y le ponemos el ~/.vimrc que tienes en la sección de apuntes del VIM...
Y ahora, para que VIM recuerde la última posición en que estábamos cuando abrimos un fichero dado por última vez, editamos /etc/vim/vimrc
y descomentamos esto, que viene comentado por defecto:

" Uncomment the following to have Vim jump to the last position when
" reopening a file
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

SI ESTO NO FUNCIONA, comprueba los permisos de ~/.viminfo. Debe pertenecer al usuario actual, si no es así, probablemente no vuelva a la última
posición cuando reabrimos un fichero.

***********Comparar ficheros con VIM***************************************************************************************************

Puedes abrir dos ficheros en modo comparación con 

vim -d fichero1 fichero2

Las líneas de guiones en uno son líneas que el otro tiene pero ese no, y de ese modo líneas iguales aparecen a la misma altura!.

***********La utilidad LOCATE**********************************************************************************************************
Efectivamente, sirve para buscar archivos en todo el disco, tirando de base de datos en lugar de buscar físicamente.
Así que lo instalamos con:

apt-get install locate

y antes de usarlo hacemos

sudo updatedb

Y ya se supone que podemos usarlo.

***********TIC-80, una consola imaginaria para Pi************************************************************************************************

Clonamos su repo y actualizamos los submódulos para poder compilar:
git clone --depth 1 https://github.com/nesbox/TIC-80.git
git submodule update --init --recursive

Creamos el dir de compilación, entramos, configuramos y compilamos:
mkdir b3
cd b3
cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_LIBRETRO=ON -DBUILD_SDL=OFF -DDISABLE_NETWORKING=TRUE \
-DCMAKE_C_FLAGS="-march=native -mtune=native" ..
make -j4

***********Compilar RAZE, el engine de Duke Nukem, Blood, Exhumed, etc para Linux****************************************************************

NOTA: Sólo funciona en modo GLES y SOFTWARE, tiene Vulkan pero en la Pi cuelga el sistema entero al cargar el primer nivel.
El soporte GLES y Vulkan son activados por defecto, así que vas a ver que desactivamos el soporte Vulkan al ejecutar cmake.

-Instalamos una dependencia previa:
sudo apt-get install libvpx-dev

-Primero, necesita OpenAL. Tienes las instrucciones de instalación en este documento.

-Segundo, necesita ZMUSIC. Vamos con ZMUSIC pues:
Instala libmpg123-dev y libvorbis-dev.
Clonamos su repo (las versiones que hay en "releases" buscan versiones de FluidSynth viejas así que no irán):
git clone --depth 1 https://github.com/ZDoom/ZMusic.git

Creamos el directorio de compilación, entramos y configuramos, compilamos e instalamos:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native"
make -j4
sudo make install

-Vamos a por RAZE en sí.
Nos bajamos la última estable de: https://github.com/ZDoom/Raze/releases

SÓLO SI VAMOS A USAR VULKAN (QUE NO FUNCIONA Y LO VAMOS A DESHABILITAR POR DEFECTO): Editamos libraries/ZVulkan/src/volk/volk.c,
y cambiamos VK_USE_PLATFORM_XLIB_KHR por VK_USE_PLATFORM_WAYLAND_KHR

Creamos el directorio de compilación, entramos, configuramos y compilamos:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native" -DHAVE_VULKAN=OFF
make -j4

Ahora, creamos ~/raze y metemos allí el ejecutable resultante ("raze"), raze.pk3, el directorio soundfonts, y los ficheros de datos del BLOOD.

Para ejecutarlo con el renderer GLES2, lo lanzamos con: +vid_preferbackend 2
Para ejecutarlo con el renderer VULKAN, lo lanzamos con: +vid_preferbackend 1 (OJO!! REVIENTA LA RAM Y EL ORDENADOR SE CUELGA!! USA GLES!!)
Para que vaya a 60FPS sólidos, puedes desactivar TODO el antialiasing, poner FPS a UNLIMITED, etc

***********EDUKE32: Duke Nukem 3D en GNU/Linux*********************************************************************************************

Va sobre SDL2 + SDL2 Mixer. Se supone que tenemos ambas instaladas y listas!

Preferentemente, usa este fork, que inclue soporte para BLOOD y EXHUMED también (OJO: el soporte de OpenGL no va):
git clone --depth 1 https://github.com/nukeykt/NBlood.git

Si quieres usar el eduke32 original, clona su repo de aquí:
git clone --depth 1 https://voidpoint.io/terminx/eduke32.git

Compilamos con:

make -j4 RELEASE=1 WITHOUT_GTK=1 USE_OPENGL=1 USE_LIBVPX=0 HAVE_FLAC=0 \
OPTOPT="-march=native -mtune=native -O2"

Mete el duke3d.grp en el mismo directorio que el ejecutable.
Para tener música con .ogg: Mete un zip con la música en el mismo directorio donde tengas el duke3d.grp.
Y lanzaríamos el juego con:
./duke3d -g<nombre_archivo_zip_música>
RECUERDA: entre el -g y el nombre de archivo NO hay ningún espacio. Va todo seguido. 
Por ahora, usamos este: https://sc55.duke4.net/

Para quitar el autorun es con BLOQ. MAYUS, y para quitar la mirilla es con "i".

************Schismtracker en GNU/Linux*******************************************************************


Bajamos la última estable de:
https://github.com/schismtracker/schismtracker/releases
¡¡¡¡¡¡¡¡¡¡¡¡¡CUIDADO, ES DE LOS QUE NOS DEJAN TODO TIRADO EN EL MISMO DIRECTORIO DEL .TAR.GZ!!!!!!!!!!!!!
¡¡¡¡¡¡¡¡¡¡¡¡¡MÉTELO ANTES DE UN DIRECTORIO PROPIO Y LO DESCOMPRIMES ALLÍ!!!!!!!!!!!!!!!


##### BLOQUE EN PRINCIPIO YA INNECESARIO#####
Instalamos dependencias previas:
sudo apt-get install autoconf

Ejecutamos:
autoreconf -vif
##### FIN BLOQUE EN PRINCIPIO YA INNECESARIO#####

Configuramos con:

CFLAGS="-O2 -march=native -mtune=native" ./configure --without-x --without-flac

En la Raspberry Pi, ejecutamos con:
AUDIODEV="sysdefault" ./schismtracker
El el PC AMD64, ejecutamos con:
AUDIODEV="default" ./schismtracker
(Puedes probar con "sysdefault" si "default" no funciona).
(En otros sistemas, lo suyo es pasar también AUDIODEV="hw:lo_que_sea" y asi se consiguen tamaños de buffer menores, pero en la Raspberry Pi
si usas la CARD vc4hdmi0, no se puede usar directamente el DEVICE llamado "hw" porque no soporta mas que un formato de audio raro,
y por eso falla con un "unsopported audio format" si lo intentas).
(Ya sabes que puedes ver los dispositivos con "aplay -L" y probarlos con "speaker-test -D<dispositivo>").

Para configurar el vídeo, editamos ~/.schism/config, y:
-Ponemos fullscreen a 1 e interpolation a linear.
-Añadimos la línea "want_fixed=1" (para tener aspect ratio corregido)
También podemos poner classic_mode a 1 para que las pantallas sean las del Impulse Tracker original.

////BLOQUE OPCIONAL (innecesario): Si no queremos tener que lanzar el Schismtracker con la variable de entorno AUDIODEV:

Editamos schism/audio_playback.c y, en la función _audio_open(), comentamos:
-ESTE "IF" Y LO QUE HAY DENTRO:
if (!(getenv("SDL_AUDIODRIVER") || getenv("AUDIODEV") || getenv("SDL_PATH_DSP"))
                 && (cfg_audio_driver[0] == '\0'))
                 _audio_set_envvars(driver_spec);

-ESTE "IF" Y TODO LO QUE HAY DENTRO:
if ((driver_name = SDL_GetCurrentAudioDriver()) != NULL && !strcmp(driver_name, "alsa"))

-POR SI ALGUNA VEZ LO QUIERES MODIFICAR, NECESITAS ENTENDER LO QUE PASA: La variable de entorno AUDIODEV es leida por el backend ALSA de SDL2,
y Schismtracker lo que hace es exportar AUDIODEV="hw" cuando SDL_AUDIODRIVER es "alsa". Como el dispositivo "hw" no se puede usar directamente
en la Raspberry cuando usas la tarjeta vc4hdmi porque solo soporta un formato de audio raro, falla.
Por eso se arregla cuando exportamos AUDIODEV="sysdefault": porque usamos el backend "alsa" de las SDL2 y concretamente el dispositivo "sysdefault".

/////FIN BLOQUE OPCIONAL

************GISH en GNU/Linux**************************************************************************************************************

Clonamos este repo, que tiene una versión SDL2:

git clone --depth 1 https://github.com/ScrelliCopter/gish.git

Editamos src/sdl/video.c y añadimos esta línea justo debajo de SDL_CreateWindow():
SDL_GL_SetSwapInterval(1);

Creamos el directorio de compilación y configuramos y compilamos así:

mkdir b4
cd b4
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_FLAGS="-march=native -mtune=native" ..

Para ejecutar el juego, copia los datos del juego tal cual al mismo directorio donde tengas el ejecutable.
TIENES los datos del juego listos en el disco duro de backup.

--REPOSITORIO ALTERNATIVO (NO recomendado, no te compliques)--

git clone --depth 1 https://github.com/EXL/Gish.git

Creamos el directorio de compilación y configuramos y compilamos así:
(OJO, que le tenemos que pasar un directorio concreto a CMake como ves)

mkdir b4
cd b4
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_FLAGS="-march=native -mtune=native" ../gish/src/main/cpp

Se ejecuta igual que el del otro repo.

************AQUARIA en GNU/Linux***********************************************************************************************************

Dependencias previas: Necesita OpenAL y SDL2 en el sistema, como muchos otros sourceports.

Clonamos su repo:
git clone --depth 1 https://github.com/AquariaOSE/Aquaria.git

Creamos el directorio de compilación, entramos y configuramos con:
mkdir b4
cd b4
cmake -DAQUARIA_USE_SDL2=TRUE \
-DCMAKE_BUILD_TYPE=Release -DCMAKE_C_FLAGS="-march=native -mtune=native" -DCMAKE_CXX_FLAGS="-march=native -mtune=native" ..

Para ejecutarlo:
-Creamos nuestro directorio "~/aquaria"
-Metemos el ejecutable "aquaria" en ~/aquaria
-Metemos los datos de una instalación juego en el directorio ~/aquaria
NOTA: Tienes los datos listos ya en el disco duro de backup.
-Copiamos el contenido del directorio "files" que viene con los sources a ~/aquaria, sobreescribiendo así parte de los datos del juego.
OJO: Es el contenido de "files" lo que tenemos que copiar, no el directorio.

************ECWOLF, el mejor port del Wolfenstein 3D, en la Pi*****************************************************************************

Clonamos su repo:
git clone --depth 1 https://bitbucket.org/ecwolf/ecwolf.git

Puedes añadir en src/sdlvideo.cpp el típico
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
justo antes de SDL_CreateWindow(), para el escalado emborronado que te gusta.

Compilamos con:

mkdir b4
cd b4

cmake -DCMAKE_BUILD_TYPE=Release -DGPL=ON -DCMAKE_C_FLAGS="-march=native -mtune=native" ..
(PARA compilar en modo verbose, haz make VERBOSE=1)

Ahora, para activar el vsync es en los menús. Y para que vaya suave, le pasas al ejecutable el parámetro --noadaptive
Puedes establecer un buffer de audio menor con --audiobuffer 512

Sólo hace falta tener el ejecutable en el mismo directorio que los datos del wolfenstein (versión de ACTIVISION, NO la original de Apogee, OJO!!!), y funcionará sin más.

Pon la resolución a 320x200 en el menú, fullscreen, vsync ON.

NO soporta el Rise Of The Triad, sólo el Wolfenstein y el Spear of Destiny.

Para mejorar la música y los gŕaficos, yo uso el pack ECWolf_hdmus_BrainStewX para la música (tienes que tener SDL2_Mixer compilado con soporte de OGG, para lo que habrás tenido que instalar libogg-dev antes de configurar, compilar e instalar SDL2_Mixer, lo normal es que ya lo tengas porque es lo que usas para las músicas custom del SCUMMVM):
https://forum.zdoom.org/viewtopic.php?f=19&t=48633

Y el pack hi-res sencillo de aquí para los gráficos de armas y enemigos, sonidos fx, etc:
https://www.moddb.com/games/wolfenstein-3d/addons/ecwolf-rmst

Al final, mi script wolf3d contiene esta línea para lanzar el ECWOLF a mi gusto:
./ecwolf --noadaptive --audiobuffer 512 --file hdpack.pk3 hdmus.pk3

NOTA: SI USAS EL CORE DE RETROARCH, pon los datos y el EXE de la versión de ACTIVISION, NO la original de Apogee, y a Retroarch, además del core, le pasas el WOLF3D.EXE.
Y se compila con:

CFLAGS="-O2 -march=native -mtune=native -O2" cmake -DLIBRETRO=1 ..

***********XASH3D para Raspberry Pi (GLES) **********************************************************************************************

XASH3D SOPORTA AHORA TANTO OPENGL COMO GLES1 Y GLES2, SIN WRAPPERS NI NADA.
OJO; SI ESTAS INSTRUCCIONES TE DAN ERRORES, QUE SEPAS QUE PROCEDEN DE AQUÍ:
https://github.com/FWGS/xash3d/wiki/Building-and-running#cmake-recommended-for-non-windows

Instalamos una pequeña dependencia que hace falta:
sudo apt-get install --no-install-recommends libfontconfig1-dev

Clonamos el repo principal:
git clone https://github.com/FWGS/xash3d-fwgs
git submodule init && git submodule update --init

Ahora creamos el directorio de compilación, configuramos con CMAKE, y compilamos:
mkdir build
cd build
cmake .. -DXASH_SDL=ON -DXASH_VGUI=OFF -DXASH_64BIT=1
make -j4

Ahora, creamos ~/halai, y vamos copiando los archivos que necesitamos:
cp engine/libxash.so game_launch/xash3d mainui/libxashmenu64.so ~/halai
Ahora nos vamos a ~/halai, y creamos nuestro script de lanzamiento, yo lo he llamado también "halai" porque es gracioso, con el siguiente contenido:
LD_LIBRARY_PATH=. ./xash3d -dev 5
Ahora copiamos el directorio "valve" de una instalación de Half Life a ~/halai/valve
(Tienen un CD completo en archive.org, en formato CUE/BIN que puedes convertir a .ISO+.WAV con:
bchunk -w HALF_LIFE.BIN HALF_LIFE.BIN half

Ahora vamos a por las librerías del juego: clonamos esto:
git clone --depth 1 https://github.com/FWGS/hlsdk-xash3d

Creamos el directorio de compilación y compilamos para 64bits:
cd hlsdk-xash3d
mkdir build
cd build
cmake -D64BIT=ON ..
make -j4

Esto nos va a generar dos archivos: hl64.so y client64.so
Mandamos estos a ~/halai/valve/dlls/hl64.so y ~/halai/valve/cl_dlls/client64.so
Editamos ~/halai/valve/gameinfo.txt, y dejamos la línea de gamedll_linux así:
gamedll_linux           "dlls/hl64.so"
(Le estamos diciendo que nuestra librería de juego es de 64bits y se llama hl64.so).
Ahora nos metemos en ~/halai/valve y nos bajamos el archivo "delta.lst" de los servidores de VALVE. Ya casi estamos!:
cd ~/halai/valve
wget https://raw.githubusercontent.com/ValveSoftware/halflife/master/network/delta.lst

Pues ya tenemos instaladas las librerías del juego. Ya debeíamos poder darle a NEW GAME.
Nos vamos a ~/halai y ejecutamos nuestro script de lanzamiento, ./halai

Y si quieres counterstrike 1.6, la librería de juego que tendrías que compilar e instalar en ~/halai/valve/dlls/ es esta:
https://github.com/FWGS/cs16-client/releases

SI QUIERES TENER MÚSICA DURANTE EL JUEGO, cuando ripees el CD con bchunk (porque vas a necesitar hacerlo para sacar el diretorio "valve" de la ISO) hazlo así:
bchunk -w HALF_LIFE.BIN HALF_LIFE.BIN half
Y ahora, los WAV que has obtenido los conviertes a mp3 con:
for i in *.wav; do ffmpeg -i "$i" -ab 320k "${i%.*}.mp3"; done
Los subes a ~/halai/valve/media, y editas cdaudio.txt para que las pistas se llamen como los mp3 que acabas de generar (half01.mp3, half02.mp3, etc).

Y si quieres counterstrike 1.6, la librería de juego que tendrías que compilar e instalar en ~/halai/valve/dlls/ es esta:
https://github.com/FWGS/cs16-client/releases

************SABER QUÉ CFLAGS USAR*******************************************************************************************************

Para saber qué hace GCC cuando le decimos que use "-march=native" en nuestra plataforma, hacemos:
gcc -### -E - -march=native 2>&1 | sed -r '/cc1/!d;s/(")|(^.* - )|( -mno-[^\ ]+)//g' 

Y para saber qué hace GCC cuando decirmos que use "-mtune=native" en nuestra plataforma, hacemos:
gcc -### -E - -mtune=native 2>&1 | sed -r '/cc1/!d;s/(")|(^.* - )|( -mno-[^\ ]+)//g'

Así que un set de flags neutral para Pi3 y Pi4, 32 o 64bit, con un GCC moderno en el que NATIVE funciona ya bien, sería:

CFLAGS="-march=native -mtune=native -O2"

************Parchear con XDelta en Linux************************************************************************************************

SI ES UN PARCHE XDELTA (como el del Xenogears al castellano):
xdelta patch parche_CD1_con_videos.xdt Xenogears\ \(USA\)\ \(Disc\ 1\).bin Xeno1.bin


SI ES UN PARCHE XDELTA3:

En este caso, tienes que usar el comando xdelta3, NO el xdelta.
xdelta3 -d -s original parche resultado

************Wolf4SDL (Wolfenstein 3D) en GNU/Linux*************************************************************************************

Compilaro y hacerlo funcionar me llevó un rato. Editamos "version.h" y nos vamos a los "defines used for different versions", donde dejamos descomentados
estos solamente:
#define GOODTIMES
#define CARMACIZED 

Luego nos bajamos la versión de Activision de emuparadise o donde nos de la gana, y pasamos a minúsculas todos los ficherso WL6 y el EXE.
Los metemos en el mismo directorio que el ejecutable de wolf4sdl (wolf3d), y ya debería ir (Excepto por temas de las SDL, ya que por defecto
el juego intenta reutilizar el modo de vídeo actual y eso está mal: editamos el código y lo ponemos a 320x200 en 16bpp).

Si aún así no tira, edita Makefile y cambia el DATADIR a ./, de tal manera que desde ahora simplemente metes los ficheros de datos del juego en el mismo
directorio que el ejecutable que acabas de compilar y los encuentra.

Otra cosa: los scripts de configuración del juego usan sdl-config --libs (o lo que es lo mismo, pkg-config --libs sdl) para ver dónde están tanto las
librerías libSDL1.2 como las SDL_mixer. Así que si tienes las SDL1.2.x en /usr/local/lib/armhf-gnueabi, no va a encontrar las SDL_mixer, ya que estas
están en /usr/local/lib y sdl-config o pkg-config sólo devuelven las rutas de las libSDL1.2.x y se asume que ahí van a estar las SDL_mixer también.
Así que mírate los apuntes sobre SDL1.2.x que hay más arriba, para instalar SDL y SDL_Mixer ambas en /usr/local/lib, y luego ejecuta ldconfig --verbose, etc.

************MÉTODO STANDARD PARA EJECUTAR PRGRAMAS AL INICIO O LANZAR SERVICIOS: DEPENDENCY BASED BOOTING SEQUENCE*************

Estos son los apuntes para sistemas que cumplen con DDBS de la FFS, como Debian, Raspbian y demás distribuciones "legales".

Si simplemente queremos que algo se ejecute como root al inicio, justo antes de que se lancen las ttys de usuario, pues con ponerlo
en /etc/rc.local antes del "exit 0", nos vale. 
Pero si queremos lanzar un SERVICIO que se quedará corriendo de fondo en lugar d un programa que retore y sigamos con una secuencia de comandos 
(cosa que no se  puede hacer si el servicio no retorna al prompt, cosa que no tiene por qué hacer), así un control más fino sobre en qué cambio de runlevel 
queremos que se ejecute, lo que es interesante a la hora de lanzar servicios, necesitamos un script de inicio.

Los scrips de inicio están en /etc/init.d, y la utilidad que los coloca en la scuencia de arranque lo que hace es crear links simbólicos a esos scrips en los dirs
/etc/rcN.d, siendo N un runlevel en que ese servicio estará activo. Así, un servicio que estará activo en los runlevels "normales" de un sistema debian, tendrá 
links simbólicos a su script de incio en los directorios /etc/rc2.d, /etc/rc3.d, /etc/rc4.d y /etc/rc5.d. Pero esto es algo que gestiona la herramienta que se
encarga de ponerlos y quitarlos del inicio, que es "insserv", y que ANTIGUAMENTE era update-rc.d, que ya NO SE USA.

El formato de un script de inicio para insserv es este:

#!/bin/bash

### BEGIN INIT INFO
# Provides:          fsynthserv
# Required-Start:    fluidsynth
# Required-Stop:     fluidsynth
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: binds MIDI ports
# Description:       binds MIDI ports

### END INIT INFO

# Cosas que se ejecutan si las pedimos específicamente pasando parámetros al script
case "$1" in
  start)
    #Espero a que esté listo Fluidsynth. Aunque se lance antes su script, el sinte tarda en estar listo.
    sleep 4
    echo "Estableciendo conexión del sintetizador con el secuenciador de red"
    aconnect 128:0 129:0
    ;;
  stop)
    echo "Deshaciendo conexión del sintetizador con el secuenciador de red"
    aconnect -x
    ;;
  *)
    echo "Usage: /etc/init.d/fsynthserv {start|stop}"
    exit 1
    ;;
esac
exit 0

La única novedad reseñable pero imprescindible es la cabecera, INIT INFO, que determina cómo colocará insserv este script de inicio. 
Los campos más importantes a este propósito son:

# Provides:          fsynthserv

¿Qué nombre en el sistema tiene el servicio que activamos? Esto sirve luego para que otros scripts dependan de él y nos podamos referir a él.

# Required-Start:    fluidsynth

¿Qué servicios tienen que estar activos ANTES de lanzar este? Esto es LO MÁS IMPORTANTE, pues es lo que usa insserv para ponerlo después de 
otros servicios, para establecer el orden de arranque. 
MUCHO CUIDADO: si este servicio depende de un script que está en /etc/init.d, con poner el nombre del script TAL CUAL no vale. NO hay que poner
un $ delante del nombre. PERO SI SE TRATA de nombres abstractos de características del sistema, como $time, $local_fs, $network... pues sí se pone.
Por ejemplo, $time indicaría que se ha establecido la hora de sistema por el método que sea, $network implicaría los niveles inferiores de metworking
como la tarjeta ethernet, etc.
PERO TEN MUCHO CUIDADO y si simplemente quieres que se ejecute este script TRAS otro script que está en /etc/init.d, pon simplemente el nombre 
del otro script sin ninguna $. MUCHO cuidado con poner la $ cuando no hace falta, porque NO FUNCIONARÁ e insserv no establecerá el orden correcto.

# Required-Stop:     fluidsynth

Esto es menos importante: se trataría de los servicios que deben estar activos cuando se desactive este.

El resto de campos se entienden bien, ya sabes de qué van y no los voy a explicar porque no hace falta.

Ahora simplemente haríamos:

sudo insserv fsynthserv

para poner el servicio en el arranque (se supone que el servicio fluidsynth, o sea, el script del mismo nombre, ya está en el arranque puesto).
O bien 

sudo insserv -r fluidsynth

para quitarlo del arranque. Olvídate de los nombres de los symlinks, que si S99, que si K01... Nada, eso ya NO IMPORTA Y NO SE USA. Ahora todo va con
dependency based booting sequence.

LA MEJOR guía para esto la tienes en este mismo directorio como "Orden de arranque o inicio de scripts (DBBS)" y procede de la página
http://www.openredes.com/2011/05/13/orden-de-arranque-o-inicio-de-scripts-de-etcinit-d-en-debian-squeeze-6-0-solucion-a-update-rc-d-using-dependency-based-boot-sequencing/ 

************MÉTODO ANTIGUO para ejecutar programas  o scripts al inicio como root: LUBUNTU (NO DEBIAN)**************************************************************

¡¡¡CUIDADO!!! ESTO SÓLO SIRVE PARA DISTROS BASADAS EN UBUNTU, QUE NO CUMPLE EL "DEPENDENCY BASED BOOTING SEQUENCE" DE LA FSS.
ASÍ QUE EN RASPBIAN O DEBIAN NO SE USA ESTO. 

Si simplemente queremos que algo se ejecute como root al inicio, justo antes de que se lancen las ttys de usuario, pues con ponerlo
en /etc/rc.local antes del "exit 0", nos vale. 
Pero si queremos lanzar un SERVICIO que se quedará corriendo de fondo en lugar d un programa que retore y sigamos con una secuencia de comandos 
(cosa que no se  puede hacer si el servicio no retorna al prompt, cosa que no tiene por qué hacer), así un control más fino sobre en qué cambio de runlevel 
queremos que se ejecute, lo que es interesante a la hora de lanzar servicios, pues seguimos estos pasos:

-El formato de un script de inicio de servicio es este:

#! /bin/sh
# /etc/init.d/blah
#

# Cosas que se ejecutan siempre
touch /var/lock/blah

# Cosas que se ejecutan si las pedimos específicamente pasando parámetros al script
case "$1" in
  start)
    echo "Iniciando script blah "
    echo "Aquí se podrían hacer más cosas"
    ;;
  stop)
    echo "Deteniendo script blah "
    echo "Aquí se podrían hacer más cosas"
    ;;
  *)
    echo "Usage: /etc/init.d/blah {start|stop}"
    exit 1
    ;;
esac

exit 0

-Creamos nuestro script, lo metemos en /etc/init.d que es el "almacén" de scripts, y le damos permisos de ejecución. Un 755 está bien.
-Ahora tenemos dos opciones: o le decimos que lo meta en uno o varios runlevels automáticamente usando algo tipo:
"update-rc.d <nombre_script_en_/etc/init.d> defaults", o creamos nosotros los link simbólicos de cada runlevel siguiendo una nomencleatura:
por ejemplo, si queremos que se inicie el servicio al entrar en el runlevel 2 y que se pare al entrar en el runlevel 6, que es el de reiniciar el sistema, 
y en el 0, que es el de haltear el sistema, haremos estos links:
"ln -s /etc/init.d/blah /etc/rc2.d/S66blah"
"ln -s /etc/init.d/blah /etc/rc0.d/K66blah"
"ln -s /etc/init.d/blah /etc/rc6.d/K66blah"
La "S" es de "start" y la "K" es de "kill", lógicamente. Así, si se cambia a alguno de esos dos runlevels, se hará lo que se tenga que hacer según corresponda.
El número determina el órden en que se ejecuta el script (iniciando o deteniendo el servicio) dentro del runlevel en cuestión. A mayor número, menor
prioridad. Así, un link simbólico llamado S99 asegura que se ejecutará el script de inicio del servicio en último lugar respecto a los demás de ese runlevel.

ANEXO:
-Para saber en qué runlevel estamos, simplemente tenemos el comando "runlevel".
-Los runlevels importantes son: 0 para haltear el sistema, 1 es el modo single-user para reparaciones, 2 al 5 son los normales o modos multiusuario
(en raspbian empezamos al logarnos en modo texto en el runlevel 2) y el 6 es reiniciar el sistema.

*************Raspberry Pi y establecimiento de modos de vídeo tras el arranque: tvservice*********************

Para listar los modos de vídeo de una categoría:

tvservice --modes=CEA
tvservice --modes=CEA

Para cambiar de modo de vídeo:

Apagamos el monitor:

tvservice -o

Lo encendemos con un modo concreto:

/opt/vc/bin/tvservice --explicit="CEA 1 HDMI"

O si quisiéramos encenderlo sin más, 

tvservice -p

Y se nos ve la pantalla en negro. PERO si lanzas un programa, ya se ve :O

Estos scripts, además, permiten que no se quede la pantalla en nego y adaptan el tamaño del framebuffer, con lo que el cambio de
resolución es perfecto:

/opt/vc/bin/tvservice --explicit="CEA 1 HDMI"
sudo chvt 3
sudo chvt 1
sudo fbset -xres 320 -yres 240

/opt/vc/bin/tvservice --explicit="DMT 39 HDMI"
sudo chvt 3
sudo chvt 1
sudo fbset -xres 1360 -yres 768

*************INSTALAR FluidSynth desde sources (sin depender de x11-common)********************************************

Instalamos unas dependencias que tiene. Necesita glib porque el threading multiplataforma se hace gracias a glib. Es inevitable.

sudo apt-get install libglib2.0-dev --no-install-recommends

Bajamos la última versión estable de fluidsynth de aquí:
https://github.com/FluidSynth/fluidsynth/releases

Configuramos y compilamos:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
cmake .. -DCMAKE_BUILD_TYPE=Release -Denable-dbus=0 -Denable-ipv6=0 -Denable-aufile=0 -Denable-network=0 -Denable-oss=0 -Denable-sdl2=0 ..

*************MIDI remoto con fluidsynth o timidity (MIDI over LAN)*************************************************************

SERVIDOR 
========

aseqnet  &

fluidsynth --audio-driver=alsa -s merlin_gold.sf2
o bien
timidity -iA -Os1 -B 2,3 &

manuel@vader:~$ aseqdump -l
 Port    Client name                      Port name
  0:0    System                           Timer
  0:1    System                           Announce
 14:0    Midi Through                     Midi Through Port-0
128:0    Net Client                       Network

manuel@vader:~$ aplaymidi -l
 Port    Client name                      Port name
 14:0    Midi Through                     Midi Through Port-0
128:0    Net Client                       Network
129:0    FLUID Synth (4309)               Synth input port (4309:0)

aconnect 128:0 129:0

CLIENTE
=======

aseqdump -l
aseqnet 192.168.5.8 &
aseqdump -l
aplay -p 128:0 nombre.mid

Para scummvm, podemos exportar SCUMMVM_PORT="128:0", o bien usar el parámetro de configuración alsa_port.

Para compilar fluidsynth podemos hacerlo desde los sources estables antiguos que hay en su página o desde svn:

-DESDE LOS SOURCES ESTABLES:

Editamos configure y quitamos los O2 y los -g que encontremos antes de ejecutar configure.
Ahora ya ejecutamos configure así:

CFLAGS="-O2 -march=armv6 -mfpu=vfp -mfloat-abi=hard" CXXFLAGS="-O2 -march=armv6 -mfpu=vfp -mfloat-abi=hard" ./configure  --prefix=/usr --disable-aufile-support --disable-oss-support --disable-dbus-support

Y POR ÚLTIMO compilamos.

-DESDE SVN:

Antes de nada necesitamos libtool.
sudo apt-get install libtool

Clonamos su repo:
git clone --depth 1 git://git.code.sf.net/p/fluidsynth/code-git

Editamos configure.ac y añadimos:
m4_pattern_allow([AC_LIB_PROG_LD_GNU])

Ejecutamos autogen.sh

Editamos configure y quitamos los O2 y los -g que encontremos antes de ejecutar configure.
Ahora ya ejecutamos configure así:

CFLAGS="-O2 -march=native -mtune=native" CXXFLAGS="-O2 -march=native -mtune=native" ./configure --prefix=/usr --disable-oss-support --disable-aufile-support  --disable-dbus-support

Y POR ÚLTIMO compilamos.

Para automatizar todo esto y hacernos un sinte que automáticamente haga estas cosas:
-Se lance el aseqnet y escuche en red en la IP 192.168.5.10 o la que nos de la gana.
-Fluisynth se lance al inicio como servicio
-Conectamos el aseqnet con fluidsynth para pasarle a fluidsynth los comandos MIDI que le llegan a aseqnet

Esto lo he resuelto con dos scripts de inicio de sistema, ya que fluidsynth es un servidor y no retorna al prompt, lo que tiene bastate sentido.
Estos dos escripts van en /etc/ini.d y son los siguientes:
/etc/init.d/fluidsynth:

#!/bin/bash

### BEGIN INIT INFO
# Provides:          fluidsynth
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Required-Start:
# Required-Stop:
# Short-Description: Sintetizador midi por software
# Description:       Un sintetizador MIDI por software
### END INIT INFO

# Cosas que se ejecutan si las pedimos específicamente pasando parámetros al script
case "$1" in
  start)
    echo "Iniciando fluidsynth"
    aseqnet &
    /usr/local/bin/fluidsynth -i -l -s /home/pi/merlin_gold.sf2 &
    ;;
  stop)
    echo "Deteniendo fluidsynth"
    killall fluidsynth
    ;;
  *)
    echo "Usage: /etc/init.d/fluidsynth {start|stop}"
    exit 1
    ;;
esac

exit 0



Y /etc/init.d/fsynthserv

#!/bin/bash
### BEGIN INIT INFO
# Provides:          fsynthserv
# Required-Start:    fluidsynth
# Required-Stop:     fluidsynth
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: binds MIDI ports
# Description:       binds MIDI ports
### END INIT INFO

# Cosas que se ejecutan si las pedimos específicamente pasando parámetros al script
case "$1" in
  start)
    #Espero a que esté listo Fluidsynth. Aunque se lance antes su script, el sinte tarda en estar listo.
    sleep 4
    echo "Estableciendo conexión del sintetizador con el secuenciador de red"
    aconnect 128:0 129:0
    ;;
  stop)
    echo "Deshaciendo conexión del sintetizador con el secuenciador de red"
    aconnect -x
    ;;
  *)
    echo "Usage: /etc/init.d/fsynthserv {start|stop}"
    exit 1
    ;;
esac
exit 0



Como puedes ver, fsynthserv depende para ejecutarse de fluidsynth, por lo que al hacer 
insserv fluidsynth
insserv fsynthserv
el comando insserv los pondrá en el orden correcto. 
He puesto "Required-Start:    fluidsynth" sin $ en el script de fsynthserv porque fluidsynth es un servicio que está en /etc/init.d y NO un servicio
virtual del sistema como $time o $network. MUCHO cuidado con poner la $ cuando no hace falta, porque NO FUNCIONARÁ.


*************Entendiendo ALSA*******************************************************************************************

Esto es una idea un poco general, ya que no entiendo del todo como va el asunto, pero sirve como una explicación superficial. Tampoco esperes 
entenderlo bien.

Centrándonos en la estructura de ~/.asoundrc (o /etc/asound.conf, siendo ambos ficheros leídos desde /usr/share/alsa/alsa.conf en la Rpi y ninguno de ellos
ignorado), podemos entender bastantes cosas de cómo funciona este sistema.

Todo está basado en plugins. Los plugins tienen definidos nombres o aliases en los ficheros de /usr/share/alsa o en la librería, y usando !<alias> podemos
redefinir el valor que corresponde a un alias.

Las aplicaciones suelen usar el plugin "default", con lo que bastaría redefinir su valor para que usaran una u otra cosa en realidad. SE SUPONE que si no
configuramos nada, el valor del plugin default debería ser "hw:0,0", o sea, la primera tarjeta, primer dispositivo.

Así, por ejemplo, imagínate que quieres que el plugin "default" sea un enchufe que mande el audio NO directamente al hardware sino a la entrada de
otro plugin que sería el dmixer, y que a su vez ya se encangará de enviar el audio donde esté definido que lo mande.
Pues haríamos esto:

pcm.!default {                          //Redefinimos el plugin default
	type plug                           //Decimos que es de tipo plug, o sea que mandará el sonido a otro sitio
	slave.pcm "dmix:0,0"   //Y concretamente lo mandará a un slave, cuyo valor será dmix:0,0, o sea dmix que mandará el sonido tras resamplearlo y mezclarlo
                                                       //a través de la primera tarjeta, primer dispositivo.
}

Y si quisiésemos redefinir el plugin "default" de tal manera que al usarlo una aplicación se estuviese enviando el sonido directamente al hardware,
concretamente a la primera tarjeta, primer dispositivo, haríamos:

pcm.!default {				//Redefinimos el plugin default
	type hw				//Decimos que no es un enchufe como antes, sino directamente acceso hardware  		
	card 0					//El hardware al que accede es primera tarjeta,
	device 0				//primer dispositivo.
}

También es posible que nosotros definamos nuestro propio plugin, y luego lo usemos. Por ejemplo, nos a inventar un plugin llamado "mymixer"
que en realidad enviará el sonido a través de dmix pero nos sirve de ejemplo. Como el tipo de plugin "dmix" ya está definido, será el tipo que tenga.
Redefiniremos default de tal modo que envíe el sonido a través de ese nuevo plugin.

pcm.!mymixer {
	type dmix
	slave {
		pcm "hw:1,0"
		period_size 512
		buffer_size 4096
		rate 48000
	}
}

pcm.!default {
	type plug
	slave.pcm mymixer
}

Si usamos dmixer y queremos cambiar la frecuencia de muestreo de salida para que coincida con la más común de entrada, editamos
/usr/share/alsa/alsa.conf y cambiamos "defaults.pcm.dmix.rate 48000" a 44100.

*************Grabar audio (grabar sonido) de ALSA, sin usar PULSEAUDIO PARA NADA*************************************************

En la mayoría de los sitios se dice que es imposible, porque el audio de ALSA es enviado a la salida y se pierde, al no pasar por ningún sitio en medio donde sea copiado.
Pero es posible lograrlo, usando simplemente arecord. Y es MUY MUY fácil.

Lo primero es entender que podemos ver los dispositivos de los que podemos grabar con arecord así:
arecord -l
Y vemos:
card 0: PCH [HDA Intel PCH], device 0: ALC269VC Analog [ALC269VC Analog]
card 1: Camera [USB 2.0 PC Camera], device 0: USB Audio [USB Audio]

Así de entrada no tenemos ningún dispositivo que nos sirva, así que lo primero insertamos este módulo:
sudo modprobe snd-aloop

Ahora volvemos a mirar con
arecord -l
Y vemos que tenemos:
card 0: PCH [HDA Intel PCH], device 0: ALC269VC Analog [ALC269VC Analog]
card 1: Camera [USB 2.0 PC Camera], device 0: USB Audio [USB Audio]
card 2: Loopback [Loopback], device 0: Loopback PCM [Loopback PCM]
card 2: Loopback [Loopback], device 1: Loopback PCM [Loopback PCM]

Los dispositivos loopback son los que nos interesan.
El que me funciona es el:
card 2: Loopback [Loopback], device 1: Loopback PCM [Loopback PCM]

Así que grabamos de la tarjeta 2 dispositivo 2 con:
arecord -f CD -r 44100 --device="hw:2,1" grabación.wav

Podría ser necesario usar otro dispositivo de loopback en otras tarjetas distintas, claro.

*************GEMRB : Engine para Baldur's Gate 1 & 2*******************************************************************************

Dependencias previas:

-sudo apt-get install libpython-dev --no-install-recommends

-HAY que tener instalado OpenAL, porque aunque tiene soporte para SDL2 sin OpenAL, faltan los sonidos ambientales si usas SDL2.
Cuando acabes de compilar e instalar OpenAL, haz:
sudo rm /etc/ld.so.cache
sudo ldconfig
...O el plugin de audio no podrá ser cargado.

Cambia en gemrb/plugins/SDLVideo/SDL20Video.cpp:
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "nearest");
por
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");

Hay que leer el INSTALL para saber cómo se compila, pero esencialmente:

cmake .. -DCMAKE_BUILD_TYPE=Release -DSDL_BACKEND=SDL2 -DOPENGL_BACKEND=None -DDISABLE_WERROR=1 \
-DUSE_SDLMIXER=0 -DUSE_OPENAL=1 -DUSE_LIBVLC=0 -DDISABLE_VIDEOCORE=1 \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native"

make -j4

El renderer OpenGL es experimental, no se está desarrollando y NO APORTA NADA. No te molestes en usarlo por ahora.

Instalar con sudo make install, el uninstall funciona bien. NO INTENTES JUGAR INSTALÁNDOLO A MANO, ES UN LIOTE Y NO MERECE LA PENA, INSTALA EL ENGINE SIN MIEDO, QUE SE DESISTALA SIN PROBLEMAS.

Ahora te creas un directorio, por ejemplo ~/baldurs, y dentro creas bg2_data, que es donde meterás el baldurs 2 instalado tal cual.
Ahora te copias el cfg de ejemplo, que viene en build/gemrb, a ~/baldurs también, lo editas y le pasas la ruta del baldurs 2 instalado, relativa a ~/baldurs.
También tienes que descomentar las líneas del .cfg:
GUIScriptsPath=/usr/local/share/gemrb
PluginsPath=/usr/local/lib/gemrb/plugins
GemRBOverridePath=/usr/local/share/gemrb
GemRBUnhardcodedPath=/usr/local/share/gemrb
...O habrá muchas cosas que no encuentre y NO DEBES copiarlas a mano ni nada, las tiene que encontrar.

Le puedes pasar el cfg con -c, en plan gemrb -c game.cfg

Por ejemplo, dejaríamos el path de los datos del BG2 como:
GamePath=./bg2_data
Ahí puedes poner fullscreen a 1 también si quieres.

Las ediciones que necesitas de GOG son las COMPLETE (Baldurs Gate Original Saga que es el Baldurs 1, Baldurs Gate 2 Complete que es el 2), NO LAS ENHANCED. Las ENHANCED NO SIRVEN.

Si no se te oye mira a ver qué plugin está cargando. Si está cargando NullSound comprueba que tienes SDLAudio.so en la ruta de los plugins.

PARA CUSTOMIZAR LAS FUENTES (vamos a verlo con el Baldur's Gate 1 como ejemplo)
1- Copia un fichero de configuración de fuentes al directorio de overrides del juego, así:
cp /usr/local/share/gemrb/unhardcoded/bg1/fonts.2da /usr/local/share/gemrb/override/bg1/
2- Copia una fuente .TTF a /usr/local/share/gemrb/override/bg1/
2- Edita el fichero de configuración de fuentes:
vim /usr/local/share/gemrb/override/bg1/fonts.2da
...Y en la columna FONT_NAME pones el nombre SIN EXTENSIÓN del .TTF que quieras usar.
PARA más información sobre la customización de fuentes, mira en:
https://gemrb.org/Fonts.html
LA MEJOR FUENTE es SHERWOOD.TTF, que es la que usa el juego pero en TTF.

PARA USAR LA RESOLUCIÓN QUE QUERAMOS tenemos que aplicar el parche widescreen, que lo puedes bajar de aquí:
https://www.gibberlings3.net/mods/tools/widescreen/
Lo primero, nos bajamos el parcheador "weidu" desde aquí:
http://www.weidu.org/~thebigg
Extraes los ejecutables weidu, weinstall y tolower, y los mandas a /usr/local/bin
Ahora extraes el parche de widescreen, y el directorio "widescreen" con todo dentro lo metes tal cual en el directorio donde tengas instalado el juego que quieres parchear.
Ahora haces "weinstall widescreen" en el directorio del juego (recuerda que a parte de los datos del juego tendrás el directorio "widescreen" ahí metido, NO sus contenidos sino el directorio en sí con todo dentro) y vas respondiendo a las preguntas.
Para X Coordinate e Y Coordinate, usa 854x480. Para el tamaño máximo del juego, usa 1920x1080. Habilita lo de las múltiples resoluciones.

*************Compilar openadventure*********************************************************************************************

Instalar cosas:
sudo apt-get install libedit-dev pyhton-yaml
editar el makefile para añadir los cflags. Compilar y listo.

*************Core Cannonball (OutRun engine) en la Rpi*****************************************************************************************

Necesitamos un directorio /roms donde metemos las roms del juego (es el romset del MAME y si te falta una eprom, es del SET B)
donde metemos también el directorio /res que viene con los sources.
Es decir, /res quedaría como /roms/res.
En /roms, creamos un archivo vacío llamado outrun.game, y lanzaríamos el core como:
retroarch -L ~/.config/retroarch/cores/cannonball-libretro.so roms/outrun.game

*************Compilar Cannonball (OutRun engine) versión SDL2 en Rpi***************************************************************************

Clonamos su repo:
git clone --depth 1 https://github.com/djyt/cannonball.git

Necesitamos libboost, eso lo primero. Concretamente, te vale con libboost-dev
sudo apt-get -y install libboost-dev --no-install-recommends
AL ACABAR DE COMPILAR, PUEDES DESINSTALAR LIBBOOST:
sudo apt-get -y purge libboost-dev && sudo apt-get -y autoremove && sudo apt-get -y clean

mkdir build
cd build
cmake ../cmake -DTARGET=pi4-opengles.cmake -DCMAKE_BUILD_TYPE=Release

-Copiamos el ejecutable "cannonball" a ~/outrun
-Creamos el directorio ~/outrun/roms y metemos ahí las ROMs del OutRun de MAME descomprimidas.
(Si te falta una eprom, es del SET B)
-Copiamos el directorio "res" que viene con los sources a ~/outrun/res
-Movemos res/config.xml a ~/outrun (es decir, lo sacamos de ~/outrun/res y lo movemos a ~/outrun, para que el ejecutable lo encuentre).
-Editamos config.xml a nuestro gusto.
-Hacemos un "touch hiscores.xml" para que no se queje de que no existe.
-La música custom va en wav, en ~/outrun/res, y sólo tienes que activarla en el config.xml

Si al ejecutarlo te sale que no encuentra las SDL, mira con un ldd sobre el ejecutable, y si efectivamente no las encuentra, es que las has instalado
en una ruta que no está en los path que usa el sistema para buscar libs en tiempo de ejecución.
Así que ejecuta sudo lddconfig -v y echa un vistazo. Mírate la parte de los apuntes de SDL1.2.x

Si te da un segfault al salir, quita la llamada a renderer->disable() de Video::~Video() en src/main/video.cpp, ya que no pinta nada en un destructor... Y pon esa llamada a renderer->disable() en quit_func(), que está en src/main/main.cpp

Si no quieres que ande bajando el volúmen de los WAVs, usa los que tienes que ya tienen el volúmen bajado, y vete a Audio::load_wav en
src/main/sdl2/audio.cpp y deja entre el LockAudio y el UnlockAudio sólo esto:

SDL_LockAudio();

	wavfile.data = (int16_t*) data;
	wavfile.length = length / 2;
	wavfile.pos = 0;
	wavfile.loaded = 2;

	resume_audio();

SDL_UnlockAudio();

============CLONAR UN REPOSITORIO DE GITHUB USANDO EL NUEVO Y ASQUEROSO SISTEMA DE PERSONAL ACCESS TOKENS (PAT)===============

git clone --depth 1 https://<TOKEN_DE_MIERDA>@github.com/vanfanel/ppsspp.git

Así ya no necesitamos meter username, ni contraseña, ni nada, al hacer updates.

============ACTUALIZAR UN REPOSITORIO DE GITHUB USANDO EL NUEVO Y ASQUEROSO SISTEMA DE PERSONAL ACCESS TOKENS (PAT)===============

-Creamos un token nuevo. Para ello, nos vamos a la foto de perfil de github (arriba a la derecha),
settings -> developer settings -> personal access tokens
y generamos el token de los cojones. Es una cadena de caracteres de mierda. La copiamos y la guardamos.
NO LA USES COMO PASSWORD, TE DEJA HACERLO UNA VEZ Y LUEGO YA NO VALE Y TIENES QUE GENEARAR OTRA.

-Nos metemos en el reposiorio que queremos actualizar y hacemos:
git remote remove origin

-Ahora le metemos un origin nuevo que incluya nuestro token, así:
git remote add origin https://vanfanel:<TOKEN_DE_MIERDA>@github.com/vanfanel/LBE_DOCS.git

-Ahora ya podemos actualizar con git push las veces que quieras desde tu copia local ese repo.

************Actualizar repositorio github****************************************************************************************

Lo primero es poner la fecha: el formato es

sudo date mes|día|hora|minuto

Actualizamos en la copia local así:

git add .
git commit -m "made some changes"

Y ahora subimos los cambios:

git remote add origin git@github.com:yourusername/yourreponame.git
git push origin master

la primera línea sólo es necesaria si es la primera vez que voy a subir algo (??)
De todos modos, en ~/.gitconfig tengo:

[user]
          name  = vanfanel
          email = redwindwanderer@gmail.com

y sólo me pide el nombre de usuario (vanfanel) y el password (Manuel22) al hacer el push, y va sin problemas.

GIT REWIND
Si queremos modificar cosas de n proyecto de alguien, hacemos un fork a mi git de ese proyecto, clonamos mi fork en local,
y luego publicamos los cambios en mi fork y hacemos un Pull Request.
Si metemos la pata y queremos dejar mi fork como cuando lo creé, hacemos
git reset HEAD^ --hard
git push -f origin master

************Deshacer un commit que hemos hecho mal*****************************************************************************

Para deshacernos del último commit, suponiendo que no hemos hecho aún un push, sencillamente:
git reset --soft HEAD~ 

************Deshacer un push que hemos hecho mal********************************************************************************

Nos vamos al branch donde queremos corregir el push:
git checkout master

Lo ponemos en el último commit bueno:
git reset --hard cc4b63bebb6

Hacemos un push forzado:
git push -f origin master

Y listo. Ya hemos vuelto en local y en el server al último commit/push bueno.

************Actualizar MI FORK con los cambios del repo original del proyecto (upstream)*********************************************

Lo primero añadimos un remote que vamos a llamar upstream como podríamos llamarlo pepito, pero para entendernos:

git remote add upstream https://github.com/libsdl-org/SDL.git

Ahora descargamos todos los branches de upstream:

git fetch upstream

Nos aseguramos de estar en el branch master de nuestro fork. Seguramente ya estaremos ahí de todos modos..

git checkout main
(si falla, cambia main por master, pero se tiende a que todo sea main)

Hacemos que nuestro fork pase a tener todo lo de upstream: lo convertimos en una copia limpia de upstream, vamos.

git reset --hard upstream/main
(lo mismo: si falla, cambia main por master)

Hacemos un push forzado a mi repo para que efectivamente quede como el upstream:

git push -f origin main
(lo mismo: si falla, cambia main por master)

Hacemos los cambios que tengamos que hacer....

<edit files...>

Hacemos commit de los cambios

git add .
git commit -m "blah blah blah"

Hacemos un push forzado a nuestro fork:

git push -f origin main
(lo mismo: si falla, cambia main por master)


Y luego ya haríamos el pull request.

SQUASHEAR TODOS LOS COMMITS DE UN PULL REQUEST EN UN SOLO COMMIT
================================================================

Suponiendo que estamos en el branch donde hemos hecho los commits, que en este ejemplo se llama "cursor_constraint", hacemos:

git reset --soft master
git add .
git commit -m  "Add pointer constraint functionality."
git push -f origin cursor_constraint

MODIFICAR UN COMMIT DEL PASADO (QUE YA HEMOS PUSHEADO Y TODO)
=============================================================

LO PRIMERO, NO DEBEMOS HABER CLONADO EL REPO CON "--depth 1" PORQUE ENTONCES NADA DE ESTO FUNCIONA.

Empezamos un rebase. El número 2 es el número de commits que vamos a retroceder desde el actual, pueden ser los que queramos.
Un rebase lo que hace es presentarnos en un editor los commits, y el que queramos cambiar lo pasamos de "pick" a "edit":

git rebase -i HEAD~2

Ahora hacemos los cambios o correcciones que queramos en ese commit...Y una vez hechos los cambios, hacemos:

git add .
git commit --amend

Y ahora finalizamos el rebase así, y ya quedamos en el último commit que hicimos:
git rebase --continue

Ahora si queremos subimos los cambios con:
git push -f origin master

============PROBAR UN PULL REQUEST QUE AÚN NO SE HA MERGEADO===============

Clonamos el repo que sea.

Ahora hacemos:
git fetch origin pull/<NUMERO_DE_PR>/head:<NOMBRE_NUEVO_BRANCH>
git checkout <NOMBRE_NUEVO_BRANCH>

Y ya estaríamos en el nuevo branch con los cambios del PR.
NOTA: En lugar de <NOMBRE_NUEVO_BRANCH> podemos poner el nombre del branch principal (MAIN, MASTER, lo que sea)
y de ese modo no se nos crea un nuevo branch y no hace falta que hagamos el checkout.

HACER PULL REQUESTS EN EL LUS QUE SE VEAN DESDE EL SOH
======================================================

Se supone que hemos hecho unos cambios en el LUS, y queremos que se vean desde el SOH para probar que compilar y que funcionan bien.

PARTE LUS
---------

En github, forkeamos el proyecto original, y en nuestro fork, creamos un nuevo branch, que vamos a llamar "remove_glew_windows"

Ahora ya empezamos con git en nuestra máquina local.
--Clonamos nuestro fork:
git clone https://<PAT>@github.com/vanfanel/libultraship.git
--Nos colocamos en el nuevo branch:
git checkout remove_glew_windows
--Hacemos los cambios que queramos, y los subimos al branch:
git add .
git commit -m "Remove remains of GLEW on Windows."
git push origin remove_glew_windows
--Nos vamos a github y creamos el Pull Request, verificando tras hacerlo que compila para todas las plataformas.

PARTE SOH
---------

En github, forkeamos el proyecto original, y en nuestro fork, creamos un nuevo branch, que vamos a llamar "remove_glew_windows"
Ahora ya empezamos con git en nuestra máquina local.
--Clonamos nuestro fork, incluyendo sus submódulos ya que LUS es un submódulo de SOH:
git clone --recurse-submodules https://<PAT>@github.com/vanfanel/shipwright.git
--Nos colocamos en el nuevo branch de SOH:
git checkout remove_glew_windows
--Nos vamos al directorio libultraship, y añadimos nuestro fork de LUS como remote (llamamos al remote "vanfanel" pero lo podríamos llamar pepito)
  y lo descargamos:
cd libultraship
git remote add vanfanel https://github.com/vanfanel/libultraship.git
git fetch vanfanel
--Nos colocamos en el nuevo branch de LUS:
git checkout remove_glew_windows
--Nos salimos a SOH, y subimos los cambios al nuevo branch de SOH:
git add .
git commit -m "Remove remains of GLEW on Windows."
git push origin remove_glew_windows

************DESCARGAR DE CDROMANCE**************************************************************************************************************

Nos vamos a la ficha del juego en cdromance.com, buscamos su CDR_TICKET, nos vamos a cdromance.org, y lo pegamos allí. ¡Listo!

************RECUPERAR PARTIDAS EN EL GABRIEL KNIGHT DE SCUMMVM**********************************************************************************

A los datos del juego les falta el archivo
VERSION
Con el contenido
01.100.000

Sin este archivo, podrás salvar pero luego no te deja recuperar la partida porque dice que es de otra versión. Así que lo creamos a mano y listo.

************Otro caso práctico de git: actualizar mi master branch al master de upstream, luego ponerme en otro branch y merger mi branch master actualizado en el branch secundario*********

O sea, el objetivo es actualizar mi branch secundario de manera que quede con los cambios del branch master de upstream. Mi branch secundario es dispmanx.

-Añado el upstream. Lo llamo upstream como lo podría llamar pepito:

git remote add upstream https://github.com/scummvm/scummvm.git

Ahora descargamos todos los branches de upstream:

git fetch upstream

Nos aseguramos de estar en el branch master de nuestro fork. Seguramente ya estaremos ahí de todos modos..

git checkout master
o si dice que no encuentra el archivo:
git checkout origin/master

Ahora hacemos el merge del master de upstream con nuestro master:

git merge upstream/master

Ahora nos ponemos en el branch que realmente queremos actualizar:

git checkout dispmanx

...Y hacemos el merge de nuestro branch master sobre nuestro branch dispmanx:

git merge master

Ahora ya haríamos el push al branch dispmanx:

git push origin dispmanx

...Y quedaría probar a compilar y ver qué desaguisados se han montado debido al merge!

************Arreglar texto de commits en github************************************************************************************

Nos ponemos en el branch donde están los commits que queremos cambiar:

Hacemos lo que se llama un rebase interactivo, que nos sacará un editor para cambiar el texto de los commits.

git rebase -i origin/HEAD
(o bien git rebase -i origin/HEAD~3 si quisiéramos incluir los 3 commits anteriores por debajo de HEAD, o sea, commits que ya no son de mi fork sino que ya venían. Con HEAD sin más
debería valernos)

Cambiamos pick por reword en cada mensage que queramos cambiar, pero NO los cambiamos aún.

Cerramos el editor, y nos saltará una edición por cada commit que hayamos marcado con reword. Cambiamos, ahora si, el texto de cada uno.

Hacemos un push forzado:

git push --force origin/dispmanx

https://help.github.com/articles/changing-a-commit-message/

************Probar un pull request (PR) que no ha sido mergido en mainline aún******************************************************

git fetch origin pull/213/head:pr-213
git checkout pr-213

...donde 213 es el número de PR, obviamente.

************Renombrar ficheros del directorio actual de mayúsculas a minúsculas*****************************************************

for SRC in `find ./ -depth`
do
    DST=`dirname "${SRC}"`/`basename "${SRC}" | tr '[A-Z]' '[a-z]'`
    if [ "${SRC}" != "${DST}" ]
    then
        [ ! -e "${DST}" ] && mv -T "${SRC}" "${DST}" || echo "${SRC} was not renamed"
    fi
done

*************MiniVMAC en GNU/Linux******************************************************************************************

Para compilar la versión más o menos ideal que usa mi backend de Dispmanx, he usado las siguientes opciones:

-t larm -api sdl -var-fullscreen 0 -fullscreen 1 -speed 1

Para SDL2:

-t larm -api sd2 -var-fullscreen 0 -fullscreen 1 -speed 1

luego he editado src/MYOSGLUE.c y he cambiado el bpp de SetVideoMode() de 8 a 16.
Para la velocidad original del Macintosh plus, tendrías que poner "-speed z"

Compilar con los flags en el makefile así:
mk_COptions = -c -Wall -Wmissing-prototypes -Wno-uninitialized -Wundef -Wstrict-prototypes -O2 -march=native -mtune=native

Para hacerte un HFV con juegos y programas, bájate los system disks de la 6.0.8 de aquí:
http://www.gryphel.com/c/sw/system/sys60/index.html
Sigue este tutorial de aquí (tienes que extraer los .data antes de conseguir "System Startup" y "System Additions", usando stuffit para Linux):
http://www.emaculation.com/forum/viewtopic.php?t=6801&mobile=on
El Stuffit para Linux es una versión vieja precompilada para i386 pero nos vale:
http://web.archive.org/web/20060205025441/http://www.stuffit.com/downloads/files/stuffit520.611linux-i386.tar.gz

Luego BORRA por completo el disco del Dark Castle, que es como formatearlo. Para ello arranca el MiniVMac con ambos discos de instalación metidos,
para lo cual le pasas ambos como parámetro, y el disco duro:

./minivmac DC.hfv System\ Startup System\ Additions

Instalas el system 6.0.8 en el disco recién formateado, luego copias el Dark Castle y el Beyond DC, metes los juegos que quieras y listo.
Pero vamos, lo mejor es que no pierdas la imágen HFV...

************MiniVMAC en X86*****************************************************************************************************

Para generar el tar con los sources para Linux X64 paso estas opciones:
-t lx64 -api sdl

*************Cómo usar pkg-config y dpkg******************************************************************************************

Estas herramientas hacen cosas distintas, pero pueden llegar a ser complementarias.
pkg-config se usa mucho en los scripts de configuración, para obtener los flags y localizaciones de librerías necesarias para compilar un 
programa contra una librería determinada. Así, por ejemplo, para compilar un programa que va a usar glib2.0, tendremos que saber contra que librerías 
por nombre vamos a linkarlo y qué rutas para includes hay que pasarle (parámetros -l<nombre_librería> y -I<ruta_includes>, recuerda, está explicado más abajo.)  

Por ejemplo, si hacemos: 
manuel@vader:~$ pkg-config --libs glib-2.0
-lglib-2.0  
manuel@vader:~$ pkg-config --cflags glib-2.0
-I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include  

pk-config usa los archivos .pc que instalan los paquetes de programas al ser instalados con dpkg (o indirectamente con apt-get, que a su vez usa dpkg). 
El nombre que tenemos que pasarle a pkg-config es sin prefijo lib, pero por si acaso, puedes mirar el nombre del .pc del paquete en cuestión.
Podemos ver mediante locate que tenemos .pc en: 
/usr/lib/pkgconfig/
/usr/share/pkgconfig/
/usr/lib/x86_64-linux-gnu/pkgconfig/
Se supone que la variable de entorno $PKG_CONFIG_PATH tiene estas rutas pero yo no lo veo, así que mirando estos directorios y tirando de locate
es como he sacado el nombre exacto que hay que pasarle a pkg-config.
Al no encontrar el configure el resultado de pkg-config, lo que se nos sugiere es exportar la información de "pkg-config --cflags glib-2.0" y de
"pkg-config --libs glib-2.0" a variables de entorno que el script leerá, $GLIB_CFLAGS y $GLIB_LIBS. Es fácil saber qué ponemos a cada variable:
GLIB_CFLAGS="-I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include"
GLIB_LIBS="-lglib-2.0"

Para saber qué paquetes tenemos instalados, por ejemplo cuando queramos hacer limpieza, hacemos "dpkg -l" que se puede combinar con grep
para buscar unas y otras cosas.

MUY IMPORTANTE: podemos localizar en qué paquete está un fichero, de manera que podemos eliminar el pquete en cuestión. Se hace con
"dpkg -S stdio.h" o con "dpkg -S /usr/include/stdio.h".

*************Cómo hacer que el directorio actual siempre esté en el PATH, para no tener que escribir ./archivo *******************

Edita ~/.bashrc y añade la línea
PATH=$PATH:.

*************Obtener información sobre los paquetes*******************************************************************************

Para conocer la versión, developer, maintainer. etc, de un paquete antes de instalarlo (o instalado), podemos hacer "apt-cache show <nombre_paquete>",
donde nombre_paquete puede ser una parte del mismo. Es muy útil si tenemos varias versiones del mismo paquete (con distinto maintainer, una libre
y la otra no, distintas versiones...) y queremos saber cuál instalar.
 
*************Extraer archivos .sit de mac en Linux***********************************************************************************

te bajas esta cosa : http://web.archive.org/web/20060205025441/http://www.stuffit.com/downloads/files/stuffit520.611linux-i386.tar.gz
y con unstuff lo haces.

*************Los parámetros y flags de GCC y del linker******************************************************************************
Cuando falle una compilación (porque no se encuentra un fichero de cabecera en un include o porque no se encuentra algo que debería estar
definido en un fichero que cabecera que no se ha incluído)

-l<nombre_librería> : Indica contra qué librería se va a linkar por el nombre de librería, sin el prefijo lib: por ejemplo, -lmath, -lSDL... Los nobres
los puedes sacar con un simple ls a /usr/lib o a donde esté la librería. Si no está en /usr/lib, acuérdate de darle la ruta de sus includes y de sus
binarios, parámetros que se explican a continuación.

-I<directorio> : Es una i latina mayúscula. añade el directorio a los paths de búsqueda de los includes para el compilador. A partir de ese momento, ya podemos usar rutas
relativas para hacer includes de los ficheros de cabecera de ese directorio, en plan #include <GLES/gl.h> en lugar de tener que hacer 
#include "/opt/vc/include/GLES/gl.h". Como lo normal es que los programas vengan con includes con rutas relativas, esto suele ser necesario.

-L<directorio> : añade el directorio a los de búsquera de librerías dinámicas del linker, o sea que es un parámetro para el linker. Por ejemplo, para
linkar cualquier programa que use las SDL2, lo que se hace es usar sdl2-config para obtener en qué directorios buscan las SDL2 las librerías que 
usan sus backends: en el caso de la Raspberry Pi, si compilas un programa que use las SDL2, las SDL2 a su vez usan librerías que están en /opt/vc/lib, 
por lo que de un modo u otro, al programa que intentas compilar hay que pasarle la ruta de esas librerías para que las encuentre en tiempo de
linkado. Así que si dicho programa no usa sdl2-config a la hora de configurar el linker, le tienes que pasar la ruta de las librerías nativas de la Rpi a mano.
Sin ser tan extremos, cualquier programa que use unas librerías dinámicas contra las que se vaya a linkar que no estén en /usr/lib, necesita este 
parámetro para encontrarlas. 

-D<nombre macro>: define (o sea, activa) una macro del preprocesador. Si por ejemplo hacemos en un programa:
#ifdef DEBUG
	fprintf (fp, "...");
#else
	....
#endif
y luego hacemos "gcc -DDEBUG", estaremos activando esa macro en compilación y se hará en fprintf.

-rpath=<path> (O lo que es lo mismo, -Wl,-rpath,<ruta>    , la explicación de esto es que -Wl nos permite pasar una serie de parámetros y sus valores, separados
por comas).
Esto sirve para pasar la ruta de manera que el ejecutable resultante busque una librería en esa ruta en tiempo de ejecución (que es DISTINTO al tiempo de
linkado: o sea que UN PROGRAMA PUEDE ENCONTRAR UNA LIBRERÍA EN TIEMPO DE EJECUCIÓN PERO NO ENCONTRARLA EN TIEMPO DE LINKADO,
O VICEVERSA!)
A veces nos encontraremos con ejecutables que podemos linkar bien contra librerías que luego no encuentrar en tiempo de ejecución.
LO PRIMERO es hacer un ldd al ejecutable y confirmar que dicha librería aparece como NOT FOUND.
Esto es porque, aunque le pases con -L<ruta> la librería que quieres que encuentre en linkado, para que la encuentre en tiempo de ejecución necesitarías
pasarle "-Wl,-rpath,<ruta>".
Aunque lo normal es que no tengas que hacer esto tampoco, sino que la librería esté en una ubicación donde el sistema busque por defecto.
Para asegurarnos de esto, hacemos "ldconfig --verbose", y se actualizarán los directorios donde se buscan las librerias que usan los programas.
Así que si has instalado una librería pero no la encuentra un programa en tiempo de ejecuciçon, puedes pasarle el -rpath o hacer un ldconfig y listo.


*************DISTCC se cuelga en el cliente (Rpi) en el punto en que va a reintentar una compilación localmente y no da el error***********

-En el servidor, inicia el servidor distcc como: 
sudo /etc/init.d/distcc start --verbose
-En el cliente, si es la Rpi, no te olvides de ponerle un swap con
sudo swapon /dev/sda1


*************Qué librerías usa un ejecutable****************************************************************************************

ldd <nombre_del_ejecutable>

*************VanillaConquer: Command and Conquer en GNU/Linux**********************************************************************

Notas previas:
-El C&C original se llama "tiberian dawn". Así que el ejecutable es vanillatd, mientras que vanillara es para el RED ALERT.
-El juego usa OpenAL, busca las instrucciones para instalarlo antes.

Clonamos el repo con:
git clone --depth 1 https://github.com/TheAssemblyArmada/Vanilla-Conquer.git

Editamos common/video_sdl2.cpp y:
-En SDL_CreateRenderer() añadimos el flag SDL_RENDERER_PRESENTVSYNC.

Configuramos y compilamos con:

mkdir b4
cd b4

cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native" ..

make -j4

Creamos el directorio ~/cconquer, y metemos ahí los datos del juego.

Copiamos el ejecutable (vanillatd para el C&C original, o vanillara para el RED ALERT) al directorio del juego, y listo!

La primera vez que ejecutemos vanillatd o vanillara, se nos creará .config/vanilla-conquer/[vanillatd|vanillara]/conquer.ini
(A NO SER que tengamos un conquer.ini entre los datos del juego, en cuyo caso lo primero es borrar ese conquer.ini).
Editamos ese conquer.ini y ponemos Scaler a "linear", el ratio a 4:3, etc.

*************SonicMania Decomp en la Raspberry Pi*************************************************************************

NOTA: Si tienes algún problema en GNU/Linux con este engine, entra en discord y cita a Mephiles, que es un dev y usuario
de Linux, y a Stxtic que es el desarrollador principal de la parte de frontend.

-Instalamos otra dependencia previa: GLFW, que solo va sobre Wayland, no tiene backend KMS/DRM.
	---Dependencia previa: apt-get install --no-install-recommends extra-cmake-modules
	---Nos bajamos la última estable de GLFW de: https://www.glfw.org/
	---Configuramos, compilamos e instalamos GLFW:
	mkdir b4
	cd b4
	cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=1 \
	-DGLFW_USE_WAYLAND=1 -D_GLFW_X11=0 -DGLFW_BUILD_EXAMPLES=0 -DGLFW_BUILD_TESTS=0 \
	-DCMAKE_C_FLAGS="-DEGL_NO_X11 -march=native -mtune=native"

-Instalamos otra dependencia previa: LIBTHEROA, que si la instalamos desde APT nos instala CAIRO, que a su vez depende de
las mierdas de X11. (Nosotros instalamos un CAIRO sin X11 a mano porque el metacompositor WLROOTS usa CAIRO).
	--Nos bajamos la última estable: wget https://downloads.xiph.org/releases/theora/libtheora-1.1.1.tar.xz
	--Configuramos, compilamos e instalamos:
	CFLAGS="-march=native -mtune=native" CXXFLAGS="-march=native -mtune=native" \
	./configure --build=aarch64-unknown-linux-gnu --disable-examples --disable-encode --disable-sdltest
	make -j4
	make install

--VAMOS A POR EL JUEGO EN SI:

PARTE 1: EL ENGINE
--Clonamos el repo del engine: git clone --recursive --depth 1 https://github.com/Rubberduckycooly/RSDKv5-Decompilation.git
--Configuramos y compilamos asi:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release -DUSE_SDL_AUDIO=1 \
-DCMAKE_C_FLAGS="-march=native -mtune=native" -DCMAKE_CXX_FLAGS="-march=native -mtune=native"

Copiamos RSDKv5 a ~/sonicmania:
cp RSDKv5U ~/sonicmania/

PARTE 2: EL JUEGO
--Clonamos el repo del juego: git clone --recursive --depth 1 https://github.com/Rubberduckycooly/Sonic-Mania-Decompilation.git
--Configuramos y compilamos asi:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native" -DCMAKE_CXX_FLAGS="-march=native -mtune=native"

Copiamos libGame.so a ~/sonicmania/Game.so:
cp libGame.so ~/sonicmania/Game.so

Metemos Data.rsdk también en ~/sonicmania

Como el juego sólo soporta gamepads y no joysticks en general, para que reconozca el mando Khensu y el adaptador de SNES:
creamos en ~/sonicmania el fichero "gamecontrollerdb.txt" con el contenido:
03000000412300003680000001010000,LLC Arduino Leonardo,a:b0,b:b1,x:b2,y:b3,back:b6,start:b7,leftshoulder:b4,rightshoulder:b5,dpup:-a1,dpdown:+a1,dpleft:-a0,dpright:+a0,platform:Linux,

-Para tener shaders(las instrucciones originales son de https://github.com/Rubberduckycooly/RSDKv5-Decompilation/blob/master/dependencies/ogl/README.md#shaders):
	---Creamos el directorio mods/GLShaders/Data
	mkdir -p ~/sonicmania/mods/GLShaders/Data
	---Creamos mods/modconfig.ini con este contenido:
	[Mods]
	GLShaders=y
	---Dentro de mods/GLShaders creamos mod.ini con este contenido:
	Name=GLShaders
	Description=GL3 shaders to enable filters and stuff
	Author=Ducky
	Version=1.0.0
	TargetVersion=5
	---Clonamos este repo: git clone --depth 1 https://github.com/Rubberduckycooly/RSDKv5-Decompilation.git
	---Copiamos el directorio de Shaders del repo que acabamos de clonar al directorio Data del mod:
	cp -R ~/src/RSDKv5-Decompilation/RSDKv5/Shaders ~/sonicmania/mods/GLShaders/Data/
	---NOTA: Si el mod no carga, podemos activar el dev menu añadiendo "devMenu=1" en Settings.ini, en la sección [Game],
	y desde ahí nos deja activar los mods que tengamos instalados. Esto lo que hace en realidad es crearnos el fichero
	mods/modconfig.ini que hemos creado a mano antes, pero por si acaso pues aquí queda anotado.

Ajustes del juego:

-Editamos Settings.ini, que el juego crea en el mismo directorio donde tengamos el ejecutable, y ponemos "faceButtonFlip" a "y",
para que la X y el O en el mando actuen como esperamos para confirmar y cancelar.

NOTAS ADICIONALES SOBRE EL ENGINE:

--SI NECESITAS EXTRAER LOS DATOS DE UN .RSDK, USA ESTO: https://github.com/MainMemory/RSDKv5Extract/releases
  FUNCIONA CON MONO, NO LO INTENTES HACER FUNCIONAR CON WINE PORQUE NO VA.	
--SE PUEDE COMPILAR SIN GLFW, USANDO SDL2 EN SU LUGAR, PASÁNDOLE A CMAKE "-DRETRO_SUBSYSTEM=SDL2", PERO ENTONCES NO HAY SHADERS.

--(!!!)SE PODRÍA COMPILAR CON PORTAUDIO EN LUGAR DE USAR EL AUDIO DE SDL2 (NO APORTA NINGUNA VENTAJA USAR PORTAUDIO). PARA ELLO:
-----Instalamos manualmente PORTAUDIO (Se podría instalar desde APT pero tiene a su vez dependencias que no queremos).
	 Para ello:
     ---Bajamos su última release estable de aquí: https://github.com/PortAudio/portaudio/releases
     ---Configuramos e instalamos con:
 	     mkdir b4
 	     cd b4
 	     cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_FLAGS="-march=native -mtune=native" -DPA_USE_JACK=OFF
     ----CONFIGURARÍAMOS EL ENGINE ASÍ, ES DECIR, SIN DECIRLE QUE USE EL AUDIO DE SDL2: 
	     cmake .. -DCMAKE_BUILD_TYPE=Release \
         -DCMAKE_C_FLAGS="-march=native -mtune=native" -DCMAKE_CXX_FLAGS="-march=native -mtune=native"

*************SONICCD EN EL ENGINE RSDK5*******************************************************************************************

-Cogemos el ejecutable RSDKv5U y lo copiamos en ~/soniccd

-Cogemos el fichero "SonicCDu.rsdk" del Sonic Origins y lo copiamos en ~/soniccd con el nombre "Data.rsdk" 

-Clonamos este repo: git clone --depth 1 https://github.com/Rubberduckycooly/Sonic-CD-2011-Script-Decompilation.git
 Y copiamos el directorio "Scripts" a ~/soniccd/

-En Settings.ini ponemos "gameType=1", porque estamos usando los datos de la versión ORIGINS.

-Metemos los mods que queramos en ~/soniccd/mods, y los cargamos desde el "dev menu" (tienes que tener "devMenu=y"
en Settings.ini y darle a ESC para acceder a él)
Tienes el mod de audio y vídeo del Sonic CD para RSDKv5U en el disco duro de backup, ya preparado.
Con el mod de shaders cargado, para elegir el shader simplemente enta en el DEV MENU, selecciona el shader que quieras y dale al ESC,
y así se queda salvado.

		***SOLO NECESARIO PARA VOLVER A CREAR EL MOD DE AUDIO Y VIDEO: SECCIÓN PARA RECREAR EL MOD DE AUDIO Y VÍDEO DEL SONIC CD EN RSDKv5U***

Vamos a crear un MOD que nos permite que suenen los efectos de sonido, las músicas y se vean los vídeos del juego.
Esto es necesario porque el .rsdk del SonicCD versión Origins no incluye estas cosas dentro.

-Creamos los directorios ~/soniccd/mods/CD_FMVS_RSDKv5/Data

-Extraemos los datos del .rsdk del SonicCD versión 2011 usando:
https://github.com/MainMemory/RSDKv5Extract/releases
y copiamos los directorios "Music" y "SoundFX" a ~/soniccd/mods/CD_FMVS_RSDKv5/Data
(Nos faltará un fichero llamado "DropDash.wav", que viene en los datos del SonicMania. No te hace falta porque el SoniCD
no lo va a usar, pero si quieres pues lo puedes sacar del .rdsk del Sonic Mania).

-Copiamos los vídeos en OGV escalados a 1024x512 en ~/soniccd/mods/CD_FMVS_RSDKv5/Data/Videos
(se tienen que llamar, con sus mayúsculas y minúsculas: "Opening.ogv", "Bad_Ending.ogv", "Good_Ending.ogv", "Pencil_Test.ogv").
-Metemos los audios de los vídeos en OGG de 44100Hz en ~/soniccd/mods/CD_FMVS_RSDKv5/Data/Music.
Se tienen que llamar como los vídeos pero con extensión .ogg

-Ahora vamos a retocar los scripts para que se reproduzcan los vídeos en OGV con audio OGG externo
(es la única manera de tener los vídeos con su música).
Para ello, copia estos ficheros de ~/soniccd/Scripts a ~/soniccd/mods/CD_FMVS_RSDKv5/Scripts
(tienes que crear sus directorios, claro):
Title/Select.txt
R8/FadeScreen.txt
Menu/LoadSaveMenu.txt
Menu/MenuControl.txt
Menu/ExtrasMenu.txt
Y ahora los vamos modificando. La idea es sencilla: Donde veas una carga de un vídeo, como por ejemplo:
LoadVideo("Opening")
...Lo sustituyes por un bloque así que carga su .ogg antes:
SetMusicTrack("Opening.ogg", 0, 0)
PlayMusic(0)
LoadVideo("Opening")

-Por último, creamos ~/soniccd/mods/CD_FMVS_RSDKv5/mod.ini con este contenido:
Name=CD_FMVS_RSDKv5
Description= Sonic CD FMVs that work with RSDKv5U
Author=Vanfanel
Version=1.1
TargetVersion=3
TxtScripts=1

Y ya sólo es cargar el mod desde el dev menu (tienes que tener "devMenu=y" en Settings.ini y darle a ESC para acceder a él),
reiniciar con el mod cargado y debería ir.

NOTA: SI NO TE VA EL MANDO, mira que no tengas más de un mando en gamecontrollerdb.txt.

INFO POR SI TIENES QUE VOLVER A PREPARAR LOS VÍDEOS Y LA MÚSICA DE LOS VÍDEOS:

Extraer sólo el audio de la versión de PC (el RSDKv5 necesita audio en 44100 pero los vídeos de PC vienen en 48000):
ffmpeg -i Opening.ogv -vn -ar 44100 Opening.ogg

Extraer sólo el vídeo de la versión de PC, escalándolo a 1024x512 que es lo que necesita el RSDKv5:
(Pongo la calidad de vídeo a 9 porque a 10 sale un frame corrupto al principio)
ffmpeg -i Opening.ogv -q:v 9 -vf scale=1024:512 -an Opening.ogv

*************HYDRA CASTLE LABYRINTH EN LA PI**************************************************************************************

Clonamos su repo:

git clone --depth 1 https://github.com/ptitSeb/hydracastlelabyrinth.git

Editamos src/sdl2/graphics.c y:
-En la llamada a SDL_CreateRenderer(), añadimos SDL_RENDERER_PRESENTVSYNC
-Antes de eso, añadimos SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
-En PHL_EndDrawing(), quitamos la sección de "implement some crude frameskipping...", y el while con el SDL_Delay() al final.
-Para controlarlo mejor con teclado usando Z y X, editamos src/sdl2/input.c, y dejamos las líneas:
case SDLK_x:        bFaceDown = w; break;
case SDLK_s:        bFaceLeft = w; break;
Así:
case SDLK_z:        bFaceDown = w; break;
case SDLK_x:        bFaceLeft = w; break;
O si quisiéramos usar controles más estilo MSX, con SPACE y CTRL, podríamos hacer:
case SDLK_LCTRL:        bFaceDown = w; break;
case SDLK_SPACE:        bFaceLeft = w; break;
(OJO! Hay que borrar otra línea con SDLK_SPACE que hay debajo, que es redundante porque podemos entrar en el menú usando ESC).

Editamos src/sdl2/audio.c y:
-Cambiamos el 4096 en Mix_OpenAudio() por 1024.

Compilamos con:
mkdir b4
cd b4
cmake -DUSE_SDL2=ON -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" ..
make -j4

Copiamos el directorio data que viene con los sources al mismo directorio donde metamos el ejecutable.

Para que se ejecute en modo fullscreen, sin cambiar resolución, sin escalado XBRZ y con escalado 1x, ejecutamos con:
./hcl -f -d -x1 --no-xbrz

*************CELESTE nativo en GNU/Linux**************

Clonamos su repo:
git clone --depth 1 https://github.com/lemon32767/ccleste.git

Editamos el Makefile, y en la línea de las CFLAGS quitamos el -g y ponemos los flags de la Pi4, que son:
-march=native -mtune=native -O2

Editamos sdl12main.c y allí:
-Comentamos toda la sección donde aparece SDL_Delay(), todo el bloque de principio a fin.

Editamos sdl20compat.inc.c y allí:
-En SDL_Flip(), duplicamos el bloque:
  SDL_RenderClear(sdl2_rendr);
  SDL_RenderCopy(sdl2_rendr, sdl2_screen_tex, NULL, NULL);
  SDL_RenderPresent(sdl2_rendr);
(Para que el juego vaya a 30FPS pero sincronizados con el VSYNC).
-Añadimos como único flag SDL_WINDOW_FULLSCREEN_DESKTOP a SDL_CreateWindow(), quitamos cualquier otro que haya.
-Añadimos antes de la llamada a SDL_CreateRenderer(): SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
-Añadimos estos flags a SDL_CreateRenderer(): SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC

Compilamos, y copiamos el ejecutable a ~/celeste/
Copiamos también el directorio "data" que viene con los sources a ~/celeste/

Lo lanzamos con:
CCLESTE_START_FULLSCREEN=1 ./ccleste

Se sale con la tecla DELETE

*************MightyMike en GNU/Linux*********************

git clone --recurse-submodules --depth 1 https://github.com/jorio/MightyMike.git

Editamos src/Heart/Window.c y allí metemos todo el bloque de
SDL_UpdateTexture, SDL_RenderClear, SDL_RenderCopy y SDL_RenderPresent dentro de esta condición:
if (gSDLTexture && gSDLRenderer) { }

Configuramos y compilamos:
mkdir b4
cd b4

cmake .. \
-DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native"

Copiamos el ejecutable MightyMike y el directorio "Data" que viene con los sources a ~/mightymike

*************Nanosaur en GNU/Linux*********************

Clonamos su repo:

git clone --recurse-submodules --depth 1 https://github.com/jorio/Nanosaur.git

Configuramos y compilamos:
mkdir b4
cd b4

cmake .. \
-DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native"

Copiamos el ejecutable Nanosaur y el directorio "Data" que viene con los sources a ~/nanosaur

*************Commander Genius en GNU/Linux*************

Podemos bajarnos una release (lo más recomendado), la última de aquí:

https://gitlab.com/Dringgstein/Commander-Genius/-/releases

O si decidimos clonar el repo, se requieren tres pasos:

git clone --depth 1 https://gitlab.com/Dringgstein/Commander-Genius.git
git submodule init
git submodule update

creamos un directorio de compilación y entramos en él:
mkdir b4
cd b4

Ahora configuramos:

cmake .. -DUSE_OPENGL=0 -DDOWNLOADER=OFF -DUSE_VIRTUALPAD=OFF -DDISABLE_HOVER=ON -DUSE_BOOST=OFF -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native"

Ya sólo es hacer make -j4 en el directorio de compilación y debería ir.

El resultado queda en src/CGeniusExe

Nos creamos ~/keen
Ahora editamos ~/.CommanderGenius/cgenius.cfg, y dejamos el primer searchpath así:
SearchPath1 = ${HOME}/keen
Ahora, creamos ~/keen/games, y metemos el directorio keen1 (que contrendrá los archivos del keen1) ahí, en ~/keen/games/keen1
Y ya lo tiene que ver el cargador.

Si queremos lanzar un juego directamente sin pasar por el lanzador, es con:
./CGeniusExe dir=games/keen1

Y si quieres tener música en keen1, gráficos mejorados, etc... te vas al directorio hqp que viene con los sources de gitlab,
y copias el directorio hqp/global a ~/keen, y luego lo que hay en hqp/keen1 a ~/keen/games/keen1,
lo que hay en hqp/keen2 a ~/keen/games/keen2, etc...

También puedes editar cgenius.cfg, y poner EnableLogfile=false para que no te genere un log en HTML cada vez que se ejecuta el juego.

*************Doomretro en GNU/Linux*************************************************************************************

Bajamos la última stable de https://github.com/bradharding/doomretro/releases

Si queremos que la resolución interna sea 320x200:
Entramos en src, editamos doomdef.h y ponemos SCREENSCALE a 1.

Si por el contrario dejamos que se renderize en alta resolución, pasamos "-nosplash" al ejecutable para que no salga el splash screen,
ya que sólo sale en alta resolución.

Editamos el Makefile y añadimos en OPTFLAGS: "-march=native -mtune=native", y quitamos el -g.
Compilar y listo.

En doomretro.cfg, ponemos:
vid_scalefilter a "linear"
gp_thumbsticks 2 si tenemos dos analógicos, y gp_sensivity_horizontal a 32 (la mitad que la vertical, vamos, que si no
es imposible apuntar bien en horizontal).

La música tiene que ir en un WAD (no valen PK3 ni movidas de esas) y tienen que estar los .ogg, los .mp3 o los .flac ahí dentro sin estar en ningún directorio ni nada, con sus extensiones y nombres originales. Y debes haber compilado SDL_Mixer con soporte para ogg o flac, claro.
Vengo usando estas músicas, que ya vienen en WAD y todo listas: https://zandronum.com/forum/viewtopic.php?t=97

Para usar el SIGIL, usa la versión COMPAT del WAD, y créate otro WAD a parte con la música en MP3, OGG o lo que sea, tal como se indica
en el párrafo anterior.

Para el 8Bitdo receiver, los botones son:
bind gamepad4 +fire
bind gamepad3 +use
bind leftshoulder +tun
Cuidado particularmente con no tener ya puesto leftshoulder a alguna otra función!

*************Problemas 8BITDO SN30******************************************************************************************

¡Tienes que encenderlo (START) y emparejarlo (SELECT) cada vez que cambias de modo!
Se cambia de modo apagando el mando (mantener START pulsado), y luego se entra en los diferentes modos al encenderlo:
START+B es el modo Dinput y es el único modo que te interesa. 
Los demás son:

B + START : Dinput mode, for Android devices or PC
X + START : Xinput mode, for PC
Y + START : Switch mode
A + START : MacOS mode, for Apple computers (NOT PHONES/TABLETS)

*************Abbaye des morts************************************************************************************************

Clonamos su repo:
git clone --depth 1 https://github.com/nevat/abbayedesmorts-gpl.git

Editamos src/main.c, y ponemos fullscreen = 1 y grapset = 1, y en Mix_OpenAudio() ponemos el tamaño de buffer a 1024 o 512.

Compilamos con:
make PLATFORM=rpi4_64 -j4

Para hacerlo funcionar, copiamos estos directorios que vienen con los sources al mismo directorio donde metamos el ejecutable:
data graphics screenshots sounds xcf

Puedes asignar el botón en src/base.h
Para usar el 8bitdo SN30, usa JUMP_BUTTON 0.

*************System Shock en la Pi con Shockolate****************************************************************************

Clonamos su repo:

git clone --depth 1 https://github.com/Interrupt/systemshock.git

Creamos el directorio de compilación, entramos, configuramos y compilamos:
cd systemshock
mkdir b4
cd b4
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_FLAGS="-march=native -mtune=native" -DENABLE_SDL2=ON -DENABLE_SOUND=ON -DENABLE_FLUIDSYNTH=ON -DOpenGL_GL_PREFERENCE=GLVND ..
make -j4

Ahora creamos ~/sshock y ahí dentro:
Copiamos el directorio shaders que viene con los sources a ~/sshock/shaders
Metemos los datos del juego en ~/sshock/res/data

Ejecutamos con:
./systemshock -nosplash

*************Chocolate DOOM en GNU/Linux**********************************************************************

Usamos el branch sdl2-branch, que clonamos con:

git clone --depth 1 -b sdl2-branch https://github.com/chocolate-doom/chocolate-doom.git 

Editamos src/i_video.c y cambiamos 
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "nearest"); 
por 
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");

Ahora editamos configure.ac ponemos el optimization level a 3 y quitamos y el -g que encontremos.
Ahora configuramos con 
CFLAGS="-march=native -mtune=native" CXXFLAGS="-march=native -mtune=native" ./configure
NO LE PASES el -O2 al script de configuración: ya lo has puesto en el configure.ac.

Compilamos con
make -j8 V=1
Verificamos que no hay -g, que se compila con -O2 y que los flags de cpu son correctos.
Listo!

NOTA: La opción de configuración de los gráficos en chocolate-setup peta. Da igual.

**************ACTUALIZAR MESON***************************************************************************************************

sudo apt-get purge meson
sudo apt install python3-pip --no-install-recommends
sudo python3 -m pip install ninja
sudo python3 -m pip install meson
PATH="/usr/local/bin:$PATH"

**************Regenerar caché LDD************************************************************************************************

sudo rm /etc/ld.so.cache
sudo ldconfig

**************SWAP de emergencia*************************************************************************************************

Algunos sistemas, como la Raspberry Pi, no usan swap normalmente porque nos cargaríamos la SD rápido.
Así que, si necesitamos un swap de emergencia para algo concreto, como compilar o linkar un programa grande que por razones de falta de 
RAM no se puede compilar en la Pi ni con distcc (esto suele pasar con el linkado, que siempre se hace de manera local), lo mejor es usar un swap
de emergencia en un disco duro mecánico, conectado por USB. Es tan simple como esto:

mkswap /dev/sdx
swapon /dev/sdx

También podemos hacer un archivo de swap si no queremos cargarnos una partición:

dd if=/dev/zero of=/path/to/swapfile bs=1M count=1024 # For 1GB swap file
swapon /path/to/swapfile

Al acabar con el swap, siempre

swapoff <device>

si no queremos colgar el sistema.

Podemos comprobar cómo se usa la swap con "free" mientras se linka.

**************Establecer un modo de vídeo "al vuelo" en GNU/Linux con KMS/DRM***************************************************

modetest -M vc4 -s 32:640x480 -d

El truco está en el "-d", que hace que modetest "suelte" el master (drop master) con lo que el siguiente programa aparece en
el modo que le hayamos dicho mientras modetest esté corriendo.

**************Text to speech en GNU/Linux con ESPEAK****************************************************************************

Nos bajamos la última release estable de:
https://github.com/espeak-ng/espeak-ng/releases

Configuramos con:
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native" -DCMAKE_C_FLAGS=="-march=native -mtune=native"

ALTERNATIVA: flite

apt-get install flite --no-install-recommends

flite -voice slt -t "hello pal"
(Para ver la lista de voices es con -vl)

**************Tyrian en GNU/Linux con OpenTyrian********************************************************************************

Clonamos el repo de:

git clone --depth 1 https://github.com/opentyrian/opentyrian.git

Editamos src/nortsong.c y en la función setDelaySpeed() dejamos delayPeriod = 0
(Con esto conseguimos que no se espere a ningún timer interno).

Editamos src/video.c, y:
-Repetimos la secuencia de llamadas:
       SDL_RenderClear(main_window_renderer);
       SDL_RenderCopy(main_window_renderer, main_window_texture, NULL, &dst_rect);
       SDL_RenderPresent(main_window_renderer);
(Con esto conseguimos que cada frame se pinte dos veces, con lo que el juego va a la mitad de frames que nuestro modo de vídeo,
así que irá a unos 30FPS suaves que no está mal).
-Añadimos SDL_RENDERER_PRESENTVSYNC a SDL_CreateRenderer()
-Añadimos SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear"); antes de la llamada a SDL_CreateRenderer()

-Editamos src/keyboard.c y comentamos entera la sección que dice "Show system mouse pointer if outside screen",
que es simplemente un SDL_ShowCursor() que sobra totalmente.

-Editamos src/opentyr.c y comentamos la llamada a intro_logos()

Compilamos con:
CFLAGS="-march=native -mtune=native" CPPFLAGS="-march=native -mtune=native" make WITH_NETWORK=false -j4

Metemos el ejecutable "opentyrian" en ~/tyrian, y los datos del juego en ~/tyrian/data,
y ejecutamos con:
opentyrian --data=data

Puedes bajar el original de:
https://exodos.the-eye.us/public/eXo/
Los archivos originales de DOS vienen todos en mayúsculas, los puedes pasar a minúsculas con:
sudo rename 'y/A-Z/a-z/' * 

**************Extraer datos de CUALQUIER ejeculable*******************************************************************************

Usa Universal Extractor:
https://github.com/Bioruebe/UniExtract2/releases

Es de Windows, usa WINE.

**************CONEXIÓN PERMANENTE AL IRC******************************************************************************************

Para OFTC: https://riot.im/app/#/room/#_oftc_#apertium:matrix.org
Para LIBERA: https://riot.im/app/#/room/#libera-matrix:libera.chat

Nos conectamos (tienes cuenta allí).

Para cambiar de nick es con !nick, para entrar en un canal es !join #canal, etc...
No sé cómo ver quién está en el canal, para eso hay que entrar en paralelo desde el IRSSI.

**************VIM autocompletion**************************************************************************************************

Ya era hora de tener esto pasado a un fichero de texto!

Instalamos exhuberant-ctags, que es el programa que genera paquetes de tags a partir de ficheros de cabecera:

sudo apt-get install exuberant-ctags

Creamos el directorio donde vamos a guardar los paquetes de tags generados a partir de los ficheros de cabecera:

mkdir -p ~/.vim/tags

Nos bajamos el plugin de VIM para autocompletion de aquí:
(si lo cambian de sitio, busca eso, el plugin de VIM para autocompletion)

http://www.vim.org/scripts/script.php?script_id=1520 

Lo mandamos a ~/.vim, y lo descomprimimos ahí con unzip omnicpp*zip. Nos crea directorios y tal, como un mini-sistema vim.

Nos bajamos también las cabeceras de C++ standard de aquí, para poder generar sus tags:

http://www.vim.org/scripts/script.php?script_id=2358 

Las descomprimimos en ~/.vim también, por ejemplo, con tar xvjpf cpp_src.tar.bz2

..y estando en ~/.vim, empezamos a generar los paquetes de tags:

ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ --sort=1 -f tags/INC /usr/include
ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ --sort=1 -f tags/STL cpp_src
ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ --sort=1 -f tags/SDL /usr/include/SDL
ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ --sort=1 -f tags/BCM /opt/vc/include   
(Esta de BCM es para la Rpi, dispmanx y tal)

Ahora, dejamos el /etc/vim/vimrc.local de esta guisa:

=====================================================

syntax on

" Para que no nos cargue los valores por defecto si no existe ~/.vimrc                                         
let g:skip_defaults_vim = 1 

" Para que NO nos transforme 8 espacios en un TAB
set noexpandtab

set number
set ls=2
set sw=1
set noswapfile

filetype plugin on
set tags+=~/.vim/tags/INC
set tags+=~/.vim/tags/STL
set tags+=~/.vim/tags/SDL
set tags+=~/.vim/tags/BCM

" para que se abra y se cierre automáticamente el menú desplegable de preview e info  
au CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif
set completeopt=menuone,menu,longest,preview

"para regenerar los tags de nuestro proyecto, los que no incluimos de base, con F12 
map <F12> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .<cr><cr>

"para desactivar la autoinserción de comentarios, que es lo que nos jode cuando copiamos código desde el navegador
"Es fundamental que esté colocada esta línea después de la de filetype plugin on,
"porque esa línea activaría de nuevo la autoinserción.
autocmd FileType * setlocal formatoptions-=c formatoptions-=r formatoptions-=o

colo torte

set encoding=utf-8                     "Estas líneas son para poder poner tildes, eñes y demás. 
setglobal fileencoding=utf-8

" Esto es para que no entremos en modo VISUAL al usar un ratón desde SSH
set mouse-=a

" Esto es para cambiar entre buffers. Hemos usado w porque se puede hacer con una mano la combinación,
" pero se cambia de buffer y no de ventana.
" Es para cuando se tienen dos ficheros abiertos a la vez. La exclamación es para poder cambiar entre buffers sin guardar cambios.
map <C-w> :bnext!<cr>

" tap indent movement 
vmap <Tab> >gv
vmap <S-Tab> <gv

" para que cuando estás en modo visual y mueves el texto con < y >, no se pierda la selección.
vnoremap < <gv
vnoremap > >gv

" Para que VIM no cree ficheros raros si no cerramos un fichero, que son una molestia.
set nobackup       "no backup files
set nowritebackup  "only in case you don't want a backup file while editing
set noswapfile     "no swap files

" Para que VIM recuerde la última posición
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

===========================================================

Y cambiamos el ownership de ~/.viminfo al usuario, ya que viene como propiedad del root y así no funciona lo que pongas en vimrc.
Y si aún así no funciona, comenta todo lo que has puesto en ~/.vimrc, debería funcionar. Entonces ve descomentando líneas y comprobando qué setting de .vimrc es el que
impide que funcione. Sí, esto me ha pasado.

===========================================================

Para que VIM no entre en modo VISUAL cada vez que pinchamos con el ratón, editamos /usr/share/vim/vim90/defaults.vim y
cambiamos
set mouse=a
por
set mouse-=a
(O SIMPLEMENTE BORRAMOS TODA ESA SECCIÓN!!!)

SI NO SABES dónde se está configurando lo del mouse, haz:
:verbose set mouse
y te lo dirá.

**************Traducir en tiempo real la consola desde una codificación distinta de UTF-8 a UTF-8***************************************

Por ejemplo, en este caso nos conectamos por telnet a un servidor que "emite" en ISO-8859-1, y de este modo vemos tildes y todo:

luit -encoding ISO-8859-1 telnet rlmud.org

**************Abrir varias ventanas en VIM y cambiar entre ellas***********************************************************************

Con el comando Sex (ESC, : Sex, Enter) y luego se cambia entre ellas con CTRL+ww
También podemos partir la ventana en dos con CTRL+ws y luego cambiar entre ellas!

**************Convertir archivos de DOS a UNIX**************************************************************************************

Para procesar todo un árbol de directorios quitando esos ridículos ^M de los documentos que generan los tontos que usan Windows:

find ./ -name '*.cpp' | xargs dos2unix

**************VIM con color en la TTY***********************************************************************************************

Tan simple como crear .vimrc en mi carpeta de usuario y añadir

syntax on
set number

**************Compilar un programa que da errores en la fase de linkado porque no encuentra las librerías********************************

Si da errores de que no encuentra los ficheros de cabecera de las librerías, tendremos que añadir -I<ruta de los  .h que necesita> a los CFLAGS 
y/o a los CXXFLAGS. Esto sería un error de compilación, no un error en el linkado. No te confundas.

Si lo que pasa es no encuentra las liberías en el linkado ("undefined reference"), tendrás que añadir, en teoría, -L<ruta de la librería> a los LDFLAGS.

**************Localizar dónde está instalada una librería******************************************************************************

ldconfig -p

**************Script que procesa varios ficheros, en este caso canciones, y las va reproduciendo******************************************
#!/bin/bash

PLAYER="omxplayer -o hdmi"
PLAYLIST="play.pls"

# Play arguments on command line if they exist
if [ $# -ne 0 ]
then
    for file
    do
        $PLAYER "$file"
    done
    exit
fi

# Play the playlist if it exists
if [ -e "$PLAYLIST" ]
then
    IFS=$'\012'
    for file in $(cat "$PLAYLIST")
    do
        $PLAYER "$file"
    done

# Play the directory structure otherwise
else
    for file in *
    do
       $PLAYER "$file"
    done
fi 


***************Compilar e instalar un programa que usa unas librerías que están instaladas en una ubicación no estándar******************

Para compilar las librerías, habremos hecho:

./configure --prefix=/home/manuel/sidplay
make -j5
make install

...con lo que acabaremos con las librerías en /home/manuel/sidplay/lib

Y para compilar el programa que las usa, en este caso un sid player, lo que le decimos es dónde está el archivo .pc de la librería, NO dónde está
la propia librería:

PKG_CONFIG_PATH=/home/manuel/sidplay/lib/pkgconfig ./configure --prefix /home/manuel/sidplay/

(En este caso concreto, el player se empeña en compilar con PULSEAUDIO, así que alteramos el script "configure", NO el Makefile, ojo, para cambiar a pkg_failed a yes justo antes
de la parte de script que lo comprueba, ya que no hay manera de desactivarlo de otra manera).
Le podríamos anteponer también la variable de entorno LDFLAGS, para decirle al linker dónde están las librerías contra las que tiene que linkad el ejecutable, 
con lo que quedaría:

LDFLAGS+=-L/home/manuel/sidplay PKG_CONFIG_PATH=/home/manuel/sidplay/lib/pkgconfig ./configure --prefix /home/manuel/sidplay

PERO esto es redundante, ya que dentro del fichero .pc de las librerías que compilamos antes, y que le pasamos mediante PKG_CONFIG_PATH, ya
sabe el linker dónde están esas librerías.
No nos sirve LDFLAGS como solución para decirle dónde están las librerías en tiempo de ejecución, ya que LDFLAGS es sólo para indicarlo en
tiempo de compilación. En tiempo de ejecución no nos quedará más remedio que usar LD_LIBRARY_PATH, como siempre, ya que está definido en el 
sistema cuáles son las localizaciones donde pueden estar las librerías, y NO es el ejecutable el que las busca.

Ahora: 

make -j5
Y para ejecutar

LD_LIBRARY_PATH=/home/manuel/sidplay/lib ./sidplayfp <tema>.sid
 

***************Rogue en Linux**************************************************************************

Descarga los últimos sources de
git clone --depth 1https://github.com/gillesdami/rogue.git

Antes de nada, instala las libncurses5-dev, antes de hacer el configure.
sudo apt-get install libncurses5-dev --no-install-recommends

Ahora actualiza el config.guess, que el que trae el rogue es viejo y no detecta bien el sistema:
wget 'http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD' -O config.guess

Configurar y compilar:
CFLAGS="-O2 -march=native -mtune=native" ./configure
make -j4

Ayuda de teclas con shift+?

Puedes pasarle un nombre de jugador, un archivo de salvado, etc.. usando la variable de entorno ROGUEOPTS. Como por ejemplo así:
ROGUEOPTS="name=Manuel,file=manuel.save" ./rogue.bin -r

***************Borrar un archivo con nombre que contiene caracteres extraños*****************************

Lo primero, buscamos su inode:
ls -il

(el número largo que aparece a la izquierda del todo es el inode de cada archivo)

Ahora, usamos find para encontrarlo por inode y borrarlo

find . -inum 14071947 -exec rm {} \;

Si el problema es que el archivo lleva un par de guiones al inicio de su nombre, lo que hacemos es:

rm -- --*

ya que el primer -- indica a rm que no se le van a pasar mas parámetros, por lo que ya no interpretaría el nombre del
archivo como tales.

***************Configurar la salida de audio de la Raspberry para que use el jack*****************************

sudo amixer cset numid=3 1

Lo pones una vez y ya queda configurado en los valores de ALSA.

Y para el audio por HDMI otra vez:

amixer cset numid=3 2

***************Gestión avanzada de acceso a ficheros en Linux********************************************

Para ver qué procesos tienen algún fichero abierto en un directorio, a quién pertenecen, etc:

lsof +D /var
lsof +D /etc
...

Para ver los números de los procesos que tienen algún fichero abierto en un directorio, a quién pertenecen, etc:

lsof -t +D /var
lsof -t +D /etc
...

Para matar los procesos que tienen algún fichero abierto en un directorio:

lsof -t +D /var | xargs kill
lsof -t +D /etc | xargs kill
...

Para matar todos los procesos de un usuario:

killall -u <usuario>

Para matar todos los procesos lanzados por un proceso (por ejemplo todos los procesos lanzados por un script):

pkill -P <PID_del_proceso_padre>

Por ejemplo, yo mato todos los procesos lanzados por el proceso con PID 1, que es mi script mínimo de inicio, con:

pkill -P 1

***************Sidplay no encuentra /dev/dsp*************************************************************

sudo modprobe snd-pcm-oss 

***************Sacar copia de seguridad del sistema*******************************************************

Del rootfs. Si hay partición de arranque, va a parte.

sudo tar -cvpzf backup.tar.gz --exclude=/backup.tar.gz --one-file-system /

Y para restaurar:

sudo tar -xvpzf backup.tar.gz -C /media/whatever --numeric-owner

***************Bajarse los sources de un programa en Debian***********************************************

Lo primero que necesitamos es una entrada de sources en el /etc/apt/sources.list, del tipo:

deb-src http://mirrordirector.raspbian.org/raspbian/ wheezy main contrib non-free rpi

Hacemos un 

sudo apt-get update

Y luego ya podemos hacer 

apt-get sources timidity

NO HAY que ser root para hacer esto, ya que los sources NO se instalan sino que se descargan en el directorio actual y ya.

****************Bajarse los sources de un kernel en debian/ubuntu******************************************

Pongamos que uname -r te dice que usas el kernel

linux-image-3.4.0-1490-omap4

Entonces, para bajarte los sources de ese kernel, haces:

apt-get source linux-image-3.4.0-1490-omap4

Si estás compilando justo este kernel, al compilar los módulos te dira no sé qué.
Deactiva CONFIG_BINFMT_AOUT y vuelve a compilar.

-Podemos extraer una configuración de un kernel previo con

./extract-ikconfig ~/panda/boot/uImage > ~/panda/.config

O bien podemos crear una muy básica que arranca, por ejemplo, en todos los OMAP, con

make ARCH=arm omap2plus_defconfig

make ARCH=arm menuconfig 

-Compilamos el kernel

make -j4 ARCH=arm CROSS_COMPILE=~/x-tools/arm-unknown-eabi/bin/arm-unknown-eabi-  uImage

-Compilamos los módulos del kernel:

make -j4 ARCH=arm CROSS_COMPILE=~/x-tools/arm-unknown-eabi/bin/arm-unknown-eabi- modules

-E instalamos los módulos:

sudo make ARCH=arm modules_install INSTALL_MOD_PATH=/media/manuel/LINUX/

-Y lo mismo el kernel:

sudo cp arch/arm/boot/zImage /media/manuel/BOOT/


****************Extraer la configuración de un kernel*******************************************************

Para extraer un .config de un kernel que sabemos que funciona, en el directorio scripts de los kernel sources tenemos un script apropiado que funciona así:
./extract-ikconfig ~/panda/boot/uImage > ~/panda/.config

****************INSTALAR GLMARK2****************************************************************************

Instalamos dependencias previas:
apt-get install libpng-dev libjpeg-dev

Clonamos su repo:
git clone --depth 1 https://github.com/glmark2/glmark2.git

Configuramos con:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" CXXFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Dflavors=drm-glesv2,gbm-glesv2,wayland-glesv2 ..

***************INSTALAR VKMARK*******************************************************************************

Instalamos dependencias previas:
apt-get install libglm-dev libassimp-dev --no-install-recommends

Clonamos su repo:
git clone --depth 1 https://github.com/vkmark/vkmark.git

Configuramos con:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" CXXFLAGS="-march=native -mtune=native" \
meson setup .. -Dbuildtype=release

***********Recuperar un archivo corrupto de Abiword u otro procesador de textos que se niega a abrir*********

Nos instalamos ipython 

sudo apt-get install ipython

Y vamos haciendo las siguientes cosas, una por línea:

data = open('current_events.abw', 'r').read()

from lxml import html

doc = html.fromstring(data)

doc

print ''.join(doc.xpath('//text()'))

Listo. Lo copiamos de la consola a un editor en condicioes y arreglado.
(Sacado de http://stephenmw.wordpress.com/2011/01/18/abiword_recovery/)


********Instalar FSV, el navegador de archivos en 3D****************

Clonamos el repo
https://github.com/mcuelenaere/fsv
e instalamos: 
sudo apt-get install libgtk2.0-dev
Ya sólo queda un -/config y make, y a correr.

*********Averiguar qué paquete contiene un archivo dado***************

dpkg -S filename

*********************Versión que tenemos instalada de un paquete******

dpkg -l |grep libgbm-dev

*********************Buscar un archivo recursivamente a partir de un punto del sistema de ficheros***********

find ./ -name '*gtk*'

************Tabla de permisos de Unix*****************

Esto lo deberías tener en la cabeza, pero se te suele olvidar.
Las tres posiciones de los números corresponden con OWNER, GROUP (del owner) y OTHER USERS.
Y los valores de los números son decimales de tres bits. Estos tres bits pueden estar activos o inactivos (¿no me digas?) configurando así el valor.
Su órden es R, W, X. (Lectura, escritura y ejecución).
Así, si queremos que el propietario tenga permisos de ejecución y lectura, será un 101 binario, que inmediatamente sabemos que es un 5.
Si queremos que el grupo tenga permisos de lectura solamente, será un 100, que es un 4.
Y si queremos que el resto sólo tengan permisos de ejecución, será un 001, que es un 1.
O sea que haremos chmod 541 nombrearchivo y nos quedaremos tan anchos.

***************Escanear las Ips conectadas en red local (la misma del equipo en que estoy)***********************

nmap -sn 192.168.1.0/24

Esto escanearía las Ips conectadas a la red 192.168.1.x, que es lo que seguramente quieres hacer.
Fácil y muy, muy útil.

****************Arrancar Lubuntu en modo texto**********************

Editamos /etc/default/grub y añadir “text” a los parámetros de la línea  GRUB_CMDLINE_LINUX_DEFAULT

Ejecutamos sudo update-grub


******************El sistema se empeña en que tenemos 0 bytes free en partición EXT4*******

Borramos archivos pero no recuperamos el espacio!
Esto es porque se reserva un 5% por defecto para el root. Para cambiar esto, simplemente hacemos:

tune2fs -m 1 <device>

y de este modo sólo se reserva el 1%. Solucionado.

******************Cambiar el tamaño del texto y la fuente en la consola**********************

sudo dpkg-reconfigure console-setup

*******************Limpiar Lubuntu de los "procesos malditos", whoopsie y apport**********

Esta pareja de hijos de puta gusanos de la fundación Canonical se tiene que ir de cualquier sistema con Lubuntu que yo instale.
Así que empieza la fiesta del dpkg...

dpkg -r --force-depends apport-gtk
dpkg -r --force-depends apport
dpkg -r --force-depends whoopsie

y por último, aunque te suene raro, desinstalamos lubuntu-desktop porque el paquete queda con sus dependencias rotas y 
nos estaría avisando el gestor de paquetes en cada arranque si no lo desinstalamos:

dpkg -r --force-depends lubuntu-desktop

Ya veremos qué pasa si intento instalar algo que dependa de lubuntu-desktop.. si empiezan a fallar las cosas, es hora de
pasar a Debian.

*******************Autologin en modo texto en Lubuntu************************************

Con systemd. 
Sabemos que el fichero principal de la unit de getty@tty1.service está en:

/lib/systemd/system/getty@.service

Vale. Tenemos varias alternativas. Podemos editar /lib/systemd/system/getty@.service y cambiar lo que necesitemos, o podemos crear un drop-in, que es 
como un parche para cambiar cosas de la unit sin cambiar la unit. 
Vamos a hacer esto segundo, a usar un drop-in. Para ello, creamos el fichero (y los directorios precedentes si hiciese falta):

sudo vim /etc/systemd/system/getty@tty1.service.d/autologin.conf

Metemos en ese fichero esto:

[Service]
ExecStart=
ExecStart=-/sbin/agetty --autologin username --noclear %I 38400 linux

Salvamos, recargamos la configuración de los daemons:

systemctl daemon-reload

y reiniciamos el servicio:

systemctl start getty@tty1.service

Para ver que todo va bien, podemos hacer:

systemctl status getty@tty1.service

FALLO GORDO: que la ruta de agetty sea incorrecta. Si no lo es, no puede funcionar el servicio, lógicamente.
Así que comprueba que tienes /sbin/agetty y que efectivamente este ejecutable existe.

Añadimos una segunta tty que se lance automáticamente (los agetty sobre tty1, tty2, tty3, etc.. se lanzan por activación
de socket, pero sólo viene que se lance el primero, así que añadimos otra agettty sobre tty2):

-Creamos la UNIT para agetty sobre tty2:
sudo ln -sf /usr/lib/systemd/system/getty@.service /etc/systemd/system/getty.target.wants/getty@tty2.service

-Creamos eo drop-in override para autologearnos en tty2 también:

sudo vim /etc/systemd/system/getty@tty2.service.d/override.conf

con el contenido:
[Service]
ExecStart=
ExecStart=-/sbin/agetty --autologin manuel --noclear %I 38400 linux

-Recargamos settings y reiniciamos el servicio:
systemctl daemon-reload
systemctl start getty@tty2.service

Fuentes:

https://wiki.archlinux.org/index.php/Automatic_login_to_virtual_console
https://wiki.archlinux.org/index.php/Systemd_FAQ#How_do_I_change_the_default_number_of_gettys.3F

Para cambiar la fuente de letra, de momento hacemos setfont Lat15-TerminusBold24x12 en .bash_profile y listo.

Ya que estás, puedes quitar más mierdas:

sudo systemctl disable NetworkManager-wait-online
sudo systemctl disable apparmor
sudo systemctl disable ModemManager
sudo systemctl disable whoopsie
sudo systemctl disable apport

fuente:

http://www.samplerbox.org/article/fastbootrpi

INFO ANTIGUA DE ANTES DE SYSTEMD

Editamos /etc/init/tty1.conf y añadimos -a username a la línea donde se lanza la consola tty1. Quedaría así:

exec /sbin/getty -8 38400 tty1 -a <nombre_usuario>

******************Desactivar tap to click en el synaptics trackpad en Lubuntu*********************************************

Entramos en Preferences->Default Applications for LXSession->Autostart, y añadimos 

synclient MaxTapTime=0

bajo la categoría "Manually Autostarted Applications". Le damos a + y ya.

*****************Gestor de conexiones no aparece************************************************************

Añadir nm-applet en el mismo lugar que cabamos de mencionar, en Preferences->Default Applications for LXSession->Autostart

*******************Desactivar servicio de los que se lanzan en arranque en Lubuntu****************************

Es un poco distinto que en Debian. 
Modemmanager se quita con un apt-get install purge modemmanager.
Por ejemplo, para deshabilitar el network manager, movemos /etc/init/network-manager.conf a /etc/init/network-manager.conf-disabled

Para volverlo a habilitar, pues lo movemos donde estaba.

Otra manera es hacer 

sudo update-rc <nombre_servicio> disable

De hecho, lo mejor es hacer ambas.

Ahora tendrás que especificar la configuración de red a piñón en /etc/network/interfaces

iface eth0 inet static
address 192.168.1.35
netmask 255.255.255.0
gateway 192.168.1.1


Y NO TE OLVIDES de añadir eth0 a la linea auto, quedando

auto lo eth0

O si no, tendrás que andar haciendo a mano ifup eth0 en cada arranque. 
Y si ves que tienes salida a internet pero no resuelve nombres, tienes dos opciones:

1)

Añadir en el propio /etc/network/interfaces

dns-nameservers 208.67.222.222 8.8.8.8

El primero es el de OpenDNS, y el segundo el servidor DNS de google, o sea que mejor usar el primero.

2)

Deshabilitar el servicio resolvconf, moviendo /etc/init/resolvconf.conf a /etc/init/resolvconf.conf-disabled, 
para que /etc/resolv.conf no sea sobreescrito. 
Ahora ya sólo queda borrar /etc/resolv.conf que es un link duro a un fichero del servicio resolvconf (concretamente, antes de borrarlo vemos 
que /etc/resolv.conf -> ../run/resolvconf/resolv.conf, por si lo quieres restaurar), editar un nuevo /etc/resolv.conf y añadirle ahí nuestros servidores DNS:

nameserver 208.67.222.222 
nameserver 8.8.8.8

Mola más este segundo estilo, ya que lo dejamos todo más sencillo y más estándar.

****************Usar SUDO sin password***************************

Hacemos sudo visudo y la línea del grupo sudo la dejamos así:

%sudo ALL=NOPASSWD: ALL 

*****************Desactivar tarjeta gráfica ATI********************

En /etc/rc.local:

echo OFF > /sys/kernel/debug/vgaswitcheroo/switch

*****************Configurar un servidor SAMBA y un share. Montar el share.********************

En el servidor:

-Instalamos el paquete samba

sudo apt-get install samba

-Editamos /etc/samba/smb.conf
 En la sección [global] dejamos el workgroup por defecto y descomentamos la línea “security = user”, para que se puedan logar usuarios.

-Al final del fichero, añadimos un share. MUY IMPORTANTE, atento al nombre que le pones al share entre corchetes porque es el nombre que necesitas luego para acceder a él a través de la IP del servidor SAMBA.
Nosotros lo hemos llamado [biblio], porque contendrá la base de datos de este programa, para que distintas instancias a través de la red accedan a la misma base de datos.
Nos queda así nuestro primer share:

[biblio] 
    comment = Biblio Database
    path = /home/edu/database
    browsable = yes 
    guest ok = yes 
    read only = no 

-En este caso, el directorio del share no tenemos que crearlo porque ya lo crea la instalación del Biblio, pero si no, habría que crearlo.
Lo que sí tenemos que hacer es cambiarle el propietario y los permisos:

sudo chown nobody.nogroup /home/edu/database
sudo chmod -R 0777 /home/edu/database

En este caso lo he hecho para .wine y todos sus subdirectorios y funciona. Es un poco radical, pero había que resolver el tema.

Relanzamos el servidor SAMBA:

sudo restart smbd 
sudo restart nmbd 


En el cliente:

-Instalamos las cifs-utils
sudo apt-get install cifs-utils
-Ya deberíamos ser capaces de montar el share con

sudo mount -t cifs -o username=edu,password=marta //192.168.1.35/biblio fakebase/

-Habremos creado previamente el directorio fakebase dentro de la instalación local de Biblio (/home/vader/.wine/drive_c/Biblio/fakebase)
y habremos hecho un link simbólico (soft) al fichero Biblio.mdb de fakebase, de manera que cuando Biblio accede a su Biblio.mdb, en realidad lo hace al Biblio.mdb del share Biblio del servidor de ficheros SAMBA.
O sea que, estando en home/vader/.wine/drive_c/Biblio, hacemos un

ln -s fakebase/Biblio.mdb Biblio.mdb 

-Ahora podemos automatizar el montaje del share en los clientes, añadiendo a /etc/fstab las líneas:

#El servidor de ficheros con la base de datos de BIBLIO 
//192.168.1.35/Biblio /home/manuel/.wine/drive_c/Biblio/fakebase cifs username=corchetema,password=enfermera 0 0 

Por supuesto, para esto deberíamos tener una IP fija en el servidor.
No hace falta acceso sin user/pass ni nada, va bien así y no hay problemas especificando el user/pass en el fstab.

Y ya podemos dar de alta libros desde dos instancias del programa sobre la misma base de datos. Enjoy!

*****************************Error recalcitrante con “sdb write cache” en Lubuntu***************************

Es un problema de los drivers del lector de tarjetas. 
Ubuntu no hace caso a los parámetros que se le pasan a los módulos en /etc/modules e ignora las entradas en /etc/modprobe.d/blacklist.conf, así que al final tuve que añadir a /etc/rc.local la línea sudo rmmod ums_realtek. 


******************************Añadir repositorio en Ubuntu************************************************ 

sudo add-apt-repository <repo_address>

*****************************Cómo instalar pyrit + módulo CUDA (Nvidia) en Lubuntu************************

Lo primero que hay que tener claro que pyrit funciona por defecto usando la CPU, y que para que use la gráfica hay que instalar unas cosas de nvidia (además del driver propietario) y luego un módulo de pyrit para cuda.

Lo primero es instalar el driver propietario de NVIDIA, ya que nouveau NO VALE para esto:
sudo apt-get install nvidia-current

El siguente paso a lo mejor no es necesario, aunque yo lo hice. Probablemente todo esto se instale al instalar los cachivaches de nvidia:

sudo apt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libgl1-mesa-glx libglu1-mesa libglu1-mesa-dev

Instalamos python-dev y otras cosas:

sudo apt-get install python-dev 
sudo apt-get install libpcap-dev
sudo apt-get install libssl-dev 

Ahora instalamos las cosas de nvidia:

sudo apt-get install nvidia-cuda-dev
sudo apt-get install nvidia-cuda-toolkit

Hacemos el siguiente link simbólico, ya que libcuda se instala en una localización por defecto distinta de donde la buscará el módulo cuda de pyrit, y si no lo hacemos, no la encuentra, con el consiguiente error:

ln -s /usr/lib/nvidia-304/libcuda.so /usr/lib/libcuda.so

Nos bajamos el pyrit y los módulos:

wget http://pyrit.googlecode.com/files/cpyrit-cuda-0.4.0.tar.gz
wget http://pyrit.googlecode.com/files/pyrit-0.4.0.tar.gz

Empezamos instalando el módulo, entrando en el directorio de cpyrit-cuda y poniendo:

python setup.py build
sudo python setup.py install
Estas cosas no deberían darme ningún error. Si dice algo de unas cabeceras que hacen falta pero no se encuentran y continuing anyway, pasamos del tema.

Entramos en el directorio de pyrit y hacemos la misma:

python setup.py build
sudo python setup.py install

El binario de pyrit se instala en /usr/local/bin/pyrit, así que le hacemos un 

ln -s /usr/local/bin/pyrit /usr/bin/pyrit

Y ya debería estar. Lanzamos

pyrit list_cores

y deberíamos ver algo como:

The following cores seem available...
#1:  'CUDA-Device #1 'GeForce 9400''
#2:  'CPU-Core (SSE2)

Ahora lanzamos un 

pyrit benchmark

...y vemos si merece la pena o no...A la gente le da 3000 y pico, con máquinas decentes.

Ahora usamos el pyrit para romper una contraseña:

pyrit -r “84:9C:A6:A3:8E:8F-01.cap” -b "84:9C:A6:A3:8E:8F" -e "Orange-8E8D" -i <diccionario.txt> attack_passthrough

**************************Tirar el servidor gráfico (Xorg) en Lubuntu************************************

sudo service lightdm stop

y para volver, obviamente, start.

**********Configuración óptima de RetroArch (En Wayland)************

Configuración base de la que partiremos, es decir, lo primero que ponemos:
VIDEO: driver VULKAN, VSYNC ON (suponiendo que no tengamos VRR), MAX_SWAPCHAIN 2
AUDIO: driver ALSATHREAD (hay que pasar unos parámetros al kernel, mira más abajo en el bloque de baja latencia),
       44100 Hz, 36ms, resampler quality normal
(Si usas otra frecuencia de audio, modifícalo también en las opciones del core FBNeo: por lo demás,
la frecuencia nativa en la mayoría de los cores es 44100Hz por lo que usándola nos ahorramos una conversión).

####### BLOQUE BAJA LATENCIA EN RETROARCH SIN VRR ########

-Para hacer que Alsathread funcione como debe, tenemos que configurarlo bien:
Para mejorar el comportamiento de Alsathread, añadimos estas cosas a la línea de comandos del kernel (tienes más info en la
sección "KERNEL REALTIME EN DEBIAN" de NOTAS_DEBIAN.TXT):
"threadirqs preempt=full nohz_full=1-3 cpufreq.default_governor=performance mitigations=off audit=0"
Esto nos permite bajar la latencia en la mayoría de los cores a 16ms,
excepto en las transiciones de modo de vídeo del DOSBOX que petardea un poco, pero si lo dejas a 36 las transiciones de DOSBOX ya no petardean.
(sigue siendo una latencia ínfima e inapreciable)
 
-La posibilidad inicial de la que partimos, es poner Max Swapchain a 2, usar Alsathread con los parámetros del kernel antes mencionados
para mejorar su desempeño, poner la latencia de audio a 32/36ms, y meter 1 frame de Runahead, o no usar Runahead en absoluto.
En este caso estamos "cargando" la GPU por lo del Max Swapchain a 2, por lo que algunos shaders un poco avanzados como Cyclone
o el Newpixe normal petardean.

-Un truco para evitar lo anterior "descargando" la CPU es poner Max Swapchains a 3, y luego compensar poniéndole 2 frames de Runahead
(se puede inluso 3, pero el Tetris de arcade con más de 1 ya hace cosas raras... piensa que estamos actuando sobre el lag interno
que algunos juegos llevan de serie, no el lag externo del sistema emulador, así que tiene esa contrapartida).
NO hace falta activar el "Use Second Instance", porque a nosotros el Runahead no nos provoca problemas de audio.
El otro método parecido a Runahead, llamado "Run Preemptive Frames", sí causa pitch wobbling. 
La idea es que al pasar el Max Swapchains a 3, liberamos la GPU para los shaders (no tiene que esperar al vsync) y a la vez
"compensamos" trucando la latencia interna de los juegos mediante el Runahead (que tiene sus consecuencias como lo del Tetris arcade).

####### FIN BLOQUE BAJA LATENCIA EN RETROARCH SIN VRR ########

SHADERS: Para la mayoría de las máquinas, el shader Fakelottes con el "Monitor Gamma" bajado a 1.95 es más que suficiente.
Para el core de SEGA, debido al tema del dithering y tal, usa el shader CYCLONE con estos parámetros puestos así:
 Curvature Horizontal = "0.05"                                                                                                                               
 Curvature Vertical = "0.05"                                                                                                                                                                                                                                                              
 Scan/Mask Brightness Dependence = "0.33"                                                                                                                              
 Saturation = "1.30"                                                                                                                          
 Bightness, Sega Fix = "1.06"                                                                                                                         
 Convergence Overal Strength = "0.50"                                                                                                                               
 Convergence Red X-axis = "1.00"
 Convergence Green X-axis = "1.00"
 Convergence Blue X-axis = "1.00"
 Potato Boost = "1.00"
 
APUNTES SOBRE CORES ESPECÍFICOS:

PARA CORES DE ORDENADOR QUE NECESITAN TODO EL TECLADO, la idea es usar el "GAME FOCUS", para lo cual
NO DEBEMOS TENER ACTIVADO el "HOTKEY ENABLE", ya que son dos funcionalidades que se solapan
y si tuvieses ambas la "HOTKEY ENABLE" no funcionaría al tener activo el "GAME FOCUS" que dedica todas las teclas al core.
Así que hacemos esto:
-En Settings->Input, pon "Auto Enable Game Focus" a "Detect".
-En Settings->Input->Hotkeys, pon en "Game Focus (Toggle)" la tecla Windows ("lsuper" se llama).
-En Settings->Input->Hotkeys, NO PONGAS NINGUNA TECLA en "Hotkey Enable".

PARA EL CORE SWANSTATION, ACUÉRDATE DE PONER EL RENDERER DEL CORE EN "SOFTWARE" (No le eches la culpa al shader si hay audio dropouts)...
Y EL "CPU EXECUTION MODE" A "CACHED INTERPRETER" (Contrariamente a lo que parece, es más rápido que "RECOMPILER")
Y EL "CD-ROM SEEK SPEED UP" PON "INFINITE/INSTANTANEOUS"
Y RECUERDA QUE ESTE CORE TIENE PROBLEMAS DE AUDIO (pequeñas distorsiones) SI PONES 1 FRAME DE RUNAHEAD: PARA SOLUCIONARLO,
PUEDES ACTIVAR LA OPCIÓN DE "USE SECOND INSTANCE" Y SUBIR EL TAMAÑO DEL BUFFER DE AUDIO A 36ms, O MEJOR AÚN, QUITAR EL RUNAHEAD
PARA ESTE CORE EN CONCRETO (USANDO OVERRIDES).
(De todos modos, si tienes max_swapchain a 2, ya tienes la misma latencia que la consola original, ya que es una consola con framebuffer).

PARA EL CORE DE NES (NESTOPIA) USA LA PALETA "CXA2025AS", O LA CONFIGURACIÓN DE SHADERS SE VERÁ MUY RARA.

PARA EL CORE DE PC-ENGINE, INITIAL_SCANLINE=10, LAST_SCANLINE=232

PARA EL CORE DE SATURN, USA LOS SIGUIENTES OVERRIDES:
	--Desactiva el Runahead por completo!
	--Backend de video: opengl
	--Hard GPU Sync: ON, con Hard GPU Sync Frames a 0

PARA EL CORE DE NINTENDO DS, ten en cuenta que no hay CPU para hacer Runahead, pero sí que funciona bien con max_swapchain a 2
y el shader Fakelottes con la curvatura comentada.

NO USES EL CORE BSNES: tendrías que desactivar el Runahead de RetroArch y activar el Runahead interno de BSNES,
o se quedará en una pantalla en negro.
A parte, tiene problemas de buffering y no va bien con latencias de sonido bajas, hagas lo que hagas.

SI USAS INTEGER SCALING Y QUIERES UN BORDE PARA LA PANTALLA:
-Clona el repo https://github.com/libretro/common-overlays.git, y mete los overlays que quieras en ~/.config/retroarch/overlay
-Ve a QUICK MENU->ON-SCREEN OVERLAY, activa DISPLAY OVERLAY, y selecciona un overlay preset de los que has copiado.
(Se podría activar y ajustar también en SETTINGS->ON-SCREEN DISPLAY->ON-SCREEN OVERLAY, estableciendo así un solo overlay
para todos los cores, pero como cada core aparece de un tamaño en pantalla al usar INTEGER SCALING, nos conviene gestonarlo
aquí en QUICK MENU para que quede configurado core a core).

PARA CORES DE ORDENADOR QUE NECESITAN TODO EL TECLADO, la idea es usar el "GAME FOCUS", para lo cual
NO DEBEMOS TENER ACTIVADO el "HOTKEY ENABLE", ya que son dos funcionalidades que se solapan
y si tuvieses ambas la "HOTKEY ENABLE" no funcionaría al tener activo el "GAME FOCUS" que dedica todas las teclas al core.
Así que hacemos esto:
-En Settings->Input, pon "Auto Enable Game Focus" a "Detect".
-En Settings->Input->Hotkeys, pon en "Game Focus (Toggle)" la tecla Windows ("lsuper" se llama).
-En Settings->Input->Hotkeys, NO PONGAS NINGUNA TECLA en "Hotkey Enable".

*********No funcionan los input en RetroArch**********

PARA que haya input con el driver udev (input_driver = "udev") debemos crear /etc/udev/rules.d/99-evdev.rules con el contenido:
KERNEL=="event*", NAME="input/%k", MODE="666"
Ahora podemos hacer
sudo udevadm control --reload-rules
sudo chmod 666 /dev/input/event*
o simplemente reiniciar.

*********Conservar la asignación de mandos a los puertos de RetroArch***************************************

La idea es que, si tenemos dos mandos por ejemplo, uno de ellos sea siempre el del puerto 1 de RetroArch y el otro sea el del puerto 2 de RetroArch.

¡¡¡NO HACE FALTA ANDAR CON REGLAS DE UDEV!!!

Nos vamos a SETTINGS->INPUT->PORT 1 CONTROLS y en DEVICE INDEX seleccionamos el mando que queramos que sea siempre
el del puerto 1.
Repetimos para  SETTINGS->INPUT->PORT 2 CONTROLS y su DEVICE INDEX.

Puedes quitar y poner los mandos como quieras, etc... y la configuración se conserva siempre. Si inicias RetroArch con uno solo de los dos mandos
conectado, tampoco hay problema y sigue en su puerto correcto.

**********RETROARCH no salva las partidas de SRAM a veces**************************

Hay que tener en cuenta que RETROARCH no salva la SRAM automáticamente, sino que vuelca la SRAM al salir del core que sea.
Para tener algo parecido a un volcado de SRAM automático, activa SETTINGS->SAVING->SaveRAM Autosave Interval,
que por defecto deberían ser unos 10s.
Sólo escribe en disco si encuentra diferencias en la SRAM (así que no escribe continuamente!) e incluso así, es una tarea que
va en su propio thread si tienes activada la opción SETTINGS->USER INTERFACE->Threaded Tasks (cosa que SIEMPRE deberías tener activada).

****************************Para configurar PINN después de actualizarlo***********

Montamos /dev/sdb1, y ponemos en config.txt:

disable_splash=1
disable_overscan=1

Para establecer una espera en segundos, puedes añadir en recovery.cmdline:
bootmenutimeout=60

Y para que no busque actualizaciones, puedes añadir en recovery.cmdline:
no_update

Tienes todas las posibles opciones de recovery.cmdline en:
https://github.com/procount/pinn/blob/master/README_PINN.md#cmdline-options

****************************Cómo compilar libmodplug*******************************

Cambia automake-1.13 a automake-1.11 en el Makefile.
Configura con: 
CFLAGS="-O2 -march=native -mtune=native" CXXFLAGS="-O2 -march=native -mtune=native" ./configure --enable-static

****************************Cambiar la resolución al vuelo en KMSDRM*******************

Se haría con switchres, que puede ser un programa que tienes aquí para bajar y compilar:

git clone --depth 1 https://github.com/antonioginer/switchres.git

Editamos custom_video_drmkms.cpp y ponemos drm_name[15] a "/dev/dri/card1" y más abajo comentamos la línea donde hace
drm_name[13] = '0' + num;

También podemos comentar el drmDropMaster() más abajo para que no nos diga "[ERROR] limited DRM rights on this screen"
(aunque funciona igual, vamos).

Y luego es simplemente:
switchres 1280 720 50 -s -k
(OJO!! -k hace los cambios permanentes!!)

...O bien compilando RetroArch con soporte para SwitchRes y luego configurando la resolución que queramos en:
Settings->Video->CRT SwitchRes

****************************Milkytracker en Linux****************************

Para evitar undefined symbols en tiempo de linkado, hacemos:

CFLAGS="-O2 -march=native -mtune=native -lasound" CXXFLAGS="-O2 -march=native -mtune=native -lasound" ./configure

***************************Menú XBM en RetroArch con carátulas, autolanzado de cores, etc...**********************************

OJO: Para tener el menú XMB funcionando con sus fuentes, mostrando iconos en lugar de cuadros negros. etc...

-Si no quieres shimmering en las letras del RGUI, tienes que irte a SETTINGS->USER INTERFACE->APPEARANCE
y activar LINEAR FILTERING.

-Tienes que habilitar el soporte para PNG (rpng) al configurar

-Necesitas los assets de aquí: https://github.com/libretro/retroarch-assets
De ese repo, copia los directorios xmb y ozone en el directorio de assets a ~/.config/retroarch/assets

-Si quieres que RetroArch te ofrezca con qué emulador quieres correr una ROM, tienes que clonar este repo:
git clone --depth 1 https://github.com/libretro/libretro-super.git
Y mandar el contenido del directorio libretro-super/dist/info a ~/.config/retroarch/cores. Sí, junto con los cores. Así:
cp -R libretro-super/dist/info/* ~/.config/retroarch/cores/
Ahora en RetroArch, en Settings->Core, desactiva "Cache core info files".
Y elimina ".config/retroarch/cores/core_info.cache".
(Si no haces estas últimas dos cosas, no funcionará, y no sabrás por qué).

-Para que el mando se autoconfigure (si es un mando conocido o compatible con uno conocido: la mayoría de ellos los reconoce como XBOX360 PAD)
tienes que clonar:
git clone --depth 1 https://github.com/libretro/retroarch-joypad-autoconfig.git
Y meter el directorio "udev" en ~/.config/retroarch/autoconfig/
Esto es imprescindible en consolas sin teclado, porque si no, no tienes manera de configurar el mando al arrancar el RetroArch al principio.

-Para poder tener las opciones de escanear directorios y tal, de modo que se nos creen las playlists que es lo que permite que al cargar una ROM
 se cargue automáticamente su core, tienes que activar libretrodb.
 Además, tienes que tener las databases de libretro, de manera que pueda comparar tus roms contra las de las databases.
 Así que te bajas las databases de este repo:
 clone --depth 1 https://github.com/libretro/libretro-database.git
 Copiamos el directorio "rdb" a "~/.config/retroarch/database" (quedará como ~/.config/retroarch/database/rdb)
 Ahora ya debería escanear las ROMS y sacártelas ordenadas por icono de sistema en la parte de arriba, pero si intentas lanzar una te dirá
 que "not cores found".
 Pues vale, nos vamos a settings->playlist, y ahí podemos asociar los playlists con cores,
 de tal manera que el playlist de NES cargue el nestopia, etc...
 Por CADA directorio de ROMs escaneado, XMB te va a crear una playlist, donde todas las ROMs de esa playlist se van a abrir con un determinado core. 
 Estas playlist son archivos.lpl que los crea al principio en ~/.config/RetroArch/playlists, pero tenemos el setting playlist_directory.
 Yo lo que he hecho ha sido configurar playlist_directory para que apunte a ~/retro/db/playlists, y ahí he metido las playlists que ya tenía, y ahí meterá XMB las nuevas
 que vaya creando.

-Si además quieres fotos de las carátulas, etc.. en las playlist, pues te bajas los thumbnails de aquí: https://thumbnails.libretro.com/
 Los mandas a donde quieras, hay que descomprimir el zip. y luego apuntas el setting thumbnails_directory a ese directorio. Por ejemplo, yo me creé ~/home/pi/retro/db/thumbnails,
o sea, mandé los thumbnails a un directorio bajo retro/db, y ahí dentro tengo Atari\ -\ 7800, etc...
Pues  pongo thumbnails_directory apuntando a ~/home/pi/retro/db/thumbnails. Así de sencillo. Lo puedes hacer desde el propio XMB en Settings > Directory

-Si quieres poner RA en autoarranque, ~/.profile es una buena opción.. PERO desactiva el autologin en la segunda TTY, o estarás lanzando dos instancias de RA
 y las cosas irán LENTAS.

-Para que se autoarranque, pero no se intente lanzar cuando entres por ssh, pon esto en .profile:

if [ -z "$SSH_TTY" ] ; then  
    cd retro
    ./retroarch-xmb -c cfg/xmb.cfg &> /dev/null && sudo poweroff
fi

-Si ves que al cargar varios juegos tienes errores de EGL, pon gpu_mem=256 en el config.txt

RETROARCH EN UN PC GENÉRICO SOBRE X11
=====================================

Dependencias previas:
sudo apt-get install libasound2-dev glslang-dev glslang-tools spirv-tools \
xcb libxcb-xkb-dev x11-xkb-utils libx11-xcb-dev libxkbcommon-x11-dev

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure --disable-ibxm --disable-vg --disable-sdl2 --disable-al --disable-cheevos --disable-ffmpeg \
--disable-networking --disable-netplaydiscovery --disable-libretrodb --enable-udev --disable-sdl --disable-pulse --disable-oss \
--disable-freetype --disable-7zip --disable-imageviewer --disable-rjpeg --disable-rbmp --disable-rtga --disable-flac \
--disable-qt --disable-materialui --disable-xmb --enable-rgui --disable-ozone --disable-gfx_widgets --disable-langextra \
--disable-cdrom --disable-accessibility --disable-tinyalsa --disable-rpiled \
--enable-opengl --enable-vulkan

Ahora ya compilamos:
make -j8 V=1
El V=1 es para ver las líneas de compilación y comprobar que nuestros flags se están usando, etc

Si quieres compilar en modo debug, haz:
make -j6 DEBUG=1 V=1
y se le pasará -O0 -g al compilador, y nada de -O2 ni -O2

COMPILAR CUALQUIER CORE DE LIBRETRO
===================================

CFLAGS="-march=native -mtune=native -fomit-frame-pointer -DALIGN_LONG" \
CXXFLAGS="-march=native -mtune=native -fomit-frame-pointer -DALIGN_LONG" make -j4

DESCARGAR CORES PRECOMPILADOS DE LIBRETRO
=========================================

http://buildbot.libretro.com/stable
http://buildbot.libretro.com/nightly

COMPILAR EL CORE MELONDS DE LIBRETRO
====================================

Clonamos su repo:

Configuramos con:

mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" -DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DENABLE_OPENGL=OFF

COMPILAR EL CORE HATARIB DE LIBRETRO
====================================

Clonamos su repo:

git clone --depth 1 https://github.com/bbbradsmith/hatariB.git

Compilamos esta línea de compilación (es así de larga porque por defecto intenta usar unas SDL2 y libzip que trae incluidas,
y en su lugar queremos que use las instaladas en el sistema):

CFLAGS="-march=native -mtune=native -fomit-frame-pointer" CXXFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
make MULTITHREAD= SDL2_INCLUDE=/usr/local/include/SDL2 SDL2_LINK=/usr/local/lib/libSDL2.so \
ZLIB_INCLUDE=/usr/include ZLIB_LINK=/usr/lib/aarch64-linux-gnu/libz.so

PARA QUE LA MÚSICA DE AMBERSTAR NO SUENE DESACOMPASADA, activa la opción CORE OPTIONS->ADVANCED->CYCLE-EXACT CACHE EMULATION.

NOTA: El Dungeon Master tarda muchísimo en cargar después de abrir la puerta. Usa la versión disponible aquí:
https://atari.8bitchip.info/ASTGA/D/dungmast.php

PARA INSTALAR JUEGOS EN DISCO DURO:
(Tienes muchos aquí: http://d-bug.me/, y aquí https://atari.8bitchip.info/fromhd3.php#DL)
Simplemente mete el juego en el directorio que quieras (ese directorio a su vez debes meterlo
en ~/.config/retroarch/hatarib/system para que el core lo vea), pon el tipo de disco duro como GEMDOS, y ya se puede acceder a él
tanto desde Atari TOS a partir de la 1.04, como desde EMUTOS, sin hacer nada más ni instalar drivers de disco ni nada.

Para que el juego se autoarranque, simplemente en el raíz del disco crea un directorio llamado AUTO y mete ahí el ejecutable del juego.
O sea, crearíamos amberstar/AUTO, y ahí copiaríamos amberstar/AMBRSTAR/AMBRSTAR.PRG.
Además, activamos la opción de "Boot hard disk" en las opciones del core.
OJO!!! Si el ejecutable es un .TOS, le cambiaremos el juego a .PRG para que se autoarranque, si se llama .TOS no se autoarrancará!!!
OJO!!! Ponle unos 4MB de RAM al equipo si no quieres que algunos de los juegos parpadeen durante el juego como el Amiga con el WHDLOAD con poca RAM.

PARA EL CAPTAIN BLOOD DESDE HDD:
-Usa la release de 42-Crew para copiarla al disco duro GEMDOS en el directorio que quieras.
Necesita la TOS 1.04 PAL como máximo: más que eso, revienta. Puedes usar versiones superiores de la TOS si son NTSC.

PARA EL DRAGONFLIGHT DESDE HDD:
-Usando la versión oficial HDD de: http://thalion.exotica.org.uk/games/dragonflight/st/dragonflight.zip
La debes copiar a un directorio que se llame E en el directorio raiz de la unidad GEMDOS.
O sea, que la puedes meter en ~/.config/retroarch/system/hatarib/dragonflight/E.
Y debes tener un floppy cualquiera metido en la disketera. No lo usa, pero debes tenerlo. Puedes crearte uno vacío con el HATARI (versión no Libretro).

COMPILAR EL CORE MUPEN64 DE LIBRETRO
====================================

Clonamos su repo:
git clone --depth 1 https://github.com/libretro/mupen64plus-libretro-nx.git

Compilamos como cualquier otro core pero poniendo la variable de entorno FORCE_GLES3=1, y las variables HAVE_PARALLEL_RSP=1 HAVE_PARALLEL_RDP=1 HAVE_THR_AL=1 para que nos compile el plugin ANGRYLION que es el que soporta Vulkan. O sea, así:
CFLAGS="-march=native -mtune=native -fomit-frame-pointer -DALIGN_LONG" CXXFLAGS="-march=native -mtune=native -fomit-frame-pointer -DALIGN_LONG" FORCE_GLES3=1 HAVE_PARALLEL_RSP=1 HAVE_PARALLEL_RDP=1 HAVE_THR_AL=1 make -j4

COMPILAR EL CORE DIRKSIMPLE (LASERDISC EN RETROARCH!!!)
=======================================================

Clonamos su repo:
git clone --depth 1 https://github.com/icculus/DirkSimple.git

Configuramos y compilamos con:

mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DDIRKSIMPLE_SDL_DEFAULT=OFF \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

Copiamos el core a la ruta habitual.
Copiamos el directorio "data" que queda en nuestro directorio de compilación a ~/.config/retroarch/system/DirkSimple/data, así:
mkdir ~/.config/retroarch/system/DirkSimple
cp -R data system/DirkSimple/

Si no tenemos el audio/vídeo del Dragon's Lair convertido a un solo archivo, podemos hacerlo con ffmpeg así:
ffmpeg -i lair.m2v -i lair.ogg -codec:v libtheora -qscale:v 7 -codec:a libvorbis -qscale:a 5 -pix_fmt yuv420p lair.ogv

Lanzamos el core con el Dragon's Lair así (el fichero de audio/vídeo se tiene que llamar lair.ogv para que el core sepa qué juego es
y cargue el LUA necesario!):

retroarch -L ~/.config/retroarch/cores/dirksimple_libretro.so lair.ogv

COMPILAR UNA VERSIÓN MÍNIMA DEL CORE FBALPHA CON DRIVERS DESHABILITADOS
===========================================================================

Lo primero, nos vamos a
cd src/burner/libretro

En Makefile.common, quitamos los directorios de la parte de FBNEO_BURN_DRIVERS_DIR. Busca la cadena snes y ahí ves qué tipo de líneas tienes que quitar.
No hace falta que quites los directorios de los includes, esos dan igual.

Editamos Makefile y dejamos la platform definition de la pi4 asi:

   else ifneq (,$(findstring rpi4,$(platform)))
      PLATFORM_DEFINES := -march=native -mtune=native -O2
   endif

Ahora hacemos un 
make platform=rpi3 generate-files
de manera que nos genere los headers sólo con los drivers que hemos dejado en el makefile.libretro_common,

y luego ya el 
make platform=rpi3 -j4
y listo. 

COMPILAR MEDNAFEN STANDALONE CON EMULACIÓN DE SATURN SOLAMENTE
==============================================================

-Bajamos los últimos sources estables de:
https://mednafen.github.io/releases/

-Configuramos con:

CFLAGS="-O2 -march=native -mtune=native" CXXFLAGS="-O2 -march=native -mtune=native" ./configure --disable-debugger \
--disable-apple2 --disable-gb --disable-gba --disable-lynx --disable-md --disable-nes --disable-ngp \
--disable-pce --disable-pce-fast --disable-pcfx --disable-psx --disable-sasplay --disable-sms --disable-snes --disable-snes-faust \
--disable-ssfplay --disable-vb --disable-wswan

--Ejecutamos por primera vez el emulador, y se nos creará ~/.mednafen/mednafen.cfg, lo editamos y ponemos
estos valores así (los vamos buscando y ajustando):

sound.device sexyal-literal-default
sound.buffer_time 32
video.fs 1
video.driver opengl
video.frameskip 0
ss.stretch aspect

CONFIGURAR BASH PARA TENER UN SALUDO Y LA IP AL INICIO
=======================================================

Al principio del todo de ~/.bashrc ponemos esto para evitar problemas con el saludo y el scp:
# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

Para añadir al PATH el diretorio actual, que no nos muestre todo el rato el usuario y el hostname,
y que nos muestre un mensaje de bienvenida y la IP añadimos en ~/.bashrc:
PATH=$PATH:.
PS1="\W "
MY_IP=$(ip -4 addr show wlan0 | grep -oP '(?<=inet\s)\d+(\.\d+){3}')

echo " ^_^    Welcome to Debian 11 GNU/Linux aarch64."
echo "(O,O)   Service management is done via SystemD."
echo "/)_)    This computer's local IP is $MY_IP"
echo " ¨ ¨    Have fun!"  
echo "     "

ERROR DE LANGUAGE DE PERL al acceder por ssh a una máquina
==========================================================

Esto ocurre porque la máquina desde la que accedemos exporta los settings de lenguaje a la máquina a la que estamos accediendo, y en esa no está instalado el 
soporte para el lenguaje que sea.
Para quitar los avisos de mierda de LANGUAGE de perl:

export LANGUAGE=en_US.UTF-8
export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
export LC_TYPE=en_US.UTF-8

en el .bashrc y listo. Si persiste, añadimos lo mismo a .bash_profile.

Localizar teléfono ANDROID
==========================

https://www.google.com/android/find/

Móviles Android, SONY walkman y dispositivos MTP que fallan al funcionar en modo MTP en Lubuntu como cámaras, etc
======================================================================================================

El problema es que el PCMANFM los automonta como MTP y no van bien. Para que los monte como MSC, es decir, como pendrives normales y corrientes, simplemente ELIMINA
o mueve a otro sitio /usr/lib/gvfs/gvfs-mtp-volume-monitor
Y el PCMANFM ya no toca los huevos.

Ahora pon el móvil en modo PTP (en los ajustes de la conexión USB) y debería ir. MTP es mierda. Se cambia en las opciones de desarrollador, en "modo USB predeterminado" o algo así.

También podrías usar jmtpfs para montarlos a mano desde la línea de comandos. Es muy fácil. Creas un punto de montaje, y se lo pasas a jmtpfs, sin nodo ni nada. Él sabe qué hacer.
jmtpfs ~/mnt

Instalar la versión que queramos de IOS desde Linux en Ipad/Ipod/la basura para retrasados que sea
==================================================================================================

Se usa un opensource que se llama idevicerestore. Tiene dependencias y mierdas varias, pero cuando lo instales puedes hacer estas cosas tan... estúpidas.

sudo idevicerestore iPad2\,5_9.3.3_13G34_Restore.ipsw

LA PESADILLA SYSTEMD: COMO LIBRARNOS DE ELLA
=============================================

Podemos simplemente hacer que fncione en modo sysvinit, que es lo bueno:
apt-get install sysvinit-core systemd-sysv-

Y para saber por qué coño se nos instaló SYSTEMD al actualizar, miramos las dependencias inversas:
apt-cache rdepends systemd --installed

GUÍA RÁPIDA PARA COMPILAR UN KERNEL REALTIME (TIEMPO REAL) EN LA RASPBERRY PI  (INSTRUCCIONES DE NOVIEMBRE DE 2017)
===================================================================================================================

NOTA: NO TIENE SENTIDO compilarte un kernel realtime si puedes aislar CPUs y ejecutar tareas en ellas (aunque sí sería interesante que esas CPUs
fueran además tickless: de ese modo tienes un desempeño similar a baremetal). Es mejor esa alternativa para asegurarte de que nada va a interrumpir
tu tarea.
Por otra parte, aumentar mucho los ticks del scheduler (Kernel features->Timer frequency) tampoco tiene sentido subirlos a 1000Hz
en un sistema para emuladores: eso es para escritorios, que NO ES LO MISMO! En un escritorio quieres responsividad y hay muchas tareas
a la vez que dan soporte a los programas (un navegador, correo electrónico, mensajería instantánea, programa de diseño, reproductor de música...
lo tienes TODO a la vez y quieres que todo tenga una respuesta buena).
EN UN SISTEMA EMULADOR ese no es el caso: tienes un proceso y se acabó. NO TIENE SENTIDO un scheduler repartiendo la CPU 1000 veces por segundo,
con 100 va que chuta. 
Si quieres elige 250 por aquello de la frecuencia de polling de los USBs, que con "usbhid.jspoll=1 xpad.cpoll=1" puedes leerlos a 1000 Hz, 
o porque para audio es algo mejor, PUES OLVÍDATE: NO TIENE SENTIDO: EL KERNEL CORRE SOBRE HRTIMERS, QUE SON TIMERS INTERNOS DE ALTA RESOLUCIÓN.
O sea que EL KERNEL NO CORRE SOBRE EL VALOR DE LOS HZ DEL SCHEDULER: ESTE VALOR SÓLO INFLUYE EN PROGRAMAS MULTITHREAD DONDE LOS THREADS
ESTÁN "ATADOS" A TIEMPO DE COMPUTACIÓN.
Así que, SÍ, PUEDES TENER UN KERNEL CON HZ_100 Y QUE A LA VER HAGA EL POLING DE LOS USBS A 200HZ (EL VALOR POR DEFECTO ES 120HZ, así que ni te molestes
con lo del polling rate de todos modos).

Tampoco te compliques con el modelo de preemption: el modelo CONFIG_PREEMPT es para escritorios de baja latencia, una vez más son muchos procesos
a la vez y quieres responsividad en todos ellos, que NO es nuestro caso. Así que CONFIG_PREEMPT_VOLUNTARY va bien, que es el valor por defecto.
Puedes usar si quieres el CONFIG_PREEMPT, que es el siguiente, y que pone que es para sistemas embedidos de baja latencia. Bueno, no nos va a aportar gran
cosa en nuestro caso.

Lo de CONFIG_PREEMPT y 250HZ NO INFLUYE en la latencia, ni en el desempeño ni en nada.
Si luego te quieres meter con CPU isolation (que es DISTINTO a que las CPUs sean tickless: las CPUs aisladas no tienen que ejecutar ticks del scheduler CUANDO NO CORRE NADA EN ELLAS,
si hay algo corriendo en varias CPUs aisladas, tienen que correr ticks del scheduler sí o sí) ya es cosa tuya, el ningún beneficio evidente es que los programas que se ejecutan en una CPU aislada
no se quedan sin CPU nunca por culpa de otros programas: combínalo con ejecutar las aplicaciones con "chrt -f 99", que le da prioridad realtime y no suelta la CPU
porque no hay otra aplicación a la que dársela con la misma prioridad (SCHED_FIFO). Luego hay SCHED_RR, que es con -r, y que genera más ticks del scheduler, así que nos conviene menos.

EL MEJOR hilo donde se habla de estas cosas es este:
https://github.com/raspberrypi/linux/issues/1216
Yo no he encontrado mejor convensación sobre este tema en internet jamás.

PERO SI AÚN ASÍ QUIERES UN KERNEL REALTIME (para emuladores fuera de las X como único proceso de usuario no tiene sentido, pero bueno), ESTOS SON
LOS PASOS (que te pueden venir bien para compilar un kernel sin más):

git clone --depth 1 https://github.com/raspberrypi/tools ~/tools

export KERNEL=kernel7
export ARCH=arm
echo PATH=\$PATH:~/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin >> ~/.bashrc
source ~/.bashrc
export CROSS_COMPILE=~/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin

git clone --depth=1 https://github.com/raspberrypi/linux

make bcm2709_defconfig

Necesitamos parchear dos cosas: lo del RT del kernel, y una movida de los USB que hace que si no el kernel RT se cuelgue aleatoriamente.
Pillamos los dos parches y los dejamos en el directorio previo al de los surces del kernel (CUIDADO: pilla el parche de RT que empieza por patch.*,
NO el que empieza por patches.*, porque fallará):

wget https://raw.githubusercontent.com/fedberry/kernel/master/usb-dwc_otg-fix-system-lockup-when-interrupts-are-threaded.patch
wget https://www.kernel.org/pub/linux/kernel/projects/rt/4.9/patch-4.9.47-rt37.patch.xz

Aplicamos ambos parches:
xzcat ../patch-4.9.33-rt23.patch.xz | patch -p1
patch -i ../usb-dwc_otg-fix-system-lockup-when-interrupts-are-threaded.patch -p1 --dry-run
patch -i ../usb-dwc_otg-fix-system-lockup-when-interrupts-are-threaded.patch -p1

KERNEL=kernel7
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2709_defconfig

Si quieres ajustar algo del kernel, ahora es el momento de hacer:
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig
Tenemos al menos que cambiar:
Kernel features->Preemption model->Fully preemptible kernel (RT)
Kernel features->Timer frequency->(lee las notas más arriba: depende de lo que necesites, 1000Hz para un sistema casi mono-proceso no tiene
ningún sentido).

make -j8 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage modules dtbs

La instalación ya te la miras en la guía de compilación oficial:
https://www.raspberrypi.org/documentation/linux/kernel/building.md
PERO ESO SÍ: RECOMIENDO COPIAR EL NUEVO KERNEL COMO "kernel7_rt.img" Y ARRANCAR OPCIONALMENTE DESDE ÉL PONIENDO
kernel=kernel-myconfig.img EN CONFIG.TXT, POR SI NO ARRANCA NUESTRO KERNEL RT.

KMSCON, EL EMULADOR DE TERMINAL PARA CONSOLA QUE USA KMS/DRM
============================================================

Instalamos una dependencia previa, libtsm (Debian no tiene ni tendra la version necesaria, ya que tiramos de forks para todo lo de kmscon):

-Clonamos su repo: git clone --depth 1 https://github.com/Aetf/libtsm.git

-Configuramos con:

cmake .. -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

VAMOS CON KMSCON EN SI:

-Clonamos su repo:
git clone --depth 1 https://github.com/Aetf/kmscon.git

-Configuramos con:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson .. -Dbuildtype=release -Dtests=false -Ddocs=disabled -Dvideo_fbdev=disabled

COMPILAR EL KERNEL CON FULL PREEMPTION Y BFS PARA LA RASPBERRY PI
=================================================================

INFO DE https://www.raspberrypi.org/documentation/linux/kernel/building.md COMPLETADA POR MÍ PARA EL TEMA DEL SCHEDULER

Clonamos el kernel, rama por defecto que ahora mismo es la 4.9:
git clone --depth=1 https://github.com/raspberrypi/linux

Yo estaba en ~/src/pi, así que lo tengo en ~/src/pi/linux
Sigo en ~/src/pi

Me bajaré los parches a ~/src/pi

Nos bajamos el parche BFS correspontiente para nuestro kernel de
http://ck.kolivas.org/patches/bfs

Nos bajamos el parche RT correspontiente para nuestro kernel de
https://www.kernel.org/pub/linux/kernel/projects/rt

Ahora aplico ambos parches. Entro en ~/src/pi/linux y hago:
patch -p1 < ../patch-4.4.9-rt17.patch
patch -p1 < ../4.4-sched-bfs-467.patch

Ahora ponemos en el path la ruta del crosscompilador:
PATH=$PATH:$HOME/tools/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/bin 
Ya deberíamos tener accesibles los binarios arm-linux-gnueabihf-

Ahora pillo la config por defecto para Pi2 y Pi3, que es la misma (estos pasos son de https://www.raspberrypi.org/documentation/linux/kernel/building.md):
KERNEL=kernel7
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2709_defconfig

Ahora, miramos http://ck.kolivas.org/patches/bfs/bfs-configuration-faq.txt y tratamos de cumplir las condiciones para mobile/netbook, o sea:
300 Hz
Tickless
Full preemption
CPU frequency scaling, ondemand default

Para ello entramos en menuconfig:
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig
Y vamos punto por punto:
-Lo de los HZ está en  KERNEL FEATURES->TIMER FREQUENCY
-Lo de Full Preemption está en KERNEL FEATURES->PREEMPTION MODEL
-Lo de Tickless está en GENERAL SETUP->TIMERS SUBSYSTEM->Timer tick handling
-Lo de CPU frequency scaling está en CPU POWER MANAGEMENT->CPU FREQUENCY SCALING
-Verifica que tienes activo el BFS en GENERAL SETUP, justo la PRIMERA opción que sale tras aplicar el parche.
 Una vez que ha arrancado el kernel, puedes comprobarlo del todo haciendo dmesg | grep scheduler y debería salir el BFS

-En menuconfig podemos quitar muchas cosas. Para saber cuáles son las mínimas mínimas para que funcione lo básico, mírate esto:
http://raspberrypi.stackexchange.com/questions/24092/kernel-config-necessary-options
EL DRIVER OTG (Synopsis DWC host support en DEVICE DRIVERS->USB SUPPORT) tiene que ir INCLUIDO, NO COMO MÓDULO, o el kernel no compilará.
EN FILESYSTEMS, deja tranquilo el AUTOMOUNT ese o systemd se quejará.

-Si quieres quitar el DEBUG_KERNEL, primero desactiva "Embedded system" en General Setup, y luego desactiva "Configure standard kernel features (expert users)"
que está un poco más arriba.
Ahora ya te puedes ir a "Kernel Hacking" y desactivar "Kernel debugging". Listo! 

Ahora compilamos:
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage modules dtbs -j8

Para instalar kernel, módulos y demás, sigue ya con: https://www.raspberrypi.org/documentation/linux/kernel/building.md

RIGEL ENGINE, Duke Nukem II en Linux
====================================

Clonamos su repo:

git clone --recurse-submodules --depth 1 https://github.com/lethal-guitar/RigelEngine.git

Creamos el directorio de compilación, configuramos y compilamos:
mkdir b4
cd b4

cmake -DUSE_GL_ES=ON -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" ..

SI QUEREMOS UNA VERSIÓN ESTABLE: Nos vamos a mirar los tags de su repositorio, que están en: https://github.com/lethal-guitar/RigelEngine/tags
Allí, buscamos la última release y nos quedamos con el nombre del tag de esa release.
Sabiendo eso, clonamos el tag de la release, e inicializamos los submódulos:
git clone --recurse-submodules --depth 1 --branch <nombre de la última release> https://github.com/lethal-guitar/RigelEngine.git

DEVILUTIONX, Diablo en Linux
============================

Dependencias previas:
sudo apt-get install libsodium-dev libbz2-dev --no-install-recommends

(OJO: EN DEBIAN 11 ESTO NO FUNCIONA AÚN PORQUE USA LIBSTORM 9.22).
Si quieres que los assets del juego (incluidos con los sources, son diferentes de los DATOS del juego, los datos los tienes que poner tú)
queden en un solo fichero llamado "devilutionx.mpq" en vez de en el directorio "assets",
tu distro debe usar una versión de smpq que use una libstorm superior a la versión 9.22 ya que libstorm 9.22 está rota en aarch64:
sudo apt-get install smpq --no-install-recommends

---Vamos con DevilutionX en sí:---

Bajamos la última estable de:
https://github.com/diasurgical/devilutionX/releases

Configuramos con:
cmake -DCMAKE_BUILD_TYPE=Release -DDEBUG=OFF \
-DASAN=OFF -DDISABLE_ZERO_TIER=ON -DBUILD_TESTING=OFF \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" ..

Compilamos y metemos en el directorio ~/diablo:
-El ejecutable "devilutionx"
-El diectorio "assets", que se nos crea en el directorio de compilación.
 En su lugar, podríamos usar "devilutionx.mpq" que se nos generaría en el directorio de compilación si hubiésemos instalado smpq
 en las dependencias previas, cosa que no podemos hacer en Debian 11 porque su smpq usa la versión de libstorm 9.22, que está rota
 en aarch64.
-El fichero de los datos del juego, que se llama "diabdat.mpq" y que tienes que conseguir por tu cuenta.

La primera vez que ejecutemos el juego, se creará el fichero de configuración en ~/.local/share/diasurgical/devilution/diablo.ini
Para saber más de su contenido, mira esto: https://github.com/diasurgical/devilutionX/wiki/DevilutionX-diablo.ini-configuration-guide

-Puedes poner Scaling Quality a 1, que es BILINEAR simplemente (viene a 2 que es anisotrópico).
-Puedes poner Buffer Size a 1024
-Si quieres que vaya a 16:9, pon "Fit to Screen=1"
(En 16:9 usa un 10% más de CPU, y upscaling es por hardware así que no usa nada de CPU extra).

Si nos da un error repetido de "Unhandled SDL Event: SDL_AUDIODEVICEADDED", ni caso. No es por el sistema sino porque el código del juego imprime eventos que no usa.
Manda la salida a /dev/null y fuera.

SM64EX, port del Mario64 para GNU/Linux
========================================

Clonamos los surces:
git clone --depth 1 https://github.com/AloUltraExt/sm64ex-alo.git

Editamos src/pc/gfx/gfx_sdl2.c y: 
-Añadimos SDL_WINDOW_FULLSCREEN_DESKTOP a los flags de SDL_CreateWindow()
-Añadimos "SDL_ShowCursor(SDL_DISABLE);" justo debajo de la llamada a SDL_CreateWindow()
-Comentamos la llamada a gfx_sdl_set_fullscreen() que hay justo debajo.

Editamos Makefile, y en la linea "OPT_FLAGS := -O2", añadimos "-march=native -mtune=native"
(Si compilas con TARGET_RPI=1 esto se hace solo, pero para el resto de sistemas tienes que añadirlo).

Hay que tener baserom.us.z64 en el directorio raiz.

Se compila asi:
make USE_GLES=1 HIGH_FPS_PC=1 RUMBLE_FEEDBACK=0 BETTERCAMERA=0 -j4

El ejecutable queda en build/us_pc/sm64.us.f3dex2e.arm

Le puedes tocar el tamaño de buffer de audio en src/pc/audio/audio_sdl.c, busca 32000 y a partir de ahí ves todo. Pero vamos, viene en 512, si lo tocas será para subirlo a 1024.

Las versiones más antiguas, como el sm64-ex original, piden algunas dependencias que sólo necesita en la máquina donde se extraen
los datos del juego, que puede ser un PC de escritorio y luego compilar en la Pi.
Si al compilar en la Pi te da errores con las tools que se hayan compilado antes en X86_64, haz todo esto:

rm tools/aifc_decode
rm tools/aiff_extract_codebook
rm tools/vadpcm_enc
rm tools/textconv
rm tools/skyconv
rm tools/n64graphics
rm tools/n64cksum
rm tools/audiofile/libaudiofile.a
make clean

Si aun así da error, borra el fichero con el que da error (el tool que da el error seguramente ya lo hayas borrado antes).

SM64-COOP, SUPER MARIO 64 COOPERATIVO EN GNU/LINUX
==================================================

Clonamos su repo:

git clone --depth 1 https://github.com/djoslin0/sm64ex-coop

Metemos la ROM en el directorio raiz de los sources como "baserom.us.z64"

Compilamos así:

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
make TARGET_RPI=1 DISCORD_SDK=0 -j4

----PARA HOSTEAR O CONECTARNOS A UNA PARTIDA----

Busca e instala, en Aurora Store, el "FWD PORT FORWARDER".
(Es totalmente opensource y está en github, solo que no está en FDRoid).

ZELDA OOT EN GNU/LINUX
======================

Clonamos el repo:
git clone --depth 1 --recurse-submodules https://github.com/HarbourMasters/Shipwright.git

---PARTE 1: EXTRACCIÓN DE LOS DATOS---

Dependencias previas:
sudo apt-get install libbz2-dev

Editamos CMakeLists.txt, buscamos "ImageMagick", y borramos toda esa sección entera.

Nos bajamos la ROM de No-Intro llamada "Legend of Zelda, The - Ocarina of Time (Europe) (GameCube).zip", extraemos la ROM del ZIP
y la copiamos a "OTRExporter/baserom.z64".
Ahora el raiz de los sources hacemos:

cmake -H. -Bbuild-cmake -GNinja \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_BUILD_TYPE=Release

Se nos habrá creado el directorio "build-cmake". Ahora seguimos con los siguientes pasos pasándole ese directorio a cmake:
cmake --build build-cmake --target ExtractAssets -j4
(Recuerda que tienes que tener un disco externo de swap o la compilación fallará).

---PARTE 2: COMPILACIÓN DEL ENGINE EN SÍ---

Editamos extern/CMakeLists.txt, y borramos la línea:
find_package(GLEW REQUIRED)
Y también borramos las ocurrencias de "GLEW::GLEW" que hay en las líneas debajo de esa.

Configuramos y compilamos con:
mkdir b4
cd b4

cmake .. -GNinja -DUSE_OPENGLES=1 \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_BUILD_TYPE=Release

-j2

(Con -j2 no hace falta disco de swap).
(Recuerda NO pasarle más de -j2, porque en la Pi5 fallará aunque le metas gigas y gigas de swap).

MAGIC CARPET 2 HD (antes remc2) en GNU/Linux
============================================

Instalamos dependencias previas:
sudo apt-get install libboost-system-dev libboost-dev --no-install-recommends

clonamos su repo:
git clone --depth 1 https://github.com/thobbsinteractive/magic-carpet-2-hd.git
git submodule update --init

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
cmake -DCMAKE_BUILD_TYPE=Release ..

Ahora crea ~/carpet2, y mete ahí:
-el ejecutable "remc2".
-el fichero "config.ini", que viene con los sources.
-el directorio "font" que viene con los sources. Está en "magic-carpet-2-hd/x64/Debug/font".

PARA INSTALAR LOS DATOS DEL JUEGO (NO NECESARIO YA QUE TIENES LOS DATOS PREPARADOS EN EL DISCO DURO DE BACKUP):
-Copia el directorio "NETHERW" de los datos del juego instalado a "~/carpet2/NETHERW"
(Es decir, los datos del juego deben estar en "~/carpet2/NETHERW").
-Crea el directorio "~/carpet2/CD_Files" y copia allí los contenidos de la ISO del CD original
PERO renombrando TODOS los archivos a mayúsculas.

FLARE, un engine RPG libre en GNU/Linux
=======================================

Clonamos el repo del engine y del juego:
git clone --depth 1 https://github.com/flareteam/flare-engine.git
git clone --depth 1 https://github.com/flareteam/flare-game.git

creamos el directorio de compilación, entramos en él, configuramos y compilamos:
mkdir b4
cd b4
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native" ..
make -j4

creamos ~/flare y mandamos el ejecutable flare allí.

entramos en flare-game, copiamos el mod default de flare-engine al directorio de mods de flare-game, y copiamos el directorio mods a ~/flare
cd flare-game
cp -R ../flare-engine/mods/default mods/
cp -R mods ~/flare

Ahora ya podemos ejecutar el juego y activar la campaña.

EXULT, Ultima VII en GNU/Linux
==============================

Cosas que debemos instalar previamente:
sudo apt-get install autoconf automake libtool

Clonamos

git clone --depth 1 https://github.com/exult/exult.git

---MODIFICACIONES AL CÓDIGO

Editamos exult.cc, comentamos la línea
std::atexit(SDL_Quit);
Y añadimos SDL_Quit() al final de la función Play(), antes del return(0).

---CONFIGURACIÓN DEL CÓDIGO

Ejecutamos el autogen.sh

Configuramos con:

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure --disable-all-hq-scalers --disable-nxbr --disable-tools \
--disable-timidity-midi --disable-alsa --disable-sdl-parachute \
--enable-lto --with-optimization=normal --prefix=$HOME/ultima7

PODRÍAS PONER --with-optimization=heavy EN LUGAR DE --with-optimization=normal, PERO ESO CAUSA SEGFAULTS A VECES.

Compilamos con make -j4

---INSTALACIÓN DEL JUEGO

Hacemos:
make install
...Esto creará:
~/ultima7/bin, donde la instalación que acabamos de hacer mete el ejecutable "exult" y el fichero "exult.cfg",
~/ultima7/share, donde la instalación que acabamos de hacer meterá unas cosas, y nosotros meteremos a mano los datos del juego,
siguiendo las instrucciones a continuación.

Creamos el directorio ~/ultima7/share/exult/forgeofvirtue
Copiamos los directorios "static" y "gamedat" de nuestra instalación de Ultima 7 a ~/ultima7/share/exult/forgeofvirtue

Para tener música y efectos de sonido, bájate el ZIP all-in-one de aquí:
http://exult.sourceforge.net/download.php
Y simplemente mete los contenidos del zip en ~/ultima7/share/exult, ahí a saco sin más. No hay que añadir nada en el CFG, va solo con lo que tienes.

La pantalla lo mejor es dejarla así:
Full Screen: Enabled
Display Mode: 1280x720 (<---Suponiendo que tengas el sistema a 720p!! Si no, usa la resolución que uses en el sistema).
Scaler: Interlaced
Scaling: 2x
Game Area: Auto
Fill Quality: Point
Fill Mode: Fit
AR Correction: Disabled

Y listo!

LOVE2D en GNU/Linux (love)
==========================

Bajamos los últimos source estables de:
https://github.com/love2d/love/releases

Satisfacemos algunas dependencias.
sudo apt-get install --no-install-recommends libmodplug-dev libphysfs-dev libtheora-dev libmpg123-dev libluajit-5.1-dev luajit

La otra dependencia es OpenAL (tienes instrucciones para compilarlas e instalarlas).

Configuramos love con:
cmake -DCMAKE_C_FLAGS="-march=native -mtune=native -O2" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2" ..

Instala copiando el ejecutable love donde quieras.

INSTALAR JACKD2 GNU/LINUX
=========================
FUENTES: http://jrigg.co.uk/linuxaudio/jack2debian7.html
		 http://jackaudio.org/faq/linux_rt_config.html

NO debes usar el gestor de paquetes para esto, porque la versión de libjack, jackd2, etc.. que trae Debian
está compilada con soporte para basuras varias, como X11 o DBUS.
Así que toda compilar a instalar la nuestra:
Bajamos los últimos sources estables de: https://github.com/jackaudio/jack2/releases
cd jack2
./waf configure --alsa --prefix=/usr
./waf -j4
sudo ./waf install
Instala tanto las librerías, como los las headers para desarrollo, como jackd.

Ahora añadimos el overlay que permite que el audio i2s funcione con mmap de verdad:
dtoverlay=i2s-mmap
(Esto es si estás usando una tarjeta de audio conectada por i2s, como la hifiberry)

Ahora añadimos mi usuario al grupo audio (probablemente ya esté):

sudo adduser pi audio

Y editamos /etc/security/limits.conf, añadiendo unas cosillas para quitar ciertas limitaciones a los miembros de ese grupo:
@audio   -  rtprio     99
@audio   -  memlock    unlimited

Comprobamos que tenemos quitados esos límites con:
ulimit -r -l
Nos tiene que salir algo como:
real-time priority (-r) 99
max locked memory (kbytes, -l) unlimited
¡¡¡CUIDADO!!!! COMPRUEBA ESTO EN LOCAL Y NO POR SSH, porque POR SSH PUEDE NO FUNCIONAR Y SÍ EN LOCAL.
En el caso de DROPBEAR, que es el servidor SSH que usamos nosotros, NO ESTÁ LINKADO con libpam, así que 
LOS SETTINGS DE limits.conf son directamente IGNORADOS SI NOS CONECTAMOS POR SSH si usas dropbear.

Puedes lanzar jackd a mano para que empieze a escuchar con:
jackd -R -P 70 -d alsa -r 48000 -n 2 -p 1024

--BLOQUE ERROR RECALCITRANTE--
SI TE DA UN ERROR COMO ESTE:
Cannot bind server to socket err = No such file or directory
Server channel open error
JackServer::Open failed with -1
..:SIGNIFICA QUE TE FALTA /dev/shm, ASÍ QUE DEBERÍAS TENER ESTO EN EL CUSTOM INIT SCRIPT QUE LEVANTA TU SISTEMA:

mkdir /dev/shm
mount -t tmpfs tmpfs /dev/shm
--FIN BLOQUE ERROR RECALCITRANTE--

También puedes lanzar retroarch compilado con soporte para jack y funciona muy bien, con una latencia por defecto de 21ms
que hasta donde yo sé no se puede cambiar porque la opción de la latencia de audio no hace nada, siempre son 21ms (lo dice retroarch al iniciarse
si no has silenciado todos los mensajes).
Y aunque la pudieras bajar da igual porque la latencia de audio que tienes viene dada por dispmanx, o sea, viene del vídeo, no se puede bajar más.
Con esos 21ms hay algo de cracking, así que mejor nos quedamos con el driver ALSA y ya.

UN SCRIPT PARA DETECTAR SI ESTAMOS EN UNA RPI
=============================================

if grep -q BCM2708 /proc/cpuinfo; then
        echo "Estamos en una Raspberry Pi"
fi

INSTALAR GCC 6.3 USANDO LOS REPOS DE STRETCH EN JESSIE (RASPBIAN)
================================================================

Actualizamos la lista de paquetes y los paquetes, estando aún en jessie:
sudo apt-get update
sudo apt-get upgrade

Cambiamos jessie por stretch en 
sudo vim /etc/apt/sources.list

Actualizamos la lista de paquetes a la de stretch:
sudo apt-get update

Instalamos gcc 6:
sudo apt-get install gcc-6 g++-6

Desisntalamos gcc 4.x:
sudo apt-get purge 4.9

Volvemos a poner jessie donde estaba stretch, y actualizamos a los índices de jessie:
sudo vim /etc/apt/sources.list
sudo apt-get update

TWIN, el gestor de ventanas para TTY
=============================

Clonamos su repo de:
https://github.com/cosmos72/twin

Instalamos esta dependencia previa si queremos ratón en la consola:
sudo apt-get install gpm libgpm-dev --no-install-recommends

Configuramos e instalamos:
CFLAGS="-O2 -march=native -mtune=native -O2" \
CXXFLAGS="-O2 -march=native -mtune=native -O2" \
./configure --prefix=/usr --enable-hw-tty=yes  --enable-hw-x11=no 
make -j4
sudo make install

Se activa el menú para moverse por él con el teclado con F12.

HEROES OF MIGHT AND MAGIC II (fheroes2) en Linux
================================================

Bajamos la última estable de:
https://github.com/ihhub/fheroes2/releases

Compilamos con:

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
WITHOUT_AUDIOCD=1 WITHOUT_XML=1 make -j4

SI TIENES MOVIMIENTO ERRÁTICO DEL RATÓN: Desconecta el mando USB.

PARA INSTALAR EL JUEGO CON SUS DATOS POR PRIMERA VEZ:
Creamos ~/heroes2
Copiamos el ejecutable a ~/heroes2
Copiamos el directorio files que viene con los sources a ~/heroes2, quedando ~/heroes2/files
Copiamos el archivo heroes2.key que viene con los sources a ~/heroes2
Copiamos los directorios DATA, MAPS, y ANIM de una instalación del Heroes 2 a ~/heroes2
(Los nombres de los directorios pueden estar en mayusculas o en minusculas, da igual eso).
Copiamos los .ogg que vienen en MUSIC de una instalación del Heroes 2 de GOG a ~/heroes2/music (los de GOG vienen desordenados,
ya que van de 01 a 42 y deberían ir de 02 a 43! Es sólo moverlas una posición adelante todas al renombrarlas, que tienes que renombrarlas a Track02.ogg, Track03.ogg, etc).
(No hace falta que les cambies el nombre ni nada, con que lleven en el nombre el número de pista, le vale).

El fichero de configuración es ~/.config/fheroes2/fheroes2.cfg
Se genera cuando ejecutas el engine por primera vez.
Ahí puedes ponerlo a pantalla completa, activar el vsync, hacer que no salga la cutre-intro con "show game intro = off", etc.

INSTALAR OPENAL en GNU/Linux
============================

Bajamos la última release de: https://github.com/kcat/openal-soft/releases
(Busca la última release en sí, no lo que pone "makemhr...").

Configuramos así:
cmake -DCMAKE_BUILD_TYPE=Release -DALSOFT_BACKEND_OSS=OFF -DALSOFT_REQUIRE_PIPEWIRE=OFF \
-DALSOFT_BACKEND_WAVE=OFF -DALSOFT_BACKEND_PORTAUDIO=OFF -DALSOFT_EXAMPLES=OFF \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" ..

STUNT CAR RACER EN GNU/LINUX
============================

Instalamos una dependencia previa (a parte de openal, justo encima lo tienes):
sudo apt-get install libglm-dev

Clonamos el repo de 
git clone --depth 1 https://github.com/ptitSeb/stuntcarremake.git

Editamos StuntCarRacer.cpp, y debajo de la llamada a "SDL_SetWindowTitle", añadimos:
SDL_GL_SetSwapInterval(1);

Editamos dx_linux.cpp, y justo antes de la línea:
glTexSubImage2D(GL_TEXTURE_2D, 0, j*m_fontsize, i*m_fontsize, surf->w, (surf->h>=m_fontsize)?m_fontsize-1:surf->h, GL_RGBA, GL_UNSIGNED_BYTE, surf->pixels);
...Añadimos:
glPixelStorei(GL_UNPACK_ROW_LENGTH, surf->pitch / surf->format->BytesPerPixel);

Editamos Makefile, y dejamos la línea:
LIB += -lGL -lGLU
como:
LIB += -lOpenGL

Compilamos con:
FLAGS="-march=native -mtune=native -O2" make -j4 LINUX=1 SDL=2 DEBUG=0

Creamos el directorio ~/stunt, y allí metemos el ejecutable "stuntcarracer", el archivo "DejaVuSans-Bold.ttf",
y los directorios "Bitmap", "Tracks", y "Sounds" que vienen con los sources.

Ejecutamos con:
stuntcarracer -f -d -n
..Donde "-f" es para pantalla completa, "-d" para usar la resolución actual, y "-n" para desactivar el MSAA.

ELDRITCH en GNU/LINUX
=====================

Clonamos su repo:
git clone --depth 1 https://github.com/ptitSeb/Eldritch.git

Creamos el directorio de compilación, entramos, configuramos y compilamos:
mkdir Code/b4
cd Code/b4
cmake -DGLES=ON -DWITH_SDL2=on -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" ..
make -j4

Para instalar el juego:
-Copia b4/Projects/Eld/Eld a ~/eldritch
-Copia los datos del juego (que los tienes ya preparados en el disco duro de backup) junto con el ejecutable.

SI TIENES QUE PRERARAR DE NUEVO LOS DATOS DEL JUEGO...(COSA QUE NO DEBERÍA PASAR)
Para preparar los datos del juego, tenemos que obtener el directorio Config, que tiene unos archivos .ccf dentro.
-Bájate la versión "Eldritch Reanimated 406". Instálala, y copia los archivos eldritch*.cpk a ~/eldritch. Todos.
-Cópiate eldritch-base.cpk a algún directorio de trabajo junto con la herramienta FilePacker.exe, que viene incluida con los sources
 en Eldritch/Projects/Eld/Tools/unpack.
 Descomprime eldritch-base.cpk así: wine FilePacker.exe -u eldritch-base.cpk
 Obtendrás los directorios Config, Fonts, Misc, y Shaders. Copia el directorio Config (SÓLO ESE) a ~/eldritch, junto con el ejecutable del juego.

OTRAS NOTAS 
CUIDADO porque este juego carga manualmente libSDL2.so en Code/Libraries/SoLoud/src/backend/sdl/soloud_sdl_dll.c,
en la función openDLL(). Así que si no arranca, fíjate que tu libSDL2.so (que es un link simbólico) esté apuntando
a una librería que realmente exista en el sistema (a veces hay lio con esto porque en Lubuntu desinstalas malamente
las SDL2 que vienen e instalas las tuyas para desarrollo, etc).

GZDOOM en la Raspberry Pi 5
===========================

-Primero, necesita OpenAL. Tienes las instrucciones de instalación en este documento.

-Segundo, necesita ZMUSIC. Vamos con ZMUSIC pues:
Instala libmpg123-dev y libvorbis-dev.
Descarla los últimos sources estables de:
https://github.com/coelckers/ZMusic/releases

Creamos el directorio de compilación, entramos y configuramos, compilamos e instalamos:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native"
make -j4
sudo make install

Vamos a por GZDoom en sí.
Instalamos dependencias previas: apt-get install libvpx-dev libwebp-dev --no-install-recommends

git clone --depth 1 https://github.com/ZDoom/gzdoom.git

Configuramos con:

cmake -DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_BUILD_TYPE=Release -DVULKAN_USE_XLIB=OFF -DVULKAN_USE_WAYLAND=ON ..

Tenemos que copiar, al directorio de ~/doom:
gzdoom
*.pk3
soundfonts

Yo lanzo doom así:
./gzdoom -iwad doom.wad -file doom1music.wad smoothed.wad blackops.wad

NOTA: Por defecto, va en GLES aunque le pongas Vulkan en las opciones (fallará al inicializar Vulkan).
Si te empeñas en que funcione sobre OpenGL en la Pi, puedes hacer:
MESA_GL_VERSION_OVERRIDE=3.3 MESA_GLSL_VERSION_OVERRIDE=330 ./gzdoom
...PERO va muy lento.

Si quieres un shader CRT, puedes usar este:
https://github.com/jorisvddonk/GZDoom_CRTShader
Se baja como ZIP (desde el propio github, dándole a CODE->DOWNLOAD ZIP)
y se carga el .zip directamente con "-file" como cualquier otro PWAD.

También podrías usar este, que tiene un link con la última versión en .PK3 y se carga igual:
https://github.com/dron12261games/MOD-VHS-CRT-Shader-by-DRON12261

LOS SHADERS NO VAN EN LA PI5 PORQUE LE FALTA UNA EXTENSIÓN DE VULKAN Y SÓLO VA EN MODO GLES,
Y LOS SHADERS SÓLO VAN EN MODO OPENGL Y EN MODO VULKAN.
Le falta la extensión "multiDrawIndirect" que es comprobada en la función "VulkanDeviceBuilder::FindDevices", aquí:
https://github.com/ZDoom/gzdoom/blob/f369cd7f6d8c4e6dc339e51d645f410c8fc897e2/libraries/ZVulkan/src/vulkanbuilders.cpp#L1833

NETHACK EN GNU/LINUX
====================

Se instala con:

sudo apt-get install nethack-common

Ahora creamos el fichero ~/.nethackrc con el contenido:
OPTIONS=name:Manuel
OPTIONS=number_pad:1

Eso es para que el jugador se llame Manuel, y que se use el numpad para jugar con diagonales y todo: las flechas no se deben usar
porque Nethack necesita que nos movamos en diagonal (o se gasta comida innecesariamente y no se puede ganar).

Para salir del juego, pulsa #, escribe quit, y dale al intro.

DUNGEON CRAWL STONE EN GNU/LINUX
================================

Instalamos una dependencias previas (se puede compilar contra LUA o contra LUA-JIT, que es más rápido en la Pi):
sudo apt-get install libluajit-5.1-dev python3-yaml

Clonamos su repo (no se puede compilar desde release por el tema de las dependencias incluidas que lleva como submódulos):
git clone --depth 1 https://github.com/crawl/crawl.git
git submodule update --init

Descomprimimos y nos vamos al directorio crawl-ref/source, y compilamos con:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
make -j4 TILES=y LUAJIT=y

Ahora creamos el directorio ~/crawl, y metemos allí el ejecutable "crawl"
Ahora copiamos el directorio "dat" que viene dentro de "sources" a ~/crawl

BARONY, UN DUNGEON CRAWLER 3D OPENSOURCE PARA LINUX
====================================================

Clonamos su repo o pillamos la última estable de:
https://github.com/TurningWheel/Barony

Instalamos una dependencia adicional que tiene:
sudo apt-get install libphysfs-dev rapidjson-dev --no-install-recommends

Editamos src/main.hpp y quitamos
#include <GL/glu.h>

Editamos CMakeLists.txt y cambiamos la línea
find_package(OpenGL REQUIRED)
que está debajo de 
ELSE (APPLE)
por esto:
	find_package(OpenGL QUIET)
	if(OpenGL_FOUND)
		message(STATUS "Using OpenGL GLX for OpenGL")
	else(OpenGL_FOUND)
		# If we couldn't find old GLX package, try to use modern libglvnd libOpenGL.so instead.
		message(STATUS "Using GLVND for OpenGL")
		FIND_LIBRARY(OpenGL_LIBRARY OpenGL)
		SET(EXTRA_LIBS ${OpenGL_LIBRARY})
    endif(OpenGL_FOUND)

Configuramos y compilamos con:
mkdir b4
cd b4
EDITOR_ENABLED=0 cmake -DCMAKE_BUILD_TYPE=Release -Wno-dev \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DFMOD_ENABLED=OFF -DOPENAL_ENABLED=ON  ..
make -j4

CSBWin, UN PORT DEL DUNGEON MASTER DE ATARI ST PARA LINUX
=========================================================

Esto lo lleva sin github Paul Stevens:
prsteven@facstaff.wisc.edu

Bajamos los últimos sources estables de aquí:
http://dianneandpaul.net/CSBwin/
Son los ficheros con nombre CSBwin_SRC_*, baja el de fecha más reciente.

Tiene un Makefile que se llama makefile, en minúsculas.

Editamos LinCSBUI.cpp y:
-Hacemos que la función LIN_PlaySound retorne SDL_TRUE (MUY importante, porque si no da un segfault al entrar en la mazmorra)
-Añadimos, antes de RenderCopy(), SDL_RenderClear(sdlRenderer);
Editamos CSBlinux.cpp y:
-Añadimos SDL_RENDERER_PRESENTVSYNC a los flags de SDL_CreateRenderer()
-Añadimos 
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
 antes de SDL_CreateWindow()

Editamos makefile y añadimos en el options de "ifeq ($(target), Ubuntu_SDL20)"
-O2 -march=native -mtune=native -O2

Compilamos con:
make target=Ubuntu_SDL20 -j4

Necesitamos los ficheros:
dungeon.dat
graphics.dat
..que los podemos bajar de alguna release compilada de http://dianneandpaul.net/CSBwin/

Ejecutamos con:
./CSBwin --fullscreen

CRISPY DOOM / CRISPY HERETIC
============================

Primero instalamos una dependencia suya para que pre-convierta TODOS los efectos de sonido y así el juego no pegue tirones:
sudo apt-get install --no-install-recommends libsamplerate0-dev

Nos bajamos la última estable de:
https://github.com/fabiangreffrath/crispy-doom/releases

Compilamos con CMAKE:
mkdir b4
cd b4

cmake -DCMAKE_C_FLAGS="-march=native -mtune=native -fsigned-char" \
-DCMAKE_BUILD_TYPE=Release ..

make -j4

El fichero de configuración está en ~/.local/share/crispy-doom/crispy-doom.cfg

PARA QUE LOS GRÁFICOS DEL HEXEN EN MODO WIDESCREEN NO SE CORTEN POR LOS LADOS:

Tenemos que cargar un WAD con los gráficos en widescreen. El único que he visto que funciona es wad que hay en "hexwide.zip" de este hilo:
https://github.com/fabiangreffrath/crispy-doom/issues/859
O sea que hacemos: ./crispy-hexen -iwad hexen.wad -file hexen_wide.wad hexen_music.wad
(O metemos hexen_wide.wad y hexen_music.wad en autoload/hexen.wad/, que los carga igual al inicio sin pasar ningún parámetro).

PARA TENER PANTALLAS DEL TÍTULO QUE OCUPEN TODA LA PANTALLA EN MODO WIDESCREEN:

Tenemos que cargar un WAD con esos gráficos en widescreen, lo que se llama "widescreen assets".
En Hexen NO es necesario porque lo hemos arreglado con lo de la sección anterior.
Para Doom, Doom2, Sigil, Heretic, etc... usamos los que vienen en el zip del primer post de este hilo: https://www.doomworld.com/forum/topic/121385-widescreen-assets-pack-and-appreciation-thread/

PARA TENER MÚSICA DIGITAL

OPCIÓN 1 (RECOMENDADA):
Simplemente usamos estos WADs ya preparados:
https://zandronum.com/forum/viewtopic.php?t=97
Se los pasamos con el parámetro "-file", por ejemplo:
./crispy-heretic -iwad heretic.wad -file heretic_music.wad

También podríamos meter en un WAD, tal cual sin directorios, los FLAC o los OGG que queramos,
PERO MUY IMPORTANTE, SIN EXTENSIÓN, en plan "E1M3" sin más.
Le puedes quitar la extensión OGG a todos los archivos de un directorio con:
find -type f -name '*.ogg' | while read f; do mv "$f" "${f%.ogg}"; done
Ahora los metes en un WAD (con SLADE en Linux vale para crear WADs)
Y le pasamos ese WAD con -file así:
./crispy-heretic -file heretic-music.wad

OPCIÓN 2: En ficheros sueltos. Nos bajamos un pack (de OGG, de FLAC o de lo que queramos y SDL_Mixer() tenga soporte para reproducir)
y lo mandamos, por ejemplo, a ~/heretic/heretic-music, dejando ahí los OGG o los FLAC tirados sin más.
Ahora editamos ~/.local/share/crispy-doom/crispy-heretic.cfg y en el setting music_pack_path ponemos el path: "/home/pi/heretic/heretic-music"
(O el que sea, vamos).
Vengo usando estas músicas, que están en OGG directamente para bajar:
https://zandronum.com/forum/viewtopic.php?t=97

PARA TENER MÚSICA GUS (COMO CURIOSIDAD: ES MEJOR MÚSICA DIGITAL), tenemos que tener SDL2-mixer compilado con soporte de Timidity,
y en crispy-heretic.ini ponemos la ruta de los patches que vienen en el directorio "base":

gus_patch_path = "/root/heretic/base/gus_patches"

AL LANZAR EL JUEGO, FÍJATE BIEN QUE AL PRINCIPIO DIGA: "Pre-caching all sounds..."

MONITORIZAR ACCESO A FICHEROS EN GNU/LINUX
===========================================

Instalamos inotify-tools si no las tienes:

sudo apt-get install inotify-tools

Y ahora, si queremos ver todos los accesos a archivos de $HOME, por ejemplo...:
inotifywait -r -m $HOME

Otra alternativa es iotop
sudo apt-get install iotop

Nos permite ver cuánto se ha escrito en disco, estadísticas después de dejarlo correr minutos u horas, etc:
iotop -oPa

XASH3D, ENGINE DE HALF LIFE EN GNU/LINUX
========================================

Clonamos el repo de:
git clone --depth 1 https://github.com/FWGS/xash3d.git

cd source
Editamos el Makefile.linux y ponemos la línea XASH_X11 ?= 1 a 0, así:
XASH_X11 ?= 0
Ahora compilamos:
make -f Makefile.linux NANO_GL=1 XASH_VGUI=0 -j4

OpenDUNE
=========

Empezamos con los sources del munt (emulador de mt32):
Clonamos de:
https://github.com/munt/munt.git

Ahora entramos en munt/

Ahora, vamos a por el OpenDUNE en sí.
Bajamos los últimos sources de:
https://github.com/OpenDUNE/OpenDUNE.git

Configuramos con:
./configure --with-asound --without-oss --without-pulse --with-sdl2 --with-munt

NOTAS TIMIDITY
==============

Para inicializarlo y que suenen a ritmo las percusiones, necesitamos los buffers más pequeños posibles, para lo que hacemos:

timidity -iA -B 4,8

Su fichero de configuración, donde le especificamos el soundfont, está en /etc/timidity++/timidity.cfg
Ahí le podemos pasar, o bien un cfg y una ruta:

dir /usr/share/timidity/freepats
source /etc/timidity++/freepats/freepats.cfg

...O bien un sounfont:

soundfont /usr/share/soundfonts/FluidR3_GM2-2.sf2

Para fluidsynth haríamos algo como:

sudo fluidsynth --audio-driver=alsa -s Downloads/WeedsGM3.sf2

INSTALAR VARIOS SISTEMAS OPERATIVOS EN LA RASPBERRY PI SIN DHCP, USANDO IP ESTÁTICA
===================================================================================

Usamos NOOBS (nos vale tanto la version light esa como la completa) pero hacemos algunas modificaciones a capón.
Arrancamos el NOOBS este y nos vamos a la consola TTY2 con CTRL+ALT+F2
Nos logueamos con root/raspberry

killall recovery

Tendremos disponible el vi, no el vim, pero nos vale.
Hacemos
		ip addr add 192.168.5.8/24 dev eth0
		ip route add default via 192.168.5.7	
Dejamos /etc/resolv.conf como:
		nameserver 8.8.8.8
Pingamos a google a ver si va.
Si tira, hacemos:

/usr/bin/recovery –qws

Listo! Nos dirá no sé qué de un sistema de settings corruptos: ni puto caso.

Para modificar el cmdline.txt o el config.txt, tienes que usar shift en el menú de arranque NOOBS, y te saldrán opciones para modificar
los ficheros de configuración de cada SO instalado. Así es como se overclockea la CPU y tal.

Para modificar el órden en que aparecen los OSes en el menú de arranque, editamos  installed_os.json que está en la partición SETTINGS, 
que en mi caso es /dev/mmcblk0p5

Para modificar el SO que arranca por defecto, editamos noobs.conf que está en una de las particiones, la llamada SETTINGS. En mi caso es /dev/mmcblk0p5
La monto desde la Pi por ssh:
sudo mount /dev/mmcblk0p5 /mnt/hdd
Y hago lo que tengo que hacer. ¡¡OJO: DESDE EL PC NO DEJA GUARDAR ESTE ARCHIVO CON SUS CAMBIOS!!
Podemos ver qué sistema arranca de qué partición consultando installed_os.json en ese misma partición. 

PARA PASAR un rootfs de Linux desde otra tarjeta, usa "rsync -av --progress <dir_orígen>/* <dir_destino>", NO USES CP -R QUE LA LIAS CON LOS PROPIETARIOS!!

COPIA DE SEGURIDAD DE UN ROOTFS, COMO EN TIEMPOS DE GENTOO!
===========================================================

Un poco de revival del 2004... Para sacar un tar del rootfs, estando en él y dejando fuera algunos directorios grandes:

sudo tar -cvpf ~/pi/cea0b7ae-2fbc-4f01-8884-3cb5884c8bb7.tar * --exclude=proc/* --exclude=sys/* --exclude=dev/pts/* --exclude=home/pi/scummvm/* --exclude=home/pi/retro/* --exclude=home/pi/src/*

Ahora, para descomprimirlo en una partición de una SD:

sudo tar -xvf cea0b7ae-2fbc-4f01-8884-3cb5884c8bb7.tar -C /media/manuel/root/

ARRANCAR LA RASPBERRY PI CON VÍDEO KMS
=======================================

Simplemente añadimos esta línea a config.txt:

dtoverlay=vc4-kms-v3d

Luego, instalamos libdrm-dev, y copiamos /usr/include/libdrm a /usr/include/drm, para que las cabeceras las encuentren bien los ejemplos (no se arregla pasando -I<ruta> ya
que depende de cabeceras que no son nuestras y en las que vienen mal las rutas), y la podemos hacer funcionar mi ejemplo 2D-KMS de atomix pageflipping.

Tenemos que instalar:
libgl1-mesa-dev
libdrm-dev
libgbm-dev
libgles2-mesa-dev

sudo apt-get install libgl1-mesa-dev libdrm-dev libgbm-dev libgles2-mesa-dev

..y el KMSCUBE original de robclark, tras añadir VC4 a la lista de drivers, tira perfectamente.

CARGAR TAP DE SPECTRUM DESDE LINUX
====================================

Lo primero cargamos el OSS:

sudo modprobe snd-pcm-oss
sudo modprobe snd_hda_intel

Ahora buscamos los sources del "playtap", tal cual, compilamos con el Makefile.linux, y hacemos
./playtap juego.tap 

Justo cuando empiece a sonar bajamos el sonido con el control de volúmen normal, como a 3/4 que si no suena muy alto y falla.

CÓMO LOGUEARSE AL SVN DE RETROGURU Y CLONAR REPOS, Y LUEGO GUARDAR LOS CAMBIOS QUE HAGAS
==============================================================================================

Lo primero es autentificarse, sólo hay que hacerlo la primera vez:
(El password es uno de los típicos que usas, tiene letras y números)
cvs -d:pserver:vanfanel@sun.hasenbraten.de:/usr/src/cvs login
El pass es: Manuel22

Y luego ya clonar el proyecto giana, por ejemplo:
cvs -d:pserver:vanfanel@sun.hasenbraten.de:/usr/src/cvs checkout giana

Una vez hechos los cambios, metemos los nuevos ficheros con
cvs add <nombre_fichero>

Si tenemos nuevos ficheros, directorios, etc, hacemos estos dos pasos porque CVS es muy espartano con esto, no hay equivalente a "git add ."
find . -type d \! -name CVS -exec cvs add '{}' \;
find . \( -type d -name CVS -prune \) -o \( -type f -exec cvs add '{}' \; \)

Y guardamos los cambios en el server con
cvs commit

COMPILAR GIANA SISTERS RETURN
==============================

Lo primero es compilar libmodplug:

O bien clonamos la última versión...
git clone --depth 1 https://github.com/Konstanty/libmodplug.git
autoreconf -i
 ./configure --enable-static

O bien usamos la 0.87 que traen los sources de los juegos, ya que en algunos casos la última versión no es compatible
CXXFLAGS="-fpermissive" ./configure --enable-static
make -j8

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure --enable-static

Buscamos libmodplug.a
find ./ -name 'libmodplug.a'
Y lo copiamos a la raiz de los sources del giana.
Así mismo, copiamos el directorio de los sources de libmodplug (llamado así, libmodplug) a la raiz de los sources del giana, porque necesita headers que buscará ahí.

Ahora, si vamos a compilar en Linux de 64 bits, tenemos que usar estos flags en nuestro Makefile, que son de Makefile_ubuntu64:
CFLAGS = $(INCLUDES) -DMODPLUG -DLINUX $(OPTIM) -Wall -DFADEINOUT -DLINUX64 -DHOME_DIR
...de lo contrario, el ejecutable resultante nos medio peta el sistema y da errores raros.

Si nos da errores de "undefined symbol" con funciones como initFPS() en main.c, añadimos fpshelper.o a nuestro Makefile en la sección de OBJS 

PARA ARREGLAR lo de la transparencia de la estrella cuando cogemos un powerup, añade:
    SDL_SetSurfaceBlendMode(scrback, SDL_BLENDMODE_BLEND);
    SDL_SetSurfaceBlendMode(star, SDL_BLENDMODE_BLEND);
justo antes de donde sea que hagas:
    SDL_SetSurfaceAlphaMod(scrback,192);
    SDL_SetSurfaceAlphaMod(star,128);
...porque estás estableciendo un nivel de transparencia sin haber dicho que quieres que esa surface sea transparente en el proceso de blitting para empezar.

Debes copiar el directorio data que viene con los sources al directorio donde metas el ejecutable.
El fichero de configuración lo crea en ~/.giana/giana.cfg.
Puedes poner ahí fast=1 para que no tengas que ver la intro, elegir idioma y todo eso.
Puedes pasarle al ejecutable  "-fs -aspect" para conservar el aspect ratio.

HURRICAN, EL TURRICAN DE LINUX
==============================

Empezamos por su dependencia libepoxy, que la tenemos que compilar a mano porque la que viene en DEBIAN depende de X11
y toda su basura:
Bajamos la última versión estable de libepoxy desde:
https://github.com/anholt/libepoxy/releases

Configuramos, compilamos e instalamos:

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson setup -Dx11=false ..

ninja -j4
sudo ninja install

AHORA VAMOS CON EL HURRICAN EN SÍ:
Clonamos su repo:
git clone --depth 1 --recurse-submodules https://github.com/HurricanGame/Hurrican.git

Editamos Hurrican/src/Main.cpp y comentamos la línea:
#  define SHOW_CRACKTRO

Configuramos y compilamos:

cd Hurrican/Hurrican
mkdir b4
cd b4

cmake -DCMAKE_BUILD_TYPE=Release -DRENDERER=GLES2 \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" ..

(Hay otros renderers disponibles, mira en el README)

make -j4 

Creamos el directorio ~/hurrican, y allí copiamos el ejecutable, junto con los directorios data y lang, que vienen con los sources.

EMULADOR MODEL 3 (SUPERMODEL) EN GNU/LINUX
==========================================

Clonamos su repo:
git clone --depth 1 https://github.com/trzy/Supermodel.git 

Editamos Makefiles/Rules.inc y quitamos glew.cpp, y todos los ficheros de Legacy3D.
Editamos Makefiles/Makefile.UNIX y cambiamos -lGL por -lOpenGL, y añadimos -lGLEW 

Editamos Src/OSD/SDL/Main.cpp, y buscamos las líneas que empiezan con "Render3D =", hay dos.
Dejamos así la primera:
IRender3D *Render3D = ((IRender3D *) new New3D::CNew3D(s_runtime_config, Model3->GetGame().name));
Y así la segunda:
Render3D = ((IRender3D *) new New3D::CNew3D(s_runtime_config, Model3->GetGame().name));

Editamos Src/Pkgs/GL/glew.h y eliminamos toda la sección GLU.

Compilamos con:

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
make -f Makefiles/Makefile.UNIX -j8

Creamos el directorio ~/model3, y copiamos allí los directorios "Config" y "Assets" que vienen con los sources.
Metemos también en ~/model3 los zips que queramos de juegos, y los lanzamos con:

wlr-randr --output HDMI-A-1 --custom-mode 992x768@60                                                           
./supermodel -fullscreen -res=992,768 -channels=2 daytona2.zip                                                 
wlr-randr --output HDMI-A-1 --custom-mode 1920x1080@60

En ese ejemplo estamos corriendo los juegos al doble de su resolución original.
Si en lugar de eso le pasas tu resolución nativa (-res=1920,1080) no hace falta que pongas la resolución con wlr-randr.
(Es necesario cambiar la resolución con wlr-randr si usas resoluciones "no standard" porque OpenGL no puede renderizar
a una resolución y escalar a otra).  

PARA CONFIGURAR LOS CONTROLES: Ejecuta simplemente "supermodel -config-inputs", y puedes usar las flechas ARRIBA Y ABAJO del teclado
para saltarte los controles que no te intererese configurar. Para configurar una tecla, dale a INTRO, y ya al botón o eje que sea.

NOTA: Si no le pasas "-channels=2", no se oirá porque por defecto Supermodel intenta abrir un sistema de audio de 4 canales,
que no tenemos.

NOTA: Cuando al iniciar un juego nos de el error "Network board not present", le damos al 6 para entrar en modo Test,
navegamos usando el 5 hasta "Game Assignments", usamos el 6 para seleccionarlo, y cambiamos la opción "Link ID" de "Master" a "Single".

NOTA: Para poner el Daytona 2 en inglés, presiona TestA para entrar en el menú,
ahora presiona a la vez ServiceA + ServiceB, y con ellos dos presionados presiona TestB, y ya estás en el menú de elegir el país.
Y prefiero usar "Export", porque en USA sale un aviso que no nos interesa.

NOTA: Para que el Magical Truck no se ralentize, pásale -ppc-frequency=100

AUDIO POR I2C: EL PI TOP SPEAKER
================================

Lo primero es saber que el pi top speaker (pts de ahora en adelante) va por i2c pillando el sonido del hdmi.
Para que el i2c funcione, tenemos que tener estos módulos cargados:

snd_bcm2835
i2c_bcm2835
i2c_dev

Para ello, en config.txt añade:

dtparam=i2c1=on
dtparam=i2c_arm=on

Y luego a parte en /etc/modules añade:
i2c_dev

Reiniciamos, y probamos que detecta el dispositivo en el i2c:

sudo i2cdetect -y 1

Si el i2cdetect no encuentra /dev/i2c-1, es que nos falta algo de los módulos. El pts debería estar en el 73 en la tabla que nos sale.

SELECCIONAR LA SALIDA DE AUDIO CON MPV
======================================

Podemos ver los dispositivos de salida con: mpv --audio-device=help
Y elegit el que queramos de la lista con: mpv --audio-device=<NOMBRE_DISPOSITIVO>

PROBLEMA: UN PROGRAMA NO ENCUENTRA UNA LIBRERÍA QUE SÍ ESTÁ INSTALADA Y CONTRA LA QUE SE HA LINKADO DINÁMICAMENTE SIN PROBLEMAS
================================================================================================================================

Vemos con ldd <nombre_ejecutable> que busca una librería que sí está instalada en /usr/local/...etc
Pues limpiamos la caché de ld:

sudo rm /etc/ld.so.cache
sudo ldconfig

Y ya debería ver la librería que le faltaba con ldd <nombre_ejecutable>

NOTAS HIFIBERRY
===============

En Debian Stretch, las cosas se han complicado ligeramente para poner a funcionar bien la HIFIBERRY DAC+, así que aquí voy a poner algunas notas.
Para que funcione perfectamente:
****En config.txt, mira que tengas estas cosas:***
-Comentada la línea
#dtparam=audio=on

-Añadidas las líneas:
dtoverlay=i2s-mmap
dtoverlay=hifiberry-dacplus

(!!!!!!!!!!!)Ahora, asegúrate de que, además de los módulos típicos, tengas, según lsmod, un módulo llamado "fixed". Si no, ve y quítalo de blacklist.conf...

Ahora, deberías poder ver la tarjeta con "aplay -L" y ver los controles de volúmen y ajustes de la hifiberry con "alsamixer".
Pero puede que alsamixer no guarde los cambios entre reinicios: esto es porque el servicio "alsa-restore.service" falla, lo que puedes comprobar
con "sudo systemctl status alsa-restore.service".
Y falla porque no se cumple la condición de que exista "/dev/snd/control*" cuando se intenta cargar alsa-restore.service
Si editamos completamente el unit del servicio alsa-restore.service ("sudo systemctl edit --full alsa-restore.service"), vemos que tiene la condición:
ConditionPathExistsGlob=/dev/snd/control*
...que es la que está fallando.
Pues bien: vamos a quitar esa condición. Para ello, editamos un "override" del unit, no el unit en sí (ya que esto se perdería al actualizar el sistema...).
Lo editamos con:
sudo systemctl edit alsa-restore.service
Y simplemente añadimos esa condition pero "en blanco":

[Unit]
ConditionPathExistsGlob=

Salvamos, reiniciamos, y alsamixer debería restaurar los niveles sin problemas. Comprueba que "systemctl status alsa-restore.service" se ha iniciado correctamente ahora.

CONVERTIR VÍDEO MPEG2 A MENOS RESOLUCIÓN SIN PERDER CALIDAD
============================================================

El vídeo de entrada era de 1440x1080, así que lo convierto a 720x540, que es exactamente la mitad, y así mantengo el aspect ratio.

ffmpeg -i maddog.m2v -an -qscale:v 10 -vf scale=720:540 -codec:v mpeg2video maddogsd.m2v

La parte de "-qscale:v 10" es para un variable bitrate de calidad 4 (1 es la máxima, 31 la mínima).
Podríamos, en lugar de eso, usar "-b:v 3000k" para un bitrate constante máximo de 3000k.
(OJO!!! si especificas la calidad con "-qscale:v 10", no especifiques el bitrate con "-b:v 3000k" o "-b:v 6000k", es calidad o bitrate constante,
PERO NO AMBAS. Si especificases ambas, la calidad (-qscale) prevalece).

Más información: https://trac.ffmpeg.org/wiki/Encode/MPEG-4
Más ejemplos en: https://github.com/DirtBagXon/hypseus_singe_data
Más juegos: https://archive.org/details/@dirtbagxon

COMPILAR NUESTRA PROPIA VERSIÓN DE WPA_SUPPLICANT
=================================================

La versión que viene en Debian depende de systemd para funcionar (falla si no tenemos systemd corriendo),
así que para tener un sistema mínimo sin init necesitamos compilar nuestra propria versión de WPA_SUPPLICANT.

Las instrucciones para compilar wpa_supplicant desde sus sources se han obtenido de:
https://www.linuxfromscratch.org/blfs/view/svn/basicnet/wpa_supplicant.html

¡EMPEZEMOS!

Dependencias previas:
apt-get install libnl-3-dev libnl-genl-3-dev libreadline-dev 

Bajamos la última estable de aquí (busca "source" en esa página):
https://w1.fi/wpa_supplicant/

Descomprimimos, entramos en el directorio wpa_supplicant, y creamos un fichero de configuración para la compilación que contenga
las opciones básicas para poder establecer una conexión estándar:

cat > .config << "EOF"
CONFIG_BACKEND=file
CONFIG_CTRL_IFACE=y
CONFIG_DEBUG_FILE=n
CONFIG_DEBUG_SYSLOG=n
CONFIG_DRIVER_NL80211=y
CONFIG_DRIVER_WEXT=y
CONFIG_DRIVER_WIRED=y
CONFIG_EAP_GTC=y
CONFIG_EAP_LEAP=y
CONFIG_EAP_MD5=y
CONFIG_EAP_MSCHAPV2=y
CONFIG_EAP_OTP=y
CONFIG_EAP_PEAP=y
CONFIG_EAP_TLS=y
CONFIG_EAP_TTLS=y
CONFIG_IEEE8021X_EAPOL=y
CONFIG_IPV6=n
CONFIG_LIBNL32=y
CONFIG_PEERKEY=y
CONFIG_PKCS12=y
CONFIG_READLINE=y
CONFIG_SMARTCARD=n
CONFIG_WPS=n
CFLAGS += -I/usr/include/libnl3
EOF

PARA SABER QUÉ SIGNIFICA CADA OPCIÓN, EDITA EL FICHERO LLAMADO "defconfig" Y AHÍ VIENEN DESCRITAS TODAS.

Compilamos e instalamos con:
make BINDIR=/usr/local/sbin LIBDIR=/usr/local/lib -j4
make install

Para desinstalar, es a mano porque no hay uninstall, y se haría con:
rm /usr/local/sbin/wpa_*

INSTALAR GLEW EN GNU/LINUX
==========================

GLEW es usado por los Sonic-1-2-2013 y SonicCD decompilation projects, por Scummvm para el render OpenGL de los juegos 3D
(NO para el modo OpenGL de los juegos 2D, y a parte para el render de los juegos 3D también se puede usar GLES2, así que
glew no es necesario ni para juegos 2D ni para aceleración de juegos 3D en Scummvm) y por otros programas que no recuerdo ahora. 

GLEW sólo conoce de OpenGL/ES, no sabe nada de sistemas de ventanas (X11, Wayland, KMSDRM).

Dependencias previas:

apt-get install python-is-python3

Clonamos su repo (NO USES LA ÚLTIMA ESTABLE PORQUE NO SOPORTA GLVND Y DARÁ ERROR):

git clone --depth 1 https://github.com/nigels-com/glew.git

Editamos config/Makefile.linux, buscamos la línea "LIBDIR = $(GLEW_DEST)/lib64" y quitamos el 64.
(Nos interesa que todas las librerías que compilemos e instalemos al margen del gestor de paquetes vayan a /usr/local/lib)

En el raiz de los sources hacemos:

make extensions

Y compilamos e instalamos con un solo comando, así:

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
make SYSTEM=linux-egl-glvnd -j4 install

AHORA EDITA /usr/local/include/GL/glew.h y, o bien añade:
#define GLEW_NO_GLU 1
(Añádelo debajo de "#define GLEW_OK 0"
...O bien ELIMINA TODO EL BLOQUE GLU, es decir, busca "GLEW_NO_GLU" y elimina todo lo que hay en el bloque donde está eso.
SI NO HACES ESTO, los programas que usen GLEW los tienes que compilar siempre pasándole al compilador "-DGLEW_NO_GLU"

AMBERMOON.NET EN LINUX
======================

Necesitamos un sistema Wayland funcionando, e instalar GLFW.
Nos bajamos la última estable de GLFW de:
https://www.glfw.org/

Y configuramos, compilamos e instalamos GLFW:
mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=1 -DGLFW_USE_WAYLAND=1 -DGLFW_BUILD_EXAMPLES=0 -DGLFW_BUILD_TESTS=0 \
-DCMAKE_C_FLAGS="-DEGL_NO_X11 -march=native -mtune=native"

make -j4
sudo make install

OPCIÓN 1: BAJARNOS LOS BINARIOS PRECOMPILADOS PARA AARCH64 Y USARLO DIRECTAMENTE:

Nos bajamos los últimos binarios compilados de:
https://github.com/Pyrdacor/Ambermoon.net/releases

OPCIÓN 2: COMPILARLO NOSOTROS

Clonamos su repo:

git clone --depth 1 https://github.com/Pyrdacor/Ambermoon.net.git

Nos bajamos el DOTNET SDK de nuestra arquitectura (NO hay que instalarlo). Se baja de:
https://dotnet.microsoft.com/download/dotnet/3.1
Hay dos descargas: el SDK y el RUNTIME. El SDK incluye el RUNTIME pero ocupa más. Para compilar, necesitamos el SDK,
y luego ya para jugar nos vale con el RUNTIME.

Entramos en el directorio del SDK y compilamos el proyecto Ambermoon.net con:
./dotnet build ~/src/Ambermoon.net/Ambermoon.net.sln --configuration Release

Copiamos el RUNTIME de dotnet al directorio de Ambermoon.net (el SDK completo no hace falta, pero funcionaría igual)
y ejecutamos el DLL con:
./dotnet Ambermoon.net/bin/Debug/netcoreapp3.1/Ambermoon.net.dll
(Alternativamente, podríamos ejecutar el projecto directamente sin compilar con: dotnet run -p Ambermoon.net/Ambermoon.net.csproj)
Podemos cambiar las opciones editando ambermoon.cfg

Tenemos que tener los .ADF (llamados Amber_a.adf, Amber_b.adf, etc...) en el mismo directorio que la DLL del juego.
Podemos descargarlos ya preparados desde: https://github.com/Pyrdacor/Ambermoon/tree/master/Disks/English

COMPILAR LA VERSIÓN MODERNA DEL EMULADOR DE LASERDISC HYPSEUS (HYPSEUS-SINGE)
=============================================================================

Clonamos el repo (usando el branch RetroPie, esto es importante para que se use el libmpeg2 del sistema!):

PARA COMPILAR PARA PC (libmpeg2 propio):
apt-get install autoconf libtool-bin
git clone --depth 1 https://github.com/DirtBagXon/hypseus-singe.git

PARA COMPILAR PARA RASPBERRY PI (libmpeg2 del sistema):
git clone --depth 1 -b RetroPie https://github.com/DirtBagXon/hypseus-singe.git

Ahora, configuramos pasándole a CMAKE el directorio src desde nuestro directorio de compilación (OJO que esto es
distinto a como se suele hacer!!!):

mkdir b4
cd b4

cmake ../src -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native"

make -j4

Copia al mismo directorio donde metas el ejecutable hypseus los directorios "sound", "fonts" y "pics".

Para poner un buffer de audio más pequeño, puedes pasar el parámetro -sound_buffer 1024
(Por defecto viene puesto 2048 que es mucho).

Para tener scanlines, pasa: -scanlines -scanline_alpha 32

Para configurar el joystick:
Copia, al mismo directorio donde metas el ejecutable hypseus, el archivo docs/hypinput.ini,
y ahí, para configurar el joystick, fíjate en el formato de cada línea. Por ejemplo:
KEY_BUTTON1 = SDLK_LCTRL 0 0
..significa que el botón 1 del juego está en el botón 0 del mando (último campo).
Así que si queremos la espada en el botón 0 del mando, dejamos esa línea como:
KEY_BUTTON1 = SDLK_LCTRL 0 1
...ya que a los números de botón del mando hay que sumarle 1.
Los números de botón del mando los puedes sacar de jstest, del paquete de Debian llamado "joystick".
Recuerda que tienes que sumarle +1 a los números de botón que te da jstest!!!

Yo tengo las líneas relevantes así:
KEY_COIN1 = SDLK_5 0 7
KEY_COIN2 = SDLK_6 0 0
KEY_START1 = SDLK_1 0 8
KEY_START2 = SDLK_2 0 0
KEY_BUTTON1 = SDLK_LCTRL 0 1
KEY_BUTTON2 = SDLK_LALT 0 2
KEY_BUTTON3 = SDLK_SPACE 0 3

Los detalles sobre los dip switches están en dle21.txt, que acompaña a las roms del Dragon's Lair Enhanced 2.1
Recuerda que ahí se cuentan los switches del 0 al 7. Se empieza de derecha a izquierda a contar.
Por lo demás, el banco A es el 0, y el B es el 1.

Para lanzar juegos de SINGE (es decir, conversiones nativas), tenemos que meter el directorio del juego que sea dentro del directorio singe,
y luego pasarle como parámetros el framefile del juego (como en cualquier juego de daphne) y el script del juego singe.
Es decir, timegal quedaría metido en:
~/laserdisc/singe/timegal
Y luego lo ejecutaríamos como:
./hypseus singe vldp -framefile singe/timegal/timegal.txt -script singe/timegal/timegal.singe -fullscreen -nolog

Si quieres juegos SINGE con buena calidad, están aquí: https://archive.org/details/@dirtbagxon
Pero recuerda que si están en HD, como la Pi no descomprime mpeg2 por hardware, tienes que convetir su fichero de vídeo con algo como esto:

ffmpeg -i maddog.m2v -an -qscale:v 10 -vf scale=720:540 -codec:v mpeg2video maddogsd.m2v

(OJO!!! si especificas la calidad con "-qscale:v 10", no especifiques el bitrate con "-b:v 3000k" o "-b:v 6000k", es calidad o bitrate constante,
PERO NO AMBAS. Si especificases ambas, la calidad (-qscale) prevalece).

Lo ideal sería que ambas dimensiones de salida fueran divisoras de las originales.
Libmpeg2 no tiene forma de usar aceleración de descompresión de vídeo (la última version de libmpeg2 es de 2008 y no tiene ninguna
optimización para ARM: para tener aceleración sería con libffmpeg).

Para ajustar cosas del Maddog, puedes hacerlo durante el juego pulsando 9, o editando maddog.cfg

EL CARGADOR para el Maddog para evitar desincronizaciones de audio al principio, y con los parámetros necesariospara que vaya bien, es así:

LA CONVERSIÓN DE JUEGOS DE SINGE2 (TRON, Sucker Punch, etc) PARA LA RASPBERRY PI, QUE SON 1920x1080p
(CONSISTE EN DEJARLOS EN LA MITAD DE RESOLUCIÓN Y LA MITAD DE CALIDAD).

  PARA CONVERTIR EL TRON desde mp4 de 1920x1080 a m2v de 960x540, hacemos esto:
  ffmpeg -i TRON.mp4 -vf tpad=stop_mode=clone:stop_duration=2,scale=960:540 -qscale:v 10 -c:v mpeg2video tron.m2v
  ffmpeg -i TRON.mp4 -ss 00:00:00.33 -vn -c:a libvorbis -ar 44100 -map a -b:a 160k tron.ogg
  
  (OJO!!! si especificas la calidad con "-qscale:v 10", no especifiques el bitrate con "-b:v 3000k" o "-b:v 6000k", es calidad o bitrate constante,
  PERO NO AMBAS. Si especificases ambas, la calidad (-qscale) prevalece).
  
########################
#INICIO CARGARDO MADDOG#
########################

sync

# Send the code and the audio to the cache to avoid initial desync problems.
cat singe/maddog-hd/*.singe > /dev/null
cat singe/maddog-hd/*.ogg > /dev/null

./hypseus singe vldp -framefile singe/maddog-hd/maddog-hd.txt -script singe/maddog-hd/maddog-hd.singe -fullscreen -nolog -oversize_overlay -manymouse -blend_sprites

#####################
#FIN CARGARDO MADDOG#
#####################

CREAR UN ALIAS EN LINUX DE MANERA PERMANENTE
===============================================

Lo añadimos a ~/.bashrc. Por ejemplo, para que make se ejecute siempre en las CPUs privilegiadas del 1 al 3:
alias make='chrt -r 1 taskset -c 1-3 make'

HACER ALGO EN UN SCRIPT DE LINUX SÓLO SI EXISTE UN FICHERO
========================================================

Es muy útil, por ejemplo, para montar unidades sólo si no están montadas ya, etc...

#!/bin/bash
if [ ! -f mnt/mpeg/lair/lair.txt ]
then
    echo "Montando unidad mpeg..."
    sudo mount /dev/sda1 mnt
fi

DUDA: SI USO UN KERNEL CON EL SCHEDULER PUESTO A 100HZ, ¿PUEDO ESPECIFICAR usbhid.jspoll=1 xpad.cpoll=1 QUE HACE QUE LOS USB SE LEAN A 1000HZ?
==============================================================================================================================================

Sí. El kernel corre sobre HRTIMERS, lo de los 100HZ es la velocidad del sheduler, es decir, cuántas veces por segundo mira a ver qué se ejecuta dónde.
Son cosas distintas e independientes, la granularidad del kernel es mucho mayor que 100HZ... eso es sólo el scheduler.
Y el scheduler, en tus sistemas de no-escritorio, va de sobra a 100Hz para una cosa que ejecutas a la vez (mas el housekeeping del kernel fuera de las CPUs aisladas).
Así que sí, se puede.

COMPILAR FROTZ 
===============

Instala las ncursesw, que es una versión más mehó de las ncurses:
sudo apt-get install libncursesw5-dev libjpeg-dev
	
Si quieres sonido en modo texto (en sfrotz no hace falta ya que el sonido va por SDL2), instalamos estas dependencias previas:
apt-get install libsamplerate0-dev libsndfile1-dev libao-dev --no-install-recommends

Baja los surces de la última estable de:
https://gitlab.com/DavidGriffith/frotz/-/releases

Ahora edita src/sdl/sf_video.c:
-Añade estos FLAGS a la línea de SDL_CreateRenderer()
SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC
-Añade esta línea antes de que se creen la ventana y el renderer
SDL_ShowCursor(SDL_DISABLE);

Ahora edita src/curses/ux_init.c y comenta el bloque de "I won't run as root".

Ahora edita el Makefile y:
-Pon sound a NONE si no quieres sonido en modo texto (sin SDL). En sfrotz el sonido va por las SDL,
 así que usa SFROTZ para los juegos que tienen sonido, y ya.
-Comenta la línea de los CFLAGS del -g, y deja así la línea de los CFLAGS:
CFLAGS += -march=native -mtune=native -fsigned-char
(Los valores de align y tal no tienen sentido porque los valores son incorrectos, -O2 ya activa los valores correctos).

Ahora compila con "make frotz" (hay "make sfrotz" para SDL, etc...)
Y sudo make install

Para compilar SFROTZ, no te olvides de pasar el CFLAG -fsigned-char, o el cursor aparecerá descolocado. En el futuro no debería ser necesario.

Hay juegos con sonido, gráficos, etc.. Estos añadidos van en ficheros .BLB, que te puedes bajar de aquí ya preparados:
http://www.ifarchive.org/indexes/if-archiveXinfocomXmediaXblorb.html
Luego sólo tienes que lanzar el sfrotz (que es el que soporta gráficos, y sonido sin depender de AO) pasándole tanto el archivo del juego como
el blb, tal que así:
sfrotz SHERLOCK.Z5 SHERLOCK.BLB
OJO que para que Sherlock suene necesitas el .DAT o .Z5 (son lo mismo) de la versión de Amiga, NO la de PC.

PARA USAR SFROTZ CON vkBasalt, NO HACE FALTA CAMBIAR LA FUENTE DE LETRA NI NADA, LA QUE TRAE POR DEFECTO SE VE ESTUPENDA.
Simplemente creamos el fichero ~/.sfrotzrc con este contenido y ya:

[Window]
AcWidth = 640
AcHeight = 400 

[Fonts]
antialias=1

PARA USAR SFROTZ SIN VKBASALT, HAY QUE CAMBIAR LA FUENTE DE LETRA POR UNA TRUETYPE ESCALADA CON ANTIALIAS. PARA ELLO:

-Instalamos una fuente truetype adecuada. Para ello bajamos el zip de una fuente parcheada nerdfont de aquí:
https://www.nerdfonts.com/font-downloads
(Son fuentes que podrías instalarte como paquetes desde Debian, pero estas versiones parcheadas Nerd traen glifos
que permiten mostrar iconos gráficos en la consola.)
Por ejemplo, yo me suelo bajar JetBrainsMono. Metemos los contenidos del zip en /usr/local/share/fonts/truetype/jetbrains.

-Creamos el fichero ~/.sfrotzrc con el contenido:

[Window]
AcWidth = 1280
AcHeight = 720 

[Fonts]
fontdir=/usr/local/share/fonts/truetype/jetbrains
textroman=JetBrains Mono Light Nerd Font Complete Mono.ttf@20
textbold=JetBrains Mono Bold Nerd Font Complete.ttf@20
textitalic=JetBrains Mono Light Italic Nerd Font Complete.ttf@20
textbolditalic=JetBrains Mono Bold Italic Nerd Font Complete.ttf@20
fixedroman=JetBrains Mono Light Nerd Font Complete Mono.ttf@20
fixedbold=JetBrains Mono Bold Nerd Font Complete.ttf@20
fixeditalic=JetBrains Mono Light Italic Nerd Font Complete.ttf@20
fixedbolditalic=JetBrains Mono Bold Italic Nerd Font Complete.ttf@20
antialias=1

NOTA: Se podrían usar valores de AcWidth y AcHeight que fuesen múltiplos de los 640x400 originales que usa sfrotz,
de manera que las imágenes gráficas se escalan correctamente y además se usa una fuente DejaVu tamaño 30 para que salgan
los mismos caracteres por línea que con la fuente VGA original.

NOTA2: Para que, al salvar partida o al cargar, SFROTZ no nos saque diálogos gráficos, sino que nos pida el filename a mano como debe ser,
le pasamos el parámetro -T.

OTRA ALTERNATIVA ES USAR ESTA FUENTE, que es la de la consola pero en TTF:
https://files.ax86.net/terminus-ttf/
(NOTA: La tienes lista en el disco duro de backup, con los nombres de archivo adecuados y todo,
mételas en /usr/local/share/fonts y listo).

El ~/.sfrotzrc quedaría así:

[Window]
AcWidth = 1280
AcHeight = 800 

[Fonts]
fontdir=/usr/local/share/fonts
textroman=TerminusTTF.ttf@34
textbold=TerminusTTF-Bold.ttf@34
textitalic=TerminusTTF-Italic.ttf@34
textbolditalic=TerminusTTF-Bold-Italic.ttf@34
fixedroman=TerminusTTF.ttf@34
fixedbold=TerminusTTF-Bold.ttf@34
fixeditalic=TerminusTTF-Italic.ttf@34
fixedbolditalic=TerminusTTF-Bold-Italic.ttf@34
antialias=1

OTRA ALTERNATIVA es usar esta fuente: https://archive.org/details/LessPerfectDOSVGA
La renombramos a dosvga.ttf, y el ~/.sfrotzrc quedaría así:

[Window]
AcWidth =  1280
AcHeight = 800 

[Fonts]
fontdir=/usr/local/share/fonts
textroman=dosvga.ttf@34
textbold=dosvga.ttf@34
textitalic=dosvga.ttf@34
textbolditalic=dosvga.ttf@34
fixedroman=dosvga.ttf@34
fixedbold=dosvga.ttf@34
fixeditalic=dosvga.ttf@34
fixedbolditalic=dosvga.ttf@34
antialias=1

PARA CONVERTIR JUEGOS DE THE QUILL A FROTZ
Puedes convertir juegos de THE QUILL a .z5 para el frotz con el unquill: https://www.seasip.info/Unix/UnQuill/
Pero el unquill recibe .SNA, y lo más que hay por ahí son .Z80, así que para pasar .SNA a .Z80 usa el spconv:
https://live.worldofspectrum.org/infoseek/utils
Una vez que tengas el .SNA, sólo tienes que hacer:
./unquill -T5 -L -OBORED1.z5 BORED1.SNA
Tienes juegos de THE QUILL en .Z80 en: http://ifmirror.russotto.net/indexes/if-archiveXgamesXspectrum.html


COMPILAR FROTZ VERSIÓN SDL, QUE SOPORTA ACENTOS, SIN INSTALAR LIBJPEG EN EL SISTEMA
===================================================================================

Empezamos compilando libjpeg-turbo, que nos va a hacer falta la versión estática de las librerías. Pillamos la última versión estable de su repo:
https://github.com/libjpeg-turbo/libjpeg-turbo/releases

Ahora creamos directorio de compilación, entramos, y configuramos con CMAKE así:
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_FLAGS="-march=native -mtune=native"

Ahora, clonamos el repo del FROTZ:
git clone --depth 1 https://github.com/DavidGriffith/frotz.git

Ahora, en el directorio de los sources del FROTZ, nos creamos un directorio llamado jpeg, donde vamos a meter las librerías estáticas y los headers de libjpeg. 
Vamos a necesitar tener en nuestro directorio jpeg dentro de los sources del FROTZ estos archivos (unos del diretorio raiz de los sources de libjpeg y otros de nuestro
directorio de compilación de libjpeg, b3 o como lo llames):
jconfig.h 
jmorecfg.h 
jpeglib.h 
libjpeg.a

Ahora, editamos el Makefile del FROTZ, y a los CFLAGS le añadimos, para que encuentre los headers de SDL2, de freetype2, de la libjpeg que hemos compilado, etc, 
quedando así la línea de CFLAGS:
CFLAGS += -I$(INCLUDEDIR) -I/usr/include/SDL2 -I/usr/include/freetype2 -I/home/pi/src/frotz/jpeg

Y la línea de LDFLAGS quedará así:
jpeg/libjpeg.a -lSDL2 -lSDL2_mixer -lz -lfreetype -lpng
(Como ves, no le pasamos -ljpeg, sino que directamente le pasamos la librería estática al linker y listo).

CONECTAR WIIMOTE EN LINUX
=========================

MÁS INFO:
https://wiki.archlinux.org/title/Wiimote
https://wiki.archlinux.org/title/XWiimote
https://wiki.archlinux.org/title/XWiimote#Cannot_connect_Wiimote

IDEAS INICIALES QUE HAY QUE ENTENDER:
El módulo del kernel es "hid-wiimote" y hay que tenerlo cargado antes de intentarnos conectar.
Nos conectamos usando "bluetoothctl" del paquete "bluez". OJO: El bluez tiene que tener el módulo wiimote, que es opcional.
Para saber si nuestro bluez tiene el módulo wiimote, hacemos: grep wiimote /usr/lib/bluetooth/bluetoothd
(En Debian, sería "grep wiimote /usr/libexec/bluetooth/bluetoothd")
Nos tiene que devolver: "grep: /usr/lib/bluetooth/bluetoothd: binary file matches"
Si no nos devuelve eso, tendríamos que compilar "bluez" con el argumento "--enable-wiimote".
Una vez conectados con bluetoothctl, debemos poder configurar el wiimote con las utilidades del paquete "xwiimote"

VEAMOS ĆOMO SE HACE:

Instalamos las cosas que necesitamos: apt-get install bluez xwiimote

Entramos en "bluetoothctl", y hacemos:
scan on  <--- (Esto es necesario para poder usar el TAB en los siguientes pasos)
pair <DIRECCIÓN MAC DEL WIIMOTE, USA TAB PARA ELEGIR UNA>
connect <DIRECCIÓN MAC DEL WIIMOTE, USA TAB PARA ELEGIR UNA>
trust <DIRECCIÓN MAC DEL WIIMOTE, USA TAB PARA ELEGIR UNA>

Si al hacer el "connect" te pide un PIN, es que tu versión de BLUEZ no tiene el plugin de Wiimote.
Si falla algo, verifica que el módulo hid-wiimote está cargado: lsmod |grep wii

Ahora, deberíamos poder ver el wiimote con: xwiishow list

	USARLO COMO UN RATÓN EN X11

sudo apt-get install -f xserver-xorg-input-xwiimote
Editamos /usr/share/X11/xorg.conf.d/60-xorg-xwiimote.conf, y en bloque de:
Identifier "Nintendo Wii Remote"
añadimos:
"Option "MotionSource" "ir"

Para saber qué otras opciones tenemos en /usr/share/X11/xorg.conf.d/60-xorg-xwiimote.conf, podemos mirar: man xf86-input-xwiimote

	USARLO COMO RATÓN EN WAYLAND
	
No nos sirve libinput porque no soporta el Wiimote.
-Lo primero, confirmamos que vemos eventos del wiimote con "evtest", que nos permitirá elegir por un lado el pad y por otro el IR.
(Vamos moviendo el mando y vemos los eventos que se generan).
Nos quedamos con el nombre del dispositivo en /dev, deberíamos ver algo como:
/dev/input/event5:      Nintendo Wii Remote IR
/dev/input/event6:      Nintendo Wii Remote

-Para mapear los eventos del Wiimote a movimientos de ratón, usamos "evsieve".
--Primero instalamos el buildsystem que necesita.
Según las instrucciones de https://www.rust-lang.org/tools/install, se hace así:
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
--Clonamos su repo: git clone --depth 1 https://github.com/KarsMulder/evsieve.git
--Compilamos: cargo build --release
--Instalamos: install -m 755 -t /usr/local/bin target/release/evsieve
--Podemos ver los eventos del IR del Wiimote con: evsieve --input /dev/input/event5 --print
--Para hacer el mapeo de los eventos de Wiimote a ratón, miramos los ejemplos en: https://github.com/KarsMulder/evsieve

-USANDO MOLTENGAMEPAD (Al usarlo como ratón se mueve solo, etc)
--Clonamos su repo: git clone --depth 1 https://github.com/jgeumlek/MoltenGamepad.git
--Editamos source/core/uinput.h, y al final de los includes del principio añadimos "#include <memory>"
--Compilamos con: make -j4
--Instalamos el binario resultante con: cp moltengamepad /usr/local/bin/
--Entramos en installation/systemuser, y ejecutamos ./install.sh
--Creamos el archivo /etc/xdg/moltengamepad/moltengamepad.cfg con el contenido:
load profiles from /home/manuel/.config/moltengamepad/profiles/mywiimote
--Creamos el archivo .config/moltengamepad/profiles/mywiimote con el contenido:
[wiimote]                                                                                                                                        
wiimote.?wm_ir_active = true
wiimote.wm_a = key(key_a)
wiimote.wm_b = key(key_b)
wiimote.wm_1 = key(key_1)
wiimote.wm_2 = key(key_2)
wiimote.wm_up = key(key_up)
wiimote.wm_down = key(key_down)
wiimote.wm_left = key(key_left)
wiimote.wm_right = key(key_right)
wiimote.wm_plus = key(key_4)
wiimote.wm_minus = key(key_3)
wiimote.wm_ir_x = mouse(rel_x)
wiimote.wm_ir_y = mouse(rel_y)
(...Y ya debería ir como ratón, pero mal).

	USARLO COMO PISTOLA EN HYPSEUS-SINGE
	
A parte de tenerlo funcionando como ratón, tenemos que pasarle al Hypseus los parámetros: "-nojoymouse -sinden 1 x"
Y para recargar dándole al botón A, en hypinput.ini tenemos que tener: "KEY_BUTTON1 = SDLK_LCTRL 0 1"

CONFIGURAR BLUETOOTH MANUALMENTE Y CONECTARSE A DISPOSITIVOS EN GNU/LINUX
=========================================================================

Instalamos los paquetes requeridos para usar hcitools y todo eso:

sudo apt-get install bluez

Insertamos los módulos necesarios del kernel y conectamos el sistema de gestión hci a nuestro hardware bluetooth:

sudo modprobe hci_uart
sudo modprobe btbcm
sudo hciattach /dev/ttyAMA0 bcm43xx 921600 noflow -

Ahora deberíamos poder ver qué dispositivos bluetooth tiene nuestro microordenador:

sudo hciconfig -a

Ahora levantamos nuestro dispositivo hci:

sudo hciconfig hci0 up

Podemos ver más información con esto:

sudo hciconfig dev

Escaneamos dispositivos bluetooth al alcance:

sudo hcitool scan

Si aparece el nuestro, nos podemos conectar con:

hcitool cc 30:23:18:DA:8A:AE
hcitool lecc 30:23:18:DA:8A:AE

Listamos las conexiones hechas con:

hcitool con

Para quitar el LAG:

sudo iwconfig wlan0 txpower off
O bien deshabilitar el WIFI en el inicio con:
dtoverlay=pi3-disable-wifi

hcitool con (para verificar que está conectado!)
sudo hcitool enc 30:23:18:DA:8A:AE off
sudo hcitool sr 30:23:18:DA:8A:AE slave

ADVENTURE ORIGINAL EN LA PI USANDO SIMH
=======================================

Clonamos el repo de simh:
git clone --depth 1 https://github.com/simh/simh.git

Editamos el makefile y comentamos toda la sección donde detecta libpng (busca png y comenta ese bloque)
También le puedes añadir los flags de la arquitectura donde se añade el -fipa-cp-clone, por ejemplo.

Compilamos sólo el simulador de pdp8 que es el que vamos a usar
make pdp8
El ejecutable queda en BIN/pdp8

Ahora necesitamos el adventure y un .ini que irá en el mismo directorio que el ejecutable pdp8. Todo eso viene en un blog:
https://raymii.org/s/articles/Running_ADVENT-on-the-PDP-8-with-SIMH.html

DESCARGAR LIBROS DE GOOGLE BOOKS EN PDF
========================================

sudo apt-get install python-glade2

git clone https://github.com/tokland/pysheng
cd pysheng
sudo python setup.py install

Y para que guarde en PDF:
pip install reportlab

EJECUTAR PROTON (PROT-ON), EL SISTEMA DE ENCRIPTACIÓN / DESENCRIPTACIÓN USADO EN LA ACADEMIA, EN GNU/LINUX
===========================================================================================================

Es posible hacerlo sin una máquina virtual.
Lo primero es bajarnos el archivo NetFx64.exe (Es parte de .NET Framework 2.0 x64, por si lo quieres hacer con Winetricks).
No especifico de dónde bajarlo, supongo que Microsoft lo tiene para bajar.
Lo instalamos usando Wine: wine NetFx64.exe
Y ya podemos instalar el PROT-ON sin errores. Al ejecutar prot-on, queda en la barra de tareas puesto, abajo a la derecha,
como si de un programa de Linux nativo se tratase, y nos permite abrir documentos y vídeos protegidos sin problemas.

DESHABILITAR SCREEN LOCK (BLOQUEO DE PANTALLA) TRAS SUSPENDER
=============================================================

No es cosa de xscreensaver, aunque se usa para bloquear.
El setting está en: 
preferences->LXQT Settings->Session settings->Lock screen before suspending

DESCARGAR VÍDEOS DE YOUTUBE EN 2024 (youtube-dl ya no funciona)
===============================================================

Se usa yt-dlp. Lo instalamos con PIP, así:

sudo apt-get install python-is-python3
sudo apt install python3-pip -y
sudo python3 -m pip install -U yt-dlp

Para seleccionar la calidad:
1) Vemos las calidades disponibles con: yt-dlp -F <URL>
2) Seleccionamos la calidad que queramos con: yt-dlp -f<NÚMERO DE CALIDAD> <URL>

MPS-YOUTUBE: CÓMO HACER QUE FUNCIONE EN RASPBIAN (Y EN GENERAL)
===============================================================

Lo primero, NO INSTALES MPS-YOUTUBE O YOUTUBE-DL DESDE APT-GET o el gestor de paquetes que sea: instálalo siempre desde pip,
pero NO hagas una instalación tipo user como dicen las instrucciones, sino exactamente así:

sudo pip3 install -U git+https://github.com/mps-youtube/mps-youtube.git

O así, si quieres la versión estable:

sudo pip3 install mps-youtube

NO OLVIDES instalar youtube-dl desde pip también, ya que es una versión de youtube-dl que se instala entre las extensiones de phyton:

pip3 install youtube-dl

Al lanzarlo puede que te diga que no encuentra mplayer, porque no puedes especificarle otro player ya que aún no lo haz lanzado. Vale, pues instala mplayer:
sudo apt-get install --no-install-recommends mplayer

Ahora entras en mps-yt y haces:
set player omxplayer
o bien
set player vlc

Y a continuación desinstala mplayer y sus dependencias:
sudo apt-get purge mplayer
sudo apt-get autoremove

Ahora, para que mps-yt te busque vídeos y no sólo audio, haz:
set search_music false
Y para que se vea el vídeo, ya que por defecto sólo reproduce el audio, haz:
set show_video true

RESTAURAR (UNDELETE) ARCHIVOS BORRADOS EN UN FILESYSTEM EXT4
============================================================

Se hace con extundelete. Desmonta la partición en la que estaba el archivo antes de pasarte extundelete.
Si no te sabes el nombre del archivo, extundelete te lo sugerirá, así que tranquilo.

sudo extundelete /dev/sdb5 --restore-file installed_os.json

Te lo va a guardar en RESTORED_FILES, en el directorio donde estés cuando ejecutes extundelete. Así que lo tienes que copiar a mano a donde estaba originalmente.

Si fuese en un fat32, usa testdisk.
Keep calm and... undelete!

INSTALANDO UN SISTEMA CUSTOM EN NOOBS
=====================================

Normalmente no es posible instalar un nuevo SO después de instalar NOOBS en una SD, pero bueno, yo lo he hecho y no es para tanto.
-Creamos las particiones. Necesitamos dos: una en FAT32, y otra en EXT4 (si vas a instalar un GNU/Linux propio "from scratch" por ejemplo, como un sistema de 64 bits, etc)
	Vamos a suponer que quedan como sdb8 (fat32) y sdb9 (ext4) desde el PC. Una es la partición de boot y otra la de rootfs, obviamente. Les puedes poner de nombre CUSTOM_BOOT
	y CUSTOM_ROOT, por ejemplo. Se cambia el nombre de las particiones con fatlabel para la fat32 y e2label para la ext4.
	Apunta también sus PARTUUID, que puedes averiguar con sudo blkid /dev/sdb8 y blkid /dev/sdb9

-En la partición boot copia todo lo que se necesita (kernel, dbts, overlays, ficheros de configuración, firmware, etc...). Con cp -R vale.
-En la partición del rootfs copia el rootfs del sistema a instalar, pero recuerda hacerlo con rsync -av --progress origen/* destino/ ,
NO con cp que la lías con los permisos.
-Crea una entrada nueva para el sistema en el fichero installed_os.json de la partición SETTINGS de NOOBS, es decir, en SETTINGS/installed_os.json. Por ejemplo así:
{ 
  "bootable" : true,
  "description" : "Sistema GNU/Linux de 64bits para juegos",
  "folder" : "/settings/os/debian64",
  "icon" : "/settings/os/debian64/icon.png",
  "name" : "Debian 64 bits",
  "partitions" : [
"/dev/mmcblk0p8",
"/dev/mmcblk0p9"
  ],
  "release_date" : "2018-11-13",
  "supported_models" : [
"Pi 3"
  ]
 },

^^^Como ves, ahí se le especifican las particiones que tiene. El directorio SETTINGS/os/debian64 lo creamos nosotros también y metemos ahí el icono que queramos que
se muestre en el arranque. Con el icono vale, no hace falta tener nada más en ese directorio.
El icono tendrá un tamaño de 40x40 pixels en png para no desentonar con el tamaño de los demás. Aqui tienes un ejemplo:
http://www.iconarchive.com/show/super-mario-icons-by-ph03nyx/Retro-Block-Question-icon.html 
Puedes escalar cualquien imágen con GIMP, en image->scale image, y dejarla a 40x40 que es lo que se necesita.

-Ahora edita el cmdline.txt del sistema custom que acabas de instalar, y ajusta el parámetro root= con el PARTUUID de la partición de rootfs.
-Ahora edita el /etc/fstab del sistema custom que acabas de instalar, y lo mismo, ajusta los dos PARTUUID a los de la partición boot y rootfs.
...Y ya debería arrancar sin ningún problema.
Si te sale sólo la pantalla en negro, es que el kernel necesita los módulos instalados en el rootfs para poder mostrar algo por pantalla.

USAR WIFI EN LA RASPBERRY PI 4 CON KERNEL GENÉRICO
==================================================

Asegúrate de no tener blacklisteado el módulo brcmfmac en /etc/modprobe.d. Con ese módulo cargado ya deberías poder ver el interface wlan0
con iwconfig.

O bien, déjalo blacklisteado, y lo cargas manualmente en: 

sudo modprobe brcmfmac

USAR YOUTUBE EN KODI/LIBREELEC USANDO EL PLUGIN DUFF YOU
========================================================

En 2023, el plugin Invidius ya no funciona, y el plugin Youtube sigue siendo una basura que pide unas keys.
Sólo nos queda Duff You.

Para instalarlo:
1-En Sistema->Sistema->Add-Ons, activamos la opción "Orígenes desconocidos"
2-En Sistema->Explorador de Archivos, nos vamos a "Añadir fuente" y añadimos la fuente: https://luarsource.github.io/Fuente
y la llamamos "luar".
3-Volvemos al menú principal y nos vamos a Add-Ons->Instalar desde un archivo zip->luar, y nos saldrán 3 zips ahí.
  Elegimos "script.luar-0.8.1.zip" y hacemos doble click sobre él.
  Con esto se nos instala el plugin Luar, que nos peromite instalar otros plugins desde él.
4-Volvemos al menú principal y nos vamos a Add-Ons->Addons de programas, y desde el Luar instalamos el Duff You que está en los recomendados.

NOTA: NO vas a poder instalar el plugin Duff You directamente por el hostigamiento de los cerdos de Google, así que hay que
usar Luar para instalarlo sí o sí.

VER CANALES DE TDT EN KODI/LIBREELEC
====================================

Instalamos el add-on "PVR IPTV Simple Client", que se instala simplemente desde:
add-ons->instalar desde repositorio->todos los repositorios->clientes PVR->PVR IPTV Simple Client

Ahora nos vamos a add-ons->clientes PVR->PVR IPTV Simple Client->Configurar
...y en "Ruta a la lista M3U" le ponemos la dirección:
https://www.tdtchannels.com/lists/tv.m3u8

Si queremos también radio o alguna otra cosa, vienen aquí las listas de m3u:
https://github.com/LaQuay/TDTChannels

INSTALAR LIBREELEC EN UNA SD CON NOOBS QUE YA TIENE OTROS SISTEMAS INSTALADOS
=============================================================================

Es igual que lo de instalar un sistema custom tuyo, solo que lo vamos a ver de manera más resumida.
-Creamos con GPARTED las dos particiones necesarias en la SD donde haya espacio libre: una de FAT32 de 512MB llamada LIBREELEC y otra en EXT4 del tamaño que puedas llamada STORAGE.
 No hay que cambiar nada en gparted al crearlas, los tipos por defecto fata FAT32 y EXT4 nos valen.
-Copiamos los contenidos de la partición LIBREELEC de la imágen descargada de LibreeElec para Raspberry Pi a nuestra partición LIBREELEC de la tarjeta (tienes en este mismo documento cómo montar una partición individual de una imágen con varias particiones, es muy fácil).
 La partición STORAGE la dejamos vacía totalmente.
-MUY IMPORTANTE: ajustamos los parámetros boot= y disk= de cmdline.txt en la partición LIBREELEC de la tarjeta, poniendo los UUID de las dos particiones LIBREELEC y STORAGE
 que puedes conseguir en gparted, mirando INFORMATION de cada una de las particiones.
-Creamos la nueva entrada para LibreeElec el archivo installed_os.json de la partición SETTINGS de la tarjeta, es decir, en /media/manuel/SETTINGS/installed_os.json.
 En ella tienes que poner qué particiones va a tener disponibles el sistema. La manera más fácil de ver qué número tiene cada partición es con fdisk -l, pero también lo puedes
 mirar en gparted. Mi entrada queda así:


{ 
  "bootable" : true,
  "description" : "Distro orientada a la reproducción de audio y vídeo",
  "folder" : "/settings/os/libreelec",
  "icon" : "/settings/os/libreelec/icon.png",
  "name" : "LibreElec",
  "partitions" : [ 
"/dev/mmcblk0p12",
"/dev/mmcblk0p13"
  ],  
  "release_date" : "2019-02-05",
  "supported_models" : [ 
"Pi 2",
"Pi 3",
"Pi Compute Module 3"
  ]
},

¡¡CUIDADO CON LA COMA DEL FINAL!! SI EL SISTEMA QUE VAS A INSTALAR ES EL ÚLTIMO, NO TE HACE FALTA UNA COMA, PERO SI NO, PUES SÍ. Y SI NO LA PONES, TE VA A SALIR
EL MENÚ EN BLANCO.

-Ahora ya sólo queda crear el directorio /media/manuel/SETTINGS/os/libreelec, y encontrar un png adecuado para ser el icon.png de ese directorio: 
Tiene que ser de 40x40 pixels: puedes coger cualquier imágen y escalarla con GIMP: la abres, pinchas sobre ella con el boton derecho, image->scale image.
Si necesitas recortarla, usa el rectángulo de selección (arriba a la izquerda), y luego en image->crop to selection.
En SETTINGS/os/libreelec, con que esté el archivo icon.png vale, no hace falta nada más.

USAR MAME (a palo seco)
=======================

Va contra las SDL2 y usa el renderer que usen las SDL2.
Primero creamos un .ini en el directorio actual:
mame -createconfig
Lo editamos a nuestro gusto, y le pasamos a MAME la ruta del .ini para cargarlo:
mame -inipath /home/manuel/mame ridgerac
Uno de los sitios donde busca por defecto los .zip de las ROMs es en $HOME/mame/roms, pero pedemos espeficar otras rutas en el .ini

INSTALAR CHDMAN A MANO
======================

Para evitar dependencias absurdas de X11 y demás.

Clonamos su repo:
git clone --depth 1 https://github.com/CharlesThobe/chdman.git

Compilamos:
mkdir b4
cd b4
cmake -B build -G Ninja ..
cmake --build build

COMPRIMR CUE/BIN A CHD
======================

Necesitamos las mame-tools:
sudo apt-get install mame-tools p7zip-full

Y se comprime pasándole el CUE:
chdman createcd -i BC\ Racers.cue -o BC\ Racers.chd

Si tienes un directorio con varios 7z (cada uno de los cuales conteniendo un cue/bin), puedes convertir todos los 7z
de ese directorio usando este sencillo script:

		------
		
#!/bin/bash
#extract 7z
  for x7zFile in *.7z; do
                gameName="$(basename "$x7zFile" .7z)"
                echo "!!!!!!!!!!Extracting ${gameName}..."
                7z x "${x7zFile}" -o./"${gameName}-tmp"

                echo "!!!!!!!!!!Converting ${gameName}..."
                chdman createcd -i "./${gameName}-tmp/${gameName}.cue" -o ./"${gameName}.chd"
#rm temporary directory
                rm -R ./"${gameName}-tmp"
### uncomment below to rm the original 7z archive
#               rm ./"$x7zFile"

                echo "!!!!!!!!!!${gameName} complete..."
done
echo "All done."

		-------

Y para convertir todos los cue/bin de un directorio, usa este script:
for i in *.cue; do chdman createcd -i "$i" -o "${i%.*}.chd"; done

MÚSICA GRAVIS ULTRASOUND Y EFECTOS DE SONIDO EN DUNGEON MASTER 2 EN DOSBOX
==========================================================================

NOTA ANTES DE COMPLICARTE: Tienes el juego ya preparado con todo en el disco duro de backup.
Necesitamos el directorio ULTRASND en C:\
Y metemos el juego en C:\dm2
Si en DOSBOX montas "dm2" como C:, ya tienes ambas cosas.

Ahora, en el directorio del dm2, actualizamos el driver HMI desde el archivo de la web:
http://dmweb.free.fr/?q=node/612
Si no lo encuentras, pues copia los archivos desde el Anvil of Dawn.
Los archivos a sobreescribir para actualizar el driver son:

DRUM.BNK
HMIDET.386
HMIDRV.386  
HMIMDRV.386  
MELODIC.BNK  
SETUP.EXE  
TEST.HMI  
TEST.WAV
(CUIDADO, puedes acabar con cada archivo dos veces, una en mayúsculas y otra en minúsculas, 
así que te puedes quitar de problemas convirtiendo todo lo del dm2 a mayúsculas con: 
for f in *; do mv "$f" "${f^^}"; done
Acuérdate de convertir a mayúsculas también los archivos del subdirectorio DATA!).
Ahora ya sobreescribe los archivos desde el anvil o desde el zip de la actualización, lo que tengas más a mano.

Metemos en el directorio c:\dm2 estos archivos del Anvil of Down:
LOADPATS.EXE
PATCHES.INI

En DOSBOX, tenemos que poner: 
--SB16 (SBPRO también vale): Address 240, IRQ 5, DMA 1
--Gravis Ultra Sound:		 Address 220, IRQ 7, DMA 3
En el setup del dm2, elegimos la SB16 para efectos de sonido (OJO! poniendo bien su IRQ), y luego seleccionamos como MIDI la GUS, sólo como MIDI!
Ejecutamos LOADPATS.EXE cada vez que carguemos el dm2. Debería funcionar si tienes una GUS activada y el ULTRASND en C:\

Tengo el DM2.BAT exactamente así (si viene puesto +VS, quítalo, para que vaya a 60HZ el juego y no a 70HZ):
LOADPATS
EREGCARD
IBMIOP SKULL.EXE

Puedes (debes, por comodidad) borrar el archivo INTRO.

Y ya debería ir... Ya sabes: Sound Blaster para los efectos, y GUS para la música. Es cutre, pero funciona de momento.

TURRICAN 2 EN DOSBOX
====================

En todas las páginas viene una versión que no funciona pero que se puede arreglar fácilmente. 
Lo único que les falta a todas es establecer la variable de entorno "T2DIR" apuntando al diretorio "CFG" que viene con el juego.
Para que funcione, simplemente créate un PLAY.BAT con este contenido (suponiendo que tenemos el juego en C:\JUEGOS\T2):

@echo off
cls
set t2dir=c:\juegos\t2\cfg
oversmpl on
t2

En c:\juegos\t2\cfg debes meter los archivos que vienen en el directorio TURRICAN.CFG que viene con las copias del juego
que hay por ahí en internet.

Con esto ya te saldrá el menú con todas sus opciones, y el juego funcionará bien.
Para que vaya el audio, selecciona la SoundBlaster PRO, PUERTO 220, IRQ 7, DMA 1 (y que estén igual en la config del DOSBOX, claro).
NO TE MOLESTES con el audio GUS, suena peor que con SBPro...

ELDER SCROLLS: ARENA EN DOSBOX
==============================

Para tener música GUS, NO PUEDES usar la GUS para el sonido y para la música a la vez: tienes que tener una SB16 para el sonido
y la GUS para la música (si intentas usar la GUS para ambas cosas, el juego se colgará, se corromperán los menús, etc).
Una vez que las hayas seleccionado así en INSTALL.EXE, edita ARENA.BAT y ajusta los valores de la GUS para que coincidan con los de DOSBOX,
ya que INSTALL.EXE no detecta correctamente los valores de la GUS.

Una vez configurado con música GUS y efectos SB16, puedes deshabilitar el OPL de la SB16 porque el juego no lo usa para nada.

Todo esto es aplicable igualmente al REALMS OF ARKANIA 2: STARTRAIL.

THE IMMORTAL EN DOSBOX
======================

Si quieres música y sonido MT32, lanza el juego con IMMORTAL.EXE ROLAND

LA MEJOR PÁGINA PARA BAJAR PELÍCULAS BUENAS Y ALTERNATIVAS
==========================================================

Busca ZOOWOMAN y el nombre de la peli.

ACTUALIZAR EL FIRMWARE DEL 8BITDO SN30
======================================

Conéctalo y escribe en la consola de comandos:

fwupdmgr get-devices

Luego haz:

fwupdmgr get-updates

Y si hay algo nuevo, pues se actualizará. Más fácil imposible.

Poner RETROARCH en el arranque de una manera moderna, basado en systemd
=======================================================================

Creamos el fichero del servicio en /etc/systemd/system/retroarch.service, con este contenido:

[Unit]
Description=Systemd service and user to run Retroarch in stand-alone mode

[Service]
User=root
Group=root
PAMName=login
WorkingDirectory=/root/retro
ExecStart=
ExecStart=-/usr/local/bin/retroarch
Restart=always

[Install]
WantedBy=multi-user.target

y activaríamos el unit con 
sudo systemctl enable retroarch.service

En realidad esto lo único que hace es copiar /etc/systemd/system/retroarch.service a /etc/systemd/system/multi-user.target.wants/retroarch.service, es decir, lo mete en el directorio del target "multiuser", que es el último, supongo, cuando se inicia el sistema. (Bueno, crea un symlink, pero ya me entiendes).

Naturalmente, "systemctl disable retroarch" hace lo contrario: borra /etc/systemd/system/multi-user.target.wants/retroarch.service.

Saber esto nos permite habilitar y deshabilitar servicios manualmente sin necesidad de que arranque el sistema, accediendo al rootfs desde otro ordenador.

Naturalmente, el ejecutable tiene que estar en /root/bin/retroarch, o donde sea pero que coincida con lo que dice el .service
Puedes quitar el Restart=always para hacer pruebas, porque al quitarlo se sale al TTY1 si tienes una consola ahí.

Si quieres tener diferentes cmdline.txt (en diferentes particiones boot) que lancen diferentes cosas, puedes:
1) NO activar el servicio
2) Entonces, puedes decirle a systemd que lance un servicio no activado desde el cmdline.txt con:
systemd.unit="retroarch.service"
3) Puedes hacer que cuando salgas del programa que sea la máquina se reinicie(y así puedes elegir otro): para ello, aniade en la sección [Unit] del .service:
SuccessAction=reboot

Algunos programas, como el Scummvm, necesitan en la sección [Service]:
WorkingDirectory=/root/scummvm
..O si no, no detecta los juegos que aniades.
Lo mismo pasa con todo lo que lances con un script en el que tienes un ejecutable al que le pasas cosas. Como no tengas un WorkingDirectory, no encontrará las cosas que le pasas.
Por ejemplo, para el doom (doomretro, siendo doom.sh un script donde a doomretro se le pasa un iwad y tal), haríamos:

[Unit]
Description=Systemd service and user to run Doom in stand-alone mode

[Service]
User=root
Group=root
PAMName=login
WorkingDirectory=/root/doom
ExecStart=
ExecStart=-/root/doom/doom.sh
Restart=always

[Install]
WantedBy=multi-user.target

OJO!!! doom.sh debe empezar con #!/bin/bash en la primera línea, o no funcionará! Esto igual para todos los scripts que lances desde units.

OPENFODDER, versión opensource de Cannon Fodder 1 y 2
=====================================================

Clonamos el repo:

git clone --depth 1 https://github.com/OpenFodder/openfodder.git

--Editamos Source/Amiga/Sound_Amiga.cpp y ponemos "desired->samples" a 0x400
--Editamos el Makefile, cambiando el clang++ por g++, y quitamos el -ferror-limit=100 que eso es específico del CLANG ese.
--Compilamos con:
CXXFLAGS="-march=native -mtune=native -O2" make -j4

Ahora, nos creamos ~/cf, y ahí:
-Copiamos el ejecutable (lo tienes en Run/OpenFodder)
-Copiamos el archivo openfodder.ini.example a ~/cf/openfodder.ini y lo editamos a nuestro gusto.
-Descomprimimos directamente los contenidos de un ZIP de datos del engine que está aquí:
https://github.com/OpenFodder/data/releases
-Obtenemos los datos del Cannon Fodder de AMIGA. NO nos valen los datos de una instalación de WHDLOAD, los tenemos que extraer nosotros
de un set de discos de AMIGA en IPF. Descargamos los IPF de AMIGA de aquí:
https://edgeemu.net/browse-amiga-C.htm
Y compilamos esta herramienta: https://github.com/OpenFodder/SOS_Unpacker
Y metemos los IPF de AMIGA en el mismo directorio que el ejecutable SOS_Unpacker, lo ejecutamos, y nos deja los archivos extraidos en "out".
Metemos los datos de AMIGA en ~/cf/Data/Amiga, y ya nos debería detectar el juego y aparecer como "Cannon Fodder" sin más en el menú al ejecutar
el OpenFodder.

Los datos del Cannon Fodder 2 irían en ~/cf/Data/Amiga2 y simplemente hay que montar el ADF del juego (tienes instrucciones de cómo montar ADFs
en este mismo archivo) y sacarlos de ahí. Puede que te el OpenFoder te diga que el MD5 un fichero llamado MAPM1.SPT es incorrecto. En ese caso,
puedes sacar el MAPM1.SPT correcto del ADF marcado como [a]. 

JAZZ JACKRABBIT 2 en GNU/Linux (jazz2resurrection-native)
=========================================================

Clonamos su repo:

git clone --depth 1 https://github.com/deathkiller/jazz2-native.git

Juegos PICO8 en GNU/Linux usando el core de libretro "fake-08"
==============================================================

Clonamos el repo:

git clone --depth 1 -b libretro-core https://github.com/jtothebell/fake-08.git
git submodule update --init

cd fake-08/platform/libretr
make -j4

También podríamos compilar una versión SDL2 usando el branch principal, con:

git clone --depth 1 https://github.com/jtothebell/fake-08.git
make sdl2 -j4

HEART OF DARKNESS en GNU/Linux (HODE)
=====================================

Bajamos la última versión de los sources de:
http://cyxdown.free.fr/hode/

Editamos el Makefile:
-Quitamos el -g y añadimos en su lugar los FLAGS: -O2 -march=native -mtune=native

Editamos system_sdl2.cpp  y:

-Dejamos la línea
desired.samples = 4096;
como
desired.samples = 512;

-Añadimos SDL_RENDERER_PRESENTVSYNC a la llamada de SDL_CreateRenderer()
-Puedes ajustar los controles del joystick también en system_sdl2.cpp:
Busca SDL_CONTROLLER_BUTTON y ahí asignas como quieras. Pero OJO, si ves SDL_CONTROLLER_BUTTON_B, no es el B del mando SN30 sino el B de un mando de XBOX360 que es como se detecta el mando en el ordenador. Así que mírate una foto del mando de 360 para hacerlo.
De todos modos, yo lo tengo así, de arriba a abajo: X, A, B, Y. Así coincide con los controles de PSX.

En el directorio donde va el ejecutable, creamos hode.ini con el contenido:

[engine]

# disable animations playback
disable_paf=false

# disable monsters handling code
disable_mst=false

# disable sound handling code
disable_sss=false

# maximum number of active sounds (original engine sets to 10 if a slow CPU or low memory is detected)
max_active_sounds=16

# 0:easy 1:normal 2:hard
difficulty=0

# frame duration in milliseconds (original is 80ms, eg. 12.5hz)
frame_duration=50


[display]

# scaling factor for game graphics (base resolution is 256x192)
scale_factor=1

# scaling algorithm for game graphics ('xbr', 'nearest', 'linear' or 'none')
scale_algorithm=none

# gamma correction
gamma=1.0

# use intensity color
grayscale=false

# fullscreen display
fullscreen=true

# widescreen (16:9)
widescreen=false

-Una vez que lo tengamos todo, ejecutamos con:
./hode --datapath=data_pc
...Donde data_pc es un directorio donde están los datos del juego (ver README para saber qué archivos se necesitan).
Las teclas son las flechas F, G y H.

Neverball en GNU/LINUX
======================

Clonamos su repo en:
git clone --depth 1 https://github.com/Neverball/neverball.git

Compilamos con
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
make ENABLE_OPENGLES=1 ENABLE_FS=stdio ENABLE_NLS=0 BUILD=release -j4

VVVVVV en GNU/LINUX
===================

Entramos en su repo y clonamos

git clone --depth 1 https://github.com/TerryCavanagh/VVVVVV.git

Entramos en desktop_version, creamos b4 y configuramos con:

cmake -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-DNDEBUG -march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-DNDEBUG -march=native -mtune=native" ..

Bajamos el data.zip que viene con la versión Windows del VVVVVV, disponible aquí:
https://thelettervsixtim.es/makeandplay/
Ponemos el data.zip junto al ejecutable... Y listo!

Puedes ocultar el cursor del ratón y poner el filtro bilineal en ~/.local/share/VVVVVV/saves/settings.vvv

DESCARGAR DESDE EMUPARADISE
===========================

Con el Firefox (si no funciona, usa Chromium) nos instalamos la extensión tampermonkey.
Ahora desde el Chromium también nos vamos a abrir este script: https://gist.github.com/infval/c69b479ff0bd590f2dd7e1975fe2fcad
Le damos a RAW (es como un github), y nos saldrá un botón de INSTALL. Instalamos el script, es un script para el tampermonkey.
Ahora nos vamos a emuparadise, le damos a Download Links de lo que queramos bajar, y nos sale una opción nueva que es "download with workaround script". Le damos y empieza a bajar.

HACER QUE LOS MANDOS SEAN DETECTADOS COMO GAMEPAD POR LA API DE SDL2 (Método actual)
====================================================================

Compila los tests que vienen con los sources. Entre ellos, se creará un ejecutable llamado "controllermap".
Lo ejecutamos y tras seguir las instrucciones nos da una cadena de mapeo para que SDL2 reconozca el mando como un gamepad.

Si algún juego no nos reconoce el mando como gamepad, podemos setear una variable de entorno antes de lanzar el juego:
export SDL_GAMECONTROLLERCONFIG="03000000412300003680000001010000,LLC Arduino Leonardo,a:b0,b:b1,x:b2,y:b3,back:b6,start:b7,leftshoulder:b4,rightshoulder:b5,dpup:-a1,dpdown:+a1,dpleft:-a0,dpright:+a0,platform:Linux,"

...O bien podríamos añadir esa misma variable de entorno en en /etc/environment, y queda exportada para todos, es lo mismo.

---Cadenas de diferentes mandos---

Adaptador DaemonBite de UltimateMister para SNES:
03000000412300003680000001010000,LLC Arduino Leonardo,a:b0,b:b1,x:b2,y:b3,back:b6,start:b7,leftshoulder:b4,rightshoulder:b5,dpup:-a1,dpdown:+a1,dpleft:-a0,dpright:+a0,platform:Linux,

Adaptador DaemonBite de UltimateMister para MegaDrive:
03000000412300003680000001010000,LLC Arduino Leonardo,a:b0,b:b1,x:b3,y:b4,back:b7,start:b6,leftshoulder:b5,rightshoulder:b2,misc1:b8,leftx:a0,lefty:a1,platform:Linux,

Mando Kersu 2.4G:
030000005e0400008e02000073060000,Khensu,a:b0,b:b1,x:b2,y:b3,back:b6,guide:b8,start:b7,leftstick:b9,rightstick:b10,leftshoulder:b4,rightshoulder:b5,dpup:h0.1,dpdown:h0.0,dpleft:h0.8,dpright:h0.2,leftx:a0,lefty:a1,rightx:a3,righty:a4,lefttrigger:a2,righttrigger:a5,

Adaptador RAPHNET de mandos de Dreamcast:
030000009b2800000800000001010000,raphnet.net Dreamcast to USB,a:b10,b:b9,x:b2,y:b1,back:b0,guide:b3,start:b8,dpup:b4,dpdown:b5,dpleft:b6,dpright:b7,platform:Linux,

DESCARGAR DE MEGA POR CACHOS CON LAS MEGATOOLS
==============================================

Se usa megadl.
Podemos descargar la última estable precompilada de:
https://megatools.megous.com/builds/builds/
Es simplemente copiar el archivo ejecutable "megatools" a /usr/local/bin

Y ya podemos descargar con:
megatools dl <LINK DE MEGA>

O bien (si hemos compilado desde los sources)
megadl <LINK DE MEGA>

Se hace resume por defecto, así que no tienes que pasarle ningún parámetro para reanudar la descarga de archivos incompletos.

######BLOQUE OPCIONAL: COMPILAR DESDE LOS SOURCES######

Instalamos dependencias previas:
sudo apt-get install libglib2.0-dev libcurl4-gnutls-dev libssl-dev meson

Clonamos el repo de las megatools:
git clone --depth 1 https://megous.com/git/megatools

Creamos el directorio de compilación, entramos en él y configuramos con meson:
mkdir b4
cd b4
meson -Dbuildtype=release ..

Compilamos
ninja -j4
sudo ninja install

######FIN BLOQUE OPCIONAL: COMPILAR DESDE LOS SOURCES######

WARCRAFT II NATIVO EN LINUX
===========================

Nos hacen falta dos cosas: el stratagus que es el engine, y el wargus que es un importador del WCII para que funcione para stratagus.

Instalamos dependencias previas:
sudo apt-get install tolua++ libluajit-5.1-dev libbz2-dev --no-install-recommends

Instalamos el stratagus:
git clone --depth 1 https://github.com/Wargus/stratagus.git
cd stratagus && mkdir b3 && cmake .. && make -j4 && sudo make install


Instalamos el wargus:
git clone --depth 1 https://github.com/Wargus/wargus.git
cd wargus && mkdir b3

Ahora atiende: configuramos stratagus pasándole el ejecutable del stratagus que tenemos instalado y el path de gameheaders, que es un directorio de los sources de stratagus. Es fácil, por ejemplo si tenemos los sources de stratagus en ~/src/stratagus, sólo hay que hacer:
cmake .. -DCMAKE_PROGRAM_PATH=/usr/local/games/stratagus -DCMAKE_INCLUDE_PATH=~/src/stratagus/gameheaders
make -j4
sudo make install

EJECUTAR EJECUTABLES DE 32BIT (armhf) EN LINU DE 64BIT (aarch64)
================================================================

Lo primero, ver si nuestro kernel soporta compat:
grep CONFIG_COMPAT= /boot/config-$(uname -r)

Ahora a ver qué arquitecturas extranjeras soporta el sistema de gestión de paquetes (nos tiene que salir armhf como mínimo):
dpkg --print-foreign-architectures

Tenemos instalado libc6 versión armhf?
dpkg -l libc6:armhf

Tenemos instalado libc++6 versión armhf?
dpkg -l libstdc++6:armhf

Si nos falta alguna, la instalamos:
sudo apt-get install libstdc++6:armhf

NO CONFUNDAS libstd con libc, son cosas distintas.

EASYRPG, EL MOTOR DE RPGMAKER EN LINUX
======================================

LO COMPILAMOS COMO UN CORE PARA LIBRETRO

Empezamos instalando libclf, que es parte del proyecto EASYRPG, así que hay que instalarla a mano:

Dependencias previas:
sudo apt-get install libexpat1-dev libpixman-1-dev libfmt-dev libsndfile1-dev --no-install-recommends

Ahora vamos a por libclf:
git clone --depth 1 https://github.com/EasyRPG/liblcf.git
mkdir b4
cd b4
cmake -DDISABLE_ICU=ON ..

Ahora vamos a por EASYRPG:
git clone --depth 1 https://github.com/EasyRPG/Player.git
git submodule init
git submodule update
mkdir b4
cd b4
cmake -DPLAYER_TARGET_PLATFORM=libretro -DBUILD_SHARED_LIBS=ON ..

Ahora lo lanzaríamos con:
retroarch -L core <.exe del juego hecho con RPG Maker>

INSTALAR DRIVER IMPRESORA CANON
===============================

Compilarlos a mano desde los sources que da Canon es imposible, porque están rotos a propósito.
Así que hay que añadir unos repos y los instalamos desde ahí con apt-get.
Las instrucciones, en castellano, aquí:

https://www.sololinux.es/instalar-drivers-de-impresoras-canon-en-ubuntu-20-04/

QUAKE 3: IOQUAKE3 EN LINUX
===========================

Clonamos los sources:

git clone --depth 1 https://github.com/suijingfeng/vkQuake3.git

mkdir ~/q3
mkdir ~/.q3a
mkdir ~/.q3a/baseq3

Entramos en los sources y, sin más, hacemos:
CFLAGS="-O2 -march=native -mtune=native -O2 -DSDL_DISABLE_IMMINTRIN_H" \
CXXFLAGS="-O2 -march=native -mtune=native -O2 -DSDL_DISABLE_IMMINTRIN_H" make -j4

En X86_64, con hacer make -j4, vale.

Cuando acabe, hacemos:
cd build/release-linux-<nombre_arquitectura>
cp oiquake3* renderer*.so ~/q3
cp -R baseq3/* ~/.q3a/baseq3/ 

Nos bajamos los pak*.pk3 desde el 1 al 8. Los puedes bajar de aquí:
https://github.com/nrempel/q3-server/tree/master/baseq3
...Y los metemos todos en ~/.q3a/baseq3

En la Pi, como NO HAY OpenGL y GLES no vale, sólo Vulkan, creamos:
~/.q3a/baseq3/q3config.cfg
Con el contenido:
seta cl_renderer "vulkan"

Y ya deberíamos poder lanzar el juego, simplemente ejecutando ~/q3/ioquake3.<nombre_arquitectura>

Para activar el renderer Vulkan, sacamos la consola con la tilde (es decir, con ~) y escribimos:
/cl_renderer vulkan
/vid_restart

Y vamos que está bien con:
/vkinfo

ACTUALIZAR RASPBERRY PI OS SIN ACTUALIZAR EL KERNEL
===================================================

Útil para cuando tenemos un kernel especial instalado, como por ejemplo el kernel realtime de: https://github.com/kdoren/linux/releases/

Se hace poniendo el paquete raspberrypi-kernel en "hold", tal que así:

-Actualizamos el índice de paquetes como siempre:
sudo apt-get update

-Ponemos el paquete del kernel en hold:
sudo apt-mark hold raspberrypi-kernel

-Actualizamos los paquetes normalmente. Como el paquete del kernel está en holdo, no se actualizará:
sudo apt-get upgrade

Opcionalmente, si quieres, puedes quitar el hold del paquete del kernel al acabar, haciendo:
sudo apt-mark unhold raspberrypi-kernel

REVENGE OF TITANS EN GNU/LINUX
==============================

Hay un tutorial aquí:
https://www.raspberrypi.org/forums/viewtopic.php?t=290589

El juego usa tres librerías cuyas versiones aarch64 necesitas: 
liblwjgl.so
libopenal.so
lwjgl.jar

Para conseguirlas, vamos al configurador online de LWJGL:
https://www.lwjgl.org/customize
Generamos el paquete, y en los *natives de cada librería tienes los .so que necesitas.
SUSTUTUYE las versiones que trae el juego con las que acabas de generar.

ACCEDER A DISPOSITIVOS USB DESDE ORACLE VIRTUALBOX
==================================================

-Añadir al usuario al grupo vboxusers:
sudo usermod -a -G vboxusers manuel

-Instalar, en el VirtualBox, las "Oracle VM Virtual Box Extension Pack", correspondiente a la versión de VirtualBox que tengas instalada
y que puedes descargar aquí:
https://download.virtualbox.org/virtualbox

-Instalar, en la máquina virtual, las "Virtual Box Guess Additions", que vienen en una ISO llamada "VBoxGuestAdditions.iso"
correspondiente a la versión de VirtualBox que tengamos instalada, y que puedes descargar aquí:
https://download.virtualbox.org/virtualbox/
Tienes que montar la ISO desde la barra superior cuando estés ejecutando la máquina, en DEVICES->OPTICAL DRIVES.

-OJO: Usa USB 2.0 en los dispositivos USB del VirtualBox (en Settings->USB), si usas USB 3.0 probablemente no funcione.

EXTRAER ARCHIVOS DE JUEGOS DE SWITCH EN LINUX
=============================================

Clonamos el repo de la herramienta que se usa:
git clone --depth 1 https://github.com/jakcron/nstool.git
git submodule update --init

compilamos:
make deps -j4
make -j4

Para extraer simplemente hacemos:

nstool -x ./extract_dir/ some_file.nsp

AMS (Advanced Mac Substitute) en LINUX
=======================================

Clonamos el repo:
git clone --depth 1 https://github.com/jjuran/metamage_1

Hacemos:
make ams-linux
(Para X11, make ams-x11)

Para lanzar el programa demo, desde el directorio de los sources:
EXHIBIT_INTERACT=interact-x11 PATH="$PWD/var/demo:$PWD/var/out:$PATH" AMS_BIN=var/links/ams-68k-bin/bin AMS_LIB=var/links/ams-68k-bin/lib AMS_MNT=var/links/ams-68k-bin/mnt var/out/minivx -Z v/bin/ams.vx

Para lanzar el Tic-tac-toe, que es otra demo, simplemente tenemos que añadir AMS_APPNAME=Tic-tac-toe
Lo mismo con "Nyanochrome Cat":

EXHIBIT_INTERACT=interact-x11 PATH="$PWD/var/demo:$PWD/var/out:$PATH" AMS_BIN=var/links/ams-68k-bin/bin AMS_LIB=var/links/ams-68k-bin/lib AMS_MNT=var/links/ams-68k-bin/mnt AMS_APPNAME=Tic-tac-toe var/out/minivx -Z v/bin/ams.vx

EXHIBIT_INTERACT=interact-x11 PATH="$PWD/var/demo:$PWD/var/out:$PATH" AMS_BIN=var/links/ams-68k-bin/bin AMS_LIB=var/links/ams-68k-bin/lib AMS_MNT=var/links/ams-68k-bin/mnt AMS_APPNAME="Nyanochrome Cat" var/out/minivx -Z v/bin/ams.vx

¿CÓMO FUNCIONA TODO ESTO?
Pues ams.vx, que es un script escrito en Varyx (??), que llama a exhibit que a su vez va llamando a otras herramientas que ya serían ejecutables nativos de Linux.
Por ejemplo, si miras los ejemplos que he puesto, interact-x11 es el frontend x11. (Idealmente habría un interact-sdl2).
Lo que nos interesa son los frontent, es decir, interact-*.

Y si quisieras instalar system-wide:

sudo make ams-linux-inst

EJECUTAR VKCUBE SIN LAS X
=========================

vkcube -m khr -k 0:0:0
(display 0, modo 0, plano 0. Usa --help para más información).

INSTALAR CERTIFICADO DIGITAL
============================

Nos vamos a https://www.sede.fnmt.gob.es/certificados/persona-fisica/obtener-certificado-software
Este va a ser nuestro índice general desde el que vamos haciendo las cosas.

-Primero nos bajamos el programa de Configuración previa, que es un .DEB. 
¡¡¡CUIDADO!!! Antes de instalarlo, instalamos sus dependencias previas:
sudo apt-get install libcanberra-gtk-module libcanberra-gtk3-module --no-install-recommends
Luego ya lo instalamos:
sudo dpkg -i configuradorfnmt_1.0.1-0_amd64.deb

-Ahora nos vamos a la parte de "Solicitud via internet de su certificado". Rellenamos el formulario y lo enviamos.
Nos llegará al correo un código, que junto con el DNI se presenta en un registro (Ayto por ejemplo) y nos dan el certificado.

PARTE 2: AUTOFIRMA

Instalamos dependencias previas:
sudo apt-get install openjdk-11-jre libnss3-tools

Se descarga un .deb desde: https://firmaelectronica.gob.es/Home/Descargas.html
Lo instalamos con dpkg desde la consola de comandos. Este paquete instala:
-El programa Autofirma, hecho en Java. En este punto, deberíamos ser capaces de ejecutar desde la consola "Autofirma" sin errores de Java.
-Un certificado en /usr/lib/Autofirma, que nosotros tenemos que importar manualmente desde Firefox, que es lo que vamos a hacer a continuación.

Ahora nos vamos en Firefox a Settings->Privacy & Security->Certificates, y en la pestaña de Authorities,
importamos el certificado /usr/lib/Autofirma/AutoFirma_ROOT.cer

CON EL CERTIFICADO DIGITAL, ADEMÁS, PODEMOS ACCEDER A LA CARPETA CIUDADANA EN: https://carpetaciudadana.gob.es/carpeta/clave.htm
(NO TIENES QUE ANDAR CON CL@AVE: DONDE PUEDAS ACCEDER CON CL@VE PUEDES ACCEDER CON EL CERTIFICADO DIGITAL).

AUTOMONTAJE DE DISPOSITIVOS DE ALMACENAMIENTO USB EN GNU/LINUX
==============================================================

-Al más bajo nivel, para que cuando udev detecte el disco se active el servicio de montaje,
creamos /etc/udev/rules.d/99-local.rules con el contenido:


KERNEL=="sd[a-z][0-9]", SUBSYSTEMS=="usb", ACTION=="add", RUN+="/bin/systemctl start usbmount@%k.service"
KERNEL=="sd[a-z][0-9]", SUBSYSTEMS=="usb", ACTION=="remove", RUN+="/bin/systemctl stop usbmount@%k.service"


-Ahora creamos el servicio de montaje, que llamaremos usbmount, en /etc/systemd/system/usbmount@.service, con el contenido:


[Unit]
Description=Mount USB Drive on %i

[Service]
Type=oneshot
RemainAfterExit=true
ExecStart=/usr/local/bin/usbmount add %i
ExecStop=/usr/local/bin/usbmount remove %i


-Creamos el script de montaje, que será llamado/usado por el servicio de montaje para hacer el montaje en sí,
y que también llamaremos usbmount, en /usr/local/bin/usbmount con el contenido:


#!/bin/bash
ACTION=$1
DEVBASE=$2
DEVICE="/dev/${DEVBASE}"

# See if this drive is already mounted, and if so, where
MOUNT_POINT=$(/bin/mount | /bin/grep ${DEVICE} | /usr/bin/awk '{ print $3 }')

# Mount or dismount
case "${ACTION}" in

	add)
		# If already mounted, exit
		if [[ -n ${MOUNT_POINT} ]]; then exit 1; fi

		# Get info for this drive: $ID_FS_LABEL, $ID_FS_UUID, and $ID_FS_TYPE
		eval $(/sbin/blkid -o udev ${DEVICE})

		# Figure out the mount point to use, based on the device label
		LABEL=${ID_FS_LABEL}	
		MOUNT_POINT="/media/${LABEL}"

		# Create the mountpoint
		/bin/mkdir -p ${MOUNT_POINT}

		# Global mount options
		OPTS="rw,relatime"				

		# FAT file system specific mount options (meh)
		if [[ ${ID_FS_TYPE} == "vfat" ]]; then
			OPTS+=",users,gid=100,umask=000,shortname=mixed,utf8=1,flush"
		fi

		# Let's mount! Delete the mountpoint and exit if failed
		if ! /bin/mount -o ${OPTS} ${DEVICE} ${MOUNT_POINT}; then
			/bin/rmdir ${MOUNT_POINT}
			exit 1
		fi
        ;;

	remove)
		if [[ -n ${MOUNT_POINT} ]]; then
			/bin/umount -l ${DEVICE}
			/bin/rmdir ${MOUNT_POINT}
		fi
        ;;
esac


-Le damos permisos de ejecución al script de montaje:
chmod +x /usr/local/bin/usbmount

-Recargamos las udev rules y los servicios:
udevadm control --reload-rules
systemctl daemon-reload

...Y ya deberíamos tener los dispositivos de almacenamiento USB automáticamente montados en /media/...

ACELERACIÓN DE VÍDEO EN LA PI4 CON VLC
======================================

El repo de VLC está en:
https://code.videolan.org/videolan/vlc

--Clonamos su repo:
git clone --depth 1 https://code.videolan.org/videolan/vlc.git
--Antes de configurar:
----Instalamos libtool:
apt-get install libtool --no-install-recommends
----Ejecutamos el script "bootstrap" que viene con los sources.

--Configuramos con:
meson -Dbuildtype=release -Dwayland=enabled -Dvideolan_manager=false -Drun_as_root=true -Dssp=disabled -Dbranch_protection=disabled \
-Dqt=disabled -Dx11=disabled -Dlua=disabled -Dpulse=disabled -Ddbus=disabled -Davahi=disabled -Dgles2=enabled \
-Dtheoraenc=disabled -Ddaalaenc=disabled ..

NOTA: Si usamos el antiguo configure && make, configuramos con:
./configure --without-x --disable-xcb --enable-wayland --disable-qt --disable-ncurses --enable-v4l2 --disable-mmal \
--enable-gles2 --disable-lua --disable-a52 --disable-freerdp --disable-vnc

ARREGLAR ROMS CON ROMVAULT
==========================

-Nos bajamos el exe del RomVault de: https://www.romvault.com/
Se ejecuta con Mono: mono ROMVault36.exe

-Nos vamos bajando los .DAT de los sistemas que queramos arreglar de:
https://datomatic.no-intro.org
...Y los metemos en el directorio DatRoot del RomVault

-Metemos los juegos de los sistemas que queramos reparar en el directorio RomRoot del RomVault

-En RomVault, le damos a "Update Dats", luego a "Find Fixes" y luego a "ROM Fixes"
Te dejará las ROMs (que pueda identificar) con los nombes correctos puestos en RomRoot/<NOMBRE_SISTEMA>,
y las que no pueda identificar en ToSort/<NOMBRE_SISTEMA>
...Le puedes poner nombes de no-intro a las ROMs parcheadas, que son las que suelen acabar en ToSort,
y así RetroArch te las reconoce y les pone thumbnails.

DRICONF
=======

Es la manera de configurar cosas de los drivers MESA.
El fichero de configuración va en ~/.drirc

La manera correcta de generarlo es usando "adriconf" (necesita GTK):
git clone --depth 1 https://gitlab.freedesktop.org/mesa/adriconf

COMPILAR WINE EN DEBIAN AMD64
=============================

NOTA: POR AHORA, SI NO INSTALAS LAS LIBERRÍAS DE 32BITS, SÓLO VALE PARA EJECUTAR PROGRAMAS X86_64, NO LOS JUEGOS DE 32BITS QUE QUIERES.
CUANDO HAYA UNA VERSIÓN PÚBLICA DE **BOX32** (de ptitSeb) LO PODRÁS USAR CON WINE PARA LANZAR JUEGOS DE 32 BITS.

INSTALAMOS DEPENDENCIAS PREVIAS:
apt-get install libxkbregistry-dev

VAMOS CON WINE EN SÍ:
--Bajamos los sources de la última estable de:
https://gitlab.winehq.org/wine/wine/-/releases
--Configuramos con:
./configure --enable-win64 --without-x \
--without-pulse --without-cups --without-gphoto --without-opencl --without-pcap --without-pcsclite \
--without-dbus --without-sane --without-oss --without-krb5 --without-netapi --without-capi

REPRODUCCIÓN DE VÍDEO EN AMD64 Y RASPBERRY PI CON MPV + FFMPEG
==============================================================
Página aclaratoria sobre el asunto: https://wiki.debian.org/HardwareVideoAcceleration

-En AMD64, se hace con la decodificación por hardware con VAAPI, por eso hay un bloque exclusivo de AMD64.
-En Raspberry Pi 5 NO HAY decodificación de H264 por hardware ya, la han quitado, va por software.
Y en la Raspberry Pi 4, aunque había decodificación de H264 por hardware, era más lenta que por software,
y requería usar un fork especial de ffmpeg, así que pasando.

###########BLOQUE EXCLUSIVO DE AMD64################

	PARTE 1: INTEL MEDIA DRIVER
(Es para Gen8 y posteriores, para otros chips más antiguos hacen falta otros drivers específicos).

--Instalamos dependendias previas:
apt-get install libigdgmm-dev --no-install-recommends
--Instalamos otra dependencia previa, libigdgmm, que la versión que viene con DEBIAN 12 es demasiado antigua
  y si no instalamos una actual, la compilación del driver fallará.
  Bajamos la última estable de aquí: https://github.com/intel/gmmlib/tags
  Configuramos con:

  mkdir b4
  cd b4

  cmake .. -DCMAKE_BUILD_TYPE=Release \
  -DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
  -DCMAKE_C_FLAGS="-march=native -mtune=native"   

Vamos con el Intel Media Driver en sí:

Bajamos la última estable de:
https://github.com/intel/media-driver/releases

Configuramos con:

mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

	PARTE 2: LIBVA

Bajamos la última estable de:
https://github.com/intel/libva/releases

Configuramos con:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" CXXFLAGS="-march=native -mtune=native" \
meson setup .. -Dbuildtype=release

	PARTE 3: VAINFO

Necesitamos VAINFO para ver qué aceleración soporta nuestra CPU:

Bajamos la última estable de:
https://github.com/intel/libva-utils/releases

Configuramos con:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" CXXFLAGS="-march=native -mtune=native" \
meson setup .. -Dbuildtype=release

Una vez instalado, podemos ejecutar "vainfo" para ver qué métodos de aceleración soporta nuestro chip.

###########FIN BLOQUE EXCLUSIVO DE AMD64################

	PARTE 4: FFMPEG
	
SÓLO AMD64: Instalamos dependenci previa: apt-get install nasm

VAMOS CON FFMPEG EN SÍ:

Bajamos la última estable de: https://github.com/FFmpeg/FFmpeg/tags

-Configuramos con:

PARA X64_64:
CFLAGS="-march=native -mtune=native" CXXFLAGS="-march=native -mtune=native" ./configure --disable-network --disable-debug \
--disable-muxers --disable-encoders --disable-indevs \
--disable-outdev=fbdev,oss \
--disable-doc --disable-bsfs \
--disable-sdl2 --disable-stripping \
--disable-thumb --disable-mmal \
--enable-libdrm --enable-vaapi

PARA RASPBERRY PI5 (es lo mismo pero en vez de "--enable-vaapi" le pasamos "--enable-neon"):
CFLAGS="-march=native -mtune=native" CXXFLAGS="-march=native -mtune=native" ./configure --disable-network --disable-debug \
--disable-muxers --disable-encoders --disable-indevs \
--disable-outdev=fbdev,oss \
--disable-doc --disable-bsfs \
--disable-sdl2 --disable-stripping \
--disable-thumb --disable-mmal \
--enable-libdrm --enable-neon

(NOTA: para tener ffplay, activa el soporte SDL2 quitando --disable-sdl2 : ffplay está pensado precisamente como un player simple
sobre SDL2 y es el único backend que tiene).

(NOTA: SI HUBIÉSEMOS ACTIVADO EL SOPORTE DE SDL2, podríamos reproducir vídeos con ffplay, para ello:
Lo primero, vermos qué codecs puede hacer por hardware la Pi: ffmpeg -codecs | grep v4l2m2m
Y ahora elegimos un codec y reproducimos el vídeo usándolo: ffplay -codec:v h264_v4l2m2m -fs <fichero_vídeo>
PERO no es muy productivo porque reproducir vídeo fullhd sobre SDL2 es lento).

	PARTE 5: MPV
	
-Instalamos dependencias previas: apt-get install libass-dev --no-install-recommends

-Instalamos otra dependencia previa, libplacebo, que está en Debian 12 pero arrastra toda la mierda de X11
así que la compilamos nosotros.
--Clonamos su repo:
git clone --depth 1 https://code.videolan.org/videolan/libplacebo.git
cd libplacebo
git submodule update --init --recursive
--Configuramos con:	

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup -Ddemos=false -Dbuildtype=release ..

VAMOS CON MPV EN SÍ:

-Instalamos dependencias previas:
apt-get install libass-dev --no-install-recommends

-Bajamos la última estable de: https://github.com/mpv-player/mpv/releases

-Configuramos con:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release ..

-Creamos ~/.config/mpv/mpv.conf con el contenido:
fs=yes

En AMD64 puedes añadir:
hwdec=vaapi
video-sync=display-resample

(NO le pases "video-sync=display-resample" a la Pi, porque no va bien de ninguna manera).
(En realidad, no poner "hwdec" es suficiente, no haría falta poner "hwdec=vaapi".

LAS INSTRUCCIONES CON TODAS LAS OPCIONES DE MPV ESTÁN EN: https://mpv.io/manual/stable/

RECUERDA: Para ver los códecs de vídeo acelerados disponibles para el decoding:
mpv --hwdec=help
También podríamos ver las salidas de vídeo disponibles con:
mpv --vo=help
También podríamos ver las APIs de la GPU disponibles con:
mpv --gpu-api=help
...con el resto de cosas de las que quieras ver qué hay disponible, igual.

--OPCIONAL: Ponemos el refresco de pantalla a lo mismo que los frames por segundo del vídeo a reproducir,
usando para ello este script para lanzar el mpv:

####SCRIPT PARA PONER EL REFRESCO DE PANTALLA DEL VÍDEO A REPRODUCIR, LANZAR MPV Y RESTAURAR REFRESCO ORIGINAL AL ACABAR####
original_rate=`wlr-randr | grep current | cut -d ' ' -f 7`
original_res=`wlr-randr | grep current | cut -d ' ' -f 5`
new_rate=$(ffprobe -v 0 -of csv=p=0 -select_streams v:0 -show_entries stream=r_frame_rate "$1")

numerador=`echo $new_rate | cut -d/ -f 1`
denominador=`echo $new_rate | cut -d/ -f 2`

new_rate=`printf "%f\n" $((10**6 * numerador/denominador))e-6`

#echo ${original_rate}
echo "Setting rate: ${new_rate}"
wlr-randr --output HDMI-A-1 --custom-mode $original_res@$new_rate
echo "Rate set: `wlr-randr | grep current | cut -d ' ' -f 7`"

mpv "$1"

wlr-randr --output HDMI-A-1 --custom-mode $original_res@$original_rate
####FIN SCRIPT####
