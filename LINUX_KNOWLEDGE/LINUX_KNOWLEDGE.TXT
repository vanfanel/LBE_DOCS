============================================================================================================================================
LANZAR programas en sus propias CPUs (realtime, nada más puede ejecutarse ahí: garantia total probada con uso masivo de CPU
de housekeeping simultáneo)
============================================================================================================================================
MÁS SOBRE MEJORAR LA LATENCIA: https://rigtorp.se/low-latency-guide/
https://github.com/redno2/Application-latency-optimization-Linux

HABIENDO AISLADO LAS CPUs DEL 1 al 3 CON "isolcpus=1-3 nohz_full=1-3" EN CMDLINE.TXT: 
-Para lanzar algo no multithread:
taskset -c 3 ./retroarch
-Para lanzar algo MUY multithread (y que por tanto puede aprovechar varios cores):
chrt -f 80 taskset -c 1-3 <programa>
CUIDADO con el -f 99: si se te cuelgan cosas bájalo a 80, a 50... 80 va bien y es lo que uso ahora.
Con la otra política de tiempo real (SCHED_RR, que se usa pasando -r en lugar de -f pero que nos conviene menos porque reparte
rodajas de tiempo de manera continua y nos conviene más que los threads pillen la CPU y no la suelten hasta que acaben,
es decir, SCHED_FIFO, que es lo que usamos con -f), pasar -r 99 es un peligro y hay cuelgues.

PARA CONSEGUIR LO MISMO EN UN SISTEMA EN EJECUCIÓN:
-Instalamos este paquete: apt-get install cpuset
-Creamos un shield para proteger las CPUs 0 y 1:
cset shield --cpu=0-1 --kthread=on
NOTA: Al hacer esto, te saldrá que algunas tareas no se pueden sacar de esas CPUs (se supone que son tareas del kernel).
En teroría, eso es porque hay que aislar esas CPUs antes de arrancar, mira esto: https://www.codeblueprint.co.uk/2020/05/03/reducing-jitter-on-linux-with-task-isolation.html
-Mandamos ahí a correr el programa que queramos:
cset shield --exec -- <programa con sus argumentos>
-Podemos ver qué hay corriendo en nuestro shield con:
cset shield -s -v
-Para saber más: man cset-shield

PARA VER QUÉ PARÁMETROS DEL SCHEDULER PODEMOS AJUSTAR:
sysctl -A |grep sched

******Establecer una variable de entorno globalmente en el arranque*****************************************************

Aunque hasta ahora lo has hecho de las más peregrinas maneras, el modo "correcto" es en /etc/environment
Basta con poner "export, el nombre de la variable y el valor. Si no pones "export", aparece con echo pero no funciona.
export SDL_VIDEO_DOUBLE_BUFFER=1
Luego puedes comprobarlo con echo $<nombre_variable>, en plan:
echo $SDL_VIDEO_DOUBLE_BUFFER

*******Teclado en español y con la tilde (~) en la Ñ sin tener que darle dos veces***************************************

Editamos /etc/default/keyboard, y lo dejamos así:

XKBMODEL="pc105"                                                                                               
XKBLAYOUT="es"                                                                                                 
XKBVARIANT="deadtilde"                                                                                        
XKBOPTIONS=""                                                                                                  
BACKSPACE="guess"

Sin lo de "deadtilde", tenemos que darle a la Ñ dos veces para sacar la tilde, y es una mierda eso.

*******Visualizar los scancodes de las teclas desde la consola TTY*******************************************************

Con el comando showkeys

******Añadir un modo de vídeo con xrandr*********************************************************************************

gtf 1366 768 50
Y con el resultado de esto hacemos:
xrandr --newmode "1366x768_50.00" 69.92 1368 1424 1568 1768 768 769 772 791  -HSync +Vsync

xrandr --addmode eDP "1366x768_50.00"
xrandr --output eDP --mode "1366x768_50.00"

******Usar MANGOHUD******************************************************************************************************

--Clonamos su repo: git clone --depth 1 --recurse-submodules https://github.com/flightlessmango/MangoHud.git
--Compilamos con:
mkdir b4
cd b4

CFLAGS="-O2 -march=native -mtune=native -O2" \
CXXFLAGS="-O2 -march=native -mtune=native -O2" \
meson setup .. -Dbuildtype=release -Dwith_x11=disabled -Dwith_dbus=disabled -Dwith_xnvctrl=disabled -Dwith_nvml=disabled

ninja -j10
ninja install

--Para usarlo es simplemente con: mangohud <programa>

--Para que se vea más grande, creamos el fichero ".config/MangoHud/MangoHud.conf" con el contenido:
font_scale=3.0

--Para que se tomen muestras más frecuentes (por defecto es cada 500ms):
fps_sampling_period=32

--Tienes el resto de opciones disponibles documentadas en: https://github.com/flightlessmango/MangoHud

******IMPRIMIR DESDE UN MAKEFILE*****************************************************************************************

Se hace simplemente con:
@echo "hola mundo!"

PERO OJO: Si te da un error de "missing separator" métele un tabulador delante.

******Actualizar el firmware de un dispositivo 8bitdo (y de dispositivos en general) en GNU/Linux**********************

Se toma como ejemplo el 8BitDo Arcade Stick.
Información procedente de: https://ladis.cloud/blog/posts/firmware-update-8bitdo.html

Lo primero es instalar FWUPD: sudo apt-get install fwupd
Ahora conectamos el mando, y lo encendemos con START+SELECT presionados para entrar en modo UPDATE.
Ahora localizamos su DEVICE ID con: sudo fwupdmgr get-devices

Ahora localizamos el firmware que necesitamos. Para ello:
-Miramos en la tabla que está en: https://ladis.cloud/blog/posts/firmware-update-8bitdo.html
 Ahí averiguamos que el TYPE del 8BitDo Arcade Stick es el 34.
-Localizamos la ruta del fichero de firmware que tenemos que descargar. Para ello, hacemos:
curl -X POST -H 'Type: 34' -H 'Beta: 1' http://dl.8bitdo.com:8080/firmware/select
Ahí nos va a dar un chorro de texto en formato JSON, del que nos interesa lo que pone a continuación de "filePathName".
En "filePathName" pone "/firmwareFile/upload/1a70f919-b88e-4a07-b56b-a65524233caf.dat", así que lo unimos al dominio
de las descargas de 8BitDo, y nos queda que para descargar el firmware hacemos:
curl -X GET -O http://dl.8bitdo.com:8080/firmwareFile/upload/1a70f919-b88e-4a07-b56b-a65524233caf.dat
-Por último, flasheamos el firmware usando el "DEVICE ID" y el fichero de firmware que hemos descargado:
sudo fwupdtool install-blob 1a70f919-b88e-4a07-b56b-a65524233caf.dat 301046452a49d84af6356d23e43a684b8f10660f

******Hacer que se lean los diagnostics del bootloader de la Raspberry Pi 4 incluso cuando arranca correctamente*******

Editamos los parámetros de configuración del bootloader con:
rpi-eeprom-config --edit

Y añadimos ahí:
HDMI_DELAY=0

Más info sobre parámetros del bootloader aquí:
https://gitee.com/jikexianfeng/documentation/blob/master/hardware/raspberrypi/bcm2711_bootloader_config.md#/jikexianfeng/documentation/blob/master/hardware/raspberrypi/boot_diagnostics.md

******Conectar a una red WIFI desde Raspberry Pi OS con SystemD (forma recomendada)************************************

-Para conectarte automaticamente a una WIFI, lo mejor es tener activado el servicio NetworkManager y meter la red/contraseña en raspi-config,
en la seccion system->wireless lan.
Las redes conocidas quedan guardadas en /etc/NetworkManager/system-connections, en lugar de en /etc/wpa_supplicant/wpa_supplicant.conf

******Conectar a una WIFI desde Debian usando nmcli********************************************************************

-Activamos la WIFI
nmcli r wifi on

-Escaneamos las redes WIFI
nmcli dev wifi

-Nos conectamos a una red WIFI
nmcli dev wifi connect "wifi_name" password "wifi_password"

******Conectar a una red WIFI desde la Raspberry PI usando el WIFI interno*********************************************

PUEDE QUE NECESITES BAJAR MANUALMENTE EL FIRMWARE DEL WIFI SI AL HACER MODPROBE AL brcmfmac NO TE CREA EL INTERFACE WLAN0.
Si es así, tienes que bajarte los archivos:
brcmfmac43430-sdio.bin
brcmfmac43430-sdio.txt
Que están en:
https://github.com/RPi-Distro/firmware-nonfree/blob/master/brcm
Y meterlos en:
/lib/firmware/brcm/

Instalamos wpasupplicant así:
sudo apt-get install wpasupplicant --no-install-recommends

AHORA VAMOS A POR EL SCRIPT PARA LEVANTAR LA RED:

Lo primero es cargar el módulo del kernel que hace falta:
sudo modprobe brcmfmac

Ahora levantamos el interface wlan0
sudo ifconfig wlan0 up

Ahora tenemos que dejar /etc/wpa_supplicant/wpa_supplicant.conf así:

ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network={
        ssid="MOVISTAR_7A40"
        psk="E3UHR3Ca3FYgJ4e7elee"
}

Ahora conectamos con la base, pasándole al wpa_supplicant nuestra configuración:
sudo wpa_supplicant -d -Dnl80211 -iwlan0 -c/etc/wpa_supplicant/wpa_supplicant.conf -B
(El parámetro -B es para que corra en modo daemon, de fondo, retornando al prompt inmediatamente... ¡sin eso, se queda esa consola para él solo!)

OPCION 1 (recomendada)
Nos damos nosotros mismos una IP del rango del router y un gateway:
sudo ip addr add 192.168.1.12/24 dev wlan0
sudo ip route add default via 192.168.1.1

OPCIÓN 2
Obtenemos una IP para wlan0:
sudo dhclient wlan0
Ahora nos damos un gateway, que es la dirección del router en la red a la que acabamos de conectarnos:
sudo ip route add default via 192.168.1.1

...Comprobamos que en /etc/resolv.conf tenemos:
nameserver 8.8.8.8

Y ya deberíamos ser capaces de hacer ping al router en la 192.168.1.1, a la dns de google en 8.8.8.8, y a google.com si nos da la gana.

******Convertir CUE/BIN a CHD*********************************************************************************************************

Instalamos chdman:
sudo apt-get install mame-tools --no-install-recommends

Y para comprimir de CUE/BIN a CHD:
chdman createcd -i image.cue -o image.chd

Y para comprimir todos los CUE/BIN de un directorio a CHD:
for i in *.cue; do chdman createcd -i "$i" -o "${i%.*}.chd"; done

Y para extraer todos los CHD de un directorio a CUE/BIN:
for i in *.chd; do chdman extractcd -i "$i" -o "${i%.*}.cue"; done

Y para extraer de CHD a CUE/BIN:
chdman extractcd -i image.chd -o image.cue -ob image.bin

******Crear un disco de arranque con varias ISOS arrancables (útil para tener un sólo pen capaz de inslatar Debian Linux, Windows 10, etc)******

--Descargamos VENTOY de: https://github.com/ventoy/Ventoy/releases
  Nos descargamos el archivo ventoy*-linux.tar.gz, lo descomprimimos y ya, no hay que compilar nada.

--Instalamos VENTOY en el pendrive desde la consola de comandos (NO USES el GUI, porque se instala mal y luego no te deja copiar las ISOS):
  sudo ./Ventoy2Disk.sh -I /dev/<NODO_DEL_PENDRIVE>

--El VENTOY nos crea una partición EFI de 32MB para el arranque, y una grande con el resto del espacio del pendrive.
  Montamos la partición "grande" (se monta sola al acabar de instalar el VENTOY, si no pues con sacar y meter el pen ya está),
  y ahí copiamos la ISO de Windows que queramos.

--Metemos el pendrive en el ordenador donde queramos instalar, reiniciamos, establecemos o elegimos el pen como unidad de arranque,
  y nos presentará inmediatamente las diferentes ISOS que hemos metido. Elegimos una y listo.

******Descargar desde Myrient directorios completos usando RCLONE*********************************************************************
NOTA: Los sets NO-INTRO de Myrient están bastante más desactualizados de lo que estaban los de ARCHIVE.ORG,
así que por ahora sigue usando los que tengas de ARCHIVE.ORG aunque ya no se puedan descargar, porque serán más recientes.

--Instalamos RCLONE (instrucciones sacadas de https://rclone.org/install/):
sudo -v ; curl https://rclone.org/install.sh | sudo bash

--Configuramos RCLONE con "rclone config" y allí:
Añadimos una nueva conexión con "n" y la llamamos "myrient" por ejemplo.
Elegimos el tipo de almacenamiento 21 que es el "HTTP".
En el "Remote URL" ponemos "https://myrient.erista.me"
El resto de preguntas que nos hace las dejamos con los valores por defecto.
Salvamos y salimos de la configuración.

--Comprobamos que podemos acceder a los archivos:
rclone ls myrient:

--Descargamos con:
rclone --http-no-head sync <DIRECCIÓN_DEL_DIRECTORIO> <DIRECTORIO_DE_DESTINO> --http-no-head -P
(El nombre de directorio de destino nos lo crea, no tenemos que tenerlo creado de antemano)
(El "-P" es para ver el progreso, "--http-no-head", es para que no pida las HEAD de HTTP,
que indican el tamaño de archivo, etc.. pero hay que pedirlas por cada archivo y son muchos, así que nos interesa
que se ponga a descargarlo directamente).

Por ejemplo, para descargar el No-Intro de Atari 2600 haríamos:
rclone sync "myrient:/files/No-Intro/Atari - 2600/" "Atari - 2600" --http-no-head -P
(¡¡¡CUIDADO!!! ¡¡¡HAY QUE PONER LAS BARRAS DEL PRINCIPIO Y DEL FINAL DE LA RUTA AL DIRECTORIO!!!)

******Descargar desde ARCHIVE.ORG (BULK DOWNLOAD) desde la línea de comandos**************

(!!!!)NOTA: Los nombres de las colecciones que queremos bajar las sacamos del "ROMS MEGATHREAD", búscalo así en el buscador.

(!!!!)NOTA: Para archivos sueltos, lo más práctico y rápido para descargar de Archive NO es hacerlo desde la línea de comandos,
sino descargar desde el navegador usando un DOWNLOAD MANAGER. El más recomendable es "Turbo Download Manager" que es una extensión para Firefox.
PERO para bulk-download de romsets completos, sigue leyendo...

Normalmente se podría usar WGET, pero como hay items que sólo se pueden descargar estando logueado, y como archive.org usa HTTPS y no es posible
loguearse por HTTPS con WGET, pues al final con muchos items no funciona WGET y nos da el famoso error 403: "forbidden".

Así que usamos la librería de python llamada "internearchive", una herramienta de Internet Archive.
Instalamos la librería "internetarchive":

pip install internetarchive

NOTA: Si al acabar de instalar no te encuentra el ejecutable "ia", añade al final de .bashrc:
export PATH="$PATH:/home/manuel/.local/bin"

Ahora configuramos la librería "ia", para darle nuestro user/pass:

ia configure

Y AHORA instalamos el script downloader en python también que vamos a usar:
(Con "ia" se puede descargar, pero NO soporta resume así que no me vale).

git clone --depth 1 https://github.com/john-corcoran/internetarchive-downloader.git
sudo cp ia_downloader.py /usr/local/bin/ia_downloader
sudo chmod +x /usr/local/bin/ia_downloader
 
Editamos /usr/local/bin/ia_downloader, y buscamos "Reducing download threads" para allí, justo debajo,
ajustar el número de bajadas simultáneas, que viene puesto a 5 y si le pasamos más desde la línea de comandos lo recorta a 5,
pero le metemos 20 o 30.

Descargamos tal que así. Para bajarnos una colección completa al directorio actual...:

ia_downloader download -i nointro.gb ./

Para bajarnos sólo unos ítems concretos de una colección (por ejemplo los romsets completos de SNES y Megadrive):

ia_downloader download -i no-intro_romsets ./ -f Super\ Nintendo Megadrive

Y para continuar si se cortó la bajada anterior:

ia_downloader download -i no-intro_romsets ./ -f Super\ Nintendo Megadrive -r

Ahora, si quisieras comprimir cada ROMSET en un zip:
for i in */; do zip -r "${i%/}.zip" "$i"; done

******Descargar vídeos de RTVE A LA CARTA*********************************************************************************************

INFO PROCEDENTE DE: https://obiwan2208.wordpress.com/2018/05/23/videos-rtve-2018/
(Válida a Enero de 2023)

Entramos en la página de la peli o lo que sea que queremos bajar.
En un área vacía de la pagina hacemos clic derecho y seleccionamos Inspect.
Hacemos clic en la pestaña Network, subpestaña XHR.
En ese momento, le damos a que empieze a reproducirse el vídeo, y esperamos a que empiezen a aparecer líneas ahi en la tabla.
Clicamos en una de esas líneas, y le damos a la subpestaña Headers: y ahí tenemos una URL del vídeo. La copiamos hasta el ".mp4"
y ya lo podemos descargar alegremente con WGET.

******Descargar contenidos de ITunes desde Linux sin ITunes***************************************************************************

El programa se llama tunesviewer.
Si te da un error y no te deja buscar, dale a view y desactiva Request HTM5 Mode.
Cambia la búsqueda a Podcast Search.

*******Eliminar la BASURA de repositorios de Micro$oft de Raspbian/RaspberryPiOS*****************************************************

sudo rm /etc/apt/sources.list.d/vscode.list
sudo rm /etc/apt/trusted.gpg.d/microsoft.gpg
sudo apt update

******Hacer que lo que conectamos en un puerto USB siempre aparezca en un nodo de /dev determinado***************************

Mediante UDEV rules. Por ejemplo, para joysticks compatibles con XBOX360 (como el 8bitdo SN30Pro), hacemos esto.

1- Obtenemos la información que necesitamos ejecutando: 

udevadm info --name=/dev/input/js0 --attribute-walk

Mirando el segundo device (es decir, el segundo bloque "looking at parent device...", nos interesan estas cosas:

ATTRS{phys}=="usb-0000:01:00.0-1.3/input0"
ATTRS{name}=="Microsoft X-Box 360 pad"

También nos interesa el SUBSYSTEM, que vemos que es "input".

2) Creamos /etc/udev/rules.d/80-joysticks.rules con un contenido como así:
 
SUBSYSTEMS=="input", ATTRS{name}=="Microsoft X-Box 360 pad", ATTRS{phys}=="usb-0000:01:00.0-1.3/input0", NAME="input/js8"

Recargamos las UDEV RULES sin reiniciar, así:

udevadm control --reload-rules && udevadm trigger

Podemos monitorear los eventos de UDEV con:
udevadm monitor -p

******Probar los dispositivos de audio con speaker-test**********************************************************************

Puedes ver los dispositivos disponibles con: aplay -L
Tiene que ser -L mayúscula.

Ten en cuenta que cada dispositivo puede tener una o varias tarjetas.
Le puedes pasar el dispositivo que quieras a speaker-test en formato dispositivo:tarjeta_que_quieras_de_ese_dispositivo

Por ejemplo, en la Pi4, verás uno de los primeros así:

hw:CARD=vc4hdmi0,DEV=0
    vc4-hdmi-0, MAI PCM i2s-hifi-0
    Direct hardware device without any conversions

Pues puedes pasárselo a speaker-test así:
speaker-test -D default:vc4hdmi0
Donde estás diciéndole a speaker-test que use el dispositivo "default" (la definición específica de "default" para el device
vc4hdmi está en /usr/share/alsa/cards/vc4-hdmi.conf) y que dentro de ese dispositivo "default" use la tarjeta "vc4hdmi0".

Podríamos INTENTAR usar directamente el dispositivo "hw", por ejemplo:
speaker-test -D hw:vc4hdmi0
...Pero "hw" es directamente "Direct hardware device without any conversions", sin DMIX, y sólo acepta un formato
llamado IEC958_SUBFRAME_LE, así que no funciona directamente con speaker-test porque speaker-test
no puede generar audio en formato IEC958_SUBFRAME_LE. De hecho, ningún programa, en general, puede hacer eso.

******Ver los modos soportados de una pantalla/monitor (EDID)****************************************************************

Se puede volcar y ver con:
cat /sys/class/drm/card1-HDMI-A-0/edid | edid-decode

******Hackeando el EDID para cambiar el rango de VRR (VRR range)*************************************************************
INFO EN GRAN PARTE SACADA DE:
https://wiki.archlinux.org/title/Variable_refresh_rate#Change_VRR_range_of_a_FreeSync_monitor

--Lo primero, necesitamos un kernel con "CONFIG_DRM_LOAD_EDID_FIRMWARE" activado.
Lo comprobamos con:
grep CONFIG_DRM_LOAD_EDID_FIRMWARE /boot/config-6.12.12

--Obtenemos el EDID de la pantalla:
cp /sys/class/drm/card0-DP-1/edid ./edid2.bin

--Vemos que parámetros trae ese EDID para ver si realmente queremos cambiar algo:
sudo apt-get install edid-decode
edid-decode edid2.bin
Ejecutamos "edid-decode edid2.bin" y miramos qué Range Limits trae el EDID originalmente. Será algo como:

Display Range Limits:
      Monitor ranges (Bare Limits): 48-146 Hz V, 180-180 kHz H, max dotclock 340 MHz
      
Esos valores nos van a hacer falta para cambiar el EDID a nuestro gusto.

ALTERNATIVA 1: EDITAR EL EDID CON EL CRU DE WINDOWS (WINE) (Es la forma más sencilla de hacerlo)

--Nos bajamos el CRU de: https://www.monitortests.com/forum/Thread-Custom-Resolution-Utility-CRU
--Lo ejecutamos con WINE. Va sin ningún problema.
--Abrimos el EDID dándole a "IMPORT"
--Cambiamos los RANGE LIMITS dándole a "EDIT" arriba a la derecha
(OJO!!! ARRIBA A LA DERECHA, HAY OTROS BOTONES "EDIT" MÁS ABAJO, PERO USAMOS ESE PARA CAMBIAR LOS RANGE LIMITS!!!)
--Salvamos el EDID modificado dándole a "EXPORT".
--Ya está!! Ahora ve a la sección de cómo cargarlo en Linux.

ALTERNATIVA 2: EDITAR EL EDID CON PROGRAMAS DE CONSOLA

--Abrimos el edid con el hexedit, buscamos la cadena en hexadecimal "FD" que es como comienza la sección de los Display Range Limits
  (para ello pulsamos la barra del siete y metemos la cadena)
  y los siguientes bytes son "FD 00 30". Pues ese 30 en hex es 48 en decimal.
  Lo cambiamos por 1E, que es 30 en decimal, salvamos y salimos (Crtl+x).

--Corregimos el checksum del EDID, ya que hemos hecho un cambio:

EXTRAEMOS EL BLOQUE 0 Y CORREGIMOS SU CHECKSUM:
head -c 127 edid2.bin > block0.bin
checksum=$(xxd -p block0.bin | tr -d '\n' | sed 's/\(..\)/0x\1 /g' | awk '{s=0; for (i=1; i<=127; i++) s+=strtonum($i);} END {print (256 - (s % 256)) % 256}')
printf "$(xxd -p block0.bin)%02x" $checksum | xxd -r -p > block0_fixed.bin

EXTRAEMOS EL BLOQUE 1 Y CORREGIMOS SU CHECKSUM:
tail -c +129 edid2.bin > block1.bin
checksum=$(xxd -p block1.bin | tr -d '\n' | sed 's/\(..\)/0x\1 /g' | awk '{s=0; for (i=1; i<=127; i++) s+=strtonum($i);} END {print (256 - (s % 256)) % 256}')
printf "$(xxd -p block1.bin)%02x" $checksum | xxd -r -p > block1_fixed.bin

JUNTAMOS LOS DOS BLOQUES Y CORREGIMOS SU TAMAÑO:
cat block0_fixed.bin block1_fixed.bin > edid_fixed.bin
mv edid_fixed.bin edid2.bin
truncate -s 256 edid2.bin

--Comprobamos con edid-decode que ahora tenemos:

    Display Range Limits:
      Monitor ranges (Bare Limits): 30-146 Hz V, 180-180 kHz H, max dotclock 340 MHz

ALTERNATIVA 3: EDITAR EL EDID CON OTROS PROGRAMAS DE ESCRITORIO MÁS CUTRES (NO RECOMENDADO)

--OPCIÓN 2: Instalamos "AW EDID Editor" que es con lo que lo vamos a editar. Es un programa de Windows pero funciona en WINE.
Una ver abierto el EDID en el AW, nos vamos a:
"EDID Base > Detailed Descriptor > Block Descriptor > Block 2", y allí a "Block Descriptor Type > Display > Range Limits". 
Ahí usamos los valores de los "Display Range Limits" que tenemos para rellenar los campos:
Siguiendo el ejemplo, ponemos "Min H. Rate" a 180, "Max H. Rate" a 180, y "Max Pixel Clk" a 340.
Y ahora ya podemos ajustar el VRR Range como queramos rellenando los campos "Min V.Rate" y "Max V.Rate".
Yo los he puesto a 30 y 140 respectivamente.  
LO MALO DE ESTE MÉTODO es que nos salen dos "Display Range Limits" (habría que eliminar la primera con el Hexedit,
buscando la cadena hexadecimal "FD" y borrando eso y los siguientes N bytes, así que para eso... pues mejor usa el hexedit directamente).

--OPCIÓN 3 (NO LO HAGAS, ESTE PROGRAMA ES UNA REPUTA MIERDA)
  Alternativamente se podría usar "wxedid", nativo de Linux pero con una usabilidad peor.
  Se instala en Debian y derivados así: apt-get install wxedid

USAR EL EDID ALTERADO EN LINUX

--Metemos el EDID alterado en un lugar donde lo podamos cargar desde el arranque:
mkdir -p /usr/lib/firmware/edid
cp edid2.bin /usr/lib/firmware/edid/

--Cargamos el EDID alterado añadiendo esto a los parámetros del kernel:
drm.edid_firmware=DP-1:edid/edid2.bin
(OJO!!! No te olvides de ejecutar "update-grub" antes de reiniciar!!!)

--Comprobamos que tenemos los valores que queremos:
edid-decode /sys/class/drm/card0-DP-1/edid

******Sangre roja en el Metal Slug de Neo Geo*********************************************************************************

En QUICK MENU->OPTIONS, ponemos NEO-GEO MODE a UNIBIOS.
Ahora, una vez dentro del juego, mantenemos pulsado START y nos sale un menú donde podemos activar varias cosas,
entre ellas la sangre roja o poner el juego en idiomas locos.

COMPILAR/INSTALAR WINE EN DEBIAN AMD64
======================================

NOTA: A día de hoy, mediante NEW WOW64 podemos ejecutar programas de 32bits (win32) sin librerías de 32bits.
Para eso sirve "--enable-archs=x86_64,i386".
NO HACE FALTA hacer lo de "WINEARCH=win32 winecfg", ya que de hecho eso no funciona en modo WOW64.

INSTALAMOS DEPENDENCIAS PREVIAS (mingw es necesario para compilar un WINE con soporte de WoW64):
apt-get install libxkbregistry-dev flex bison libusb-dev libusb-1.0-0-dev mingw-w64 mingw-w64-x86-64-dev --no-install-recommends
(Si usas el gstreamer del sistema, hay que instalar libgstreamer-plugins-base1.0-dev).

INSTALAMOS OTRA DEPENDENCIA PREVIA: libgstreamer (no podemos instalar la de Debian porque nos mete la porquería de X11 y MESA viejo)
--Clonamos su repo: git clone --depth 1 https://github.com/GStreamer/gstreamer.git
--Configuramos con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup .. -Dbuildtype=release -Dgst-plugins-bad:avtp=disabled -Dgst-examples=disabled -Drtsp_server=disabled \
-Dtests=disabled -Dtools=disabled -Dexamples=disabled -Dbenchmarks=disabled -Dorc=disabled -Ddevtools=disabled

VAMOS CON WINE EN SÍ:
--Bajamos los sources de la última estable de:
https://gitlab.winehq.org/wine/wine/-/releases
--Configuramos con:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure --without-x --with-wayland \
--without-pulse --without-cups --without-gphoto --without-opencl --without-pcap --without-pcsclite \
--without-dbus --without-sane --without-oss --without-krb5 --without-netapi --without-capi \
--without-gettext --without-gnutls --without-v4l2 --without-odbc --enable-archs=x86_64,i386

(Lo de "--enable-archs=x86_64,i386" es necesario para compilar con soporte WoW64, es decir, ejecutar juegos de 32bits
 sin tener las versiones i386 de todas las librerías instaladas).
(Si compilas para un sistema con escritorio X11, NO le pases "--without-x").

Ahora hacemos:
wine reg add "HKEY_CURRENT_USER\Software\Wine\Drivers" /v Graphics /t REG_SZ /d wayland

...Y ya debería ir WINE sobre Wayland puro y con programas de 32bits usando el modo WoW64. Prueba a hacer "winecfg" o bien "wine notepad"

******LAS FUENTES DE LETRA EN WINE SE VEN MUY PEQUEÑAS**********************************************************************

Ejecutamos "winecfg", vamos a la pestaña "Graphics" y allí ponemos "Screen Resolution" a un valor de unos 168.

******DIRECTX SOBRE VULKAN USANDO WINE**************************************************************************************

OPCIÓN 1 (RECOMENDADO): USANDO DXVK

--Clonamos su repo:
git clone --depth 1 --recurse-submodules https://github.com/doitsujin/dxvk.git

--Compilamos las versions de 32 bits:

mkdir build32
cd build32

CFLAGS="-O2 -march=native -mtune=native -O2" \
CXXFLAGS="-O2 -march=native -mtune=native -O2" \
meson setup .. -Dbuildtype=release --cross-file ../build-win32.txt

ninja -j10

--Las metemos en el profile de Wine que estemos usando:
find ./ -name "*.dll" -exec cp {} ~/.wine/drive_c/windows/syswow64 \;

--Compilamos las versions de 64 bits:

mkdir build64
cd build64

CFLAGS="-O2 -march=native -mtune=native -O2" \
CXXFLAGS="-O2 -march=native -mtune=native -O2" \
meson setup .. -Dbuildtype=release --cross-file ../build-win64.txt

ninja -j10

--Las metemos en el profile de Wine que estemos usando:
find ./ -name "*.dll" -exec cp {} ~/.wine/drive_c/windows/system32 \;

--Ejecutamos "winecfg", y allí vamos a la pestaña LIBRARIES, y vamos añadiendo overrides para "d3d8", "d3d9" y "d3d10",
poniéndolos a "NATIVE" solamente, y ya está, ya todo lo de DirectX 8, 9 y 10 te irá sobre Vulkan.

OPCIÓN 2: USANDO EL SOPORTE D3D->VULKAN QUE INCLUYE WINE DE SERIE

Ejecutamos "regedit", nos vamos a HKEY_CURRENT_USER\Software\Wine, añadimos una nueva clave llamada "Direct3D",
y dentro de ella añadimos un nuevo valor string llamado "renderer" al que daremos el valor "vulkan".

Alternativamente, podríamos hacer "winetricks renderer=vulkan", pero para eso hay que tener instalado winetricks.

******APOTRIS (clon de Tetris) en GNU/Linux**********************************************************************************
(OJO: POR AHORA no tiene soporte de pantalla completa ni de joystick, asi que espera a la version 4.1 de los sources).

-Actualizamos MESON a la ultima version (necesita MESON 1.1 como minimo). Tienes apuntes sobre ello en este fichero.

-Instalamos dependencias previas:
apt-get install xxd

-Clonamos su repo:
git clone --depth 1 https://gitea.com/akouzoukos/apotris.git

-Configuramos y compilamos con:

mkdir b4
cd b4

CFLAGS="-O2 -march=native -mtune=native -O2" \
CXXFLAGS="-O2 -march=native -mtune=native -O2" \
meson setup -Dbuildtype=release ..

-Ahora creamos el directorio ~/apotris, y mandamos alli el ejecutable "Apotris" que acabamos de compilar,
junto con el directorio "assets" que viene con los sources.

******Legend of Zelda: A Link to the Past (ZELDA3) nativo en GNU/Linux*******************************************************

Clonamos el repositorio:
git clone --depth 1 https://github.com/snesrev/zelda3.git

(ARREGLO TEMPORAL HASTA QUE MERGEEN MIS CAMBIOS)
-Editamos opengl.c y dejamos la línea:
viewport_width = viewport_height * g_draw_width / g_draw_height;  // limit width
como:
viewport_width = viewport_height * 4 / 3;  // limit width
(Podríamos también editar main.c y dejar la línea:
SDL_RenderSetLogicalSize(renderer, g_snes_width, g_snes_height);
como:
SDL_RenderSetLogicalSize(renderer, 4, 3);
...pero no es necesario porque usaremos el renderer OpenGL, NO el SDL, así que no nos aporta nada).

(PASO INNECESARIO: tienes los datos ya extraidos como zelda3_assets.dat en el disco de backup, sólo es meterlos en "~/zelda3/tables"):
--Si NO tenemos los datos extraidos
	-Instalamos las dependencias necesarias para extraer los datos de la ROM:
	python3 -m pip install -r requirements.txt
	-Copiamos la ROM USA a tables/zelda3.sfc, para que se extraigan los datos al compilar.

--Si ya tenemos los datos extraidos, para que NO se intenten extraer los datos sino sólo generar el ejecutable:
Editamos Makefile y dejamos la parte:
all: $(TARGET_EXEC) tables/zelda3_assets.dat
como:
all: $(TARGET_EXEC)

Compilamos con:

CFLAGS="-O3 -fomit-frame-pointer -march=native -mtune=native" make -j4

Ahora, mete el ejecutable resultante "zelda3", el "zelda3.ini" y tables/zelda3_assets.dat en ~/zelda3
(O sea, los datos tienen que quedar en ~/zelda3/assets/zelda3_assets.dat)

Nos metemos en el directorio ~/zelda3, y clonamos los shaders allí:

git clone --depth 1 https://github.com/snesrev/glsl-shaders

Editamos zelda3.ini y ponemos "Fullscreen" a 1, "OutputMethod" a OpenGL, "LinearFiltering" a 1, "DisableFrameDelay" a 1,
"EnhancedMode7" a 0, y "Shader" a "glsl-shaders/crt/fakelottes.glslp".

******WipeOut nativo en GNU/Linux********************************************************************************************

Clonamos su repo:
git clone --depth 1 https://github.com/phoboslab/wipeout-rewrite.git

Instalamos GLEW (mira en la sección de cómo instalar GLEW de este mismo documento) y SDL2.

Compilamos con:
USER_CFLAGS="-march=native -mtune=native -fomit-frame-pointer" make sdl -j4

Necesitamos los datos de:
https://phoboslab.org/files/wipeout-data-v01.zip
(LOS TIENES EN EL DISCO DE BACKUP, POR SI DESAPARECE EL LINK)

Creamos el directorio ~/wipeout, y ahí metemos el ejecutable "wipegame" y creamos el subdirectorio "wipeout" donde metemos
los datos del juego.

******Compilar core PCSX2 para LIBRETRO**************************************************************************************
NOTA: EL RENDERER SOFTWARE SÓLO FUNCIONA CON OPENGL. Necesitas activar OpenGL tanto cuando compiles RetroArch
como cuando compiles el core.

--Instalamos dependencias previas:
apt-get install liblzma-dev

--Clonamos su repo con sus submódulos:
git clone --depth 1 https://github.com/libretro/ps2.git
cd ps2
git submodule update --init --recursive

--Editamos "cmake/SearchForStuff.cmake", buscamos la línea "find_package(OpenGL REQUIRED)" y justo encima ponemos:
set(OPENGL_USE_OPENGL ON)

--Editamos "pcsx2/CMakeLists.txt", buscamos "OpenGL::GL" y lo cambiamos por "OpenGL::OpenGL".

--Compilamos con:

mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DUSE_VULKAN=TRUE -DUSE_OPENGL=TRUE \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

--La BIOS que necesitamos está en https://pcsx2.gitlab.io/ps2bios/ (tienes copia de seguridad en el disco de backup)
  Nos bajamos la que queramos de las tres, ya que el core no implementa region locking, y la metemos en:
  ~/.config/retroarch/system/pcsx2/bios/
ADEMÁS DE LA BIOS, se necesita tener "bin/resources" copiado al mismo sitio:
cp -R bin/resources ~/.config/retroarch/system/pcsx2/bios/

--RECUERDA QUE EL CORE NO ES COMPATIBLE CON RUNAHEAD!! Para desactivarlo sólo para este core, creamos el archivo
~/.config/retroarch/config/LRPS2/LRPS2.cfg con el contenido:
run_ahead_enabled = "false"

--Las opciones del core las dejamos como vienen por defecto:
Renderer: Auto
Internal Resolution: 1xNative (PS2)
Mipmapping: ON

******Carmageddon en GNU/Linux***********************************************************************************************

Clonamos el repo:
git clone --depth 1 --recurse-submodules -j8 https://github.com/dethrace-labs/dethrace.git

Configuramos con:
cmake .. -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

Creamos el directorio ~/carma, y ahí metemos el ejecutable "dethrace".
Además creamos ~/carma/data, y ahí en data metemos una instalación completa del Carmageddon tal cual (se recomienda versión GOG).
Ahora, cargamos el juego con:

DETHRACE_ROOT_DIR=./data
dethrace

******Cargar juegos de GameMaker (GM) de Android en GNU/Linux****************************************************************

OJO!!! Se tiene que hacer con un Linux de 32bits (armhf).
De momento no es compatible con Linux de 64bit (como aarch64) y cuando lo sea, sólo se podrán usar juegos que funcionen sobre
un GMLoader de 64bit, con lo que no será compatible con juegos de GameMaker versión 2.x como el Maldita Castilla.

Instalamos dependencias previas:
sudo apt-get install libbz2-dev libzip-dev

TAMBIÉN se necesita OpenAL, que tiene su sección en este documento para compilarla e instalarla rápidamente.

Bueno, vamos al lio.
Clonamos el repo:
git clone --depth 1 --recurse-submodules -j8 https://github.com/JohnnyonFlame/droidports.git

Editamos "ports/gmloader/sdl2_media.c" y:
-Añadimos justo antes de la llamada a SDL_CreateWindow() el típico "SDL_ShowCursor(SDL_DISABLE);"
-Añadimos SDL_WINDOW_FULLSCREEN_DESKTOP a las flags de SDL_CreateWindow().

Creamos el directorio de compilación, configuramos y compilamos:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

Para que las scanlines se vean bien y para quitar las mitigations, etc, añade a cmdline.txt:
video="HDMI-A-1:1152x864@60" mitigations=off audit=0 fsck.mode=skip
(La resolución original del Maldita Castilla es 256x224, y coincide que el monitor de la PICADE soporta 1152x864 como modo preferido,
que tiene el mismo número de líneas que 4x224. ¡Genial!).

Ahora es tan simple como cargar el Maldita Castilla con:
./gmloader Maldita_Castilla.apk
(Se usa la versión para Ouya que está en la página de Locomalito)

Para cargarlo en la PICADE, donde hay que establecer el volúmen al empezar tras activar softvol mediante /etc/asound.conf,
lo cago así:

aplay /dev/zero -s 1 -q
amixer set Master 120 -q
SDL_VIDEO_DOUBLE_BUFFER=1 ./gmloader maldita.apk

####SI VAS A USARLO EN LA PICADE:#####
-Para poder controlar el volúmen, tienes que activar softvol. Tienes varias soluciones en el fichero de documentación NOTAS_ALSACONF.TXT
Pero vamos, que tienes que poner /etc/asound.conf como:

pcm.hifiberry {
    type softvol
    slave.pcm "plughw:0"
    control.name "Master"
    control.card 0
}

pcm.!default {
    type             plug
    slave.pcm       "hifiberry"
}

Y luego cargar el juego como:
aplay /dev/zero -s 1 -q
amixer set Master 230 -q
./gmloader maldita.apk

-Para arreglar los controles, tienes dos opciones:
1) (RECOMENDADA) Configurar la Picade para que los botones y palanca envíen los códigos que usa el juego, que se mueve con las flechas del teclado
y las teclas Z y X. Para ello, en config.txt, en la línea de "dtoverlay=picade" haríamos:
dtoverlay=picade,button5=44,button6=45
(Los valores 44 y 45 los sacamos de pulsar X y Z mientras "showkey" está ejecutándose.

2) (MÁS ROLLO PORQUE HAY QUE EDITAR EL CÓDIGO DEL JUEGO) Poner el valor de button1 y button 2 en el juego para que se usen los valores UTF8
de CRTL y ALT (que son las teclas que envían los botones que sueles usar de la Picade) son
[164] = "L Alt";
[162] = "L Control";
(Sacado de https://forum.yoyogames.com/index.php?threads/how-do-i-convert-key-code-to-its-correct-key.76372/,
en el post #6 tienes la lista de todos los códigos de las teclas).
Puedes metérselos a la sección gml_Object_obj_control_Other_2 del código del juego: para editar el código del juego,
tienes que hacerlo con el UndertaleModTool: tienes notas sobre esto más abajo.

####FIN SECCIÓN PICADE####

Para Metroid am2r, tenemos que bajarnos la versión 1.1 y parchearla a la última versión que haya en ese momento:

-Instalamos el parcheador xdelta: sudo apt install python xdelta3

-Descargamos el AM2R versión original 1.1 de aquí: https://archive.org/details/am2r1.1
y lo guardamos dentro del directorio AM2R-Autopatcher-Linux como AM2R-Autopatcher-Linux/AM2R_11.zip
(OJO: Bájalo por Torrent, ya sabes que todo lo de Archive se corta si te bajas el .zip directamente)

-Clonamos el repo de la última versión del auto-parcheador: git clone --depth 1 https://github.com/AM2R-Community-Developers/AM2R-Autopatcher-Linux

-Bajamos la última versión del parche de GITHUB:
https://github.com/AM2R-Community-Developers/ProfessorG64/releases
De ahí copiamos el archivo "droid.xdelta" a "AM2R-Autopatcher-Linux/data/droid.xdelta"
y "AM2RWrapper.apk" a "AM2R-Autopatcher-Linux/data/android/AM2RWrapper.apk".

-Parcheamos así:

cd AM2R-Autopatcher-Linux
python patcher.py

(Te preguntará por el tipo de parche: responde Android. Y no hace falta que instales el pack de sonido de alta calidad porque
ocupa MUCHO más.)

NOTA: Si hemos instalado el juego en JELOS usando PORTMASTER y no nos va el audio, editamos AM2R.sh y añadimos estas dos líneas al principio:
export SPA_PLUGIN_DIR="/usr/lib32/spa-0.2"
export PIPEWIRE_MODULE_DIR="/usr/lib32/pipewire-0.3/" 

******EDITAR Y CAMBIAR COSAS EN JUEGOS GML COMO EL MALDITA CASTILLA**********************************************************

Por ejemplo, vamos a ver cómo activar en el juego la interpolación bilineal para evitar el shimmering.

Bajamos la versión 0.3.5.8 del Undertale Tool de aquí:
https://github.com/krzys-h/UndertaleModTool/releases

NO usamos la última versión porque se cuelga al salvar archivos de juego después de editarlos.

Instalamos la versión de .NET que nos pida. Por ejemplo, para la versión 0.3.5.8 nos pide .NET 4.6.2 que además DEBE ser
la de 32bits, así que hacemos:
sudo rm -R ~/.wine
WINEPREFIX="$HOME/.wine" WINEARCH=win32 wine wineboot
winetricks dotnet462
(OJO: No es un proceso desatendido, te pedirá varias veces que reinicies, NO LO HAGAS).

Ejecutamos el UndertaleTool.exe con wine.

Abrimos el archivo assets/game.droid.

PARA CAMBIAR COSAS, desplegamos la categoría CODE, y allí hacemos doble click en el fichero de código que queramos cambiar.
Nos aparecerá la vista DECOMPILED del fichero, que es la que tiene código legible que podemos editar a nuestro gusto.
Entonces nos vamos a a la vista DISSASEMBLY, y CONFIRMAMOS que se ha generado el código equivalente a la línea que hemos añadido.
OJO!!! HASTA QUE NO VAYAMOS A DISSASEMBLY, NO SE GUARDAN LOS CAMBIOS!!!

PARA SABER QUÉ NOS INTERESA CAMBIAR, LO PRIMERO EXPORTAMOS EL CÓDIGO PARA LUEGO PODER BUSCAR EN ÉL (DESDE EL UndertaleModTool NO SE PUEDE).
Para ello, nos vamos a SCRIPTS->BUILTIN SCRIPTS->EXPORT ALL CODE, y una vez exportado ya podemos buscar.
A CONTINUACIÓN, NOTAS DE COSAS QUE YA HEMOS BUSCADO, PARA DEJAR CIERTOS ASPECTOS DEL JUEGO COMO QUERAMOS:

-EDITAMOS "gml_Script_scr_initial_values", y ahí ponemos "global.is_ouya" a 0.
 Eso hace que en "gml_Object_obj_old_tv_Draw_64", se vaya por la ruta de arriba (la del "if (!global.is_ouya)"),
 así que quitamos todos las llamadas a "texture_set_interpolation()" menos la primera, que la ponemos a "true".
 (Esto hace que todo vaya interpolado, naturalmente, y si se activa el overlay irá interpolado también, que dentro
 de lo que cabe queda mejor).
-EDITAMOS "gml_Object_obj_control_Other_2", y ahí podemos desactivar poner el "speedrun" a 0,
configurar los controles (para usar los botones típicos de la PICADE, que envían las pulsaciones LCTRL y LALT,
debes poner button1 a 164 y button2 a 162), etc.
También podríamos poner el "overlay" a 0, pero no lo recomiendo porque el juego se ve mejor con overlay si ponemos
una resolución adecuada.

Salvamos, sobreescribiendo el archivo .droid, y reempaquetamos el .APK comprimiendo el directorio del juego con ZIP,
PERO SIN COMPRIMIR, SÓLO "STORE". Si lo haces desde la consola, es:
cd <directorio_del_APK_descomprimido>
zip -0 -r maldita.apk *
(¡¡¡OJO!!!: Hay que hacerlo exactamente así, entrando en el directorio del juego descomprimido, NO pasándole el directorio a zip,
porque no funcionará).

Para comprimirlo con sólo store y guardando los archivos y directorios como se debe, entramos en el directorio donde tenemos
descomprimido el APK y hacemos:
zip -r -0 maldita.apk *

TIENES UN APK LISTO EN EL DISCO DURO DE BACKUP, CON TODAS LAS MODIFICACIONES A TU GUSTO.

PARA QUE SE VEA BIEN EL OVERLAY:
COMO la imágen que se usa para las scanlines, (CURIOSIDAD: está en SPRITES y se llama "spr_old_tv"), es de 576x432,
tenemos que poner una resolución en cmdline.txt cuya altura (número de líneas) sea múltiplo de 432.
O sea que con una resolución que tenga una altura de 864, ya se ve bien.
PERO además nos interesa que sea 864 de altura y que tenga un ratio de 16:9, por lo que la anchura será 1536.
Los detalles para establecer un modo de vídeo de 1536x864 y con el aspect ratio correcto, los he sacado de:
https://wiki.archlinux.org/title/kernel_mode_setting#Early_KMS_start
El parámetro "video=..." de la línea de parámetros del kernel quedaría así:
video="HDMI-A-1:1536x864@60"


*****CÓMO CARGAR OTROS JUEGOS DE GAME MAKER (GML) CON EL GMLOADER***********************************************************

PARA CARGAR OTROS JUEGOS HECHOS CON GML, LA IDEA BÁSICA SERÍA COGER EL APK DE UN JUEGO ("donor apk"),
DESCOMPRIMIRLO, COPIAR LOS DATOS DEL NUEVO JUEGO A "assets", RENOMBRAR "data.win" A "game.droid", Y RECONSTRUIR EL APK.

PERO OJO! El APK que usas de "donante" tiene que tener una versión del runner que coincida con la versión
que el data.win/data.droid espera.
Así que para saber qué versión del runner espera el data.win/game.droid, lo cargamos con el UnderTaleModTool (UTMT) y
en la caja de texto de la parte de abajo del todo, escribimos una de estas:
Data.GMS2_2_2_302
Data.GM2_2_3
Data.GM2_2_3_1
Data.GM2_2_3_2
(Cuando coincida la versión te dirá TRUE, y cuando no coincida te dirá FALSE).
(Si quieres ver qué más heurustics hay para averiguar la versión, mira en el código fuente del UTMT, aquí:
https://github.com/krzys-h/UndertaleModTool/blob/4b52cb69c0939c4ccf6392838eee2eb5d8b2cfc8/UndertaleModLib/UndertaleData.cs#L60 )
(Si con una de esas te dice algo de "UndertaleData' does not contain a definition for...", significa que necesitas
una versión del UTMT más moderna, que conozca los heuristics de esa versión. EL PROBLEMA ES QUE LAS VERSIONES MODERNAS DE UTMT
PETAN EN LINUX, Y NO SE PUEDE USAR NATIVAMENTE PORQUE USA CIERDA MIERDA QUE LO HACE EXCLUSIVO DE WINDOWS, ASÍ QUE ES WINE O NADA).

CON ESO QUE TE ACABO DE EXPLICAR, DEBERÍAS SER CAPAZ DE AVERIGUAR QUÉ APK PUEDES USAR COMO DONANTE PARA UN data.win/game.droid DETERMINADO.

******RetroArch en Android***************************************************************************************************

Instálalo desde FDroid. Viene sin cores. Para instalar los cores, lo primero ve a "Online Updater -> Update Core Info Files",
y después ya puedes ir a "Online Updater->Core Downloader" y descargar los cores que quieras de la lista.

Para que no estén cambiamos los botones de OK y CANCELAR del mando, ve a "Settings->Input->Menu Controls->Swap OK and Cancel Buttons"
y desactívalo.

Para poder usar el teclado, ve a "Settings->Input->Select Physical Keyboard" y selecciónalo.

Para meterle juegos a saco, los puedes copiar en:
/media/manuel/<nombre_partición_grande>/media/0/Roms (tienes que crear "Roms")
y las BIOS van en /media/manuel/<nombre_partición_grande>/media/0/RetroArch/system

******PPSSPP, el emulador de PSP en GNU/LINUX***************************************************************************

Bajamos la última versión estable:
git clone --depth 1 --recurse-submodules -b <NOMBRE_TAG> -j8 https://github.com/hrydgard/ppsspp.git

	COMPILAR VERSIÓN LIBRETRO:

mkdir b4
cd b4
cmake .. -DLIBRETRO=ON -DUSE_VULKAN_DISPLAY_KHR=ON -DUSE_WAYLAND_WSI=OFF -DUSING_X11_VULKAN=OFF \
-DCMAKE_BUILD_TYPE=Release -DUSING_GLES2=ON -DUSE_DISCORD=OFF

OJO!! Por ahora no le pasamos optimizaciones porque la versión resultante se cuelga con el Ridge Racers,
 pero en un futuro se las pasaremos así:
-DCMAKE_C_FLAGS="-DEGL_NO_X11 -march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-DEGL_NO_X11 -march=native -mtune=native"

¡¡¡OJO!!! Tenemos que copiar el contenido del directorio "assets" que viene con los sources a ~/.config/retroarch/system/PPSSPP/
o si no, el Ridge Racers se nos quedará en una pantalla en gris después del menú principal."

Es un core con sonido 44100Hz, así que configura los settings de audio así y guarda los core overrides.

PARA FRAMERATE ESTABLE:
Desactiva "Buffer Graphis Commands"
Activa "Duplicate Frames in 30Hz games"

	COMPILAR VERSIÓN STANDALONE:

PARA WAYLAND (OJO: Si no le pasamos "-DUSING_GLES2=ON" intentará compilar contra GLX, de todos modos vamos a usar Vulkan):
cmake .. -DCMAKE_BUILD_TYPE=Release -DUSE_WAYLAND_WSI=ON -DUSE_VULKAN_DISPLAY_KHR=OFF -DUSING_X11_VULKAN=OFF -DUSING_GLES2=ON -DUSE_DISCORD=OFF \
-DCMAKE_C_FLAGS="-DEGL_NO_X11 -march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-DEGL_NO_X11 -march=native -mtune=native"

PARA KMSDRM:
cmake .. -DCMAKE_BUILD_TYPE=Release -DUSE_WAYLAND_WSI=OFF -DUSE_VULKAN_DISPLAY_KHR=ON -DUSING_X11_VULKAN=OFF -DUSING_GLES2=OFF -DUSE_DISCORD=OFF \
-DCMAKE_C_FLAGS="-DEGL_NO_X11 -march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-DEGL_NO_X11 -march=native -mtune=native"

Si nos da un error al linkar relacionado con ffmpeg, tenemos que recompilar ffmpeg interno que trae, lo cual se hace con esta
secuencia de comandos:

pushd ../ffmpeg
./linux_arm64.sh
popd

(Ese error ocurre porque, por defecto, intenta usar un FFMPEG que trae PRE-compilado contra otras libc.. normal que de error!)

Ahora copiamos el directorio "assets" al mismo directorio del ejecutable PPSSPP

	NOTAS SOBRE JUEGOS ESPECÍFICOS (OPCIONES DEL CORE)

EN GENERAL:
--Para evitar framerate errático, pon "Video -> Buffer Graphics Commands" a "No Buffer".
De ese modo, verás que el scroll de texto del menú del Ridge Racers va perfectamente suave. 
--Para evitar "tirones" de vídeo y audio en las cargas, pon "System -> I/O Timing Method" a "Host"
y déjalo así a no ser que algún juego pete, en cuyo caso lo desactivas para ese juego y ya.

-OUTRUN 2006:
Para que vaya a 60FPS constantes, pon "System -> Locked CPU Speed" a 444.
Para evitar "tirones" en las cargas entre stages, pon "System -> I/O Timing Method" a "Host".

*******Compilar el core libretro Yabause***********

Clonamos su repo:

git clone --depth 1 -b kronos https://github.com/libretro/yabause.git

entramos en yabause/src/libretro

make -j4

La bios tiene que ir en ~/.config/retroarch/system/saturn_bios.bin o ~/.config/retroarch/system/kronos/saturn_bios.bin

(OJO: Tienes que tener puesto el driver de vídeo en GLCORE, o en SETTINGS->CORE, permitir que los cores hagan el cambio de driver de vídeo).
(OJO: requiere OpenGL 4.1 o algo así, y NO FUNCIONA CON VULKAN, GLES, GLES2 ni GLES3, así que olvídate de que funcione en la Raspberry Pi 4).

*******Compilar el core Beetle-Saturn********************************

git clone --depth 1 https://github.com/libretro/beetle-saturn-libretro.git

CFLAGS="-march=native -mtune=native" CXXFLAGS="-march=native -mtune=native" make -j4

La BIOS tiene que ir en ~/.config/retroarch/system/mpr-17933.bin

Si estás en un sistema con PERFORMANCE CPUs y EFFICIENCY CPUs, debes asignarle un par de PERFORMANCE CPUs al RetroArch así:
taskset -c 0-1 retroarch -L ~/.config/retroarch/cores/mednafen_saturn_libretro.so roms/Sega\ -\ Saturn/Virtua\ Fighter\ Remix\ \(USA\).chd
Esto es así porque el core oscila muy rápido en el uso de la CPU: cuando usa poca es asignado a una CPU de tipo EFFICIENCY y luego
cuando de repente usa mucha se ralentiza porque el scheduler no llega a tiempo de pasarlo a una CPU de tipo PERFORMANCE.

*******Compilar 86Box************************************************
INFORMACIÓN ORIGINAL PROCEDENTE DE: https://86box.readthedocs.io/en/latest/dev/buildguide.html

--Se necesita FluidSynth y OpenAL, que ya las deberías tener instaladas.
--Instalamos otras dependencias previas:
apt-get install libsndfile1-dev libslirp-dev librtmidi-dev 

--Clonamos su repo:
git clone --depth 1 git clone https://github.com/86Box/86Box.git

--Configuramos con:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release

--Para generar una versión para SDL2 sin QT (no tiene soporte para shaders...):
cmake .. -DCMAKE_BUILD_TYPE=Release -DQT=OFF

--PARA INSTALAR LAS ROMS:
----Clonamos su repo (Sí, sí, ¡las ROMs están en un repo!):
git clone --depth 1 https://github.com/86Box/roms.git
----Las metemos en su sitio:
cp roms/* -R ~/.local/share/86Box/roms/

--CONFIGURACIÓN
Nos creamos un directorio para cada máquina. Por ejemplo, nos creamos el directorio "486", metemos ahí la imágen
de disco duro que queramos usar, entramos en él y hacemos:
86Box -C 486.cfg
De esta manera nos crea una configuración para la máquina en el directorio actual.
Ahora, con la versión que incluye QT, generamos la configuración que queramos y la usamos con la versión SDL2.
Una vez tenemos la configuración lista, podemos pasarle "-F" para que arranque en modo de pantalla completa,
ya que no hay una opción en el cfg para ello).

*******Compilar DOSBOX-STAGING***************************************
 
--Instalamos dependencias previas:
apt-get install libopusfile-dev

--Bajamos los últimos sources estables de:
https://github.com/dosbox-staging/dosbox-staging/releases

--Editamos "meson.build", buscamos la línea:
opengl_dep = dependency('gl', not_found_message: msg.format('use_opengl'))
...Y la dejamos así:
opengl_dep = dependency('opengl', not_found_message: msg.format('use_opengl'))

--Compilamos con:
mkdir b4
cd b4

CFLAGS="-O2 -march=native -mtune=native" \
CXXFLAGS="-O2 -march=native -mtune=native" \
meson setup -Dbuildtype=release -Ddefault_library=static ..

ninja -j10

--Copiamos el ejecutable "dosbox" a /usr/local/bin

--Copiamos unos directorios de resources obligatorios a donde dosbox espera encontrarlos:
mkdir ~/.config/dosbox
cp -R resources/glshaders  ~/.config/dosbox/
cp -R resources/mapping ~/.config/dosbox/
cp -R resources/mapping-unicode.org ~/.config/dosbox/

--Metemos las ROMs de MT32 (MT32_CONTROL.ROM, MT32_PCM.ROM) en ~/.config/dosbox/mt32-roms

	AJUSTES EN DOSBOX.CONF

Está en ~/.config/dosbox/dosbox.conf
--Ponemos "integer_scaling" a "off"
--Ponemos "cpu_cycles" a "6000" (los "cpu_protected_cycles" a "60000" están bien si no encuentras ningún juego que vaya lento con eso).
--Para tener scroll perfecto en monitor VRR la única manera es poner un modo de 60Hz para la mayoría de los juegos
y uno de 70 para las excepciones como Lemmings, Lemmings 2, Lotus 3...
Así que lo primero es poner un modo a 60Hz o de 70Hz en el monitor (dependiendo del juego)
y para no tener input lag aunque pongamos un modo de 60/70Hz, usar AdativeSync en vez de VSYNC normal, para lo cual ponemos en el dosbox.conf:

vsync = adaptive

Y ahora, si vamos a cargar un juego de 60Hz hacemos:
wlr-randr --output DP-1 --custom-mode 1920x1080@60
dosbox --set host_rate=60 --set dos_rate=host SF.EXE

Y si vamos a cargar un juego de 70Hz hacemos:
wlr-randr --output DP-1 --custom-mode 1920x1080@70
dosbox --set host_rate=70 --set dos_rate=host lemmings.bat

*******Compilar el core DOSBOX-CORE**********************************

Este sí sincroniza el vídeo bien (al fin).

Clonamos su repo:

git clone --depth 1 https://github.com/realnc/dosbox-core.git

SI QUEREMOS QUE NO AJUSTE EL RATIO (lo cual causa pausas de audio...) editamos libretro/src/libretro.cpp
y comentamos entero el contenido de la función update_gfx_mode()
Si decidimos hacer esto, luego es posible ajustar el ratio de ciertos juegos como el JAZZ (16:10) usando los overrides.

Entramos en el directorio "libretro" y compilamos así:

COMMONFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
make -j6 platform=unix WITH_FAKE_SDL=1 STATIC_LIBCXX=1 \
WITH_FLUIDSYNTH=0 BUNDLED_AUDIO_CODECS=0 BUNDLED_GLIB=0 BUNDLED_LIBSNDFILE=0 WITH_PINHACK=0 WITH_VOODOO=0 WITH_BASSMIDI=0

(Desactivo FLUIDSYNTH porque compila un montón de mierdas como libsndfile y demás que consumen CPU,
 con la emulación de GRAVIS vas que chutas en DOS).
(También desactivo la emulación de tarjetas Voodoo, el PINHACK que es para ver completas las mesas de pinball sin scroll, etc).

-Para que todo vaya suave en general (luego veremos que hay ciertos juegos que necesitan 70Hz sí o sí), en OPTIONS del core:
En TIMING->FRAME TIMING MODE elegimos "EXTERNAL".

-PARA TENER VÍDEO PERFECTO SI TIENES VRR/AdaptiveSync:
--Juegos de 60Hz (la GRAN mayoría!):
  En las opciones de RetroArch activa el VSYNC y desactiva "SYNC TO EXACT" (en este core NO funciona bien).
  Además, van mejor poniéndole en las opciones del core "Timmings->Override emulated video refresh rate" a "59"
  (previene dropouts de audio al cambiar el modo de vídeo en el PF, por ejemplo).
--Juegos de 70Hz (Lemmings, Lemmings 2, Lotus 3, Pinball Dreams):
----Crea el archivo ~/.config/retroarch/config/70hz.cfg con el contenido:
####CONFIG DE RETROARCH PARA JUEGOS DE 70Hz####
video_refresh_rate = "143.595642"
config_save_on_exit = "false"
####FIN CONFIG DE RETROARCH PARA JUEGOS DE 70Hz####
y se lo pasas a RetroArch con "--appendconfig ~/.config/retroarch/config/70hz.cfg",
y estableces un modo de 140Hz antes de lanzarlos.
Por ejemplo, para lanzar Lemmings, lo hago así:
####SCRIPT PARA LANZAR JUEGOS DE 70Hz####
wlr-randr --output DP-1 --mode 1920x1080@143.854996
retroarch -L ~/.config/retroarch/cores/dosbox_core_libretro.so --appendconfig ~/.config/retroarch/config/70hz.cfg confs/lemmings.conf
wlr-randr --output DP-1 --preferred
####FIN SCRIPT PARA LANZAR JUEGOS DE 70Hz####

LÓGICAMENTE, trata siempre de tratar los juegos como si fuesen compatibles con 60Hz. Para saber si un juego es compatible con 60Hz,
ponle "Timmings->Override emulated video refresh rate" a "59" y comprueba que no hace nada raro (músicas lentas). Si suena bien,
es compatible con 60Hz.

-SÓLO SI NO TIENES VRR Y NO TIENES UN MODO DE 120HZ PUESTO POR DEFECTO (DEBERÍAS TENERLO!):
Para evitar el input lag causado por tener el VSYNC activado (es necesario si no tienes VRR),
puedes poner un modo de vídeo de 120Hz y además tener "VSYNC SWAP INTERVAL" en "AUTO".
A tal efecto, lo más cómodo es que crees /usr/local/bin/dos con este contenido:
########
wlr-randr --output HDMI-A-1 --mode 1920x1080@120
retroarch -L ~/.config/retroarch/cores/dosbox_core_libretro.so "$1" &> /dev/null
wlr-randr --output HDMI-A-1 --mode 1920x1080@60
#########
...Y luego en el script de lanzamiento de cada juego simplemente tendrías este contenido:
#########
dos confs/juego.conf
#########

-La configuración general (ciclos, emulación de la CPU usada, tarjetas de vídeo y audio, etc) se hace desde las OPTIONS del core.
Y luego, para que en el inicio monte un directorio y se meta en él, debes pasarle un .conf que sólo haga eso, así:

[autoexec]
mount c: ~/root/dos/superfrog
sf.exe
exit

PARA QUE FUNCIONE EL TECLADO, la idea es usar el "GAME FOCUS", para lo cual
NO DEBEMOS TENER ACTIVADO el "HOTKEY ENABLE", ya que son dos funcionalidades que se solapan
y si tuvieses ambas la "HOTKEY ENABLE" no funcionaría al tener activo el "GAME FOCUS" que dedica todas las teclas al core.
Así que hacemos esto:
-En Settings->Input, pon "Auto Enable Game Focus" a "Detect".
-En Settings->Input->Hotkeys, pon en "Game Focus (Toggle)" la tecla Windows ("lsuper" se llama).
-En Settings->Input->Hotkeys, NO PONGAS NINGUNA TECLA en "Hotkey Enable".

PARA QUE EL PAD NO SE QUEDE ATASCADO EN UNA DIRECCIÓN AL SALTAR EN LOS JUEGOS:
-En "QUICK MENU->CONTROLS->PORT 1 CONTROLS", usa "Joystick" como "DEVICE TYPE", y pon así los controles direccionales:
D-Pad UP: Left Analog Y-
D-Pad UP: Left Analog Y+
D-Pad UP: Left Analog X-
D-Pad UP: Left Analog X+

PARA TENER escalado non-integer sin que se jodan las scanlines es el LOTTES, con la curvatura quitada.

PARA EL ASPECT RATIO: Lo de siempre para todos los cores en general: en SETTINGS->VIDEO se pone en 4:3 para todo y fuera.  

PARA EVITAR PANTALLA NEGRA al principio del SUPERFROG si se usa el driver de vídeo VULKAN: desactiva el "FRAME DUPING" en las opciones del core.
(Sólo ocurre con el driver del vídeo VULKAN).

PARA EVITAR QUE SE QUEDE EN EL MENÚ DE RETROARCH AL SALIR, desactiva SETTINGS->CORE->LOAD DUMMY CORE ON CORE SHUTDOWN.

LA EQUIVALENCIA DE CICLOS VA ASÍ:
8088 (4.77 MHz)     300
286-8               700
286-12             1500
386SX-20           3000
386DX-33           6000
386DX-40           8000
486DX-33          12000
486DX/2-66        25000
Pentium 90        50000
Pentium MMX-166  100000
Pentium II 300   200000

PARA CARGAR EL Might & Magic 2, antes tienes que ejecutar LOADFIX (es un comando del propio DOSBOX), para que no se queje de la memoria.

PARA EVITAR el error de que no encuentra /dev/snd/seq, pues cargar el módulo "snd_seq", o ignorar el error.

PARA PONER EL ISHAR 1 EN INGLÉS SIN TENER TECLADO NUMÉRICO, dale a la tecla END. 

PARA QUE NO HAYA "DISTORSIONES" DE AUDIO AL CARGAR EL MAPA Y LOS NIVELES DE "LEMMINGS 2", que hace algo raro al cargar de disco,
manda los ficheros a la caché de disco así antes de empezar:
find games/lem2 -type f -exec cat {} >> /dev/null \;
...o bien usa el driver de audio ALSA en vez de ALSATHREAD

PARA LOS JUEGOS QUE SE VEN MAL EN "ALTA" DEBIDO A LAS SCANLINES:
-Los hay que se soluciona activando el INTEGER SCALING, ya que incluso con escalado a enteros se ven casi casi casi a pantalla completa,
tal es el caso de Pinball Fantasies / Pinball Dreams.
-Los hay que al activar el INTEGER SCALING se ven muy pequeños, como Lemmings y Rusty. Para estos, nos creamos un nuevo shader preset
que llamaremos fakelottes_noscanlines.glslp, que cargará un shader fakelottes modificado con lo de "#define SCANLINES" comentado.  

PARA CONTROLAR EL BCRACERS BIEN CON EL MANDO, NO intentes usar el joystick desde el SETUP del juego ni desde las opciones del menú del juego.
El control de joystick de este juego está totalmente roto. Deja el control de teclado y ahora le hacemos el truco.
Usamos la funcionalidad del dosbox-core "Gamepad/Joystick 1 keyboard mappings", y ponemos:
(J1) B -> A
(J1) A -> Q
(J1) Y -> Space
(J1) Start -> Retunn/Enter
(J1) Right Thumb -> Tab
NOTA: Además, debes tener, en QUICK MENU->Controls->Port 1 Controls, el "R Button (Shoulder)" asignado a "[Core] Right Thumb",
o si no, lo de atacar con el botón R no funcionará.

#######################
# EMPIEZA EL DOS.CONF #
#######################

[autoexec]

mount c: /home/manuel/dos/juegos
c:

#####################
# ACABA EL DOS.CONF #
#####################

El tema del teclado: para que las teclas se lean todas desde DOS, sin liarse con las hotkeys de RETROARCH,
debes tener un "HOTKEY ENABLE" en "SETTINGS->INPUT"
(yo tengo puestas las comillas simples) para que así al pulsar las teclas no se activen cosas del RetroArch a no ser que pulses
el "HOTKEY ENABLE" que tengas configurado.
PARA QUE NO SE ATASQUEN LAS TECLAS DE DIRECCIÓN MIENTRAS JUEGAS CON TECLADO: Vete a "QUICK MENU->CONTROLS->PORT 1 CONTROLS"
y pon el DEVICE TYPE a "KEYBOARD+MOUSE", y dale a "SAVE CORE REMAP FILE".

Juegos de DOS para bajar: te enganchas el TORRENT y bajas sólo los que vayas queriendo: https://www.retro-exo.com/exodos.html

NOTAS JUEGOS DOSBOX

--Lemmings se puede iniciar el modo high-performace sin tener que elegir nada con: lemvga /v /o
--Wizardry 6 necesita ir instalado en C:\BANE para que el setup (WINSTALL.EXE) funcione correctamente,
  y para no colgarse en el primer logotipo, "Core Options->Specs->CPU core" puesto a "Auto",
  y para sonar bien, usar el Nuked OPL3. Menos mal que con pocos ciclos el juego va bien...
--PsychoPinball tiene que estar en C:\PSYCHO, o sea que tienes que meterlo en ~/dos/psycho/psycho
  y luego montar ~/dos/psycho como C: en DOSBOX. Si no, se queda colgado en el DOS4GW.
--Los juegos de modo real (es decir, todos los que NO usen extensores como el DOS4GW, etc) se supone que van
  perfectos a 3000 ciclos constantes, y en teoría los juegos de modo real deberían usar el "CPU CORE" en "AUTO" o "NORMAL", NO el Dynamic Recompiler.
--Dicho lo anterior, el Rusty lo debes poner a 3000 ciclos, no más, y si usas el kernel Cachyos, puedes usar el audio ALSA (no hace falta
Alsathread) con 32ms de latencia.

******Usar PCSX2 STANDALONE en GNU/Linux*************

Nos bajamos el último AppImage de: https://github.com/PCSX2/pcsx2/releases
...Y le damos permisos de ejecución.

La AppImage viene linkada contra libGLX, así que la simulamos. Para ello, creamos un fichero llamado "fake_glx.c" con el contenido:
####EMPIEZA fake_glx.c#####
void* glXChooseFBConfig(void* dpy, int screen, int* attribList, int* nElements) { return 0; }
int glXGetConfig(void* dpy, void* visual, int attrib, int* value) { return 0; }
void* glXGetVisualFromFBConfig(void* dpy, void* fbConfig) { return 0; }
int glXGetFBConfigAttrib(void* dpy, void* fbConfig, int attrib, int* value) { return 0; }
void* glXChooseVisual(void* dpy, int screen, int* attribList) { return 0; }
####ACABA fake_glx.c#####
...Y lo compilamos como librería así:
gcc -shared -fPIC -o libGLX.so.0 fake_glx.c
...¡¡¡Y ya tenemos nuestro libGLX.so.0!!!
(Antes, en lugar de crearnos una librería GLX fake, hacíamos "ln -s /usr/local/lib64/libOpenGL.so.0 ./libGLX.so.0",
pero eso ya no funciona porque nos da "undefined symbols" para funciones de GLX).

Lanzamos el emulador con:
I_WANT_A_BROKEN_WAYLAND_UI=YES LD_LIBRARY_PATH=./ ./pcsx2.AppImage "$1" >> /dev/null 2>&1

PARA TENER GRÁFICOS CON REFRESCO PERFECTO SIN LAG (=SIN VSYNC):
--En "Settings->Graphics" ponemos el Renderer a "Vulkan" y ponemos el Texture Preloading a "None"
  (El Texture Preloading produce parones de audio en las transiciones, cargas, etc).
--En "Settings->Graphics" activamos "Spin GPU during readbacks" y "Spin CPU during readbacks"
  (Evita bajones de FPS durante transiciones).
--En "Settings->Emulation", activamos "Enable Thread Pinning" (aunque ponga que es para sistemas con CPUs asimétricas,
  evita droputs de audio en cualquier CPU al evitarse los fallos de caché por cambio de contexto).
--En "Settings->Emulation", en la parte de abajo:
  ----SI TENEMOS VRR: DESACTIVAMOS TODO. ABSOLUTAMENTE TODO.
  ----SI NO TENEMOS VRR:
          Activamos solamente "Sync to Host Refresh Rate".
          Con Vulkan no es necesario activar "Vertical Sync (VSync)".
--En "Settings->Audio", dejamos "Backend" a "Cubeb" y "Driver" a "alsa".

-SI LOS CONTROLES DEL DPAD VAN MAL: En "Settings->Controllers->Controller Port 1->Mapping Settings" activamos "Ignore inversion".

-PARA OCULTAR EL CURSOR DEL RATÓN CON WAYFIRE:
--En Wayfire, lo primero es instalar "plugins-extra" (ver instrucciones en fichero de NOTAS_WAYLAND),
y luego ya podemos larzar PCSX2 standalone así, ocultando el cursor antes y desocultándolo respués:
sed -i "s/plugins =/& hide-cursor/g" ~/.config/wayfire.ini
sync
I_WANT_A_BROKEN_WAYLAND_UI=YES LD_LIBRARY_PATH=./ ./pcsx2.AppImage "$1" >> /dev/null 2>&1
sed -i "s/ hide-cursor//g" ~/.config/wayfire.ini

******Compilar e instalar QT6 en GNU/Linux****************************************************************************************

Las instrucciones básicas las he sacado de: https://wiki.qt.io/Building_Qt_6_from_Git

VERSION ESTABLE (RECOMENDADO):
wget https://download.qt.io/official_releases/qt/6.8/6.8.0/submodules/qtbase-everywhere-src-6.8.0.tar.xz

ALTERNATIVA: BAJANDO DE GITHUB LA VERSIÓN ESTABLE Y LOS SUBMÓDULOS (NO RECOMENDADO):
Clonamos su repo:
git clone https://code.qt.io/qt/qt5.git qt6
Nos vamos a la versión tagged LTS actual:
git switch 6.6.0
Inicializamos los módulos que vamos a usar
(puedes ver los módulos disponibles editando el archivo ".gitmodules"):
(qttools es necesario para tener el componente LinguistTools, que es necesario para compilar PCSX2)
./init-repository --module-subset=qtbase,qttools

--CONFIGURACIÓN: 
Puedes deshabilitar features de esos módulos con "-no-feature-loquesea". Y para saber qué cosas le ponemos pasar,
miramos en "CMakeCache.txt". Por ejemplo, entras en "CMakeCache.txt" y buscas "html" y ya ves qué cosas relacionadas con el html puedes
deshabilitar.
Y NO DESHABILITES nada nuevo, que luego el PCSX2 no compila.

mkdir b4
cd b4
cmake .. -GNinja -DCMAKE_BUILD_TYPE=Release -DQT_BUILD_EXAMPLES=OFF -DQT_BUILD_TESTS=OFF

SI QUISIÉRAMOS SOPORTE PARA KMSDRM:
cmake .. -GNinja -DCMAKE_BUILD_TYPE=Release -DQT_FEATURE_eglfs_egldevice=ON -DQT_FEATURE_eglfs_gbm=ON \
-DQT_BUILD_EXAMPLES=OFF -DQT_BUILD_TESTS=OFF

--COMPILACIÓN:
cmake --build . --parallel 10

--INSTALACIÓN:
cmake --install .
Y ahora editamos /etc/profile.d/custom.sh y añadimos algo como esto para que los ejecutables de QT queden en el PATH:
export PATH=/usr/local/Qt-6.8.0/bin:$PATH
(NO instales en /usr/local/bin, déjalo donde se instala por defecto, en ese subdirectorio de /usr/local con número de versión,
 ya que es lo correcto según la documentación debido a que se pueden tener varias versiones de QT en el mismo sistema, etc).

PARA DESINSTALAR, ya que no hay "make uninstall", hacemos:
for f in $(cat install_manifest.txt) ; do rm "$f"; done

PARTE 2: MÓDULOS DE QT6 NECESARIOS PARA LOS EMULADORES

---WAYLAND (Necesario para PCSX2)---

wget https://download.qt.io/official_releases/qt/6.8/6.8.0/submodules/qtwayland-everywhere-src-6.8.0.tar.xz

mkdir b4
cd b4
cmake .. -GNinja -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH="/usr/local/Qt-6.8.0/lib/cmake"
cmake --build . --parallel 12
cmake --install .

---TOOLS (Necesario para PCSX2)---

wget https://download.qt.io/official_releases/qt/6.8/6.8.0/submodules/qttools-everywhere-src-6.8.0.tar.xz

mkdir b4
cd b4
cmake .. -GNinja -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH="/usr/local/Qt-6.8.0/lib/cmake"
cmake --build . --parallel 12
cmake --install .

---SVG (Necesario para Dolphin)---

wget https://download.qt.io/official_releases/qt/6.8/6.8.0/submodules/qtsvg-everywhere-src-6.8.0.tar.xz

mkdir b4
cd b4
cmake .. -GNinja -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH="/usr/local/Qt-6.8.0/lib/cmake"
cmake --build . --parallel 12
cmake --install .

******Compilar PCSX2 standalone**********************************************************************************************

-LO PRIMERO es que se necesita tener en el sistema una versión de QT6 con el módulo TOOLS.
 En la sección de cómo compilar QT6 tienes también cómo compilar e instalar este módulo.

-Instalamos dependencias previas:
apt-get install --no-install-recommends extra-cmake-modules liblzma-dev libpcap-dev libaio-dev liblz4-dev libbacktrace-dev

-Instalamos a mano otra dependencia previa: libshaderc. (La versión que viene con Debian 13 es muy antigua y no nos vale).
----Clonamos su repo: git clone --depth 1 https://github.com/google/shaderc.git
----Entramos en el raiz de los sources y clonamos a mano sus sub-dependencias así:
./utils/git-sync-deps
----Configuramos y compilamos con:
mkdir b4
cd b4
cmake .. -GNinja -DCMAKE_BUILD_TYPE=Release -DSHADERC_SKIP_TESTS=ON \
-DSPIRV_SKIP_EXECUTABLES=ON -DSKIP_GLSLANG_INSTALL=ON \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native"
ninja -j10

PARA DESINSTALAR (no hay "make uninstall"):
for f in $(cat install_manifest.txt) ; do rm "$f"; done

AHORA VAMOS CON PCSX2 EN SÍ:

Clonamos su repo:
git clone --depth 1 https://github.com/PCSX2/pcsx2.git --recurse

Editamos common/CMakeLists.txt y borramos "X11:X11" y "X11::Xrandr". 

Configuramos y compilamos (asegúrate de que la ruta de instalación de QT6 que le pasas en "-DCMAKE_PREFIX_PATH=..." es la correcta):

mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DX11_API=OFF \
-DCMAKE_PREFIX_PATH="/usr/local/Qt-6.8.0/lib/cmake" \
-DSHADERC_LIBRARY=/usr/lib/x86_64-linux-gnu/libshaderc.so \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native"

Creamos un directorio ~/ps2, y copiamos allí el ejecutable "pcsx2-qt" que está en el directorio "bin", 
y los directorios "resources" y "translations"

NOTAS DE CONFIGURACIÓN:
-En EMULATION, activa "Optimal Frame Pacing" y "Scale to Host Refresh Rate", y pon "Affinity Control" a "EE > GS > VU"
-En GRAPHICS
--En la pestaña principal, pon "Renderer" a "Software", o bien a "Vulkan" pero en ese caso activa "Spin CPU during readbacks"
--En la pestaña "DISPLAY" desactiva "Anti-Blur"
--En la pestaña "RENDERING" pon "Software Rendering Threads" al número de CPUs que tengas -2, sin pasarte de 6.
--En la pestaña "RECORDING" desactiva "Capture Video" y "Capture Audio"
--En la pestaña "OSD" desactiva "Show OSD Messages" y pon el "OSD Scale" al 200%, por si activas "Show Speed Percentages"
--En la pestaña "Post Processing" pon el "TV Shader" a "Scanline Filter"

*******Compilar DOLPHIN standalone***********************************
OJO!! LA VERSIÓN NOGUI NO SOPORTA MÁS QUE X11 Y FBDEV, Y LA VERSIÓN NORMAL AUNQUE FUNCIONA SOBRE QT6 NO SOPORTA WAYLAND,
ASÍ QUE DALE UN AÑO O DOS PARA MEJORAR, NO PIERDAS EL TIEMPO.

git clone --depth 1 --recurse-submodules -j8 https://github.com/dolphin-emu/dolphin.git dolphin-emu

mkdir b4
cd b4

Para compilar sólo la versión NOGUI:
cmake .. -DCMAKE_BUILD_TYPE=Release -DENABLE_QT=OFF -DENABLE_X11=OFF -DENABLE_NOGUI=ON -DUSE_MGBA=OFF -DUSE_DISCORD_PRESENCE=OFF \
-DENABLE_SDL2_VIDEO=ON

Para compilar contra QT6 (PUAJ!!!)
cmake .. -DCMAKE_BUILD_TYPE=Release -DENABLE_X11=OFF -DUSE_MGBA=OFF -DUSE_DISCORD_PRESENCE=OFF \
-DCMAKE_PREFIX_PATH="/usr/local/Qt-6.6.0/lib/cmake" -DQt6Svg_DIR=/usr/local/lib/cmake/Qt6Svg

Para seleccionar el platform plugin al lanzar el emu:
QT_QPA_PLATFORM=eglfs Binaries/dolphin-emu

*******Compilar el core libretro Swanstation (Duckstation)***********

(OJO: en el repo oficial de ducktstation tienes cores ya compilados, pero NO funcionan cuando Retrorch funciona sobre KMSDRM.
NO te molestes en reportarlo, porque el autor de duckstation es un poco gilipollas.)

Clonamos el repo donde mantienen la versión no oficial:
git clone --depth 1 https://github.com/libretro/swanstation.git

Editamos src/libretro/libretro_host_interface.cpp y comentamos el contenido de la función
LibretroHostInterface::UpdateGeometry(), dejándola inutilizada por completo.
(Esto evita las ralentizaciones cuando el WipeOut hace el efecto de terremoto de pantalla al sufrir un ataque enemigo).
OJO!!! RECUERDA que debes poner en las opciones del core el ratio a 4:3 porque al comentar UpdateGeometry() no se puede establecer
bien automáticamente.

mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

ACUÉRDATE DE PONER EL RENDERER DEL CORE EN "SOFTWARE" (No le eches la culpa al shader si hay audio dropouts)
Y EL "CPU EXECUTION MODE" A "CACHED INTERPRETER" (Contrariamente a lo que parece, es más rápido que "RECOMPILER"),
Y EL "CD-ROM SEEK SPEED UP" PON "INFINITE/INSTANTANEOUS"
Y EL "USE OLD MDEC ROUTINES" a "OFF" (las OLD MDEC ROUTUNES son para sustituir texturas en los juegos, nada más).
A PARTE, EN "SETTINGS->AUDIO->OUTPUT" PON "ALSA" CON UN "AUDIO LATENCY" DE 32.

CROSSCOMPILAR DOSBOX-CORE PARA ARM64
====================================
NOTA PREVIA: En Debian, el sistema es "ARM64", pero el compilador sigue siendo "AARCH64", ojo.

-Instalamos el cross-compilador:
sudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu

-Instalamos otra herramienta que nos hace falta en el host:
apt-get install libtool-bin

-Instalamos el debootstrap
sudo apt-get install debootstrap

-Instalamos los componentes que nos permitan ejecutar binarios arm64 en x86_64:
sudo apt install qemu-user-static biplatform=unix WITH_FAKE_SDL=1 STATIC_LIBCXX=1 \
WITH_FLUIDSYNTH=0 BUNDLED_AUDIO_CODECS=0 BUNDLED_GLIB=0 BUNDLED_LIBSNDFILE=0 WITH_PINHACK=0 WITH_VOODOO=0 WITH_BASSMIDI=0nfmt-support

-Creamos el directorio para el rootfs:
mkdir ~/root_arm64

-Creamos el rootfs para AARCH64, usando como base Debian Trixie (Debian 13) que es la última estable:
sudo debootstrap --arch=arm64 --no-check-gpg --variant=minbase bookworm ~/root_arm64 http://deb.debian.org/debian

-Nos chhrooteamos en el nuevo sistema e instalamos algunas cosas que necesitamos:
sudo mount -t proc /proc ~/root_arm64/proc
sudo mount -t sysfs /sys ~/root_arm64/sys
sudo mount --bind /dev ~/root_arm64/dev
sudo chroot ~/root_arm64

apt-get install libasound2-dev

--IMPORTANTE: Tras salir del chroot, desmontamos los pseudo-filesystems que montamos antes de entrar:
sudo umount ~/root_arm64/dev
sudo umount ~/root_arm64/sys
sudo umount ~/root_arm64/proc

-Clonamos el repo de dosbox-core:
git clone --depth 1 https://github.com/libretro/dosbox-core.git

-Editamos libretro/Makefile.libretro y cambiamos las líneas:
CMAKE=$(cross_prefix)cmake
PKGCONFIG=$(cross_prefix)pkg-config
por:
CMAKE=cmake
PKGCONFIG=pkg-config
(Esto es porque tanto CMAKE como PKGCONFIG son herramientas que NO se deben coger del rootfs de destino, 
sino que deben ser los del sistema donde estamos cross-compilando, a poco que lo pienses lo entiendes;
ni siquiera existen "aarch64-linux-gnu-pkg-config" o similares... no tiene sentido).

-Crosscompilamos con:

cd libretro

make \
TARGET_TRIPLET=aarch64-linux-gnu \
CC="aarch64-linux-gnu-gcc --sysroot=$HOME/root_arm64" \
CXX="aarch64-linux-gnu-g++ --sysroot=$HOME/root_arm64" \
platform=unix \
platform=unix WITH_FAKE_SDL=1 STATIC_LIBCXX=1 \
WITH_DYNAREC=arm64 WITH_FLUIDSYNTH=0 BUNDLED_AUDIO_CODECS=0 BUNDLED_GLIB=0 BUNDLED_LIBSNDFILE=0 WITH_PINHACK=0 WITH_VOODOO=0 WITH_BASSMIDI=0

********CROSSCOMPILAR el core libretro Swanstation(Duckstation)************

La idea es crosscompilar en X86_64 para aarch64 (arm64).

-Instalamos los paquetes:
sudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu

-Copiamos el rootfs a /opt/DEBIAN_ROOT, excluyendo home, con:
sudo rsync -av --progress /media/manuel/DEBIAN_ROOT /opt/ --exclude DEBIAN_ROOT/home/pi

-Bajamos la última release estable de aquí:
https://github.com/kivutar/swanstation/releases

-Creamos en el raiz de los sources (o donde nos de la gana) el cmake toolchain file, donde le especificamos todo lo necesario
para crosscompilar para aarch64.
Yo lo he llamado toolchain.cmake, con el contenido:

# Target system
SET(CMAKE_SYSTEM_NAME Linux)
SET(CMAKE_SYSTEM_PROCESSOR aarch64)

SET(CMAKE_SYSROOT /opt/DEBIAN_ROOT)
#set(CMAKE_FIND_ROOT_PATH /opt/DEBIAN_ROOT)

# Cross compiler
SET(CMAKE_C_COMPILER   aarch64-linux-gnu-gcc)
SET(CMAKE_CXX_COMPILER aarch64-linux-gnu-g++)
SET(CMAKE_LIBRARY_ARCHITECTURE aarch64-linux-gnu)
SET(CMAKE_PREFIX_PATH /opt/DEBIAN_ROOT/usr/lib/aarch64-linux-gnu)

SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
SET(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)

-Ahora creamos el directorio de compilación y nos movemos a él:

mkdir build
cd build

-Configuramos pasándole el cmake toolchain file así:
cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_LIBRETRO_CORE=ON -DENABLE_CHEEVOS=OFF -DENABLE_DISCORD_PRESENCE=OFF \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2" \
-DCMAKE_TOOLCHAIN_FILE=../toolchain.cmake ..

-Compilamos con make, y comprobamos el ejecutable, que sea aarch64:
file duckstation_libretro.so

¡¡Y listo!! Menuda aventura macho....

NOTAS ADICIONALES para el core:

SI DUCKSTATION DA SEGFAULT AL SELECCIONAR VULKAN, VE A SETTINGS->VIDEO->OUTPUT Y EN "OUTPUT" SELECCIONA "VULKAN"

******Sonic Robo Blast 2 en GNU/Linux****************************************************************************************

--Instalamos dependencias previas:
apt-get install libgme-dev libminiupnpc-dev

--Nos bajamos la última estable de: https://github.com/STJr/SRB2/archive/refs/tags/SRB2_release_2.2.15.tar.gz

--Compilamos con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
make -j10

--Creamos el directorio ~/srb2 y metemos ahí el ejecutable resultante de la compilación, que queda en: bin/lsdl2srb2

--Nos bajamos la última versión en ZIP de aquí:
https://www.srb2.org/download/

--Descromprimimos el ZIP y metemos todos los .PK3 que trae en ~/srb2 junto con el ejecutable.

******Doom 64 EX en GNU/Linux************************************************************************************************

Clonamos su repo:
git clone --depth 1 https://github.com/svkaiser/Doom64EX.git
git submodule update --init --recursive

Editamos CMakeLists.txt, buscamos:
  find_package(OpenGL REQUIRED)
Y lo dejamos como:
  set(OPENGL_USE_OPENGL ON)
  find_package(OpenGL REQUIRED)

Compilamos con:

mkdir b4
cd b4

cmake -DCMAKE_BUILD_TYPE=Release -DENABLE_SYSTEM_FLUIDSYNTH=ON .. \
-DCMAKE_C_FLAGS="-march=native -mtune=native -O2" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2"

Creamos el directorio ~/doom64 y allí metemos:
-El ejecutable "doom64ex"
-El fichero "doom64ex.pk3"
-Los ficheros "doom64.wad" y "doomsnd.sf2", que se obtienen haciendo:
 doom64ex -wadgen PATH_TO_ROM
 (Los tienes en el disco de backup, pero por si lo tienes que volver a hacer, la ROM necesaria es la USA que NO sea la Rev1.)

******Crosscompilar el 64doom de N64-****************************************************************************************

--Nos bajamos el último .deb de la toolchain de N64 para x86_64 (compilador, librerías, etc) de aquí: https://github.com/DragonMinded/libdragon/releases/tag/toolchain-continuous-prerelease
Lo instalamos con: sudo dpkg -i gcc-toolchain-mips64-x86_64.deb
Quedará todo en /opt/libdragon.

--Exportamos esta varable de entorno:
export N64_INST=/opt/libdragon

--Nos bajamos la última versión del código del branch UNSTABLE de las libdragon:
git clone --depth 1 -b unstable https://github.com/DragonMinded/libdragon.git 
Las compilamos e instalamos simplemente entrando en su directorio principal y ejecutando build.sh,
con lo cual acabarán también instaladas en /opt/libdragon.
Ahora nos bajamos la versión del código de branch TRUNK de las libdragon, y la compilamos e instalamos sin desinstalar la UNSTABLE:
git clone --depth 1 -b trunk https://github.com/DragonMinded/libdragon.git 

--Nos bajamos la última versión del 64doom:
git clone --depth 1 https://github.com/jnmartin84/64doom.git

--Compilamos con:
IWAD_DIRECTORY="~/doom" IWAD_PREFIX="DOOM" make -j8
Donde IWAD_DIRECTORY es el directorio donde guardamos nuestros .WAD (que deben tener nombres todo en mayúsculas)
e IWAD_PREFIX es el identificador de juego: DOOM, DOOM2, DOOMU, etc.

******Doom 3 en GNU/Linux****************************************************************************************************

Bajamos los últimos sources estables de: https://github.com/dhewm/dhewm3/releases

Descomprimimos y entramos en el directorio "neo", y editamos "sys/linux/main.cpp", buscamos "root"
y eliminamos el check que evita que funcione al ejecutarlo como root.

Configuramos y compilamos:

mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DIMGUI=OFF \
-DCMAKE_C_FLAGS="-march=native -mtune=native -DEGL_NO_X11" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -DEGL_NO_X11"

make -j10

Creamos el directorio: mkdir ~/doom3
--Metemos ahí el ejecutable y unas librerías que se nos acaban de generar:
  cp dhewm3 base.so d3xp.so ~/doom3/
--Copiamos el directorio "base" que viene con los sources:
  cp -R base ~/doom3/
--Metemos los archivos .pk4 del Doom 3 en ~/doom3/base/ (NO VALE la BFG Edition, que además está censurada así que evítala).
  (Tienes un ZIP con los datos del Doom 3 y todas sus extensiones en el disco duro de backup).

Lanzamos así el juego y nos salimos inmediatamente ya que sólo queremos que nos cree los ficheros de configuración:
./dhewm3 +set fs_basepath .

Ahora editamos el archivo ~/.config/dhewm3/base/dhewm.cfg
Allí, ponemos a "1" los valores "r_fullscreenDesktop" y "r_fullscreen"
SI NO TENEMOS VRR (si tienes VRR, no necesitas hacer esta parte): ponemos "r_swapInterval" y "r_fixedTic" a "1".
El valor "r_fixedTic" es para que el juego NO VAYA a 62.5 Hz internamente, ya que si lo hiciese nos obligaría a poner un modo de vídeo de 62.5Hz,
y "r_swapInterval" activa el VSYNC.
Opcionalmente, podemos poner a 1 también el valor "r_finish" para disminuir el input lag.

PARA PANTALLA PANORÁMICA EN LOS MENÚS, usa este mod: https://www.moddb.com/mods/doom-3-redux
Otros mods recomendados: https://dhewm3.org/mods.html

******Compilar DUCKSTATION versión NOGUI (directo a KMSDRM!)*****************************************************************

Clonamos duckstation:

git clone --depth 1 https://github.com/stenzek/duckstation.git

Instalamos dependencias previas:

sudo apt-get install libevdev-dev --no-install-recommends
Y si vas a compilar con soporte para wayland, también esto:
sudo apt-get install extra-cmake-modules --no-install-recommends

Configuramos con:

doom cmake .. \
-DCMAKE_C_FLAGS="-march=native -mtune=native -DEGL_NO_X11" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -DEGL_NO_X11" \
-DCMAKE_BUILD_TYPE=Release -DENABLE_CHEEVOS=OFF -DENABLE_DISCORD_PRESENCE=OFF -DUSE_X11=OFF -DUSE_DRMKMS=ON \
-DBUILD_NOGUI_FRONTEND=ON -DBUILD_QT_FRONTEND=OFF -DHAVE_EGL=ON -DUSE_WAYLAND=ON -DUSE_SDL2=ON ..

(Hay que dejar el soporte de SDL2 porque EVDEV no implementa aún los ejes de los mandos)

Copia todo el contenido de bin a ~/psx. No copies sólo el ejecutable, o te dará un segfault cuando lo ejecutes.

Si  el ejecutable resultante te da un error con que no puede abrir card1, edita src/common/drm_display.h y cambia card = 1 por card = 0.

La BIOS va en ~/.local/share/duckstation/bios/

PARA LANZAR LOS JUEGOS tienes que pasarle la ruta COMPLETA del .cue, no vale que le pases una ruta relativa a donde estás,
ni que empiezes la ruta en home con ~/, etc. RUTA COMPLETA.

******Compilar el core SameBoy (GB/GBC) para Raspberry Pi 4**********

Lo primero, clona este repo PERO usa la versión 0.5.2 porque la actual no funciona:

git clone https://github.com/gbdev/rgbds.git
git fetch --tags
git checkout v0.5.2
make -j4

Ahora copia a mano a /usr/local/bin los ejecutables generados: rgbasm, rgbgfx y rgblink.

Ahora clona el repo del SameBoy upstream:

git clone --depth 1 https://github.com/LIJI32/SameBoy.git

Y entramos en el directorio "libretro" y compilamos con:

make platform=rpi4_64 -j4

******Compilar el core FLYCAST LIBRETRO en GNU/Linux********

--Clonamos su repo:
git clone --depth 1 --recurse-submodules https://github.com/flyinghead/flycast.git

--Editamos CMakeLists.txt y cambiar la línea:
set(OpenGL_GL_PREFERENCE LEGACY)
por
set(OpenGL_GL_PREFERENCE GLVND)

--Configuramos y compilamos:

mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DLIBRETRO=ON -DUSE_VULKAN=ON -DUSE_OPENGL=ON \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

Ahora ponemos la BIOS, llamada "dc_boot.bin", en ~/.config/retroarch/system/

RECUERDA: Este core NO SOPORTA RUNAHEAD, SI LO TIENES ACTIVADO DARÁ UN SEGFAULT AL INICIARSE.

PARA TENER VÍDEO PERFECTAMENTE SUAVE EN TODOS LOS JUEGOS, TANTO LOS DE 60FPS COMO LOS DE 30FPS ("REZ", "Napple Tale"),
TENEMOS QUE DEJAR LAS OPCIONES DE RETROARCH COMO SI NO TUVIÉRAMOS NI QUISIÉRAMOS VRR YA QUE ESTE CORE SE SINCRONIZA CON EL AUDIO Y EL VÍDEO DEL HOST
Y NO LO HACE AL REVÉS. O SEA, LAS DEJAMOS ASÍ:
-ACTIVAMOS "VSYNC" Y DESACTIVAMOS "SYNC TO EXACT CONTENT FRAME",
-ACTIVAMOS EN LAS OPCIONES DEL CORE "FULL FRAMEBUFFER EMULATION".
 (NO ACTIVES "DETECT FRAME RATE CHANGES", ESO JODE LA SINCRONIZACIÓN, HAZLO JUSTO COMO TE HE DICHO).

RECUERDA: Puede ser necesario activar "Native Depth Interpolation" si tienes errores y usas un chip gráfico de Intel o AMD
(no consume más recursos ni nada según el autor del emulador). Deja la segunda demo del Daytona USA 2001
y si hay errores de clipping en los edificios del lado izquierdo, lo activas.

RECUERDA: Este es un core de 44100 Hz, se nota mucho, usa esa frecuencia de audio y guárdalo como un override para este core.

RECUERDA: NO ACTIVES "Emulation Hacks -> GD-ROM Fast Loading", porque aunque evita los crujidos de la intro del Soul Calibur,
introduce microcortes en el audio de la intro/demo del DOA2. No es solución. No lo uses.

RECUERDA, SI NO USAS WAYLAND: Para que no de segfault al iniciarse desde la TTY, tienes que poner al final de la línea de retroarch: < /dev/null

SI NO TIENES VRR: Ejecuta el emulador a 120Hz para evitar el input lag:

wlr-randr --output HDMI-A-1 --mode 1920x1080@120
taskset -c 0,1 retroarch -L .config/retroarch/cores/flycast_libretro.so "$1"
wlr-randr --output HDMI-A-1 --mode 1920x1080@60

******Compilar FLYCAST STANDALONE en GNU/Linux*******
NOTA PREVIA: Usa el emulador standalone sólo si tienes VRR/AdaptiveSync. Sin eso, es imposible que se sincronice bien.

Instalamos una dependencia previa rara:
apt-get install libcurl4-openssl-dev

git clone --depth 1 --recurse-submodules -j8 https://github.com/flyinghead/flycast.git

Configuramos y compilamos con:

mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DUSE_VULKAN=ON -DUSE_OPENGL=OFF \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

Ponemos la BIOS, llamada "dc_boot.bin", en ~/.local/share/flycast

PARA VÍDEO SUAVE (CON O SIN VRR, ES LO MISMO EN ESTE EMULADOR):
En Settings->Video, activa Vsync y "Duplicate Frames"

Entra en Settings->Video, y pon "Transparent Sorting" a "Per Pixel"
Puede ser necesario activar "Native Depth Interpolation" si tienes errores y usas un chip gráfico de Intel o AMD
(no consume más recursos ni nada según el autor del emulador).

Entra en Settings->Video, y desactiva "Fix Upscaling Bleeding Edge" ya que vas a usar los juegos en su resolución nativa,
así que no hay nada que arreglar.

Entra en Settings->Audio y pon el driver a SDL2 con 42ms de buffer (recuerda que para que el audio no tenga microcortes necesitas
un kernel "Preemptible Kernel (Low-Latency Desktop)" y a 300 Hz).

Si quieres puedes configurar la tecla de EXIT asignándola a ESC, en settings->controls->keyboard->map

RECUERDA: Para quitar los crujidos/dropouts de audio, usa el driver de audio SDL2,
OJO: NO pongas "FastGDRomLoad" a "yes" en ~/.config/flycast/emu.cfg: no mejora NADA y provoca problemas de audio en el REZ,
cosas raras en el Crazy Taxi, etc 

RECUERDA: Para que el menú se vea a buen tamaño con resolución 1080p, edita ~/.config/flycast/emu.cfg
y pon "UIScaling" a "200".

	#### BLOQUE ARREGLO PARA EL FRAMERATE ####

SÓLO WAYLAND (RECUERDA QUE EN WAYLAND+VULKAN EL VSYNC DEBE ESTAR DESACTIVADO!!!):
Creamos este script en /usr/local/bin/dreamcast para lanzar el emulador:

wlr-randr --output HDMI-A-1 --custom-mode 1920x1080@59.94
flycast "$1"
wlr-randr --output HDMI-A-1 --mode 1920x1080@60.000000

PARA LOS JUEGOS DE 30FPS: Activar "full framebuffer emulation"

	#### BLOQUE ARREGLO PARA EL FRAMERATE ####


	#### BLOQUE PARA EJECUTAR EL EMULADOR EN UN CONJUNTO DE CPUS AISLADAS ####
	
# Esto nos crea dos conjuntos de CPUs: "user" donde quedan las CPUs aisladas que hemos especificado
# y "system", donde quedarán las demás CPUs.
cset shield --cpu=0,1,2,3 --kthread=on

# Movemos el compositor al conjunto de CPUs aisladas ("user")
COMPOSITOR_PIDS=$(pgrep "wayfire")
for PID in $COMPOSITOR_PIDS; do
        cset proc --move --pid="$PID" user
done
                                                                                                                                       
# Ejecutamos el emulador en el conjunto de CPUs aisladas ("user")
wlr-randr --output HDMI-A-1 --custom-mode 1920x1080@59.94
cset shield --exec -- flycast "$1" > /dev/null 2>&1
wlr-randr --output HDMI-A-1 --mode 1920x1080@60.000000
                                                                                                                                       
# Una vez hemos acabado, eliminamos los conjuntos de CPUs para que todo vuelva a la normalidad.                                                                                                                 
cset shield --reset

		#### FIN BLOQUE PARA EJECUTAR EL EMULADOR EN UN CONJUNTO DE CPUS AISLADAS ####

ARREGLO PARA EL FRAMERATE, SÓLO PARA KMS/DRM:
Editamos core/deps/SDL/src/video/kmsdrm/SDL_kmsdrmvulkan.c y en la función KMSDRM_Vulkan_CreateSurface() comentamos el bloque de:
"for (i = 0; i < mode_count; i++) {"
y de:
"if (mode_found &&" y de ""
y de esa manera obligamos a que cree un modo de vídeo que nosotros queramos, y para que ese modo sea a 59.94Hz, cambiamos la línea:
new_mode_parameters.refreshRate = window->fullscreen_mode.refresh_rate * 1000;
por
new_mode_parameters.refreshRate = 59940;
(Para los juegos de NAOMI es igual).


******Compilar core MOJOZORK libretro***************************************************

git clone --depth 1 https://github.com/icculus/mojozork.git

mkdir b4
cd b4

cmake .. -DMOJOZORK_MULTIZORK=OFF \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2" \
-DCMAKE_C_FLAGS="-march=native -mtune=native -O2"

*************Compilar MAME standalone*******************************************************************************************

Instalamos dependencias previas:
apt-get install libfontconfig-dev

Clonamos su repo:
git clone -b mame0277 --depth 1 https://github.com/mamedev/mame.git mame0277

--Editamos 3rdparty/bgfx/3rdparty/khronos/EGL/eglplatform.h, buscamos la línea:

#elif defined(__unix__) || defined(USE_X11)

y cambiamos lo que hay ahí dentro por esto:

typedef struct gbm_device  *EGLNativeDisplayType;
typedef struct gbm_bo      *EGLNativePixmapType;
typedef void               *EGLNativeWindowType;

--Editamos scripts/src/osd/modules.lua, y allí:
----Borramos "input_x11.cpp".
----Nos vamos a la función osdmodulestargetconf(), y donde pone
links { 
	"GL",
lo cambiamos por "OpenGL".

--Editamos src/osd/modules/lib/osdobj_common.cpp y borramos la línea:
REGISTER_MODULE(m_mod_man, LIGHTGUN_X11)

--Compilamos así:
CFLAGS="-march=znver3 -mtune=znver3" \
CXXFLAGS="-march=znver3 -mtune=znver3" \
make USE_WAYLAND=1 NO_X11=1 USE_QTDEBUG=0 NO_USE_XINPUT=1 NO_USE_PULSEAUDIO=1 -j8

NOTA: No le pasamos los parámetros de optimización "native" típicos porque entonces VR sale con los gráficos mal,
así que le pasamos estos específicos de AMD.

	##### COMPILAR SÓLO CON DRIVERS SELECTOS #####

--Editamos "makefile" (en minúsculas) y añadimos la lista de los .cpp de los drivers que queremos que se incluyan, tal que así:
SOURCES = src/mame/sega/model1.cpp,src/mame/sega/model2.cpp,src/mame/namco/namcos11.cpp,src/mame/namco/namcos21.cpp,src/mame/namco/namcos21_c67.cpp,src/mame/namco/namcos22.cpp

--Compilamos añadiendo el parámetro "REGENIE=1" a MAKE (es para que se regenere la configuración o algo así):

CFLAGS="-march=znver3 -mtune=znver3" \
CXXFLAGS="-march=znver3 -mtune=znver3" \
make USE_WAYLAND=1 NO_X11=1 USE_QTDEBUG=0 NO_USE_XINPUT=1 NO_USE_PULSEAUDIO=1 REGENIE=1 -j8

(+)MÁS INFO DE REFERENCIA:

Un hilo sobre el asunto con la solución para compilar sólo un driver:
http://forum.arcadecontrols.com/index.php?topic=162794.0

This is actually spelled out in the mame documentation:

https://docs.mamedev.org/initialsetup/compilingmame.html

Quote:

    You can do driver specific builds by using SOURCES=<driver> in your make statement. For instance, building Pac-Man by itself would be:
    "make SOURCES=src/mame/drivers/pacman.cpp REGENIE=1"
    including the necessary REGENIE for rebuilding the settings

USAR MAME STANDALONE
====================

--Lo primero, para conocer todos los parámetros de MAME, hacemos "mame -showusage".

--Copiamos los directorios "bgfx" y "artwork" que vienen en la raiz de los sources a "~/mame/bgfx":
cp -R bgfx artwork ~/mame/

--Ejecutamos "mame" sin ningún juego, y en el menú nos vamos a "General Settings->Video Options",
y ponemos "Video Mode" a "bgfx", "GLSL" a "On", "Window Mode" a "off", "Wait Vertical Sync" a "On". 
El "Low Latency" no tiene ningún efecto si se tiene VRR: https://docs.mamedev.org/usingmame/commonissues.html#gsync-freesync
Los demás valores los dejamos como están por defecto.
Ahora, para que no nos salga la info de cada juego ni nos salgan los warnings con los juegos imperfectos,
nos vamos a "General Settings->Miscelaneous Options" y ponemos
"Skip imperfect emulation warnings" a "On"
"Skip system information screen" a "On"

--Ponemos un modo de 125Hz antes de entrar: eso nos permite que el VRR vaya bien con juegos ~55-60Hz
al darle 4Hz de sobra para que VRR "respire". Lo típico. Y sí, para que vaya perfecto son 125Hz, NO 123Hz.

--Editamos "~/.mame/mame.ini" y nos aseguramos de que esto está así:
bgfx_backend	vulkan

--Lanzamos MAME, entramos en el menú TAB, nos vamos a "Slider Controls", allí a "Window 0, Screen 0 Effect"
y con el cursor situado ahí, usamos los cursores a derecha/izquierda para seleccionar el efecto deseado. Se queda guardado para cada juego. 

--Para tener una fuente mejor en el menú:
----MÉTODO RECOMENDADO: Ejecutamos "mame" sin ningún parámetro para entrar en el menú del MAME en sí.
Nos vamos a "GENERAL SETTINGS -> CUSTOMIZE UI -> FONTS -> UI Font" y ahí podremos elegir entre las fuentes TTF del sistema.
----ALTERNATIVA: Usamos una fuente en formato .BDF que guardamos como "ui.bfd" en el mismo directorio del ejecutable como "ui.bdf"
y así se carga sola.
Nos podemos bajar fuentes en BDF ya listas de https://mrdo.mameworld.info/mame_artwork_supp.php
A mi me gusta la llamada "Nostalgia Four", que es estilo AtariST.

******CONOCER EL STATUS DE UN DRIVER DE MAME ANTES DE COMPILARLO******************

Lo más fácil es mirar en su fichero de código si tiene algún flag como MACHINE_IMPERFECT_SOUND, MACHINE_IMPERFECT_GRAPHICS, etc.
Los flags posibles los puedes ver aquí: https://wiki.mamedev.org/index.php/Game_Drivers
Por ejemplo, para saber qué imperfecciones hay en los drivers del fabricante APPLE, puedes hacer esto:
grep MACHINE_IMPERFECT_ src/mame/apple/* -R

******Compilar MAME LIBRETRO con soporte sólo para unos ciertos drivers************
NOTA IMPORTANTE!!! Para entrar en el menú interno de MAME, mantén pulsado SELECT y pulsa el botón que tengas asignado como Y.

git clone --depth 1 https://github.com/libretro/mame.git

Ahora, editamos "makefile" (en minúsculas) y añadimos la lista de los .cpp de los drivers que queremos que se incluyan, tal que así:
SOURCES = src/mame/sega/model1.cpp,src/mame/sega/model2.cpp,src/mame/namco/namcos11.cpp,src/mame/namco/namcos21.cpp,src/mame/namco/namcos21_c67.cpp,src/mame/namco/namcos22.cpp

Ahora ya ponemos compilar así (lo de REGENIE es para que se regenere la configuración o algo así):
CFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
CXXFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
make REGENIE=1 -f Makefile.libretro -j4

******DAYTONA USA EN MAME*********************************************************************

Para poner el juego en inglés y en "single":
Pulsamos F2 para entrar en modo "service", y allí nos movemos con el 9 y aceptamos con el 1.
Entramos en "Game System" y allí ponemos "LINK ID" a "SINGLE" y "COUNTRY" a "EXPORT" o a "USA".

******USAR MAME LIBRETRO PARA EMULAR MACINTOSH 128/SE Y MACINTOSH II**************************
OJO!!! OJO!! OJO!! El core MAME de RetroArch NO soporta Runahead al emular Mac , si lo tienes fallará el arranque con un error del sistema Mac,
y habrá un sonido popping de fondo muy desagradable. 
NOTA IMPORTANTE!!! Para entrar en el menú interno de MAME, como este es un core de ordenador primero debes pulsar ScrollLock y después
mantén pulsado SELECT y pulsa el botón que tengas asignado como Y.

El Macintosh 128 original no soporta disco duro, si queremos un Mac en blaco y negro emulamos el Mac SE (el Mac Plus no arranca con discos
de más de 20MBm y el Mac Classic es incompatible con el Arkanoid).

-Bajamos la última versión estable de: https://github.com/libretro/mame/tags

-En makefile, la línea de SOURCES la dejamos así para Mac 128 (emulamos Mac SE que es el más compatible como se ha explicado arriba)
y Mac II Ci:
SOURCES = apple/mac128.cpp,apple/maciici.cpp

Ahora ya ponemos compilar así (lo de REGENIE es para que se regenere la configuración o algo así):
CFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
CXXFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
make REGENIE=1 -f Makefile.libretro -j10

-Las ROMs necesarias de los Mac que vamos a emular las bajamos de retroroms.info (Downloads->MAME->Current ROMs)
 Para emular un Mac SE, necesitamos adbmodem.zip y macse.zip.
 
-Creamos el directorio "macse" y ahí metemos las roms
adbmodem.zip
macse.zip
macsefd.zip
maciici.zip y la imágen de disco que queramos usar (la mía se llama system.hdv),

-Creamos un archivo llamado "macse.cmd" (lo podemos llamar como queramos, PERO ES FUNDAMENTAL que tenga extensión ".cmd")
con el contenido:
macse -rompath macse -hard macse/system.hdv

-Lo cargamos con:
retroarch -L ~/.config/retroarch/cores/mame_libretro.so macse.cmd

OJO!!! OJO!! OJO!! MAME al emular Mac NO soporta Runahead, si lo tienes fallará el arranque con un error del sistema Mac,
y habrá un sonido popping de fondo muy desagradable. 

PARA SALIR de "The Manhole", mantén presionado COMMAND (en PC es ALTGr) junto con SPACE, y sale la barra de arriba y puedes salir.

	BLOQUE PARA CREAR LA IMÁGEN DE DISCO DURO (NO NECESARIO, TIENES LA IMÁGEN .HDV EN EL DISCO DE BACKUP, ES POR SI LA PIERDES)
	(Info destilada de: https://wiki.mamedev.org/index.php/Driver:Mac_68K)

El ejemplo va a ser para crear una imágen de Macintosj II ci (maciici) pero para Mac SE es muy parecido (sólo cambia la versión
del sistema que instalamos).

-Nos creamos una imágen de disco de 128M:
dd if=/dev/zero of=system.hdv bs=1000000 count=128

-Lo primero, en RetroArch, ponemos "Settings->Input->Auto Enable Game Focus Mode" a "Detect",
 y "Settings->Input->Hotkeys->Game Focus(Toggle)" a "Key LSuper".
 Esto es imprescindible para que el ratón vaya bien dentro del emulador y para tener teclado.

-Arrancamos en modo Mac II tanto si vamos a emular un Mac 128/SE como si vamos a emular un Mac II (ya que si no, no tenemos CDROM)
 con el "Apple Legacy Recovery Oct 1999", que lo tienes en el disco de backup y también está en archive.org.
 Para ello, creamos "maciici.cmd" con el contenido:
 maciici -rompath macse -ramsize 8M -hard maciici/system.hdv -cdrom "Apple Legacy Recovery Oct 1999.iso"
 Y lo lanzamos con:
 retroarch -L mame_libretro.so maciici.cmd
 
 Nos vamos a "Legacy Recovery" y a "Disk Utilities" y a "Formatting Software" y a "Driver Setup 1.5",
 seleccionamos el disco y le damos a inicializar. Cuando acabe, reiniciamos la emulación.
 Para Mac 128/SE instaremos el System 6.0.8, y para Mac II el System 7.1 (El 7.1.1 Pro sólo se diferencia
 en que trae algunos extras que no usamos como AppleTalk, utilidades de file sharing, etc..,
 y las versiones más modernas que 7.1.1 usan ya MUCHA RAM).
 Para ello, nos vamos a "System Software by CPU" e instalamos la versión del System que corresponda según hemos dicho,
 usando el "Net Install.scr". Le damos a "Customize", elegimos "System Software for all Macs" y le damos a INSTALL.
 
	BLOQUE PARA METER JUEGOS EN LA IMÁGEN DE DISCO
 
Usamos HFSUTILS.
(Si no nos funciona "apt-get install hfsutils" (no parece haber hfsutils en Debian 13),
nos bajamos la última versión del paquete .deb desde https://debian.stanford.edu/debian/pool/main/h/hfsutils/ y la instalamos a mano con dpkg).

Lo primero, nos bajamos el Stuffit Expander 5.5 en formato .img de aquí:
https://winworldpc.com/product/stuffit-expander/55
(La primera descarga, en la que pone "3.5-1.44mb" y el icono de un diskette)

Ahora montamos el IMG con el hmount (nos quedamos con el "Volume name"):
hmount stuffit_expander_5.5.img
Miramos sus contenidos si queremos:
hdir "StuffIt Expander 5.5":
Copiamos el instalador a un directorio de Linux:
mkdir stuffit
hcopy -m "StuffIt Expander 5.5":* stuffit/
(El "-m" es para que no se pierda el "resource fork")
Desmontamos el IMG:
humount "StuffIt Expander 5.5":
Ahora montamos el disco de sistema (nos quedamos con el "Volume name"):
hmount macse/system.hdv
Y copiamos el instalador del stuffit allí:
hcopy -m stuffit/* System:
Y desmontamos el disco de sistema:
humount System
Ahora en el Mac instalamos el Stuffit (dice que necesita System 7.1.1 pero con 7.1 va igual),
y ya podemos descomprimir archivos SIT que le podemos subir directamente como queramos ya que no hay que preocuparse por el tema de los forks.

Ahora, por ejemplo podemos bajarnos un puñado de juegos en .SIT (macintoshgarden.org),
y luego los copiamos al sistema para después descomprimirlos con Stuffit, así (en este caso no hace falta "-m" porque no tenemos resource fork):
hmount macse/system.hdv
hcopy juegos/* System:
humount System

OJO!!! NOTAS PARA JUEGOS ESPECÍFICOS:
-Dungeon Master II: Necesita el QuickTime 2.1 y el Sound Manager 3.1. Ambos vienen en el CD "Apple Legacy Recovery Oct 1999"
 que has usado para instalar el sistema.
-Para extraer juegos comprimidos con .CPT debes usar Stuffit Deluxe 4.5, PERO instalarlo supone que te llena de mierda el sistema
 y no se puede limpiar ni borrando las extensiones que mete. Así que usa una copia desechable del disco duro de sistema.
-Hay juegos, como el Alone in the Dark, que están en un IMG que es para DiskCopy, un programa de Mac, y que
por lo tanto no se pueden montar desde Linux con el típico "mount -t hfs". Para esos, usa DiskCopy 6.3.3 de Mac.

ALTERNATIVA: TRAERNOS LOS JUEGOS YA INSTALADOS DESDE UNA IMÁGEN DE DISCO PRE-COCINADA
Por ejemplo, vamos a extraer los archivos del Prince de una imágen de disco
al sistema de archivos de Linux, extracción que hacemos en formato macbinary (para eso es el "-m") para que no se pierda el "resource fork",
y luego copiamos esos archivos al disco HFV:

hmount prince.dsk
hdir "Prince of Persia"
mkdir prin
hcopy -m "Prince of Persia":* prin/
humount prince.dsk

hmount myhdd.hdv
hmkdir "System7":"Prince of Persia"
hcopy -m prin/* "System7":"Prince of Persia":
humount hyhdd.hdv

PARA EVITAR PROBLEMAS AL PULSAR SHIFT, ve a Menú Manzana->Control Panels, crea una carpeta llamada DISABLED, y mete ahí el panel "Easy Access".
De lo contrario, pulsando shift varias veces (como en el Prince cuando luchas) se interrumpe todo el sistema para activar "sticky keys".
PARA DESACTIVAR EXTENSIONES, ve a SYSTEM FOLDER, EXTENSIONS, y ahí creas una carpeta llamada DISABLED y metes las extensiones
que quieras deshabilitar.

		FIN BLOQUE PARA CREAR LA IMÁGEN DE DISCO DURO

******USAR MAME PARA EMULAR UN 486 CON EL DRIVER CT486******************************************
(INFORMACIÓN ORIGINAL SOBRE LA CONFIGURACIÓN DEL DRIVER: https://wiki.mamedev.org/index.php/Driver:CT486)

	PARTE 1: ARRANQUE Y CONFIGURACIÓN PREVIA DEL SISTEMA

--Se necesitan las BIOS:
at_keybc.zip
ct486.zip
et4kw32i.zip
s3_764.zip
kb_ms_natural.zip

--Creamos el directorio ~/mame/ct486 donde metemos las BIOS.

--Creamos una imágen de disco de 512MB con:
dd if=/dev/zero of=ct486/dos622.img bs=1M count=512

--Metemos el set de discos de MS-DOS (Disk1.img, Disk2.img, Disk3.img, Disk4.img) en en directorio ct486. 

--Lanzamos el sistema con:
mame ct486 -rompath ct486 -hard1 ct486/dos622.img

--Le damos a F1 para continuar cuando nos dé el error, y le damos a DEL para entrar en la BIOS.

--En la BIOS:
----Nos vamos a "STANDARD CMOS SETUP":
--------En "HARD DISK C: Type" ponemos
		"CYLN" a 1041, "Head" a 16, "WPCom" y "LZone" a 0, "Sect" a 63, y nos tiene que salir "Size" puesto a 2048 MB.
(NOTA: Si la imágen de disco que hemos creado fuese más grande, simplemente ajustaríamos el número de CYLN
y los demás parámetros los dejaríamos como están. O sea que 1041 es para 512MB, para 2GB serían 4161, etc).
--------En "Floppy Drive A:" ponemos "1.44 MB 3 1/2"
----Nos vamos a "ADVANCED CMOS SETUP" y ponemos "System Boot Up Sequence" a "A:, C:"

	PARTE 2: INSTALACIÓN DE MS-DOS

--Lanzamos el sistema otra vez con:
mame ct486 -rompath ct486 -hard1 ct486/dos622.img -flop1 ct486/Disk1.img

--Aporreamos teclas (las que queramos) justo antes de que aparezca lo de "Iniciando MS-DOS..." para evitar que se cuelgue.
(Ni idea, pero funciona).

--Salimos de la instalación con F3. Particionamos el disco con FDISK, reiniciamos, volvemos a salir de la instalación,
formateamos con "format c:", y reiniciamos.
Esta vez procedemos con la instalación. Cuando nos pida otro diskette, pulsamos SCREEN LOCK (=BLOQ.DESP) para que se nos permita
usar la GUI de MAME.
(Si el teclado no tiene SCREEN LOCK, asignamos la tecla que queramos en:
"General Settings -> Input Assignments -> User Interface -> Toggle UI Controls". Yo en el portátil uso el 0 del keypad). 
Ahora pulsamos TAB para entrar en dicha GUI, entramos en FILE MANAGER y elegimos el siguiente diskette,
y así sucesivamente.

	PARTE 3: AÑADIR JUEGOS Y PROGRAMAS

--Para meter más juegos, simplemente montamos la imágen con:
sudo mount dos622.img -o rw,offset=32256 /mnt
Le metemos lo que queramos y lo desmontamos.

--Para tener 16MB de RAM y Sound Blaster 16 (poner otra tarjeta VGA aparentemente mejor como la S3 en el slot "isa1" no produce ninguna diferencia),
lanzamos el sistema así:
mame ct486 -rompath ct486 -hard1 ct486/dos622.img -ramsize 16M -isa1 svga_s3 -isa2 sblaster_16
(RECUERDA QUE PUEDES VER LAS OPCIONES DE SLOTS DISPONIBLES CON "-listslots")

--Para que vaya el sonido con Sound Blaster 16 en los juegos que necesitan la variable BLASTER, ponla así en AUTOEXEC.BAT:
SET BLASTER=A220 I5 D1 T6 P330

--Con VRR, para que el scroll vaya perfecto tanto en juegos de ~70Hz como de ~60Hz,
ponemos el máximo refresco del monitor antes de entrar:
wlr-randr --output DP-1 --mode 1920x1080@143.854996

******USAR MAME LIBRETRO PARA EMULAR UN APPLE2GS************************************************
NOTA IMPORTANTE!!! La emulación de este sistema en MAME no soporta RunAhead!!! Así que desactívalo y sálvalo como un GAME OVERRIDE.
Si lo dejas activado, los programas se comportan de manera muy extraña: no tienen sonido, se resetean al pulsar teclas o botones, etc.
NOTA IMPORTANTE!!! Para que funcione el joystick tienes que pasarle en el .cmd la opción "-gameio joy"
Hay otras cosas que puedes conectar en el slot "gameio", lo puedes ver aquí: https://wiki.mamedev.org/index.php/Driver:Apple_II
NOTA IMPORTANTE!!! Para entrar en el menú interno de MAME, como este es un core de ordenador primero debes pulsar ScrollLock y después
mantén pulsado SELECT y pulsa el botón que tengas asignado como Y.

Información adicional: https://wiki.mamedev.org/index.php/Driver:Apple_II
(Ver sección "Quickstart")

En makefile, dejamos así la línea SOURCES:
SOURCES = apple/apple2.cpp,apple/apple2gs.cpp

Compilamos con:
CFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
CXXFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
make REGENIE=1 -f Makefile.libretro -j10

Creamos ~/apple2gs con las ROMS:
apple2gs.zip
a2scsi.zip
a2cffa2.zip
(La ROM "a2cffa2.zip" es para emular la expansión interface CF, llamada cffa2, que nos permite cargar imágenes de disco duro en un IIGS,
que normalmente funciona con floppies y no sabe nada de discos duros).

Para lanzar un juego en floppy, creamos apple2gs.cmd con este contenido:
apple2gs -rompath apple2gs -ramsize 8M -gameio joy -flop3 apple2gs/juego.2mg
(NOTA: flop3 y flop4 son para discos 2mg/po de 800K del IIGS, ya que flop1 y flop2 son para discos de AppleII.
 Por eso para cargar discos de IIGS le pasamos "-flop3").

LO MÁS RECOMENDADO: para cargar una imágen de un juego en disco duro individual de la colección EXOAPPLEIIGS (disponible por Torrent
en https://www.retro-exo.com/appleIIGS.html) hacemos:
apple2gs -rompath apple2gs -ramsize 8M -sl7 cffa2 -gameio joy -hard1 apple2gs/Immortal.po

SI FUESE UN JUEGO DE DOS DISCOS, como el Rocket Ranger, haríamos:
apple2gs -rompath apple2gs -sl7 cffa2 -hard1 "apple2gs/Rocket-1.2mg" -hard2 "apple2gs/Rocket-1.2mg"

Y para cargar el cmd hacemos así:
retroarch -L mame_libretro.so apple2gs.cmd

OTRAS ALTERNATIVAS DE SOFTWARE PREINSTALADO EN DISCO DURO PARA EL IIGS

Por ejemplo, para cargar la conección de Ninja Force, cargamos a la vez el disco de arranque con el sistema
y los discos que queramos de las diferentes categorías de juegos (por eso usamos cffa2 en vez de scsi,
ya que con scsi sólo se puede cargar una única imágen de disco cada vez):
apple2gs -rompath apple2gs -ramsize 8M -sl7 cffa2 -hard1 apple2gs/A_Boot.po -hard2 "apple2gs/C_Adventure and Sim Games.hdv"

Colección de juegos de Apple IIGS en disco duro:
http://www.ninjaforce.com/downloads/wita2gs_0_70.zip
Software en disco duro preparado:
https://www.whatisthe2gs.apple2.org.za/home/index.html
Concretamente, juegos instalados en disco duro y parcheados para funcionar:
https://www.whatisthe2gs.apple2.org.za/files/Games_with_Path_Mods.zip

*************EMULAR UN X68000 EN MAME*******************************************************************************************
NOTA IMPORTANTE!!! La emulación de este sistema en MAME no soporta RunAhead!!! Así que desactívalo y sálvalo como un GAME OVERRIDE.
Si lo dejas activado, los programas se comportan de manera muy extraña: no tienen sonido, se resetean al pulsar teclas o botones, etc.
NOTA IMPORTANTE!!! Para que funcione el joystick, ve a "QUICK MENU->CONTROLS->PORT 1 CONTROLS" y pon "MAPPED PORT" a 2.
También ve a "QUICK MENU->CONTROLS->PORT 2 CONTROLS" y pon "MAPPED PORT" a 1.
NOTA IMPORTANTE!!! Para entrar en el menú interno de MAME, como este es un core de ordenador primero debes pulsar ScrollLock y después
mantén pulsado SELECT y pulsa el botón que tengas asignado como Y.
NOTA IMPORTANTE!!! Para quitar los LEDs de la pantalla, entra en el menú interno de MAME,y ve a "VIDEO OPTIONS->SCREEN #0" y selecciona 
"Screen 0 Standard (4:3)"

Creamos un directorio llamado "x68000" y dentro ponemos:
x68000.zip
x68k_cz6bs1.zip
+Juegos en floppy o en disco duro.

--SÓLO SI NO TIENES VRR: Cargamos el core así con el .cmd que crearemos con las instrucciones a continuación (el sistema va a 55.86254 Hz):
wlr-randr --output HDMI-A-1 --custom-mode 1920x1080@111.72508
retroarch -L mame_libretro.so x68000.cmd
wlr-randr --output HDMI-A-1 --mode 1920x1080@60

--Para arrancar con los dos floppys del Akumajou Dracula, creamos el archivo "x68000.cmd" con el contenido:
x68000 -rompath x68000 -flop1 "x68000/Akumajou Dracula (Disk A).hdm" -flop2 "x68000/Akumajou Dracula (Disk B).hdm"

--Y para arrancar con una imágen de disco duro (el x68000 original no arranca desde el disco duro SCSI así que arrancamos desde
un disco maestro o algo así, tienes copia de ese disco de arranque en el disco duro de backup):
x68000 -rompath x68000 -flop1 MasterDisk_V2.xdf -exp1 cz6bs1 -hard1 x68000/akumajou.hdf 

--Tienes imágenes de floppy y de disco duro para cada juego si buscas "x68000 collection" en Archive.org
--Tienes imágenes de disco duro grandes con muchos juegos por imágen (poco práctico en MAME...) en:
https://nfggames.com/forum2/index.php?board=14.0

******KILLER INSTINCT en core MAME LIBRETRO*******************

En el mismo directorio donde tengas el kinst.zip, crea un directorio kinst donde meterás el .chd, quedando así:
/kinst.zip
/kinst/kinst.chd
Ahora lánzalo pasándole el directorio donde está el CHD:
retroarch -L .config/retroarch/cores/mame_libretro.so emulation/MAME/kinst

*************ROMS MAME**********************************************************************************************************

https://pleasuredome.github.io/pleasuredome/mame/

******Compilar DOLPHIN standalone en GNU/Linux****************

Dependencias previas:
sudo apt-get install libevdev-dev

git clone --depth 1 --recurse-submodules -j8 https://github.com/dolphin-emu/dolphin.git

cmake .. -DCMAKE_BUILD_TYPE=Release \
-DENABLE_QT=OFF -DENABLE_PULSEAUDIO=OFF -DENABLE_LLVM=OFF -DENABLE_TESTS=OFF -DUSE_DISCORD_PRESENCE=OFF \
-DUSE_MGBA=OFF -DENABLE_AUTOUPDATE=OFF -DUSE_UPNP=OFF -DENABLE_ANALYTICS=OFF -DENCODE_FRAMEDUMPS=OFF \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

******Space Cadet pinball en GNU/Linux*********

Bajamos los últimos sources estables de aquí:

https://github.com/k4zmu2a/SpaceCadetPinball/releases

Configuramos y compilamos con:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native"
make -j4

Copiamos el ejecutable y los datos del juego (que los tienes ya preparados en el disco duro de backup).

Cargamos el juego pasándole una fuente SF2 a SDL así para que suene la música:
SDL_SOUNDFONTS=TimGM6mb.sf2 ./SpaceCadetPinball

Puedes ajustar la configuración (fullscreen, uncapped framerate, etc..) en el menú, o editando ~/.local/share/SpaceCadetPinball/imgui_pb.ini

******Juegos JAVA que usan GL/GLES en GNU/Linux*********************************************************************

Lo primero sería compilar esta librería:
https://github.com/LWJGL/lwjgl3

******TIC-80 FANTASY CONSOLE para Raspberry Pi como core libretro***************************************************

Clonamos su repo:
git clone --recursive https://github.com/nesbox/TIC-80 --depth 1

Configuramos con:
cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_LIBRETRO=ON -DBUILD_SDL=OFF -DDISABLE_NETWORKING=TRUE \
-DCMAKE_C_FLAGS="-march=native -mtune=native" ..

Los juegos están en:
https://tic80.com/play?cat=0

******Error tonto: ACLOCAL is missing on your system********

No te falta nada realmente. Sencillamente, hazle un touch a:
aclocal.m4
configure
Makefile.am
Makefile.in

Y ya debería solucionarse. Sin instalar nada.

******Llaves en LibreOffice**********

Antes de esto, aprende a trabajar con marcos de texto, de manera que puedas luego moverlos dentro de las laves y tal sin andar jugando con tabulaciones.
Los marcos de texto se crean con Insert->Text Box. Así de fácil.
Ahora ya, lo de las llaves va así:

1)Abrimos el programa de libreoffice
2)Clickeamos en barra de herramientas opción "ver".
3)Luego de entrar en la opción "ver" continuamos clickeando en "barra de herramientas"
4)Después ingresamos a la opción dibujo para lograr aparecer "la tabla de dibujo".
5)Tocamos en las formas de símbolos (una carita sonriente).
6)Clickeamos en la llave de apertura.
7)Para darle color, forma y espesor clickeamos en la llave con el botón derecho en la opción línea.
8)Cada cual elige como desea su llave.
9)Para rotarla se debe tocar con el botón derecho, posición y tamaño y en el mismo rotación.
10)Y luego cada uno elige la predeterminación que desea.
11)Llave finalizada.

******ESTABILIZAR FRAMERATE CON VRR********************************

echo "high" > /sys/class/drm/card0/device/power_dpm_force_performance_level

******AVERIGUAR QUÉ PARÁMETROS ACEPTA UN MÓDULO DEL KERNEL*********

modinfo -p <nomre_módulo>

Por ejemplo:
modinfo -p i915

Y podemos pasarle parámetros en la línea de comandos del GRUB editando /etc/default/grub,
tras lo cual debemos ejecutar "update-grub".

******Overclockear la GPU Intel integrada en GNU/Linux*************
NOTA: A PARTE DE ESTO, ME INTERESA DESACTIVAR EL RC6 DE DE LOS GRÁFICOS INTEL, YA QUE AUNQUE LO DESACTIVEMOS EN LA BIOS,
SIGUE ACTIVÁNDOSE EN EL KERNEL, COSA QUE SABEMOS PORQUE "/sys/class/drm/card0/power/rc6_residency_ms" SIGUE AUMENTANDO.
PARA ELLO, cuando compilo un kernel siempre edito "drivers/gpu/drm/i915/gt/intel_rc6.c"
y hago que la función rc6_supported() retorne siempre "false" (esto está en NOTAS_DEBIAN.TXT en la sección de compilación del kernel),
con lo cual nunca se entra en RC6 (podemos monitorear "/sys/class/drm/card0/power/rc6_residency_ms" para comprobar que nunca sube de 0).
NINGUNO de los parámetros del módulo i915 funciona para desactivar el RC6 ("i915.enable_rc6=0" no existe desde 2017,
"i915.enable_dc=0" no hace nada, y el módulo "intel_idle" no existe).

Ve a /sys/class/drm/card0 y juega con esos valores.
Por ejemplo, para que la GPU no baje de 1200 MHz, puedes hacer:
echo 1200 > gt_min_freq_mhz
Y lo puedes comprobar con:
cat gt_cur_freq_mhz

Con este script pondríamos a velocidad máxima constante la GPU, y después de ejecutar un programa la devolvemos a su velocidad normal:

####EMPIEZA SCRIPT####

gpu_min_freq=$(cat /sys/class/drm/card0/gt_min_freq_mhz)
echo $(cat /sys/class/drm/card0/gt_max_freq_mhz > /sys/class/drm/card0/gt_min_freq_mhz)

<EJECUTAR_PROGRAMA>

echo $gpu_min_freq > /sys/class/drm/card0/gt_min_freq_mhz

####ACABA SCRIPT####

*******Overclockear la CPU Intel en GNU/Linux**********************

Ve a /sys/devices/system/cpu/cpu0/cpufreq/ y juega con esos valores.
Por ejemplo, mira la velocidad máxima de la CPU con:
cat scaling_max_freq
Y para que siempre vaya a la velocidad máxima, puedes hacer (4400000 es la velocidad máxima en este caso):
echo 4400000 scaling_min_freq
Y lo puedes comprobar con:
cat scaling_cur_freq

Podrías pensar que poner a performance el governor tiene el mismo efecto, pero no. Si haces:
echo performance > scaling_governor
Puedes comprobar que si haces:
cat scaling_cur_freq
...No va a la velocidad máxima.

Con este script pondríamos a velocidad máxima las CPUs 0 y 1, y después de ejecutar un programa las devolvemos a su velocidad normal:

####EMPIEZA SCRIPT####

#Declaramos un array para guardar los valores originales de min_freq de los P-Cores
declare -A cpu_min_freqs

#Ponemos los dos P-Cores al máximo
for cpu in cpu0 cpu1; do
        cpu_min_freqs[$cpu]=$(cat /sys/devices/system/cpu/$cpu/cpufreq/scaling_min_freq)
        echo $(cat /sys/devices/system/cpu/$cpu/cpufreq/scaling_max_freq) > /sys/devices/system/cpu/$cpu/cpufreq/scaling_min_freq
done

<EJECUTAR_PROGRAMA>

#Devolvemos los P-Cores a su estado normal
for cpu in cpu0 cpu1; do
        echo ${cpu_min_freqs[$cpu]} > /sys/devices/system/cpu/$cpu/cpufreq/scaling_min_freq
done

####ACABA SCRIPT####

Puedes vigilar la temperatura de la CPU con:
watch -n 0.5 'cat /sys/class/thermal/thermal_zone1/temp'
Es en milésimas de grado, así que con que mires las dos primeras cifras es suficiente.
El i5-1235U hace thermal throttling a los 100 grados.

******Scripts "turbo" y "noturbo" para overclockear la CPU y la GPU del i5-1235U***********

####TURBO EMPIEZA####
# Ponemos los dos P-Cores al máximo
for cpu in cpu0 cpu1; do
        echo 4400000 > /sys/devices/system/cpu/$cpu/cpufreq/scaling_min_freq
done

# Ponemos los E-Cores al máximo
for cpu in cpu2 cpu3 cpu4 cpu5 cpu6 cpu7 cpu8 cpu9; do
        echo 3300000 > /sys/devices/system/cpu/$cpu/cpufreq/scaling_min_freq
done

# Ponemos la GPU al maximo
echo 1200 > /sys/class/drm/card0/gt_min_freq_mhz
####TURBO ACABA####



####NOTURBO EMPIEZA####
#Restaurar los P-Cores
for cpu in cpu0 cpu1; do
        echo 400000 > /sys/devices/system/cpu/$cpu/cpufreq/scaling_min_freq
done

#Restaurar los E-Cores
for cpu in cpu2 cpu3 cpu4 cpu5 cpu6 cpu7 cpu8 cpu9; do
        echo 400000 > /sys/devices/system/cpu/$cpu/cpufreq/scaling_min_freq
done

# Restaurar GPU
echo 100 > /sys/class/drm/card0/gt_min_freq_mhz
####NOTURBO ACABA####

******Overclockear la Raspberry Pi 4*******************************

[pi4]
# Run as fast as firmware / board allows
arm_boost=1

[all]
over_voltage=4
arm_freq=1800
gpu_freq=600
force_turbo=1

(NO ES NECESARIO ningún valor de overvoltage, el firmware ajusta el voltaje automáticamente desde hace tiempo).
(gpu_freq a 600 es necesario para que los shaders funcionen fullspeed en 1080p).

******Vigilar la temperatura del SOC de la Raspberry Pi************

watch -n 0.5 'cat /sys/class/thermal/thermal_zone0/temp'

(Nos da la temperatura en milésimas de grados centígrados, así que con que mires las dos primeras cifras vale,
y nos la mide cada 0.5 segundos.
La Pi4 empieza a hacer throttling a los 80 grados, y hace full throttling a los 85).

******Medir velocidad de la CPU en Raspberry Pi**********

sudo cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq

*****SDL2 en hardware genérico con mi driver KMSDRM******

Lo primero, borra la versión del sistema.
sudo rm -R /usr/lib/libSDL*
sudo rm -R /usr/include/SDL*

VAMOS A DEJAR QUE SE INSTALE EN /usr/local/lib Y /usr/local/include, ASÍ QUE NO LE PASAMOS --prefix=/usr

Antes de compilar, instalamos estas dependencias:
sudo apt-get install libudev-dev libasound2-dev libvorbis-dev libpng-dev libjpeg-dev libfreetype6-dev xsltproc libpciaccess-dev xutils-dev libtool make automake pkg-config gcc g++ --no-install-recommends
(libgbm NO TENEMOS QUE INSTALARLO ni nada, se compila e instala con MESA automáticamente, si es que instalas MESA compilándolo por tu cuenta. Si no, pues sí, hace falta libgbm-dev si usas un MESA precocinado.)
(Si has compilado SDL2 con soporte para kmsdrm pero te da el error "not available video device", es porque compilaste sin tener instalado libgmb-dev junto con un MESA precocinado, y no te ha avisado... Instala ese paquete y recompila, anda.)

Clonamos:
git clone --depth 1 https://github.com/libsdl-org/SDL.git

Ahora ya configuramos:
./configure --enable-video-x11 --disable-video-wayland --disable-dbus --disable-diskaudio --disable-oss \
--disable-pulseaudio --disable-dummyaudio --disable-video-dummy --enable-video-opengles --enable-video-opengl \
--enable-libudev --disable-dbus --disable-ime --enable-video-kmsdrm

Fíjate que en el resúmen al acabar del configure, te tiene que indicar que el soporte KMSDRM está activado, para ello se requiere que las librerías necesarias estén en el sistema (libgbm y libdrm).
Ahora borra las librerías libSDL2* que vienen instaladas en la mayoría de las distros en /usr/lib/x86_64-linux-gnu/, e instala las que acabas de compilar, que acabarán en /usr/lib.

Si quieres debugear las SDL, añade antes de ./configure: CFLAGS="-O0 -ggdb"

******SDLPop : el clon open source y libre de Prince of Persia para GNU/Linux*********

Bajamos la última release estable de aquí:
https://github.com/NagyD/SDLPoP/tags

Entramos en el directorio "src", y compilamos con:
CFLAGS="-march=native -mtune=native" CPPFLAGS="-march=native -mtune=native" make -j4

******Cambiar la región de un juego de MegaDrive y Master System********************

PARA IR A UNA DIRECCIÓN CONCRETA EN HEXEDIT: PULSA ENTER Y TE PIDE LA DIRECCIÓN, Y ALLÁ VAMOS.
Editamos el juego con el hexedit. Nos vamos a la dirección $1F0. Pulsamos TAB para ir al texto. Cambiamos la E por una U, o por una J, como queramos.
Salimos y salvamos con CTRL+X.
Si el juego así alterado nos da un pantallazo rojo o negro, es que nos hemos cargado el checksum, pero sería muy raro. Hay programas para repararlo, anyway.

Para juegos de Master System, buscamos $7FFF, que ya sé que está muy avanzada, pero es esa,
y cambiamos el valor correspondiente a los primeros 4 bits de esa dirección: 
si es PAL vendrá un 4, pones un 3 donde el 4 SIN CAMBIAR al texto con TAB, sino directamente en los valores en HEX, y ya lo tienes en JAP.
Míralo aquí mejor si no lo pillas: http://www.smspower.org/Development/ROMHeader#ProductCode7ffc25Bytes

******Emulando arcades con la frecuencia de vídeo correcta en RetroArch sin VRR*****

OJO!!! Si usas esta técnica, NO ACTIVES "Force 60Hz" en FBNeo: son mutuamente excluyentes!!!
OJO!!! Si usas esta técnica, recuerda incrementar "MAXIMIMUM TIMING SKEW" hasta 0.100 o algo así,
ya que no vas a usar frecuencias exactas de los juegos sino redondeadas para más compatibilidad,
por lo que va a haber una diferencia de a veces más de 1Hz con la velocidad original del juego, así que
con el "MAXIMIMUM TIMING SKEW" por defecto habría micro-stuttering debido a esa diferencia.

Vamos al lio: Usando un shellscript, es posible establecer un refresco de pantalla según el nombre del juego,
y pasarle un fichero de configuración con ese refresco a RetroArch.
Se usa frecuencia doble para evitar el input lag por vsync, por lo que un juego de 55Hz usará una frecuencia de 110Hz,
y se usan números enteros: un juego de 54.70684 se considerará que va a 55Hz.
Además, algunos juegos se ejecutan con MAME en lugar de FBNeo.
Este sería mi cargador de juegos arcade:

##########EMPIEZA EL CARGADOR DE ARCADES############# 

CORE=fbneo_libretro.so

case "$1" in
  *mk*)
    new_refreshrate=108.000000
    ;;
  *hharry*|*rtype*|*demonwld*|*outzone*|*nspirit*)
    new_refreshrate=110.000000
    ;;
  *rodland*|*vigilant*)
    new_refreshrate=112.000000
    ;;
  *pang*|*spang*|*thoop*|*tumblep*|*robocop*|*baddudes*|*drgninja*|*xsleena*|*vf*|*vr*)
    new_refreshrate=114.000000
    ;;
  *cbuster*|*darkseal*|*cninja*|*snowbros*)
	# Estos deberían ir a ~116Hz, pero el monitor no acepta esa frecuecia.
    new_refreshrate=115.000000
    ;;
  *aligator*)
    new_refreshrate=118.000000
    ;;
  *)
    new_refreshrate=0
    ;;
esac


# Para ciertos juegos, usamos el MAME porque no están en el FBNeo.
if [[ "$1" =~ vf|vr|ridgerac ]]; then
	CORE=mame_libretro.so
fi


if [ $new_refreshrate != 0 ]; then
    echo "This game needs refresh rate adjustment. Adjusting screen refresh rate."
                                                                                                                             
    new_videomode="1920x1080@"$new_refreshrate

    echo "video_refresh_rate = "$new_refreshrate >> /tmp/video_adjust.cfg
    echo "config_save_on_exit = "false"" >> /tmp/video_adjust.cfg

    echo "New videomode is:"$new_videomode
    wlr-randr --output HDMI-A-1 --custom-mode $new_videomode
    sleep 1

    sync
    retroarch -L .config/retroarch/cores/$CORE --appendconfig /tmp/video_adjust.cfg "$1"

    echo 'Restoring default screen refresh rate...'
    wlr-randr --output HDMI-A-1 --mode 1920x1080@60
    rm /tmp/video_adjust.cfg
else
	wlr-randr --output HDMI-A-1 --mode 1920x1080@120
    retroarch -L .config/retroarch/cores/$CORE "$1"
    wlr-randr --output HDMI-A-1 --mode 1920x1080@60
fi

##########ACABA EL CARGADOR DE ARCADES############# 

******Emulando la NES con FBNeo*****************************************************

OJO: NO TE COMPLIQUES CON TODO LO DE ABAJO SI PUEDES EVITARLO. LAS ROMS DE FBNEO ESTÁN TODAS EN:
www.retroroms.info

RAINBOW ISLANDS necesita, a parte de la última ROM de retroroms, la BIOS cchip.zip.

El emu de NES de FBNeo es el más exacto, pero requiere un A72 (Pi4) como mínimo.

Las ROMS además hay que prepararlas antes.
Lo más fácil es irte a 
www.retroroms.info
y bajarlas de ahí. O preguntarle a dink por privado en https://neo-source.com/index.php?action=pm#msg14377

Pero por si tuvieras que prepararlas "a mano", aquí tienes cómo hacerlo.
Veamos como ejemplo cómo preparar el romset de NES:
-Cogemos la parte de NES del ROMSET de FBNeo, o el ROMSet no-intro de NES si no tenemos otra cosa
(con el no-intro te van a faltar muchas cosas, mejor usa el ROMSet de NES de FBNeo, tienes romsets de FBNeo en archive.org).
-Cogemos el DAT de aquí:
https://github.com/libretro/FBNeo/blob/master/dats/FinalBurn%20Neo%20(ClrMame%20Pro%20XML%2C%20NES%20Games%20only).dat
Cogemos el CLRMAME de aquí (bajamos el último ZIP para Windows, NO HAY versión Linux):
https://mamedev.emulab.it/clrmamepro/#downloads
Lanzamos el CLRMAME con WINE, en el profiler simplemente le damos a "Add DatFile", y le damos el DAT que acabamos de bajar.
Ahora al volver al profiler le damos a Load/Update y ya nos sale el menú de dibujitos del CLRMAME.
Ahí nos vamos a REBUILDER. En rebuilder, dejamos todo como está menos esto:
-En el menú principal marcamos "non-merged sets" y elegimos como orígen el directorio donde tenemos el romset no-intro,
y destino el que queramos.
-En Advanced nos aseguramos de que "Separated BIOS sets" está sin marcar.
Pues ya está, le damos a Rebuild.

Ahora, para cargar la rom que queramos tenemos que pasar el parámetro --subsystem, así:
retroarch -L ~/.config/retroarch/cores/fbneo_libretro.so --subsystem=nes nes/mario.zip

O bien en el RetroArch, nos vamos a "load core", cargamos el core FBNeo, y luego vamos a "load content" y nos aparecerá
"subsystem", allí elegimos NES, y luego volvemos a "subsystem" y le damos a "start content" y elegimos otra vez NES.

Si quieres emular FDS, necesitas fdsbios.zip que contiene disksys.rom.
PERO no te compliques: usa www.retroroms.info, o en los torrents de ROMsets de FBNeo viene todo lo de FDS listo.

******MSX en el core FBNEO***************************************************************************************

Los juegos los podemos bajar de aquí, que ya están preparados para el core FBNeo: www.retroroms.info
Los metemos en un directorio junto con el msx.zip que lleva las BIOS del MSX.

Ahora, para cargar la rom que queramos tenemos que pasar el parámetro --subsystem, así:
retroarch -L ~/.config/retroarch/cores/fbneo_libretro.so --subsystem=msx msx/pengadv.zip

O bien en el RetroArch, nos vamos a "load core", cargamos el core FBNeo, y luego vamos a "load content" y nos aparecerá
"subsystem", allí elegimos MSX, y luego volvemos a "subsystem" y le damos a "start content" y elegimos otra vez MSX.

RECUERDA que para poder salvar (o cargar!) los mapeos de teclado que se aplican sólo a lo que tengas en el directorio de
los juegos de MSX (SAVE CONTENT DIRECTORY REMAP FILE), tienes que pasar la ruta de la ROM o bien completa o bien con ./ al menos, en plan:
msx1 ./msx/penguin.zip
Si haces: msx1 msx/penguin.zip, se salvará un .RMP con nombre de archivo corrupto.

RECUERDA QUE TIENES QUE TENER EN SETTINGS->INPUT->MAXIMUM USERS MÍNIMO 3, YA QUE EL TECLADO VA EN EL PLAYER 3.

PARA QUE FUNCIONE EL TECLADO, la idea es usar el "GAME FOCUS", para lo cual
NO DEBEMOS TENER ACTIVADO el "HOTKEY ENABLE", ya que son dos funcionalidades que se solapan
y si tuvieses ambas la "HOTKEY ENABLE" no funcionaría al tener activo el "GAME FOCUS" que dedica todas las teclas al core.
Así que hacemos esto:
-En Settings->Input, pon "Auto Enable Game Focus" a "Detect".
-En Settings->Input->Hotkeys, pon en "Game Focus (Toggle)" la tecla Windows ("lsuper" se llama).
-En Settings->Input->Hotkeys, NO PONGAS NINGUNA TECLA en "Hotkey Enable".

******LA ABADÍA DEL CRIMEN, nativo en LINUX**********************************************************************

Copiamos su repo:
git clone --depth 1 https://github.com/Samuel85/Abbey.git

Creamos el directorio de compilación y compilamos:
mkdir b4
cd b4
cmake ..
make -j4

Creamos el directorio donde va a ir el juego, por ejemplo ~/abadia
Y ahí copiamos los directorios "roms", "fonts" y "res" que vienen con los sources en su directorio "build".
Copiamos también el ejecutable "abbey", y ya debería ir. No necesitas nada más externo.

******Compilando OpenBOR*********************************************************************

Dependencias previas: sudo apt-get install libvpx-dev

Clonamos los sources de:
git clone --depth 1 https://github.com/DCurrent/openbor.git

Entramos en openbor/engine
Editamos Makefile y:
-Quitamos el -Werror para que no trate los warnings como errores.
-Comentamos la línea de STRIP debajo de "ifdef BUILD_LINUX"
-Quitamos el -g de la segunda línea de CFLAGS que hay al inicio de la sección Compiler Flags
-Para que cuando compilemos veamos los flags, nos vamos a la sección "Rules to manage Files and Libraries for SDL"
 y debajo del "@echo Compiling" de los .c, metemos: "@echo $(CC) $(CFLAGS) -c $<"

Antes de compilarlo, ejecutamos version.sh para que nos cree version.h

Entramos en el directorio "engine" y hacemos:

-En la Raspberry Pi:
CFLAGS="-O2 -march=native -mtune=native" \
CXXFLAGS="-O2 -march=native -mtune=native" \
make BUILD_LINUX_LE_arm=1 GCC_TARGET=64 -j4

-En el PC:
CFLAGS="-O2 -march=native -mtune=native" \
CXXFLAGS="-O2 -march=native -mtune=native" \
make BUILD_LINUX_LE_x86_64=1 GCC_TARGET=64 -j4

Para meter los juegos:
La primera vez que ejecutas OpenBOR, te crea entre otros un directorio llamado Paks. Mete los .pak ahí, y listo.

El mítico juego de HE-MAN lo tienes en su página oficial: https://gamejolt.com/games/he-man/19434
EN LAS OPCIONES DEL HE-MAN:
NO TE OLVIDES de dejar SOFTWARE RENDERER a SIMPLE 2X y el HARDWARE RENDERER a BILINEAR, activar la pantalla completa y el vsync.

Para lanzarlo sin pasar por el lanzador:
./OpenBOR Paks/HE-MAN.PAK

NO HAY opciones "generales", cada juego gestiona las suyas desde su menú. Son todos parecidos, anyway.

Puedes lanzar los juegos desempaquetados, pero no hay ventaja en ello. Para hacerlo:
Extrae el juego con borpak, una utilidad que viene en las tools de OpenBOR y que te tienes que compilar. Simplemente es hacer "borpak juego.pak" y te lo deja descomprimido en el directorio en el que estés. Sólo te interesa el directorio "data", TODOS los juegos tienen uno.
Pilla el directorio "data" del juego, y lo copias en el mismo directorio donde tengas el ejecutable del OpenBOR.
Crea un archivo de 0 bytes llamado bor.pak, y lo metes en Packs.
Total, que tienes que tener:
OpenBOR
Paks/bor.pak (0 bytes)
data (del juego que sea)
Y ya puedes hacer "./OpenBOR Paks/bor.pak" y te lanzará el juego desempaquetado.

******Another World GNU/Linux******************************************************

Clonamos su repo: git clone --depth 1 https://github.com/cyxx/rawgl.git

-En el Makefile:
	-Cambiamos -lGL por -lOpenGL en la línea de SDL_LIBS, 
	-Añadimos los CXXFLAGS que son: -O2 -march=native -mtune=native
Y añade la línea de optimiación agresiva debajo de la original de CFLAGS:
CXXFLAGS += -flto
(NO se puede mezclar -fwhole-program con -flto: una o la otra. Y como tenemos más de una unidad de compilación, -fwhole-program no va aquí).

-En mixer.cpp, ajusta el tamaño del buffer de 4096 a 1024
-En systemstub_sdl.cpp:
	-Descomenta el SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, 1) y ponlo como SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear")
	-SÓLO SI NO TIENES VRR NI USAS VKBASALT: Añade SDL_RENDERER_PRESENTVSYNC a la llamada de SDL_CreateRenderer()

Si queremos renderer por software, lanzamos con:
./rawgl --language=us --render=software --fullscreen-ar --datapath=data_dos
(usar --render=original provoca errores como tiras en las piernas de los enemigos en lugar de ser sólidas).

Si queremos renderer por OpenGL, lanzamos con:
./rawgl --language=us --render=gl --fullscreen-ar --datapath=data_dos

******FLASHBACK en GNU/Linux*********

Instalamos dependencias previas:
apt-get install libmodplug-dev --no-install-recommends

Clonamos su repo:
git clone --depth 1 https://github.com/chermenin/REminiscence.git

Editamos systemstub_sdl.cpp y cambiamos:
desired.samples = 4096;
por
desired.samples = 512;
Y también añadimos SDL_RENDERER_PRESENTVSYNC a la llamada de SDL_CreateRenderer()

Compilamos con:
CFLAGS="-O2 -march=native -mtune=native -O2" \
CXXFLAGS="-O2 -march=native -mtune=native -O2" \
make -j10

### BLOQUE DE RECREACIÓN DE FICHEROS DE DATOS. INNECESARIO: TIENES COPIA DE SEGURIDAD EN EL DISCO DE BACKUP ###
Creamos el directorio DATA y allí metemos los datos de la versión MS-DOS.
Creamos el directorio TUNES y ahí metemos los MODs de:
http://wiibrew.org/w/images/2/2b/Flashbackmods.zip
(NO, no sirven los ficheros de música de AMIGA directamente).
### FIN BLOQUE DE RECREACIÓN DE FICHEROS DE DATOS ###

Lanzamos con:
./rs --datapath=./data --fullscreen

NOTA: El juego corre internamente a 256x224, por si lo quieres tener en cuenta para los sahders externos.

********Supaplex en GNU/Linux con OpenSupaplex********************************************************************

--Clonamos su repo: git clone --depth 1 https://github.com/sergiou87/open-supaplex.git

--Editamos src/sdl2/video.c y:
-Cambiamos todas las demás ocurrencias de SDL_WINDOW_FULLSCREEN por SDL_WINDOW_FULLSCREEN_DESKTOP. 
-Añadimos antes de la llamada a SDL_CreateRenderer(): SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");

--Entramos en el directorio linux, editamos Makefile y añadimos a los CFLAGS:
-O2 -march=native -mtune=native

--Compilamos simplemente con "make"

--Copiamos el contenido del directorio "resources", tal cual, a ~/supaplex, junto con el ejecutable.

--Para ponerlo a pantalla completa, usamos ALT+ENTER. Y al salir ya se queda guardado.

********Instalando ROCKBOX en un Sony NWZ 383 (Walkman MP3)***************************************************

Los archivos que necesitamos están en este hilo:
http://forums.rockbox.org/index.php/topic,43630.0.html

Y las instrucciones confusas aquí
http://www.rockbox.org/wiki/SonyNWZE370Port

PERO para que no tengas que volver a perder tiempo, la solución es esta: 
El bootloader es el mismo para todos los NZW 37x y los 38x. El ROCKBOX en sí, igual: el mismo para todos los modelos.
-Bájate el bootloader, que es el archivo que se llama sonynwze370_rb_firmware.sb. Lo metes en la raíz del dispositivo RENOMBRÁNDOLO a firmware.sb
-Bájate el Rockbox en sí, que es el archivo que se llama rockbox-sonynwze370.zip, y lo descomprimes en la raiz del dispositivo. Te creará el directorio .rockbox
-Resetea el dispositivo, si hace falta a base de meter algo en el agujero de reset que tiene detrás (a mi no me hizo falta pero tuve que conectarlo por USB para que se "despertara"
porque no se encendía tras meter el bootloader y el ROCKBOX en la raíz), y se iniciará en ROCKBOX, o deberia.

******Copiar y pegar usando GNU/Screen***************************************************************

Hacemos CTRL+A y [ , con lo que nos ponemos en modo copia. Ahora nos ponemos donde queramos empezar a copiar, le damos al espacio, seleccionamos el texto a copiar,
le damos al espacio otra vez cuando acabemos y al intro para acabar. Ya tenemos el texto copiado a un buffer. Lo pegamos con CTRL+A y luego ] . 

******Cosas a borrar después de actualizar el firmware en una Raspberry Pi...************************

/lib/modules.bak
/boot.bak

******GRAFX2 en GNU/Linux****************************************************************************

Si tenemos SDL2 instalado y funcionando, podemos tener este increíble programa de dibujo en 2D que se usa para sprites y gráficos raster!
Tenemos que tener también SDL2_image con soporte para JPG, PNG y TIFF, así que comprueba que tienes esos formatos soportados al configurar SDL2_image.
Tendrás que instalar para ello libtiff-dev.

Clonamos su repo:
git clone --depth 1 https://gitlab.com/GrafX2/grafX2.git

Editamos src/sdlscreen.c y cambiamos:
SDL_WINDOW_FULLSCREEN
por
SDL_WINDOW_FULLSCREEN_DESKTOP
Y antes de SDL_CreateWindow aniadimos:
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");

Compilamos con:
make API=sdl2 NOTTF=1 NOLUA=1 -j4

Si queremos que busque los init, skin y demás en el mismo directorio donde tengamos el ejecutable, editamos src/setup.c y tocamos las funciones:
Set_data_directory() : Dejamos sólo la primera línea, "strcpy(data_dir,program_dir);" Comentamos lo demás.
Set_config_directory() : Deejamos sólo una línea que diga: "strcpy(config_dir,program_dir);" Comentamos todo lo demás.

...Y ahora copiamos. al mismo directorio que el ejecutable:
gfx2def.ini
skings
...tienes ambas cosas en share
..Y ahora, editamos gfx2def.ini y cambiamos  el Skin_file, para evitar el error "Error in skin file: Was looking right from 254,139 for a 'mouse cursor', and reached the edge of the image":
Skin_file = skin_modern.png

Lanzamos con:
./grafx2-sdl2 -mode 640x360

******EtherTherm, un emulador de terminal gráfica para GNU/Linux*******

Instalamos dependencias previas:
apt-get install libssh-dev libyaml-cpp-dev --no-install-recommends

Clonamos su repo:
git clone --depth 1 https://github.com/M-griffin/EtherTerm.git

Nos vamos al directorio linux y compilamos:

cd linux

CFLAGS="-O2 -march=native -mtune=native -O2" \
CXXFLAGS="-O2 -march=native -mtune=native -O2" \
make -j4

******Compilar VICE en GNU/Linux*********

Necesitaremos tener instalados los paquetes flex y bison durante la configuración.
Configuramos con:

./configure --disable-sdlui --enable-sdlui2 -v --enable-arch=arm --disable-debug --disable-debug-code --disable-ipv6 --disable-ethernet --disable-rs232 --disable-realdevice --disable-shared-ffmpeg \
--disable-static-ffmpeg --disable-external-ffmpeg --without-oss --without-sdlsound --disable-midi --without-png --without-pulse 

(El -v es porque queremos que compile de modo verbose.)

Nos copiamos el directorio data, que viene con los fuentes, a donde tengamos instalado el ejecutable, x64

Luego le podemos indicar los parámetros de las roms que necesita así:

./x64 -kernal data/C64/kernal -sounddev alsa -basic data/C64/basic -chargen data/C64/chargen -dos1541 data/DRIVES/dos1541

O simplemente pasándole el directorio donde están las ROMs de ese sistema:

./x64 -directory data/C64 -sounddev alsa

Se entra en el menú con F12

******Grabar WIFISLAX moderno en un pendrive de arranque************************************************************************

Extraemos los dos directorios de la ISO, wifislax y boot, a nuestro disco duro.
Formateamos el pen a FAT32. Esto no nos va a dejar ejecutar cosas por temas de permisos de los que carece FAT32, así que ya verás lo que hay que hacer.
Copiamos ambos directorios al pen en FAT32 (el script de instalación, bootinst.sh, va a buscar el LILO en el pendrive, no en la copia de nuestro disco duro).
Copiamos boot/bootinst.sh al disco duro. Está pensado para ejecutarse desde el pen, pero como el pen está en FAT32 no podemos, así que lo editamos y dejamos las líneas
de declaración de ciertas variables así:

TARGET="/dev/sdb1"
MBR=""
MYMNT="/media/manuel/WLX"

Comentamos entero el bloque "# Find out which partition or disk are we using": entero.
Ejecutamos bootinst.sh desde nuestro disco duro, y listo. Si se queja de que no encuentra archivos para instalar el bootloader, lo mandas a la copia local del directorio boot
de la ISO y lo ejecutas desde allí.

*******Aplicar parches ips en Linux***************************************************************************************

Lo hacemos con el UIPS, un parcheador hecho en C de Neil Corlett (sí, el traductor del Seiken Densetsu 2, la gente es la hostia!) de hace mil años.
Clonamos este repo: https://github.com/chungy/cmdpack.git
Compilamos y a correr.

******Aplicar parches BPS en Linux****************************************************************************************

Usamos el FLIPS.
Clonamos su repo, lo compilamos y lo instalamos:
git clone --depth 1 https://github.com/Alcaro/Flips.git
make -j4
sudo cp flips /usr/local/bin

Se aplica con:
flips -a <parche> <ROM original>

*******Cambiar las fuentes de tamaño en Debian/Lubuntu cuando dpkg-reconfigure console-setup falla************************
El problema es que /lib/udev/console-setup-tty está jodido.
Si hacemos strace /lib/udev/console-setup-tty fbcon, vemos que está buscando un fichero de fuente en /etc/console-setup que no existe, y además lo busca en PSF y nosotros
los tenemos en .psf.gz. Así que ajustamos cosas en /etc/default/console-setup para que busque una fuente que tengamos en /etc/console-setup y se la ponemos ahí.
Intercambia la altura y anchura, descomprime la fuente con gzip.. así hasta que la encuentre.
Fuente: http://unix.stackexchange.com/questions/198791/how-do-i-permanently-change-the-console-tty-font-type-so-it-holds-after-reboot

*******Nos faltan las tildes en algunos programas en Lubuntu, a pesar de tener el teclado puesto en español****************

Regenera las LOCALES con:
sudo dpkg-reconfigure locales
Y ahí activa solo en_US.UTF8 y es_ES.UTF8, dejando por defecto en_US.UTF8, y arreglado.

*******Evitar que en Debian/Lubuntu se nos cierren las ventanas minimizadas al clickar sobre ellas en la barra de tareas***

Hacemos click con el botón derecho en la barra de tareas > Configure “Task Manager” > General > Close on middle-click

*******Tamaño de fuente de letra en la barra de direcciones de Firefox en Debian/Lubuntu***********************************

Nos vamos a "Preferences -> LXQT Settings -> Appearance", que es donde ajustamos las fuentes del sistema en general,
y además nos vamos a la pestaña "GTK Themes" y marcamos "Set GTK Themes", para que todas las opciones de apariencia
se apliquen también a los programas hechos con GTK.

*******Escritorio Lubuntu sin tearing**************************************************************************************

Sacado de https://wiki.archlinux.org/index.php/Intel_graphics#Tear-free_video

Para GPUs INTEL:

Creamos /usr/share/X11/xorg.conf.d/20-intel.conf con el contenido:

Section "Device"
   Identifier  "Intel Graphics"
   Driver      "intel"
   Option      "AccelMethod"  "sna"
   Option      "TearFree"    "true"
EndSection

Si no te funcinona glxgears, cambia "sna" por "uxa".

Para GPUs AMDGPU:

Creamos /usr/share/X11/xorg.conf.d/20-amdgpu.conf con el contenido:

Section "Device"
   Identifier  "AMD Graphics"
   Driver      "amdgpu"
   Option      "TearFree"  "true"
EndSection

Reiniciamos el servidor gráfico. Magia!

*******Eliminar accesos directos en el menu de Lubuntu*******************************************************************

Borra los que quieras de ~/.local/share/applications/

*******Comprimir un ZIP partiéndolo en varias partes*********************************************************************

Con esto creamos varios volúmenes de 1990 MB cada uno:

zip -r -s 1990m pi4.zip pi4.img

*******Comprimir un PDF*********

gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/ebook -dNOPAUSE -dQUIET -dBATCH -sOutputFile=xenon2-compressed.pdf Downloads/Xenon.2-Manual.pdf

******Arrancar e instalar una instalación de Linux en un Toshiba C50-B (o en cualquier cagarro de PC moderno con UEFI)*********

Entramos en el menú UEFI manteniendo presionado F2 al encender. Ponemos como primera unidad de arranque el USB.
Cambiamos el modo de arranque a CSM.
Instalamos y arrancamos desde el disco duro. Si hemos instalado en modo CSM, debería arrancar.
Ya que estás, desactiva SECUREBOOT.
Miseria y muerte a Microsoft y a todos los malnacidos que trabajan en ella.

*******Mantener una sesión de IRSSI y conectarse a ella por SSH******************************************************************

Lanzamos IRSSI bajo SCREEN, ya sea en local o por SSH, así:

screen irssi

Nos logueamos normalmente, abrimos los canales que queramos, etc

Y ahora podemos recuperar la sesión abierta haciendo:

screen -R -A -DD

*******Guardar LOG de una ventana en el IRSSI********

/lastlog -file <archivo>.log

JUEGOS DE JAVA DE MÓVIL CON FREEJ2ME
====================================

Instalamos dependencias previas (nos instalará la máquina virtual de JAVA, openjdk, en versión headless, que es necesaria
porque es la que va a correr los juegos JAVA realmente):
sudo apt-get install ant

Nos bajamos los últimos sources:
git clone --depth 1 https://github.com/hex007/freej2me.git

Entramos en freej2me y simplemente escribimos:
ant
Se nos generará build/freej2me-sdl.jar, build/freej2me-lr.jar, etc
Dependiendo de si vamos a compilar la versión LIBRETRO o la versión SDL2, copiamos
el freej2me-sdl.jar o freej2me-lr.jar que acabamos de generar a ~/.config/retroarch/system

Creamos ~/j2me, y ahí meteremos los juegos que nos bajemos en .jar

COMPILAR VERSIÓN LIBRETRO

cd src/libretro

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2"
make -j4

cp freej2me_libretro.so ~/.config/retroarch/cores

COMPILAR VERSIÓN SDL2

Entramos en freej2me y simplemente escribimos:
ant
Se nos generará build/freej2me-sdl.jar.
Creamos el directorio ~/j2me, y copiamos el freej2me-sdl.jar que acabamos de generar a ~/java
y metemos ahí los juegos que nos bajemos en .jar

Ahora generamos el interface de gráficos SDL, llamado sdl_interface. Para ello, entramos en src/sdl2, y hacemos:
make -j4
sudo make install
Esto simplemente nos mandará el interface de gráficos sdl_interface a /usr/local/bin

Ejecutamos el juego que queramos con:
java -jar freej2me-sdl.jar DoomRPG.jar 240 320 -i linear
Piensa que los juegos son verticales, por eso doy una anchura de 240 y una altura mayor, de 320.

CORE "LIBRETRO UAE", EMULADOR DE AMIGA BASADO EN SOURCES ACTUALIZADOS DE WINUAE
===============================================================================

LO PRIMERO QUE DEBES HACER CON ESTE CORE ES DESACTIVAR EL RUNAHEAD Y SALVAR DICHA OPCIÓN CON UN CORE OVERRIDE.
SI NO LO HACES, EL CORE HACE COSAS RARAS COMO FALLOS CON LOS MANDOS, NO FUNCIONA EL TECLADO, ETC..

Clonamos su repo:
git clone --depth 1 https://github.com/libretro/libretro-uae.git

Se compila como los demás cores.

			####¡¡¡¡MUY IMPORTANTE!!!! PRIMEROS AJUSTES DE BASE####

-NO se puede usar RUNAHEAD con este core, acuérdate de desactivarlos: según el propio autor del core, la carga de savestates
es muy lenta lo que lo hace imposible. 

-La mejor manera de tener los juegos instalados es cada uno en su directorio (cuyo nombre incluirá la cadena "PAL" si es PAL,
para que mi script de lanzamiento desde GNU/Linux ponga un modo de 100Hz para los juegos PAL y 120Hz si es NTSC),
sin comprimir, y sin un .info acompañando al directorio ni nada.
(Aunque funciona lo de tener cada juego instalado en un ZIP, a veces falla al lanzarlos, hace cosas raras,
y se pierden los saves. No merece la pena, déjalos descomprimidos y ya).

-Deja como modelo de Amiga el que viene por defecto para juegos en HDD, que es un 1200 con 8MB de FAST.

-Deja "System->CPU Compatibility" como viene, es decir, a "Cycle-exact (DMA/Memory)".
Esto se refiere a que la comunicación DMA/Memoria SÍ será cycle-exact aunque la emulación de la CPU no lo sea.
Lo que NO tiene sentido emulando un 1200 es "Cycle-exact (Full)" ya que la emulación de la CPU 68020 en el WinUAE no es cycle-exact,
el autor del WinUAE no tiene información para hacerlo, no se conoce el 68020 como para implementar su emulación cycle-exact y no hace falta.
PERO SÍ QUEREMOS que la comunicación DMA/Memory sea cycle-exact SIEMPRE.
(Si no lo fuese, por ejemplo al poner "System->CPU Compatibility" a "More compatible" pues fallan cosas en los juegos,
como el Ishar 1 y 2 AGA que pierden efectos de sonido, etc. Así que hazte caso y deja siempre "System->CPU Compatibility"
puesto a "Cycle-exact (DMA/Memory)").
La emulación de 68000 plano sí es full cycle exact y podría tener sentido poner "Cycle-exact (Full)", pero no nos hace falta para nada
ya que nosotros emulamos un Amiga 1200+FAST y tiramos de WHDLoad mayoritariamente.

-COMO HEMOS VISTO, TODO LO EMULAMOS CON EL A1200+8MB FAST+CPU "Cycle-exact (DMA/Memory)", y si un juego va demasiado rápido
o hace cosas raras, tenemos varios remedios posibles (a parte de simplemente bajarle la velocidad de la CPU, claro, que no suele prevenir
las corropciones gráficas derivadas de correr en CPUs más rápidas de lo esperado juegos de 68000 que no esperan al blitter, pero prueba).
Así que, para ciertos juegos instalados sin WHDLoad que efectivamente no esperan al blitter porque nunca pensaron que fuesen a correr
en nada superior a un 68000, como el DUNE, tienes varias opciones:
-MEJOR OPCIÓN SI FUNCIONA: Correr el juego en una configuracón A1200+8MB FAST+CPU "Cycle-exact (DMA/Memory)" como para todos los demás,
 y poner "Immediate/Waiting Blits" to "Immediate Blitter" con lo que los errores derivados de correr un juego de 68000
 en una máquina más rápida deberían desaparecer (lee https://eab.abime.net/showthread.php?t=95418 para entender lo que sucede).
-Emular un A500/A600 (no he visto ninguno en el que haga falta aún si se hace lo anterior).
-Usar una instalación WHDLoad cdel juego, on sus fixes para que funcionen en modo A1200 sin Cycle-Exact.

-Pon "Video->Immediate/Waiting Blits" a "OFF" siempre que el juego no tenga ningún fallo gráfico.
Viene puesto a "Wait for Blitter" pero eso es incorrecto: tanto "Immediate" como "Waiting Blits" son parches para juegos que usan el blitter mal,
y el arreglo lo necesita el juego realmente. Es decir, un Amiga real es como "Video->Immediate/Waiting Blits" puesto a OFF. 

-Para evitar problemas de audio en ciertos juegos (intro del Harlequin, etc), debes dejar "Allow Hz Change" a "Locked PAL/NTSC"
en las opciones del core (viene así por defecto así que no deberías tener problema si no lo cambias),
y para juegos PAL 40ms en las opciones de RetroArch.
(NOTA: Lo que hace "Allow Hz Change" a "Locked PAL/NTSC" es redondear NTSC a 60.0000Hz y PAL a 50.0000Hz, todo con 44100Hz de audio,
con lo que el buffer de audio es mucho más estable y no se dan tantas distorsiones si tenemos un buffer de audio pequeño).
POR SI QUIERES SABER MÁS SOBRE POR QUÉ HACEN FALTA 40ms EN PAL, ESTO DICE SONNINOS AL RESPECTO:
"Oh right you said 32ms, so since the audio buffer is supposed to only saturate half of the buffer, meaning that it targets 16ms which is not even enough for 60fps since it is a bit more than 16ms. Meaning that PAL needs minimum 40ms in that case."

-Desactiva "Media->WHDLoad Support" siempre que el juego no use WHDLoad. No te olvides, porque si no se usa WHDLoad los juegos
tienen problemas con esta opción activada.

			####FIN PRIMEROS AJUSTES DE BASE####

En Core Options->Video, desactiva "Automatic Crop Delay", para evitar dropouts de audio en los cambios
de geometría de vídeo (como dar muchas veces a la "P" en el Agony). 
NO actives pongas "Crop" a "Automatic", ve ajustándolo por cada juego. Lo de Automatic falla y encima produce dropouts de audio.

Para comprobar el estado de los buffers, activa los stats en On-Screen Display Notifications. Los valores de "Deviation" y "Underrun" no deberían
llegar nunca al 100%, que es cuando se producen dropouts con ALSA y distorsiones con ALSATHREAD.

Tienes TODAS las kickstarts posibles que puede necesitar el core, para TODOS los modelos de Amiga que soporta, en el disco de backup,
con sus nombres ya correctos y las MD5SUM comprobadas.

PARA QUE FUNCIONE EL TECLADO, la idea es usar el "GAME FOCUS", para lo cual
NO DEBEMOS TENER ACTIVADO el "HOTKEY ENABLE", ya que son dos funcionalidades que se solapan
y si tuvieses ambas la "HOTKEY ENABLE" no funcionaría al tener activo el "GAME FOCUS" que dedica todas las teclas al core.
Así que hacemos esto:
-En Settings->Input, pon "Auto Enable Game Focus" a "Detect".
-En Settings->Input->Hotkeys, pon en "Game Focus (Toggle)" la tecla Windows ("lsuper" se llama).
-En Settings->Input->Hotkeys, NO PONGAS NINGUNA TECLA en "Hotkey Enable".
SI AUN ASÍ NO TE FUNCIONA EL TECLADO, ASEGÚRATE DE TENER QUITADO EL RUNAHEAD PARA ESTE CORE!! Aparentemente no tiene nada que ver,
pero tener activo el RUNAHEAD hace que no funcione el teclado, además de provocar errores raros en los juegos.

No hace falta andar con HDFs, carga los .info de las carpetas que contengan juegos de WHDInstall,
o los .slave de los juegos WHDLinstall, o directamente los .lha que contengan juegos de WHDInstall.

Tienes todos los juegos instalados con los últimos slaves de WHDLoad listos para usar en:
https://gamesnostalgia.com/whdownload

--PARA CARGAR JUEGOS PAL A 100Hz (necesario tanto si tienes un monitor con VRR/AdaptiveSync/FreeSync como si no,
ya que el VRR sí que da microtirones tanto en PAL como en contenido ~60Hz-70Hz):
-Crea un script /usr/local/bin/amiga como este que normalmente lanza los juegos como PAL pero que unos pocos los lanza como NTSC:
############SCRIPT DE CARGA DE JUEGOS NTSC/PAL DE AMIGA#############################################################
if [[ 
"$1" == DefenderOfTheCrown || "$1" == *RocketRanger* ||
"$1" == *ItCameFromTheDesert* || "$1" == *FuryOfTheFurries* ||
"$1" == *Might\&Magic2* || "$1" == *MoonStone* || "$1" == *Turrican2AGA* ||
"$1" == *Lemmings* || "$1" == *OhNoMoreLemmingsNTSC* 
]]; then
  retroarch -L ~/.config/retroarch/cores/puae_libretro.so "$1"
else
  wlr-randr --output DP-1 --mode 1920x1080@100
  retroarch -L ~/.config/retroarch/cores/puae_libretro.so --appendconfig ~/.config/retroarch/config/PAL.cfg "$1"
  wlr-randr --output DP-1 --preferred
fi
############FIN SCRIPT DE CARGA DE JUEGOS NTSC/PAL DE AMIGA#############################################################
-Crea ~/.config/retroarch/config/PAL.cfg con este contenido (la última línea es porque NO queremos que al quitar el juego
el RetroArch se quede a 100Hz).
video_refresh_rate = "100.000000"
config_save_on_exit = "false"
-Luego, en cada juego, creamos su propio fichero de opciones del core, con el tipo sistema Amiga que usamos para ejecutarlo
(en principio deja el modelo por defecto que es un 1200 con 8MB de FAST), las opciones de pixel ratio y de cropping que mejor le sientan, etc.

--Para pasarle parámetros CUSTOM de WHDLoad:
Pulsa repetidamente los botones RED y BLUE del mando de CD32 (que normalmente son el A y el B de un mando de SNES)
y te aparecerá el README del WHDInstall del juego y a continuación podrás meter los CUSTOM que quieras y se quedarán guardados.
(Para el segundo botón del Toki hay que pasarle "CUSTOM2=1", y para el Shadow of the Beast "CUSTOM4=2" para el segundo botón
y "CUSTOM1=1" para saltar la intro).

--Para jugar a juegos NO instalados con WHDLoad, simplemente en el directorio del juego crea un directorio "s" y dentro un fichero startup-sequence,
y además un fichero .info que se llame igual que el directorio del juego. Este .info no necesita tener nada, lo puedes crear con "touch",
es sólo para pasárselo al core.
Por ejemplo, para jugar al Lemmings de CDTV, tendríamos:
lemmings
lemmings/s/startup-sequence
lemmings/c/assign <--Esto lo sacamos del disco de WB correspondiente a la Kickstart que estemos usando. Con tener este archivo nos vale.
Y en el caso del Lemmings, en el startup-sequence hacemos los Assigns necesarios y lanzamos el juego así:
#####INICIO STARTUP-SEQUENCE#####
assign LemSamples: dh0:LemSamples
assign LemMusic: dh0:LemMusic
assign LemGraphics: dh0:LemGraphics
assign LemLevels: dh0:LemLevels
assign LemMisc1: dh0:LemMisc1
assign LemMisc2: dh0:LemMisc2
Lemmings
#####FIN STARTUP-SEQUENCE#####
Para el "It Came from the Desert", tenemos que hacer Assign de los volúmenes desert1, desert2, desert3, des4 y dsave
al directorio donde están los datos del juego. El ejecutable se llama "dshell".

--PUEDES AHORRAR RAM Y TIEMPO DE ARRANQUE si, en los juegos instalados sin WHDLoad, vas a "Core Options->Media" y pones
"WHDLoad Support" a "OFF". Además, debes copiar el comando "Assign" al directorio raíz del juego, porque casi todos lo usan.
(NO hace falta que esté en C/, con que esté en el raíz del juego ahí tirado vale).

--PARA INSTALAR JUEGOS DESDE ADFs A DISCO DURO USANDO ESTE CORE:
-Pon "Core Options->Media->Global Boot HD" a "Files". Esto creará el directorio ~/.config/retroarch/saves/PUAE/BootHD, que es
el disco duro desde el que se arrancará el sistema ahora.
-Arranca el core, dejando que arranque desde ese disco duro vacío.
-Usando "Disk Control->Load New Disk" + "Disk Control->Insert Disk", con cada disco, ya podemos ir cargando los ADF del juego
e instalándolo (una vez cargado un ADF, nos permite ir a DF0: sin problemas para ejecutar el instalador o copiar los archivos a mano al disco duro).

--PARA ACCEDER AL DISCO DURO DEL CORE MINIMIG, QUE ESTÁ EN PSF3 POR LO QUE NO SE PUEDE MONTAR DESDE LINUX:
Lo mismo:
-Pon "Core Options->Media->Global Boot HD" a "Files". Esto creará el directorio ~/.config/retroarch/saves/PUAE/BootHD, que es
el disco duro desde el que se arrancará el sistema ahora.
-Arranca el core pasándole como contenido el HDF que usas en el core de Minimig.
-Una vez arrancado el core, ya puedes acceder a ambos. Al disco "local" accedes simplemente haciendo "BootHD:"

	NOTAS SOBRE JUEGOS CONCRETOS (NUNCA EMULES UN A500/A600, USA SIEMPRE EL 1200+8MB FAST QUE VIENE POR DEFECTO)

-La mayoría de juegos como el Another, Agony, Gods (CUSTOM2=1 para 2 botones), Beast, BC Kid, Defender of the Crown, Fuzzball,
 SuperFrog, Moonstone, Another, Pinball Dreams y Fantasies, Turrican 1 y 2, etc
 como mejor van es con "CPU Compatibility" a "More Compatible" y con "Video->Immediate/Waiting Blits" a "OFF".
 Así que usa esa configuración de base. Luego algunos necesitan alguna cosilla especial:
 El BC Kid lo mismo pero con "Immediate Blitter" 
 El Lotus III con "CPU Speed" a "+400%" para una conducción suave.
 El DUNE (versión NO WHDLoad)con "CPU Speed" a "-80%" para que la intro no vaya a mil por hora.
 El Lionheart con "CPU Speed" a "-50%" para que se vea bien el agua del primer nivel.
 El Hybris (CUSTOM4=1 para ir en PAL, CUSTOM3=1 para quitarle los blitterwaits) con "CPU Speed" a "-80%" para que vaya suave.
 El Might & Magic II (no WHDLoad) con "Immediate Blitter" para que no se vean los colores raros al moverse.
 
-En el IsharAGA e Ishar2AGA (versiones NO WHDLoad), para tener todos los sonidos de la intro, etc, tienes que
    tener "CPU Compatibility" puesto a "Cycle-exact (DMA/Memory). 
    (Con una CPU pocha tipo N100, podrías poner "CPU Compatibility" a "More Compatible", con "CPU Speed" a "-60%",
    y con "Immediate Blitter", y también iría, más lento el juego como en un Amiga 500 o un Atari ST, claro, pero iría).
    Para que no se salga con parte del área de juego por la derecha, pon "Core Options->Media->WHDLoad Support" a "OFF".
	(Eso lo deberías desactivar para todos los juegos NO WHDLoad, recuerda).
	Tanto Ishar como Ishar 2 (versiones NO WHDLoad) van mejor sin memoria extra de ningún tipo, sólo con los 2MB de chip un Amiga 1200 básico,
    así que desconecta todo tipo de memoria extra o habrá corrupción del cursor al guardar objetos, etc.
	Tanto Ishar como Ishar 2 necesitan video PAL, pero con pixel ratio NTSC si quieres círculos redondos.
	El Ishar 1 puedes acelerarlo sin coste alguno poniendo "Immediate/Waiting Blits" a "Immediate Blitter".

-En el Turrican2AGA lo más sencillo para tener los controles perfectos es poner en las opciones del menú del juego
 "INPUT TYPE" a "JOYSTICK CUSTIMISED", y "FIRE 2" a "JUMP" (el rayo se saca manteniendo pulsado el botón de disparo).

-En los juegos que necesitan integer scaling porque tienen secuencias en alta resolución que se ven mal sin ello si usas shaders
 (Agony, Pinball Dreams, Pinball Fantasies...) pon el CROP a "Minimum" para que se vean más grandes: si lo pones a Maximum se verán,
 de hecho, mucho más pequeños.

NOTAS PARA INSTALAR ROCKET RANGER SIN WHDLOAD (OJO: NO FUNCIONA EN MODO AMIGA 1200, DA GURÚS CASI SIEMPRE QUE SE INICIA)
-El Rocket Ranger se puede instalar a mano en una máquina A500/600 sin ampliación de memoria, sin WHDLoad.
Para ello, como la versión de CD32 que hay en el FTP de EAB usa el "diskimage.device", y como el "diskimage.device" no funciona
más que en 68020 y superiores, usamos el XFS:
---Nos bajamos el XFS de Aminet
---Copiamos, del paquete del XFS al sistema donde vamos a correr el RR: xfsd a L, devio a C, y fd.device mountlist.xfs y a Devs: 
---En startup-sequence lo dejamos así para que nos monte los discos, lanze el juego en un fork nuevo, e imprima las claves
para verlas con AMIGA+M (y de nuevo AMIGA+M para volver al juego):
#################STARTUP-SEQUENCE PARA ROCKET RANGER########################
Assign ENV: RAM: 
Assign T: Ram:
setenv env:file.device,0 DISK1.ADF
mount file0: from devs:mountlist.xfs >nil:
devio --reset file.device,0 >nil:
                                                                                                            
setenv env:file.device,1 DISK2.ADF
mount file1: from devs:mountlist.xfs >nil:
devio --reset file.device,1 >nil:

file0:

RUN >NIL: RR
ED sys:Codes
#################FIN STARTUP-SEQUENCE PARA ROCKET RANGER#####################
NOTA: SI TE DA ERROR EL MOUNT, ES QUE NO ESTÁS USANDO LA VERSIÓN CORRECTA DEL COMANDO: HAY QUE USAR LA DE WB 3.1.

Compilar Amiberry en GNU/Linux
==============================

--Clonamos su repo: git clone --depth 1 -b preview https://github.com/BlitterStudio/amiberry.git
(Lo de clonar la rama "preview" es para compilar la rama 6.x, que es la que está basada en el último WinUAE).

--Instalamos dependencias previas: apt-get install libserialport-dev libportmidi-dev

--Configuramos y compilamos con:

mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native" -DCMAKE_CXX_FLAGS="-march=native -mtune=native"

make -j8

--Creamos ~/amiga, y ahí metemos el ejecutable "amiberry" y ciertos directorios que vienen con los sources:
mkdir ~/amiga
cp amiberry ~/amiga/
cp -R confs data kickstarts harddrives conf nvram cdrom controllers savestates plugins screenshots whdboot plugins ~/amiga/

								##################################
								#PARA TENER SCROLL SUAVE PERFECTO#
								##################################

Editamos src/osdep/amiberry_gfx.cpp, nos vamos a la función "target_adjust_vblank_hz()", comentamos todo su contenido
y hacemos que devuelta la frecuencia exacta con decimales de nuestro monitor.

OTRA ALTERNATIVA: El emulador Amiberry produce ~59.94005994 FPS en NTSC (recuerda que la frecuencia típica de NTSC es 59.94005994005994)
por lo que antes de lanzarlo tenemos que hacer:

wlr-randr --output HDMI-A-1 --custom-mode 1920x1080@59.940060

MONTAR DISCOS ADF DE AMIGA EN LINUX
===================================

modprobe affs
sudo mount disco.adf /mnt

JUEGOS Y DEMOS DE AMIGA
=======================

https://ftp2.grandis.nu/turran/FTP/

CORE DOSBOX PURE
================

Clonamos su repo:

git clone --depth 1 https://github.com/libretro/dosbox-pure.git

Compilamos con make -j4 sin más.

Para que no nos molesten las hotkeys de RetroArch al teclear palabras, tenemos que poner una tecla para el HOTKEY ENABLE en:
Settings -> Input -> Hotkeys -> Hotkey Enable
Al tener configurada una tecla para HOTKEY ENABLE, las hotkeys NO están activas a no ser que pulses esa tecla, y así no molestan.
Y recuerda que puedes quitar todas las hotkeys una a una poniéndote encima de ellas en Settins -> Input -> Hotkeys y presionando la tecla DELETE.

Los juegos que se usan (en ZIP) son los de la colección EXODOS, que está aquí:
https://exodos.the-eye.us/

CORE DOSBOX RETROARCH: ACTIVAR DYNREC
=======================================

Hay que pasarle los flags de dynrec, unaligned memory y tal en el Makefile.libretro. Las platform definitions para la Pi2 están así:

# Raspberry Pi 2
else ifeq ($(platform), rpi2)
   TARGET := $(TARGET_NAME)_libretro.so
   LDFLAGS += -shared -Wl,--version-script=libretro/link.T
   fpic = -fPIC

   ENDIANNESS_DEFINES := -DLSB_FIRST
   COMMONFLAGS += -DARM
   COMMONFLAGS += -mfloat-abi=hard
   COMMONFLAGS += -marm -mtune=cortex-a7 -mfpu=neon-vfpv4 -mfloat-abi=hard -fstrict-aliasing
   COMMONFLAGS += -DDISABLE_EXCEPTIONS
   COMMONFLAGS += -DC_DYNREC -DC_TARGETCPU="ARMV7LE" -DC_UNALIGNED_MEMORY
   IS_X86 := 0
   NEED_BPP := 16


Luego nos vamos a

libretro/dosbox.cpp

Buscamos el bloque:

const char* cores[] = { "auto",
#if (C_DYNAMIC_X86) || (C_DYNREC)
		"dynamic",
#endif
		"normal", "simple",0 };
Pstring = secprop->Add_string("core",Property::Changeable::WhenIdle,"auto");

Y lo dejamos así:

const char* cores[] = { 
                "dynamic"};
Pstring = secprop->Add_string("core",Property::Changeable::WhenIdle,"dynamic");

Compilamos con:

make -f Makefile.libretro -j8 platform=rpi2

*******OpenXComm, el UFO para la GNU/Linux***********************************************

(NO ESTÁ LISTO PARA SDL2 AÚN)

--Clonamos su repo:
git clone --depth 1 https://github.com/OpenXcom/OpenXcom.git

--Compilamos con:

mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native"

*******Catacomb3d en GNU/Linux****************************************************

--Descargamos los últimos sources estables de: https://github.com/ArnoAnsems/CatacombGL/releases

--Compilamos con:

mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native"

--Creamos el directorio de instalación y metemos allí el ejecutable:

mkdir ~/catacomb
cp CatacombGL ~/catacomb/

--Metemos los datos de cada juego soportado en subdirectorios de ~/catacomb.
Es posible lanzar cada juego directamente con "--descent", "--abyss", "--armageddon", "--apocalypse", etc...

***********NBLOOD: Duke Nukem 3D en GNU/Linux*********************************************************************************************

Va sobre SDL2 + SDL2 Mixer. Se supone que tenemos ambas instaladas y listas!

--Preferentemente, usa este fork, que inclue soporte para BLOOD y EXHUMED también (OJO: el soporte de OpenGL no va):
git clone --depth 1 https://github.com/nukeykt/NBlood.git

Si quieres usar el eduke32 original, clona su repo de aquí:
git clone --depth 1 https://voidpoint.io/terminx/eduke32.git

--Compilamos con:

make -j4 RELEASE=1 WITHOUT_GTK=1 USE_OPENGL=1 USE_LIBVPX=0 HAVE_FLAC=0 \
OPTOPT="-march=native -mtune=native -O2"

--Mete el duke3d.grp en el mismo directorio que el ejecutable.
Para tener música con .ogg: Mete un zip con la música en el mismo directorio donde tengas el duke3d.grp.
Y lanzaríamos el juego con:
./duke3d -g<nombre_archivo_zip_música>
RECUERDA: entre el -g y el nombre de archivo NO hay ningún espacio. Va todo seguido. 
Por ahora, usamos este: https://sc55.duke4.net/

--Para tener filtrado lineal de texturas, tecleamos en la consola "r_texfilter 1" y le damos al intro, salimos de la consola y del juego,
o bien creamos el archivo ~/duke3d/autoexec.cfg con el contenido: "r_texfilter 1"

--Para quitar el autorun es con BLOQ. MAYUS, y para quitar la mirilla es con "i".

--SI QUEREMOS USAR UN SHADER DE VKBASALT DISTINTO AL QUE TENEMOS PUESTO POR DEFECTO EN ~/.config/vkBasalt/vkBasalt.conf,
debemos añadir a la línea de comandos:
VKBASALT_CONFIG_FILE=/root/duke3d/vkBasalt.conf

*******jfduke3d, el port güeno del duke3d para GNU/Linux**************************
OJO!! ESTE PORT NO SOPORTA ARMAS CORREGIDAS PARA WIDESCREEN, ASÍ QUE SE VERÁN CORTADAS EN 16:9.
USA NBLOOD EN SU LUGAR SI BUSCAS UN PORT VANILLA-ACURATE!!

Es el port original en el que colabora Ken Silverman!
Clonamos su repo de:
git clone --depth 1 https://github.com/jonof/jfduke3d.git
cd jfduke3d
git submodule init
git submodule update

Editamos jfaudiolib/src/driver_sdl.c, y dejamos spec.samples a 1024, comentando el while que hay debajo.
Editamos jfbuild/src/sdlayer2.c, y cambiamos, justo antes de SDL_CreateRenderer(), en la llamada a SDL_SetHint(), "nearest" por "linear".
Editamos jfaudiolib/Makefile, y eliminamos el "-g" ese que hay ahí perdido.

Compilamos con:

CFLAGS="-march=native -mtune=native -fomit-frame-pointer" CXXFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
make -j4 WITHOUT_GTK=1 RELEASE=1 USE_POLYMOST=1 USE_OPENGL=USE_GL3

Mete el duke3d.grp en el mismo directorio que el ejecutable.
Para tener música con .ogg: Mete un zip con la música en el mismo directorio donde tengas el duke3d.grp.
Y lanzaríamos el juego con:
./duke3d -g<nombre_archivo_zip_música>
RECUERDA: entre el -g y el nombre de archivo NO hay ningún espacio. Va todo seguido. 
Por ahora, usamos este: https://sc55.duke4.net/

Si quisieras música en MIDI, podrías meter un .sf2 en el mismo directorio donde tengas el duke3d.grp.

LOS CONTROLES CON 8BitDo SN30 Pro
--LOS EJES--
LEFT X - STRAFING - 50
LEFT Y - MOVING - 50
RIGHT X - TURNING - 12
RIGHT Y - LOOKINGUPANDOWN - (-12)
RIGHT TRIGGER - (+)FIRE
--LOS BOTONES--
A - JUMP
B - OPEN
X - INVENTORY
Y - JETPACK
LEFTSTICK - CROUCH
LEFTSHOULDER - PREVIOUS WEAPON
RIGHTSHOULDER - NEXT WEAPON
BACK - MAP
START - SHOW MENU

*******StarControl 2 (Ur-Quan Masters o UQM) en la Pi**********************************

Lo primero, vamos con una dependencia previa que tiene: libmikmod. La versión que viene incluida suena a rata en la Pi,
instalar libmikmod-dev nos arrastra dependencias de pulseaudio, X11 y la hostia, etc. Así que sólo nos queda instalar
nuestra propia build de libmikmod.
Para ello, clonamos su repo, configuramos, compilamos e instalamos así:

git clone --depth 1 https://github.com/sezero/mikmod.git
cd libmikmod
mkdir b4
cd b4

cmake -DCMAKE_BUILD_TYPE=Release -DENABLE_PULSE=0 -DENABLE_OSS=0 -DENABLE_DOC=0 \
-DCMAKE_C_FLAGS="-march=native -mtune=native" ..

make -j4 
make install

Y AHORA VAMOS A POR EL UQM EN SÍ:

Bajamos los últimos sources estables de:
https://sourceforge.net/projects/sc2/files/UQM/

Descomprimimos los sources, y ejecutamos:
./build.sh uqm config
Activamos y desactivamos lo que queramos, sobre todo estas cosas:
-Compilar una RELEASE en vez de una versión DEBUG.
-Usar libmikmod del sistema, NO el libmikmod incluido que como ya hemos dicho suena mal en la Pi.

Ahora editamos build.vars, y ahí buscamos el "-O3" y añadimos las CFLAGS y CXXFLAGS al lado:
-march=native -mtune=native

Ahora editamos src/libs/graphics/sdl/sdl2_pure.c, y en la llamada de SDL_CreateRenderer(), metemos los flags:
SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC

Ahora editamos src/libs/sound/mixer/sdl/audiodrv_sdl.c, y cambiamos todas las ocurrencias de:
desired.samples = 4096;
por:
desired.samples = 1024;

Compilamos con:
./build.sh uqm

Ahora creamos:
~/sc2
Y copiamos ahí el ejecutable "uqm" que acabamos de obtener.
Ahora copiamos el directorio "content" que viene con los sources a ~/sc2, tal cual el directorio con todo lo que tiene dentro.
Ahora creamos:
~/sc2/content/packages
Descargamos los datos del mismo sitio que los sources (con uqm-content.uqm es suficiente) y los metemos en:
~/sc2/content/packages

Y ya está.
Para que no nos mande mensajes a la consola, lo podemos ejecutar con:
./uqm --logfile=/dev/null
Se sale del juego con F10 o F12.

Como mejor se ve es en poniendo la resolución del juego en su menú a 640x480, con filtro bilineal y con scanlines,
y a su vez usando wlr-randr para poner un modo de pantalla de 1280x960 (ya que 960 es justo el doble de 480 y así no se nos forman patrones
en las scanlines).

*******vkQuake en la Pi***********************************************************

Bajamos la última estable de:
https://github.com/Novum/vkQuake/releases

cd Quake

Editamos Makefile y quitamos -lX11, y ponemos MP3LIB=mad a MP3LIB=mpg123 (para no tener que instalar libmad!)

make -j4

CFLAGS="-march=native -mtune=native -O2" make -j4

*******Debugear programas de Vulkan con RENDERDOC**********************************

--Instalamos dependencias previas:
apt-get install python3-dev

--Bajamos los últimos sources estables de:
https://github.com/baldurk/renderdoc/releases

--Compilamos con:
mkdir b4
cd b4

cmake .. -DENABLE_XLIB=FALSE -DENABLE_XCB=FALSE \
-DENABLE_UNSUPPORTED_EXPERIMENTAL_POSSIBLY_BROKEN_WAYLAND=TRUE \
-DENABLE_QRENDERDOC=OFF -DENABLE_PYRENDERDOC=OFF -DENABLE_GLES=OFF -DENABLE_GL=OFF

make -j10

RECUERDA: Si quisieras compilar QRenderdoc, NO RECOMENDADO PORQUE NO FUNCIONA EN WAYLAND,
que es una versión de Renderdoc con interface de ventanas y diálogos mediante QT,
no le pases "-DENABLE_QRENDERDOC=OFF", pero en ese caso necesitas QT instalado: mira el apartado corresponiente para saber cómo instalo.

--Instalamos:
make install
PARA DESINSTALAR, ya que no hay "make uninstall", hacemos:
for f in $(cat install_manifest.txt) ; do rm "$f"; done

--PARA CAPTURAR, lanzamos con:
renderdoccmd capture <PROGRAMA>
Y pulsamos F12 o PrintScreen para capturar un frame.
MUY IMPORTANTE: Las capturas van a /tmp/RenderDoc/

*******Capturar escenas de Vulkan para los informes de errores de MESA*************

Se hace usando GFXRECONSTRUCT.

--Clonamos su repo:
git clone --depth 1 https://github.com/LunarG/gfxreconstruct.git
git submodule update --init

--Compilamos e instalamos con:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release -DLZ4_OPTIONAL=ON
make install

--Para empezar a capturar (instrucciones sacadas de https://github.com/LunarG/gfxreconstruct/blob/dev/USAGE_desktop_Vulkan.md):
Añadimos a la variable de entorno VK_LAYER_PATH las rutas del .json y de la librería,
añadimos el layer a la lista de layers que queremos activar, y ponemos el loglevel a WARNING:
export VK_LAYER_PATH=/usr/local/share/vulkan/explicit_layer.d:/usr/local/lib:$VK_LAYER_PATH
export VK_INSTANCE_LAYERS=VK_LAYER_LUNARG_gfxreconstruct
export GFXRECON_LOG_LEVEL=warning
Especificamos que queremos capturar frames específicos, que la tecla para capturarlos es "Home", y que se van a guardar en "capture001":
export GFXRECON_CAPTURE_FILE=capture001
export GFXRECON_CAPTURE_FRAMES=true
export GFXRECON_CAPTURE_TRIGGER_FRAMES=Home

--Para desinstalar (no tiene "make uninstall"):
rm /usr/local/lib/libVkLayer_gfxreconstruct.so
rm /usr/local/bin/gfxrecon*
rm -R /usr/local/share/vulkan/explicit_layer.d

*******Quakespasm en GNU/Linux*****************************************************

Clonamos su repo:
git clone --depth 1 https://github.com/sezero/quakespasm.git

Entramos en el directorio Quake, editamos Makefile para cambiar -lGL por -lOpenGL, y compilamos con:

CFLAGS="-march=native -mtune=native -O2" make -j4 USE_SDL2=1 USE_CODEC_MP3=0 USE_CODEC_WAVE=0

En engine guarda su configuración en el subdirectorio id1 de donde tengas el ejecutable!
Los pak0.pak y pak1.pak van en ./id1
La música en OGG y con nombres de archivo como track01.ogg.. track11.ogg, va en ./id1/music

Si quieres agua transpatente, es con "r_novis 1" y "wateralpha 0.6"

*******Core TYRQUAKE en RetroArch************

Copia el core a ~/.config/retroarch/cores
Los datos del juego (los .PAK) van en un subir llamado id1, así en minúsculas. La música, en ogg, va en id1/music.

Se lanza con:
retroarch -L ~/.config/retroarch/cores/tyrquake_libretro.so id1

Pon en "Options" el "Frame Rate" a 60.

Nada más empezar, los controles no te responderán. Para arreglarlo, ve a "controls->port 1 controls"
y "Device Type" ponlo a "Gamepad Classic", y dale a "save core remap file".
O puedes tener controles tipo HALO: para ello, pon "Device Type" a "Gamepad Modern" y luego en "Options" activar el "Invert Y Axis".

Y para cambiar cosas del juego y que se conserven los cambios, mételos en id1/autoexec.cfg.
Por ejemplo, con esto queda muy a mi gusto el tamaño de pantalla, escalado de texturas, animaciones suaves, volúmen...

viewsize 120 
r_lerpmodels 1.00
r_lerpmove 1.00
dither_filter 1.00
gamma 0.90
bgmvolume "0.500000"
volume "0.200000"
bind F1 ""

Y desactiva lo de "load dummy core on shutdown", dentro de settings->core, si no quieres que al darle a quit en el menú del Quake
te mande al menú de RA.

--PARA CARGAR A CUJO--

Te puedes bajar la última versión (cujo14.zip) de aquí: https://github.com/Jason2Brownlee/QuakeBotArchive/tree/main/bin
El mod de Cujo es un sencillo archivo pak0.pak. Copia el pak0.pak a id1/pak2.pak, y ya se carga automáticamente al cargar el core.
Ahora, para llamar a Cujo y encender su luz apretando los analógicos del mando hacia abajo, pon esto en id1/autoexe.cfg
(Sí, aunque parezca raro hay que hacer unbind, wait, unbind, wait... y luego ya bind. Cosas que pasan).

unbind "JOY_L3"
unbind "JOY_R3"
wait
unbind "JOY_L3"
unbind "JOY_R3"
wait
bind "JOY_R3" "IMPULSE 100"
bind "JOY_L3" "IMPULSE 105"

Hilos de interés de cómo cargar mods en el core tyrquake (por si quieres cargar algún día las expansiones oficiales, que
a parte de un pak0.pak traen su propia música y tal):
https://www.psx-place.com/threads/tyrquake-mods-for-retroarch.9539/
https://forums.libretro.com/t/tyquake-qauke-mods-how/15631
https://docs.libretro.com/library/tyrquake/

*******TYRQUAKE standalone en GNU/Linux****************************************************************************************************

clonamos su repo:
git clone --depth 1 git://disenchant.net/tyrquake

Editamos el Makefile y cambiamos:
GL_LIBS     += GL
por:
GL_LIBS     += OpenGL

Compilamos con:
make USE_SDL=Y OPTIMIZED_CFLAGS=Y DEBUG=N -j4

POR DEFECTO compila tanto el motor software como el modotor GL, pero podemos compilar sólo uno de ellos:
-Si sólo quisiéramos el motor por software, haríamos:
make bin/tyr-quake USE_SDL=Y OPTIMIZED_CFLAGS=Y DEBUG=N -j4
-Si sólo quisiéramos el motor GL haríamos:
make bin/tyr-glquake USE_SDL=Y OPTIMIZED_CFLAGS=Y DEBUG=N -j4

*******EN RASPBIAN NO PUEDO DEBUGEAR PROGRAMAS EN C++ QUE HAN SIDO COMPILADOS CON DISTCC*********************************************************

Da todo el rato "no symbol <loquesea> in current context".
Hay que actualizar gdb...

Desisntalamos nuestro viejo gdb, el que viene con Raspbian. No tiene dependencias graves, sólo debería ser ese paquete y ya:

sudo apt-get purge gdb

Instalamos texinfo y libncurses5-dev:

sudo apt-get install texinfo libncurses5-dev

Bajamos los últimos sources de http://ftp.gnu.org/gnu/gdb/. La versión 7.9.1 va perfectamente.
Hacemos

./configure --prefix="/usr"
make -j8
sudo make install -j8

Y listo. Con el nuevo gdb ya podemos debugear cosas compiladas con el distcc, ya que encuentra los debug simbols sin problemas y podemos ir línea a línea y todo eso.

*******Saltarse temporalmente los límites de tethering******

for N in $(sudo sysctl --all 2>/dev/null |grep -Eo "^net\.ipv6\.conf\.[^\.]+\.hop_limit"); do
    sudo sysctl --write "$N=128"
done

Y para hacerlo permanente:

sudo sysctl --all 2>/dev/null |grep -E -e "^net\.ipv6\.conf\.[^\.]+\.hop_limit" -e "net.ipv4.ip_default_ttl" |sudo tee /etc/sysctl.d/11-custom-ttl-hop.conf

*******Profiling de programas usando OPROFILE*********

Puede que necesitemos activado el soporte de Oprofile en el kernel: PARA PROGRAMAS NORMALES NO PARECE HACER FALTA ESTO.
General Options, casi abajo del todo, Profiling y dentro de eso Oprofile.

Hay que bajar los sources y compilarlos. Pide ciertas librerías:
libiberty está en libiberty-dev. 
bfd está en binutils-dev.
Las demás librerías que va pidiendo se ve bien su nombre de paquete.

Lo normal es hacer el profiling según lanzamos el programa:

operf <ejecutable>

Para hacer el profiling de un programa en ejecución, 

operf --pid=<PID_DEL_PROGRAMA>

Luego, cuando acabemos de usar el programa, usaríamos opereport para leer el informe que hemos generado (http://oprofile.sourceforge.net/examples/):

opreport --demangle=smart --symbols `which scummvm`

Si te salen cosas como 
138941   69.8828  libc-2.19.so             /lib/arm-linux-gnueabihf/libc-2.19.so
eso quiere decir que el 69% de la CPU se está usando en una función de libc, pero como no tienes los debug symbols de libc instalados, no te la muestra.
Así que instala libc6-dbg y te saldrán todas las llamadas.

*******Añadir username, hostname  y ruta actual al prompt del bash************************************************
Añade esto a .bash_profile:

PS1="\u@\H\w$ "

******Quitar versión de kernel y lastlogin************************************************************************

Editamos /etc/pam.d/login y comentamos:

#session    optional     pam_motd.so  motd=/run/motd.dynamic
#session    optional     pam_motd.so noupdate
#session    optional     pam_mail.so standard noenv # [1]
#session	optional	 pam_lastlog.so

Editamos 
/etc/pam.d/sshd y comentamos:

#session    optional     pam_motd.so  motd=/run/motd.dynamic
#session    optional     pam_motd.so noupdate
#session    optional     pam_mail.so standard noenv # [1]

*******El comando IP**********************************************************************************************

Fuente: http://www.tecmint.com/ip-command-examples/

Añadir una IP fija:
ip addr add 192.168.5.10/24 dev eth0

Para confirmar:
ip addr show

Ahora añadimos el gateway:
ip route add default via 192.168.5.7

Probamos que podemos salir a internet:
ping 8.8.8.8

Lo único que nos faltaría es poner un servidor DNS en /etc/resolv.conf, para poder hacer ping a google y demás.
nameserver 8.8.8.8

También es posible desconectar el cable, etc

*******Mantener más o menos en hora sistemas que no tienen reloj interno (Rpi, Cubie2...)*********************************************
en Debian, instala el paquete "fake-hwclock", pon el sistema en hora y reinicia. Ya guarda la hora del último aparago y más o menos nos vale para evitar clock skews.

*******Ver los modos de vídeo disponibles usando el interface KMS/DRM*****************************************************************

modetest |grep -50 modes |more

*******Cambiar el modo con xrandr*****************************************************************************************************

Listar modos de vídeo: xrandr -q
Cambiar el modo de vídeo: 
xrandr --output LVDS1 --mode 640x480

*******Acceso a piratebay cuando la bloqueen desde europa********************************************************************************************

No hace falta ni TOR

Haced un ping o un nslookup a thepiratebay.se, tendreis la IP, los filtros de las operadoras suelen ser por nombres y no por IPs

Sustituid la IP que os salga por la URL en el navegador y ya ;) muahahahaha... 

*******Imágenes de CD: cambios de formato, etc**********

Para pasar de una combinación CUE+WAV+ISO a CUE+BIN, usamos el CDMage en Wine. Es un programa MUY antiguo, pero funciona. 
Simplemente abrimos el CUE del combo CUE+WAV+ISO, y luego le damos a SAVE AS... y el programa lo guarda como CUE/BIN!!

Para hacer lo contrario, ripear de CUE/BIN a CUE+WAV+ISOS, usamos otro programa de Windows: el BINCHUNK.EXE.
Viene en el parche del Castlevania Rondo of Blood al inglés.

*******Las tildes de Libreoffice no funcionan tras cambiar entre libreoffice y otro programa********

Instala el paquete libreoffice-gtk, y arreglado.
Recuerda: libreoffice-gtk. Es un paquete de integración.

*******Ver la configuración del kernel en ejecución****************

Para que nos aparezca /proc/config.gz, hacemos:

modprobe configs

Ahora ya podemos buscar con ZGREP directamente:

zgrep PREEMPT /proc/config.gz

*******Deshabilitar el three-finger salute (ctrl-alt-sup)**********

En algunos casos puede ser importante por seguridad, o porque arrancas con un script mínimo custom, sin sistema init.
En ese caso el kernel no sabe hacer nada a parte de "botonazo" al recibir la señal: normalmente el tratamiento
de de la señal se especifica en /etc/inittab pero sin un proceso init ese fichero no lo lee ni el gato, por lo que hacer
ctrl-alt-sup implica un reinicio inmediato sin sincronizar los discos.

Para ello, podemos ver el estado de las variables de configuración del kernel con: sysctl -a
Podemos ver el estado de la variable que nos interesa: sysctl kernel.ctrl-alt-del
Y ahora, podemos deshabilitar el ctrl-alt-sup así: sysctl -w kernel.ctrl-alt-del=0

TAMBIÉN PODRÍAMOS editar /etc/sysctl.conf y añadir allí kernel.ctrl-alt-del=0, o incluso hacer:
echo 0 > /proc/sys/kernel/ctrl-alt-del

OJO: Al deshabilitarlo, en un sistema sin init es probable que tengamos kernel panic al matar el proceso con PID1 (es decir,
al acabar nuestro script de inicio). Supongo que porque el kernel usa el mismo vector para el ctrl-alt-sup que para reiniciar
mediante el comando reboot. Ni idea.

*******Preparar el portátil como router para salir a internet desde la Raspberry Pi u otra placa conectada a él por ethernet************

Al router (el portátil, por ejemplo, que es el que se conecta a internet) le ponemos una IP fija en el mismo rango que el cliente.
En Lubuntu es tan fácil como crear una conexión ethernet nueva en el gestor de redes. 
CUIDADO!!! CUIDADO!!! NO LE PONGAS un gateway o puerta de enlace, porque LA CONEXIÓN WIFI DEJARÁ DE FUNCIONAR AL PONER EL CABLE SI LO HACES.

<BLOQUE DEBIAN> 

En DEBIAN con LXQT, que usa connman (con su GUI llamada Connman UI), hacemos lo mismo pero a mano, así:
Averiguamos el nombre que le da connman a nuestra conexió ethernet:
connmanctl services
...vemos este, que es el cableado: ethernet_3822e2bae00a_cable 

AHORA, creamos la conexión con IP estática así:
connmanctl config ethernet_3822e2bae00a_cable --ipv4 manual 192.168.1.27 255.255.255.0
...Esta conexión quedará guardada automáticamente en /var/lib/connman/ethernet_3822e2bae00a_cable/settings

<FIN BLOQUE DEBIAN>

Ahora editamos /etc/sysctl.conf y descomentamos la línea
#net.ipv4.ip_forward=1
Añadimos el binding a las IPtables:
sudo iptables -t nat -A POSTROUTING -o wlo1 -j MASQUERADE
Donde digo wlo1, me refiero al interface con el que el servidor se conecta a internet.
Antes de la 14.04 de Lubuntu, la wifi era eth1, luego fue un tiempo wlan0... así que fíjate bien.
Si queremos que estas cosas empiezen a funcionar sin reiniciar, hacemos
echo 1 > /proc/sys/net/ipv4/ip_forward
Ahora salvamos las IPtables:
sudo iptables-save | sudo tee /etc/iptables.sav
Y nos aseguremos de que se carguen al reiniciar. Para ello, editamos el crontab así:
sudo crontab -e
Y le añadimos la línea:
@reboot /usr/sbin/iptables-restore < /etc/iptables.sav
Recuerda crear una conexión en el servidor que sea del mismo rango que la IP fija del cliente,
y en el cliente poner como gateway la IP del servidor (también en RISC OS!!!),
añadir el servidor dns en /etc/resolv.conf (sólo en LINUX, claro) si hace falta, etc...
Lo típico de /etc/network/interfaces, que tienes más abajo en varios sitios.

*******Un servicio de systemd para levantar la red**************************************************************************************************

Nos interesa que no se reinicie al salir (por eso NO le ponemos "Restart=always"),
que se ejecute una sola vez (por eso ponemos "Type=oneshot")
y que permanezca activo tras ejecutarse (por eso "RemainAfterExit=yes").
Así que queda así nuestro /etc/systemd/system/wifiup.service:

[Unit]
Description=WIFI network upbringring

[Service]
Type=oneshot
User=root
Group=root
PAMName=login
ExecStart=
ExecStart=-/usr/local/bin/wifiup
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target

Lo activamos con: "systemctl enable wifiup"
(Lo único que hace es crear un symlink en /etc/systemd/system/multi-user.target.wants, ya que es ese target el que depende de nuestro script
para ser alcanzado).

Recuerda que nuestro script "wifiup" debe tener al principio la cadena:
#!/bin/bash
...O no funcionará lanzarlo desde la UNIT que acabamos de crear, porque por defecto considera que es un binario, no un script.

*******No tengo rc.local! Dónde añado cosas al inicio??*********************************************************************************************

En las versiones actuales de Debian/Ubuntu, el servicio rc-local, que leía comandos de /etc/rc.local, no viene ya, así que tenemos dos opciones:

OPCIÓN 1: Añadir cosas al crontab. Es la opción más simple.

Editamos el crontab
sudo crontab -e
Y ahí al final le añadimos la línea del comando que queramos, pero con la ruta completa donde está el comando. Además, si queremos que
lo que sea se ejecute al inicio, le ponemos delante @reboot. Así:
@reboot <COMANDO CON SU RUTA COMPLETA>

OPCIÓN 2: Crearnos un servicio rc-local

sudo vim /etc/systemd/system/rc-local.service
..con el contenido:
[Unit]
Description=/etc/rc.local Compatibility
ConditionPathExists=/etc/rc.local

[Service]
Type=forking
ExecStart=/etc/rc.local start
TimeoutSec=0
StandardOutput=tty
RemainAfterExit=yes
SysVStartPriority=99

[Install]
WantedBy=multi-user.target

Ahora creamos /etc/rc.local con este contenido:
#!/bin/sh -e
#
# rc.local

exit 0

Ahora lo hacemos ejecutable:
sudo chmod +x /etc/rc.local

Ahora metemos en él lo que necesitemos, antes del exit 0, lógicamente. Habilitamos el servicio, lo lanzamos, y comprobamos su status:
sudo systemctl enable rc-local

sudo systemctl start rc-local.service
sudo systemctl status rc-local.service

... y ya debería ejecutarse lo que hayamos puesto en /etc/rc.local

*******Averiguar IP externa***********************************************************************************************************************

curl ipecho.net/plain ; echo

*******Conocer la IP de un equipo de casa en todo momento desde fuera, mediante un email cada vez que cambia**************************************

Para linuxeros en general: Recibir un correo con la IP de tu equipo de casa (sólo Linux):

INSTALAR PAQUETES
sudo apt-get install curl mutt ssmtp

CONFIGURAR SERVICIO DETECTA IP
sudo nano /root/notify-ip
######################################
#!/bin/bash
email=USERNAME@gmail.com
if [ ! -e /tmp/ip ]; then
curl -s ifconfig.me > /tmp/ip
fi
curl -s ifconfig.me > /tmp/ip2
newip=$(diff /tmp/ip /tmp/ip2 | wc -l)
if [ $newip -gt 0 ]; then
mv -f /tmp/ip2 /tmp/ip
cat /tmp/ip | mail -s "CAMBIO DE IP DINAMICA" $email
else
rm /tmp/ip2
fi
######################################
sudo chmod +x /root/notify-ip

CONFIGURAR SERVIDOR DE CORREO
sudo nano /etc/ssmtp/ssmtp.conf
root=USERNAME@gmail.com
mailhub=smtp.gmail.com:587
rewriteDomain=
hostname=USERNAME@gmail.com
UseSTARTTLS=YES
AuthUser=USERNAME
AuthPass=PASSWORD
FromLineOverride=YES

CONFIGURAR PLANIFICADOR DE TAREAS (cada 30 mins)
sudo crontab -e
30 * * * * /root/notify-ip | date >> /tmp/notify-ip.log

sudo service cron restart 

SCREENSHOTS EN WAYLAND
======================

Usamos GRIM.
--Clonamos su repo: git clone --depth 1 https://git.sr.ht/~emersion/grim
--Compilamos con:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release ..

ninja -j4
ninja install

--Ahora ya podemos capturar la pantalla simplemente escribiendo "grim", o si queremos capturar una salida concreta usamos "grim -o HDMI-A-1". 

*******Captura de pantalla en Linux y apertura automática con el PINTA*****************************************************************************

Creamos un script, captura, con permisos de ejecución y el siguiente contenido:

gnome-screenshot --file=captura.png
pinta captura.png

Lo enviamos a /usr/bin

Ahora editamos ~/.config/openbox/lubuntu-rc.xml (NO editamos /etc/xdg/openbox... porque ESO LO IGNORA), y buscamos Print.
Vemos que viene la combinación A-Print (Alt+Print screen) para capturar la pantalla. La dejamos sólo como Print, y entre <Command> y </Command>
ponemos simplemente captura. Listo.

*******Whatsapp en Linux**************************************************************************************************************************

Más fácil que mear en pared.
Nos bajamos el plugin para pidgin de aquí:  http://davidgf.net/nightly/whatsapp-purple/
O de github si lo queremos compilar (https://github.com/davidgfnet/whatsapp-purple), pero vamos, que desde la página de binarios va bien.
PARA COMPILARLO necesitamos tener instalados los paquetes libpurple-dev y libfreeimage-dev, o nos faltarán cabeceras.

Una vez que tenemos el binario, bajado o compilado por nosotros, lo mandamos a /usr/lib/purple-2, que es donde todos los programas basados en libpurple, incluído pidgin,
buscan los plugins.

Pero claro, necesitamos un user y pass. El user será el número de teléfono con el 34 delante. El pass lo tenemos que hacer registrándonos.
Para ello, usamos yowsup-cli del paquete yowsup: https://github.com/tgalal/yowsup
Clonamos el repo, instalamos python-dateutil, y damos permisos de ejecución al script yowsup-cli en python que está en src.
INstalamos esto: sudo apt-get install python-dateutil
Ahora hacemos:

./yowsup-cli registration --requestcode sms --phone 34620626230 --cc 34

Y nos llegará un mensaje al móvil con un código para registrarnos. Así que hacemos:

./yowsup-cli registration --register 396-299 --phone 34620626230 --cc 34

Sustituimos 396-299 por el código, obviamente.
Al acabar este último comando, nos dará un password. Ese password lo podemos meter en nuestro fichero config, y/o lo podemos usar ya
directamente en el plugin de pidgin como password de la cuenta, de tal manera que mi cuenta es:

login: 34620626230
pw: ymcAunpgwsfsdDFHK4FSHPHJqxM=

Ahora ya podemos agregar contactos de whatsapp con normalidad!

Si tienes problemas de conectividad, edita ~/.purple/accounts.xml y busca el servidor, versión de android, puerto...

*********DISCORDO, un cliente de discord para GNU/Linux en consola******************

Instalamos el compilador de go:

sudo apt-get install golang
(HAY una versión de gcc que compila lenguaje GO, pero no soporta la última versión del lenguaje y falla).

Clonamos el repo del DISCORDO:

git clone --depth 1 https://github.com/ayntgl/discordo.git

Compilamos con:

make build -j4

Se ejecuta directamente con: ./discordo
El pass es el que acaba en 5555.

SI ENTRAS Y NO SE VEN LOS SERVIDORES Y CANALES, entra desde la web y muévelos un poco, moviendo unos arriba y otros abajo, etc.
Y curiosamente ya se verán.

También podríamos pasarle un token de identificación con:
discordo --token <nuestro_token_de_autentificación>

*********Evitar desconexión de red WIFI cuando la batería está baja*****************

Editamos este fichero:

sudo vim /etc/NetworkManager/conf.d/default-wifi-powersave-on.conf

y ponemos
wifi.powersave = 2
(Viene puesto a 3, que es "default", y lo ponemos a 2 que es "disable").

Reiniciamos el sistema o hacemos:

systemctl restart NetworkManager

..Y listo.

*************HACER FUNCIONAR PINCHO WIFI con MT7601U en Linux********************

El kernel trae ya los módulos necesarios, pero hay que bajarse el firmware:

wget wget -c 'http://git.kernel.org/cgit/linux/kernel/git/firmware/linux-firmware.git/plain/mt7601u.bin'

...Y meterlo en su sitio:

cp mt7601u.bin /lib/firmware/

Si por alguna razón no tienes wlan0, mira dmesg.

Este driver sí soporta el modo nl80211, así que la línea de wpa_supplicant queda así:

wpa_supplicant -iwlan0 -D nl80211 -c/etc/wpa_supplicant/wpa_supplicant.conf -B

*************HACER FUNCIONAR PINCHO WIFI con RTL8188EU en Linux******************

Instalamos dependencias previas:
apt-get install build-essential linux-headers-amd64 git

Clonamos el repo:
git clone --depth 1 https://github.com/lwfinger/rtl8188eu.git

Instalamos el nuevo módulo:
make
make install
cp rtl8188eu/rtl8188eufw.bin /lib/firmware/rtlwifi/

depmod -a

update-initramfs -u

modprobe 8188eu

Ten en cuenta que el chip rtl8188eu NO SOPORTA el driver nl80211, así que en el script WIFIUP,
vez de poner -D nl80211, tiene que poner -D wext, que es el driver viejo.
Total, que la llamada a wpa_supplicant queda así:

wpa_supplicant -iwlan0 -D wext -c/etc/wpa_supplicant/wpa_supplicant.conf -B

*********NO funciona la conexión con una tarjeta de broadcom (módulo b43)***********

Si miras 
dmesg | grep err
verás queSE QUEJA DE QUE LE FALTAN LOS FICHEROS DEL FIRMWARE. Tendrías que instalar el b43-fwcutter... pero claro, no tienes internet. (Si tienes internet, simplemente
instala firmware-b43-installer
Vale, la solución es descargar a mano desde otro ordenador con conexión:
http://mirrors.kernel.org/ubuntu/pool/main/b/b43-fwcutter/b43-fwcutter_015-9_amd64.deb
http://www.lwfinger.com/b43-firmware/broadcom-wl-5.100.138.tar.bz2

Ahora descomprime, recorta el hardware y déjalo instalado:

sudo dpkg -i b43-fwcutter_015-9_amd64.deb
tar xfvj broadcom-wl-5.100.138.tar.bz2
sudo b43-fwcutter -w /lib/firmware broadcom-wl-5.100.138/linux/wl_apsta.o

Instrucciones sacadas de:
https://askubuntu.com/questions/730799/installing-firmware-b43-installer-offline

*********Conexión WIFI lenta con BCM4313*********************************************
Para arreglarlo, líbrate de los drivers b43 que son una mierdaca.

sudo apt-get install bcmwl-kernel-source
sudo modprobe -r b43 ssb wl
sudo modprobe wl

reboot and ejoy! :)

Si no tienes wifi en absoluto, instala el paquete firmware-b43-installer y reinicia, a ver si hay suerte.

********Establecer el niceness de un programa siendo usuario******************************************************************************************

Editamos /etc/security/limits.conf y añadimos la fila:
pi 	-	nice	-20

Ahora podemos lanzar el programa con nice -n -10 <nombre_programa>

********DOSBOX en ARM**************************************************************************************************************

Nos bajamos el archivo svn de aquí: http://www.dosbox.com/wiki/BuildingDOSBox
Si queremos el ARM dynarec, tras ejecutar el ./configure tenemos que editar el config.h y añadir:
#define C_DYNREC 1
#define C_TARGETCPU ARMV7LE
#define C_UNALIGNED_MEMORY 1
Cuidado, que estos valores ya estarán undef en otras partes de fichero o con valores distintos.
La info de cómo habilitar el dynanrec ARM viene de aquí: http://www.vogons.org/viewtopic.php?f=31&t=37651&p=333227#p333318

Para compilar SDL1.2.15:

Añadimos la llamada a: 

ioctl(console_fd, FBIO_WAITFORVSYNC, 0);

en src/video/fbcon/SDL_fbvideo.c, función FB_WaitVBL().

Configuramos con:

CFLAGS="-march=native -mtune=native -O2" ./configure --disable-video-opengl --enable-video-fbcon --disable-video-kms --disable-video-directfb --disable-oss --disable-alsatest --disable-pulseaudio --disable-pulseaudio-shared --disable-arts --disable-nas --disable-esd --disable-nas-shared --disable-diskaudio --disable-dummyaudio --disable-mintaudio --disable-video-x11

Si se queja el DOSBOX de que falta el ratón, usa la variable de entorno SDL_NOMOUSE=1
Si se queja de que las SDL no tienen soporte para CDROM, pues te toca recompilar las SDL.

********DESHABILITAR EL CURSOR QUE PARPADEA MIENTRAS ARRANCA EL KERNEL*********************************************************

Añadimos a cmdline.txt:
vt.global_cursor_default=0

********Hacer que el cursor de la consola deje de parpadear********************************************************************

echo -e '\033[?17;0;0c' > /dev/tty1

********Buscar un fichero a partir de parte de su nombre***********************************************************************
find ./ -iname gl*
find ./ -name gl*

Lo de iname es para ignorar las mayúsculas o minúsculas.

******************USAR QEMU PARA EMULAR UN MAC QUADRA 800**********************************************************************

NOTAS PREVIAS:
-Si emulas un sistema basado en 68K con QEMU, el proceso QEMU va a pillar el 100% de al menos un core: Esto es normal, y se debe
 a que el 68000 no tiene instrucción "idle" para "no hacer nada cuando no hay nada que hacer", va a full todo el rato.
 Es así, no se puede hacer absolutamente nada para evitarlo.
-QEMU sólo puede usar las tecnologías de virtualización (KMV) si emulamos una máquina con la misma arquitectura que la máquina host.
 O sea, que olvídate de KVM para cosas como emular un Mac 68K en X86.
-OJO!!! OJO!! OJO!! Algunos juegos más antiguos de Mac II como el Ishar 1 y 2 NO FUNCIONAN en un Macintosh Quadra 800 real.
 Si los ejecutas en el QEMU petarán con un segfault del QEMU.

-La info sobre los modos de vídeo de los modelos de Mac fue sacada de:
http://adb.arcadeitalia.net/lista_mame.php buscando por el fabricante Apple y des-marcando la casilla "MameCab only".

El primer Mac (Macintosh 128), usa un modo de vídeo de 512x342@60.14742 Hz.
El primer Mac en color (Macintosh II) usa 640x480@66.662467 Hz.
LO IMPORTANTE: Los Mac posteriores al Macintosh II, como el Mac II Ci o este Quadra 800, son ya VGA, por lo que: 640x480@59.940476 Hz.

El Lemmings no suena bien con vsync activado (es decir, si le pasas PRESENTVSYNC a SDL_CreateRenderer),
incluso si la frecuencia de refresco es la correcta del host es la correcta (66.662467 Hz, ya que salió para Mac II).

		CÓMO COMPILAR Y USAR QEMU

-Dependencias previas
--Instalamos pip (es NECESARIO o el script de configuración falla!!)
apt-get install python3-pip --no-install-recommends
--Instalamos la última versión de MESON:
	sudo apt-get purge meson
	pip3 install --user meson
--Instalamos libepoxy (necesario para el soporte OpenGL):
Bajamos la última versión estable de libepoxy desde:
https://github.com/anholt/libepoxy/releases

Configuramos, compilamos e instalamos:

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson setup -Dx11=false ..

ninja -j4
sudo ninja install

VAMOS CON QEMU EN SÍ:

-Clonamos su repo:

git clone --depth 1 https://gitlab.com/qemu-project/qemu.git

-Editamos ui/sdl2.c y hacemos estos cambios:
--(NO NECESARIO PARA MODO OPENGL, QUE ES LO QUE USAMOS) Buscamos la llamada a SDL_CreateRenderer(), le añadimos el flag SDL_RENDERER_ACCELERATED,
 y añadimos SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear") justo encima (si lo añadieses en el bloque de llamadas a SDL_SetHint()
 que hay más arriba, sólo tendría efecto en modo OpenGL, que no hace falta porque ya salen suavizados los gráficos). 
 NO le pasamos el flag SDL_RENDERER_PRESENTVSYNC porque entonces el Lemmings suena mal, entrecortado.
--Nos vamos a la función sdl_grab_start() y comentamos el primer *if*, que dice: 
if (!(SDL_GetWindowFlags(scon->real_window) & SDL_WINDOW_INPUT_FOCUS))
...de lo contrario, el mouse grab automático en modo fullscreen no funcionará.

-Editamos ui/console-gl.c, nos vamos a surface_gl_render_texture(), y cambiamos:
glClearColor(0.1f, 0.1f, 0.1f, 0.0f);
por:
glClearColor(0.0f, 0.0f, 0.0f, 0.0f);

-Para compilar con emulación de 386, plataformas basadas en Motorola 68000 y plataformas basadas en PowerPC, configuramos con:

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
./configure --disable-gtk --disable-tpm --disable-pa --disable-oss --disable-sndio --disable-vnc --disable-png --enable-sdl --disable-sdl-image \
--disable-selinux --disable-iconv --disable-qom-cast-debug --disable-dbus-display --disable-keyring \
--target-list=m68k-softmmu,i386-softmmu,ppc-softmmu

-Ahora compilamos simplemente con: make
Y los ejecutables qemu-* quedan en el directorio "build". Los copiamos a /usr/local/bin:
cp build/qemu-img /usr/local/bin/
cp build/qemu-system-i386 /usr/local/bin/
cp build/qemu-system-m68k /usr/local/bin/

		CÓMO USAR QEMU PARA EJECUTAR MS-DOS
(OJO!! NO recomendado, QEMU va fatal con MS-DOS: el escalado de pantalla es una mierda pixelada con shimmering y ratio incorrecto,
 la compatibilidad con juegos es atroz, no va ni el Lemmings, el refresco de pandalla va a lo loco, etc.
 QEMU es para Windows 95 en adelante SOLAMENTE. Para DOS, usa DOSBOX o similar).

Copiamos la BIOS que incluye QEMU a ~/msdos:
cp build/qemu-bundle/usr/local/share/qemu/bios-256k.bin ~/msdos/

Nos bajamos las BIOS necesarias al directorio ~/msdos:
cd ~/msdos
wget https://gitlab.com/qemu-project/qemu/-/raw/master/pc-bios/vgabios-stdvga.bin
wget https://gitlab.com/qemu-project/qemu/-/raw/master/pc-bios/vgabios-cirrus.bin
wget https://gitlab.com/qemu-project/qemu/-/raw/master/pc-bios/kvmvapic.bin
wget https://gitlab.com/qemu-project/qemu/-/raw/master/pc-bios/efi-e1000.rom

Y con este script de inicio lo lanzamos:
qemu-system-i386 -display sdl,gl=core -full-screen -machine pc -cpu 486 -hda msdos.img -device sb16

SOBRE LA IMÁGEN DE DISCO
Se puede usar la misma imágen de disco que se usa en la MiSTer.
Si quisiéramos, podríamos crear una imágen de disco así:
qemu-img create -f raw msdos.img -o preallocation=full 256M

NOTA: Si quisiéramos ejecutar Windows 3.x, le pasaríamos "-vga cirrus". Para MS-DOS nos interesa la VGA estándard.

		CÓMO USAR QEMU PARA EMULAR UN MAC QUADRA 800

		INSTALAR UN SISTEMA OPERATIVO

La información principal procede de: https://www.emaculation.com/doku.php/m68k-qemu-on-osx
Un vídeo muy bueno sobre el tema (aunque emula un Mac POWERPC, el mac99) es este: https://www.youtube.com/watch?v=fzTyl5Ss8nA

-Bajamos la BIOS del Quadra 800 de: https://www.macintoshrepository.org/17137-macintosh-rom-archive
 La llamamos q800.rom, y la metemos en ~/mac

-Creamos una imágen donde guardar los parámetros de la BIOS del Mac:
qemu-img create -f raw pram-macos.img 256b

		RECOMENADADO: INSTALAR SYSTEM 7.1

-Creamos la imágen de disco (con preallocation, porque si no, nos crea un archivo de esos enanos que van creciendo según lo usamos,
además un Quadra 800 venía con 256M):
qemu-img create -f raw system71.img -o preallocation=full 256M

-Nos bajamos el disco de instalación de Mac OS 7.1 con el particionador de disco incluido que hay en la sección
"Starting qemu-system-m68k to install Mac OS 7.1" de https://www.emaculation.com/doku.php/m68k-qemu-on-osx#running_qemu-system-m68k_with_mac_os_71-81_guests

-Iniciamos la emulación del modelo de Mac Quadra 800 ("-M q800"), con 32MB de RAM ("-m 32"), usando la BIOS ("q800.rom"),
pasándole la imágen de instalación de Mac OS 7.1 que nos acabamos de bajar como primer disco,
y la imágen de disco donde lo vamos a instalar como segundo disco:
qemu-system-m68k -M q800 -m 32 -bios q800.rom \
-display sdl -audio driver=alsa \
-device scsi-hd,scsi-id=0,drive=hd0 \
-drive file=macos71_Install.img,media=disk,format=raw,if=none,id=hd0 \
-device scsi-hd,scsi-id=1,drive=hd1 \
-drive file=system71.img,media=disk,format=raw,if=none,id=hd1

-Una vez arrancado el sistema, ejecutamos "Apple HD SC v3.0 (A/UX)", le damos al botón "Drive" para cambiar a la unidad 1,
y seguimos estas instrucciones para particionar el disco e instalar el sistema operativo:
-Start the Apple HD SC v3.0 (A/UX) tool and initialise your disk. Verification can take a long time. When finished give the disk a name.
-Next, click Partition and then Custom. You'll notice a partition of 20Mb was created with the name you entered.
-Click the name and click Remove, OK.
-Click in the gray area to create a new partition. Click Macintosh Volume and then manually enter the desired partition size,
 not exceeding the maximum size indicated. Click OK.
 The partition will be created. Click Done, then Quit to have the disk available on the desktop.
-Open the InstallMeFirst folder and start the installer.
If you want CD Rom support, open the corresponding folder and install it. This will also install Quicktime 1.5.

-Una vez instalado el sistema, ya arrancamos con el disco duro preparado solamente:
qemu-system-m68k -M q800 -m 32 -bios q800.rom \
-display sdl -audio driver=alsa \
-device scsi-hd,scsi-id=0,drive=hd0 \
-drive file=system71.img,media=disk,format=raw,if=none,id=hd0 \
-display sdl,gl=on -full-screen

-Para instalar QuickTime 2.1 y SoundManager 3.1, lo más cómodo es arrancar desde el "Apple Legacy Recovery Oct 1999",
que lo tienes en el disco de backup y también está en archive.org, así:
qemu-system-m68k -M q800 -m 32 -bios q800.rom \
-display sdl -audio driver=alsa \
-device scsi-hd,scsi-id=0,drive=hd0 \
-drive file=system71.img,media=disk,format=raw,if=none,id=hd0 \
-cdrom ../"Apple Legacy Recovery Oct 1999.iso" \
-display sdl
NOTA!!! TAMBIÉN PUEDES PREPARAR EL DISCO E INSTALAR EL SISTEMA DESDE ESA MISMA ISO. DE HECHO, ES MÁS CÓMODO PORQUE LO PUEDES HACER TODO
SIN REINICIAR EL SISTEMA EMULADO. SE HACE IGUAL LA PREPARACIÓN DEL DISCO DURO, Y LUEGO SE INSTALA ELIGIENDO EL MODELO DE ORDENADOR DESDE
"MAC OS -> SYSTEM SOFTWARE BY CPU-> CENTRIS/QUADRA -> QUADRA 800 -> SYSTEM 7.1 -> NET INSTALL.SRC"

-Si te tienes que traer juegos o cosas desde otro sistema (por ejemplo, que hayas instalado para emular Mac en MAME)
puedes montar el disco del otro sistema como segundo disco así ("system.img" sería el disco del otro sistema):
qemu-system-m68k -M q800 -m 32 -bios q800.rom \                                                                                        
-display sdl -audio driver=alsa \                                                                                                      
-device scsi-hd,scsi-id=0,drive=hd0 \                                                                                                  
-drive file=system71.img,media=disk,format=raw,if=none,id=hd0 \                                                                        
-device scsi-hd,scsi-id=1,drive=hd1 \                                                                                                  
-drive file=system.img,media=disk,format=raw,if=none,id=hd1 \                                                                          
-display sdl 

-PARA EVITAR PROBLEMAS AL PULSAR SHIFT, ve a Menú Manzana->Control Panels, crea una carpeta llamada DISABLED, y mete ahí el panel "Easy Access".
De lo contrario, pulsando shift varias veces (como en el Prince cuando luchas) se interrumpe todo el sistema para activar "sticky keys".
PARA DESACTIVAR EXTENSIONES, ve a SYSTEM FOLDER, EXTENSIONS, y ahí creas una carpeta llamada DISABLED y metes las extensiones
que quieras deshabilitar.

	ALTERNATIVA 2: INSTALAR SYSTEM 8.1

-Para instalar Mac OS 8.1 (ISO descargada desde https://winworldpc.com/product/mac-os-8/81):
qemu-system-m68k -M q800 -m 32 -bios q800.rom \
-display sdl -audio driver=alsa \
-device scsi-cd,scsi-id=3,drive=cd1  \
-drive file=MacOS8_1.iso,media=cdrom,if=none,id=cd1 \
-device scsi-hd,scsi-id=0,drive=hd0 \
-drive file=system81.img,media=disk,format=raw,if=none,id=hd0

-Una vez arrancado el sistema desde el CDROM de System 8.1, entramos en la carpeta "Utilities" y usamos la herramienta
"Drive setup" para inicializar el disco duro, tras lo cual pinchamos en el icono en el escritorio y le ponemos el nombre que queramos,
y luego ya instalamos el sistema dándole a "Install Mac OS 8.1".  

-Para arrancar el sistema instalado:
qemu-system-m68k -M q800 -m 32 -bios q800.rom \
-display sdl -audio driver=alsa \
-device scsi-hd,scsi-id=0,drive=hd0 \
-drive file=system81.img,media=disk,format=raw,if=none,id=hd0 \
-display sdl,gl=on -full-screen

	ALTERNATIVA 3: INSTALAR SYSTEM 9.2 (ESTO YA ES CON POWERPC, Y POWERPC NO SOPORTA 7.x/8.x)
	(INSTRUCCIONES DE: https://www.emaculation.com/doku.php/ppc-osx-on-qemu-for-osx)

-Para instalar Mac OS 9.2 (ISO descargada desde https://winworldpc.com/product/mac-os-9/92):
-Creamos la imágen de disco duro donde vamos a instalar el sistema:
qemu-img create -f raw system92.img -o preallocation=full 2G
-Arrancamos el sistema para instalar con el CD metido así:
./qemu-system-ppc \
-L pc-bios \
-M mac99,via=pmu \
-m 512 \
-boot d \
-drive file=macos_921_ppc.iso,format=raw,media=cdrom \
-drive file=system92.img,format=raw,media=disk 

	TRANSFERIR ARCHIVOS AL DISCO DE MAC OS

-Instalamos: Si no nos funciona "apt-get install hfsutils" (no parece haber hfsutils en Debian 13),
 nos bajamos la última versión del paquete .deb desde https://debian.stanford.edu/debian/pool/main/h/hfsutils/ y la instalamos a mano con dpkg.
Ahora, montamos la imágen de disco de orígen con:
hmount juego.dsk
Nos dirá qué nombre de volúmen tiene. Quédate con él.
Ahora creamos un directorio temporal donde vamos a meter los datos del juego, y hacemos:
hcopy -m nombre_volúmen_origen:* directorio_temporal_juego/
(El "-m" es FUNDAMENTAL para que no se pierda el resource fork del juego al copiarlo al filesystem de Linux!!!) 
Ahora, desmontamos la imágen de orígen:
humount juego.dsk
Ahora montamos la imágen de destino:
hmount system81.img
Y copiamos los datos del juego al disco de destino:
hcopy -m directorio_temporal_juego/* nombre_volumen_destino: 

NOTA: Se puede usar ctrl-alt-f para salir del modo fullscreen.

******************USAR CORE QEMU LIBRETRO (QEMU-LIBRETRO) PARA EMULAR UN MAC QUADRA 800*****************************************************

-Instalamos dependencias previas:
apt-get install python3-venv flex bison zlib1g-dev

-Clonamos su repo:
git clone --depth 1 --recursive https://git.libretro.com/libretro/qemu-libretro.git

-Configuramos con (sólo soporte para Mac 68k, y OJO!!! NO USES "-march=native -mtune=native" porque la versión resultante no funciona bien):

mkdir b4
cd b4

CFLAGS="-Os -Wno-error -Wno-nested-externs -Wno-redundant-decls" ../configure \
    --target-list=m68k-softmmu \
    --without-default-features \
    --glib=internal \
    --zlib=internal \
    --disable-pie \
    --enable-fdt=internal \
    --disable-modules \
    --disable-plugins \
    --enable-libretro \
    --audio-drv-list=libretro \
    --disable-sdl \
    -Dwrap_mode=forcefallback

make -j$(nproc) libqemu_libretro.so
(OJO!!! ES MUY IMPORTANTE COMPILAR JUSTAMENTE ASÍ PARA EVITAR ERRORES!!! NO HAGAS SIMPLEMENTE "make -j10"!!!)

-Para ejecutarlo:
----Creamos un directorio llamado "quadra800" donde metemos la BIOS (que llamaremos "q800.rom")
    y el disco duro con el sistema y los juegos (que llamaremos "system71.img" y que tienes instrucciones en otra parte
    de este documento de cómo crearlo, instalar el sistema, meterle juegos, etc).
----Creamos un fichero llamado "quadra800.qemu_cmd_line" con el contenido:
qemu-system-m68k -M q800 -m 32 -bios quadra800/q800.rom -device scsi-hd,scsi-id=0,drive=hd0 -drive file=quadra800/system71.img,media=disk,format=raw,if=none,id=hd0
----Lo ejecutamos con:
retroarch -L ~/.config/retroarch/cores/libqemu_libretro.so quadra800.qemu_cmd_line

******************Actualizar a de DEBIAN WHEEZY a DEBIAN JESSIE****************************************************************************

Podemos usar el generador de sources.list que está en http://debgen.simplylinux.ch, o directamente dejar el /etc/apt/sources.list así:

deb http://ftp.es.debian.org/debian testing main contrib non-free
deb-src http://ftp.es.debian.org/debian testing main contrib non-free

deb http://ftp.debian.org/debian/ jessie-updates main contrib non-free
deb-src http://ftp.debian.org/debian/ jessie-updates main contrib non-free

deb http://security.debian.org/ jessie/updates main contrib non-free
deb-src http://security.debian.org/ jessie/updates main contrib non-free

Ahora hacemos sudo apt-get update, apt-get --download-only dist-upgrade, apt-get dist-upgrade. Y cruza los dedos ^_^"

********Instalar DOTNET 472 en WINE***********************************************************************************************************

Creamos un WINEPREFIX de 32bits:

rm -R ~/.wine
WINEARCH=win32 winecfg 

Actualizamos Winetricks a la última versión:

sudo winetricks --self-update

Instalamos:

winetricks dotnet472

********Biblioteca de San José****************************************************************************************************************

La base de datos está en un PC con IP fija (ahora mismo, 192.168.1.128) y se comparte mediante SAMBA. El fichero de configuración de SAMBA en 
el servidor está en /etc/samba/smb.conf
La entrada para servir el biblio, que está al final del smb.conf, es esta:

[biblio]
    comment = Biblio Database
    path = /home/biblioteca/.wine/drive_c/Biblio
    browsable = yes
    guest ok = yes
    read only = no

En los clientes, el directorio compartido se monta mediante un script en el directorio .wine/drive_c/Biblio/bibio.sh, que contiene un directorio "fakebase"
donde se montará el directorio completo de Biblio del servidor (Biblio por tanto NO se instala en los clientes sino que se ejecuta la misma copia
del servidor, locamente).
Dicho script, biblio.sh, tiene el siguiente contenido:

#!/bin/bash
set -o noclobber
sudo mount -t cifs -o username=biblioteca,password=giner //192.168.1.128/biblio fakebase/
cd ~/.wine/drive_c/Biblio/
wine ./Biblio.exe

El acceso directo del escritorio tiene este contenido:

[Desktop Entry]
Name=Biblio
Exec=sh /home/pikar/.wine/drive_c/Biblio/biblio.sh
Type=Application
Comment=Biblio
Path=/home/pikar/.wine/drive_c/Biblio
Icon=accessories-dictionary
Terminal=false
StartupNotify=false 

El usuario/contraseña del servidor es biblioteca/giner, y se puede entrar por ssh.

*********ARRANCAR A LA SHELL DE EFI***************************************************************************************************

OPCIÓN 1: LANZAR UN .EFI DESDE GRUB2

Consiste básicamente en añadir un menuentry en GRUB2 que nos lance el .efi que queramos.

-Bajamos la EFI shell desde: https://github.com/tianocore/edk2/tree/UDK2018/ShellBinPkg/UefiShell/X64).
 Desde Linux, suponiendo que Debian monta la partición EFI en /boot/efi, la metemos en /boot/efi/EFI/debian/Shell.efi
-Editamos /etc/default/grub, y nos aseguramos de que "GRUB_TIMEOUT" esté puesto a algo que no sea 0,
porque si es 0, no veremos el menú de arranque.
-Editamos /etc/grub.d/40_custom y añadimos al final del archivo la entrada custom que queramos.
 (Como la partición EFI está montada en /boot/efi, pasamos la ruta del archivo a partir de /boot/efi. 
  Podemos averiguar la UUID de la partición EFI con: blkid /dev/nvme0n1p1).
 
menuentry "Chainload EFI shell" {                                                                                                                
  insmod part_gpt                                                                                                                                
  insmod fat                                                                                                                                     
  search --no-floppy --fs-uuid --set=root 0CE3-98FA                                                                                              
  chainloader /EFI/debian/Shell.efi                                                                                                              
}
 
OPCIÓN 2: ARRANCAR UN .EFI DESDE UN PENDRIVE USB

Formateamos un pincho USB en FAT32. Creamos en él un directorio /efi/boot/, y metemos allí el .efi que queramos, renombrándolo a BOOTX64.efi
Reiniciamos y entramos en la BIOS, y establecemos ese disco como disco de arranque. Y ya debería ir.

NAVEGAR POR EL EFI SHELL Y EJECUTAR COSAS

Miramos las unidades disponibles con "map".
Cambiamos a la unidad desde la que hemos arrancado con "FS0:", y allí podemos ir navegando por el sistema de archivos con "cd" y "dir",
estilo DOS. Podemos ejecutar el .efi que queramos simplemente escribiendo su nombre.

*********Actualizar la BIOS de un N100 desde GNU/Linux***************************************************************************************

Normalmente se usa una utilidad de Intel llamada "Intel FPT", con versión para Windows, Linux y EFI. Pero no he encontrado una versión
lo suficientemente reciente como para que soporte el N100, así que usamos el programa de GNU/Linux "flashrom".

-Nos bajamos la última BIOS, que vendrá con un .bin que es lo que nos interesa.
 En el caso de este N100, la última BIOS estaba en: https://theminixforum.com/index.php?threads/neo-z100-0db-beta-version-of-bios-ad0j0181.6860/
 
-Instalamos flashrom: sudo apt-get install flashrom

-Averiguamos qué chip de flash BIOS tenemos con: flashrom --programmer internal
 Ahí vemos que nuestro chip de flash se llama "Opaque flash chip"  

-Sacamos una copia de seguridad de la BIOS por si falla algo:
 flashrom --programmer internal -c "Opaque flash chip" -r bios_flash_backup.bin 

-Flasheamos la nueva BIOS con:
flashrom --programmer internal -c "Opaque flash chip" -w AD0J0181.bin

Y cuando acabe, podemos reiniciar. En el primer arranque tarda un poco: no te asustes.

ALTERNATIVA: ARRANCANDO UN PROGRAMA FLASHEADOR DESDE LA EFI

Tienes un archivo llamado "MINIX NEO Z100-0dB AD0J0181 20240308.zip" en el disco duro de backup y en el correo.
-Formateamos un pen en FAT32 y copiamos todos los archivos allí.
-Encendemos el ordenador y le damos a F11
-Elegimos la opción "UEFI" y le damos a INTRO. Ya deberíamos estar en el EFI shell (si no, tienes apuntes a parte para arrancar al EFI shell
 en este mismo documento).
-Introducimos FS3:, luego ls, y empezamos a flashear con: AfuEfix64.efi AD0J0181.bin /p /b /n /x
 Al acabar, reiniciamos el ordenador y ya está.

*********Túnel SSH***************************************************************************************************************************

ssh manuel@108.15.38.135 -L 5900:127.0.0.1:5900 -N

**********Hago un blacklist a un módulo pero sigue cargando************************************************************************************

Tienes que poner "blacklist <nombre_módulo>" en /etc/modprobe.d/blacklist.conf

Y luego, hacer un:

sudo update-initramfs -u


**********Establecer un modo de video físico en el arranque en sistemas con KMS****************************************************************

Habría que pasarle una línea de este estilo al kernel:

video=HDMI-A-1:1360x768@60

En la Raspberry Pi, eso se añadiría a cmdline.txt (antes se hacía con parámetros hdmi_* en config.txt, pero esos parámetros
son ignorados en modo KMS).

**********Cuestiones de modo de vídeo en plataformas con KMS (IFC6413, etc)********************************************************************

Miramos cual es el conector activo, mirando en
/sys/class/drm/card0-*
cuál tiene "connected" en el status. 

Editamos /etc/default/grub, añadimos lo que nos interese de estas cosas a la linea de los parámetros del kernel, por ejemplos:

video="HDMI-A-1:800x600"  

video=DVI-I-1:1024x768@60

y luego hacemos un update-grub.

Información completa en:
http://nouveau.freedesktop.org/wiki/KernelModeSetting/

Comprobar resolción y movidas:
/sys/devices/platform/omapdrm.0/drm/card0

Para quitar el salvapantallas a negro:
consoleblank=0 (en el boot.scr, claro)

**********Deshabilitar el polling de KMS, que causa parpadeos y movidas en ciertos sistemas***************************************************

En :
/etc/modprobe.d/modprobe.conf:
Añadimos:
options drm_kms_helper poll=0

**********Notas instalación DEBIAN************************************************************************************************************

--Nos puede pedir firmware para hardware de red cuyo firm es non-free. Nos bajamos el archivo "firmware-ralink_0.28+squeeze1_all.deb" o el que sea que
necesitemos, pero NO nos bajamos otra ISO para esto, se hace desde un pequeño DEB, lo descomprimimos con:

ar vx mypackage.deb
tar xvzpf data.tar.gz

y mandamos los .bin al directorio raíz de un pendrive, tal cual, los .bin tirados ahí.
Y ya lo debería de detectar la instalación cuando nos pide un "removable media" con el firmware que le falta.

--Le ponemos una IP fija editando /etc/networks/interfaces y dejándo exactamente así:

auto lo eth0

iface lo inet loopback
#iface eth0 inet dhcp

iface eth0 inet static
address 192.168.5.9
netmask 255.255.255.0
gateway 192.168.5.7

Ya deberíamos poder hacer ping al equipo servidor (el portátil).
Sin embargo, nos faltaría ponerle algunos servidores dns en resolv.conf:

nameserver 208.67.222.222 
nameserver 8.8.8.8

--Deshabilitamos el MTA (Mail Transport Agent):

insserv -r exim4

---ANTES de poder instalar ningún paquete, tenemos que poner a punto el /etc/sources.list. Si no, nos pedirá el CD ROM de netinstall!
Tenemos que dejar el sources.list más o menos así:

deb http://http.debian.net/debian wheezy main
deb-src http://http.debian.net/debian wheezy main

deb http://http.debian.net/debian wheezy-updates main
deb-src http://http.debian.net/debian wheezy-updates main

deb http://security.debian.org/ wheezy/updates main
deb-src http://security.debian.org/ wheezy/updates main

y a continuación hacer un apt-get update y si queremos un apt-get upgrade. Tras eso, ya ponemos empezar a instalar paquetes.
Instalamos sudo, añadimos el usuario a la lista de sudoers. Para ello, como root hacemos:

visudo -f /etc/sudoers

y bajo la línea
root    ALL=(ALL) ALL

añadimos 
manuel   ALL=(ALL) ALL

Y abajo del todo del fichero, añadimos:

manuel ALL = NOPASSWD : ALL

Salvamos y listo.

Quitamos el IPV6:

echo 'blacklist ipv6' >> /etc/modprobe.d/blacklist

Instalamos los buil-essential:

sudo apt-get install build-essential


Ahora ya sigue la guía rápida de configuración de raspbian, porque es todo igual. 

**********Sustituir todas las ocurrencias de una cadena por otra en un directorio*******************************************************************

find ./ -type f -exec sed -i 's/apple/orange/g' {} \;

Y si simplemente queremos borrar una línea que contenga cierta cadena, sed '/pattern to match/d'

Para aplicarlo sobre un fichero:

sed -i 's/apple/orange/' <nombre_archivo>

**********Formatear FAT32 con tamaño de cluster a 32K******************************************************************************************

sudo mkfs.msdos -s 64 /dev/sdb1

ya que el tamaño de bloque es de 512bytes y -s expresa el tamaño de un sector (cluster) en bloques.

**********Seleccionar columnas en VIM*********************************************************************************************************

Esto es la hostia. Usa CTRL+V para entrar en VISUAL BLOCK MODE y seleccionar columnas. Ya las puedes borrar o hacer lo que quieras con ellas.

**********Search and replace (buscar y sustituir) en VIM******************************************************************************************

Se hace con el comando:
:%s/cadena_original/nueva_cadena/g

Y si la cadena que buscas o por la que sustituyes lleva un punto, como es un caracter especial que significa "cualquier caracter", tienes que "escaparlo", o sea,
poner un backslash antes. Por ejemplo, si quieres sustituir la cadena 1.0f por 0.5f, harías:

:%s/1\.0f/0\.5f/g

Para confirmar cada ocurrencia, usamos gc en lugar de g:
:%s/cadena_original/nueva_cadena/gc

**********Desactivar números de línea en vim****************************************************************************************************

:set nu!

**********Secuencia de debugeo rápido mediante logs*******************************************************************************************
FILE *fp;
fp = fopen("SDL_log.txt","w");
fprintf (fp,"\nSetColors() Función completada con éxito!!\n");
fclose (fp);

**********Crear un parche para que la gente pueda aplicar nuestros cambios sobre sources originales************************************************

Lo primero es conseguir el directorio con los sources originales.

Ahora, comprobamos qué ficheros están solo en los sources modificados, y qué ficheros, estando en ambos, han cambiado. Para ello hacemos:

diff -rq originales modificados

Ahora, sabiendo eso, es muy fácil saber qué ficheros borrar, es decir, los que no nos interesa que se incluyan en el parche,
tales como los generados por los buildsystems, ya que habremos estado haciendo pruebas y compilando mientras desarrollábamos.
Una vez eliminado lo que sobra, ya sí, sacamos el parche:

diff -rupN originales modificados > parche.patch

Como ves, es muy sencillo!

El parche que hemos generado, se debería poder aplicar simplemente copiándolo en el raíz de los sources originales y haciendo un
patch -p1 < parche.patch

APÉNDICE: Si sólo queremos crear un parche para un archivo (que es algo menos común):

diff -u original.c modificado.c > parche.patch

**********Parchear el kernel y el scummvm*******************************************************************************************************

Ponemos el parche en el directorio raiz de los sources, y hacemos

patch -p1 < parche.diff

Y para revertir los cambios, hacemos:

patch -R -p1 < parche.diff

**********Usar FIND correctamente**************************************************************************************************************

find . -name 'openmsx'

***********ERRROR: Programa no encuentra librería en tiempo de ejecución, pero sí la encuentra en tiempo de linkado (no hay undefined symbols)******

LO PRIMERO es hacer un ldd al ejecutable y confirmar que dicha librería aparece como NOT FOUND.
Esto es porque, aunque le pases con -L<ruta> la librería que quieres que encuentre en linkado, para que la encuentre en tiempo de ejecución necesitarías
pasarle "-Wl,-rpath,<ruta>".
Aunque lo normal es que no tengas que hacer esto tampoco, sino que la librería esté en una ubicación donde el sistema busque por defecto.
Para asegurarnos de esto, hacemos "ldconfig --verbose", y se actualizarán los directorios donde se buscan las librerias que usan los programas.
Así que si has instalado una librería pero no la encuentra un programa en tiempo de ejecuciçon, puedes pasarle el -rpath o hacer un ldconfig y listo.

***********ACCEDER A ESCRITORIO REMOTO POR VNC USANDO TIGHTVNC**************************************************************************

Se usa tightvnc porque es el cliente más ligero.
Se ha seguido este tutorial: https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-ubuntu-20-04-es

				---EN EL SERVIDOR---

Instalamos tightvnc server:
sudo apt-get install tightvncserver

Lo ejecutamos por primera vez. Nos pedirá un user/pass y un user para mirar solamente. Del user para mirar pasamos.
vncserver

Podemos levantar varios servers a la vez en el mismo ordenador, ejecutando vncserver varias veces.
Y luego podemos matarlos con:
vncserver -kill :1
vncserver -kill :2
vncserver -kill :3
..etc

Bueno, pues ahora ya podríamos conectarnos a las X remotamente, pero serían las X sin nada y no podríamos hacer nada de nada.
Así que tenemos que decirle al servidor vnc que ejecute unos comandos que lancen el escritorio en sí cuando nosotros lanzamos el servidor.
Así que matamos el servidor:
vncserver -kill :1
Hacemos una copia de seguridad de la secuencia de comandos que ejecuta el servidor al inicio:
mv ~/.vnc/xstartup ~/.vnc/xstartup.bak
Y creamos un nuevo fichero de secuencia de comandos del servidor vnc:
vim ~/.vnc/xstartup
Con el contenido (específico de lxqt, otros escritorios requerirán otras cosas):

!/bin/sh
# Uncomment the following two lines for normal desktop:
unset SESSION_MANAGER
#exec /etc/X11/xinit/xinitrc
exec openbox-session &
exec startlxqt &

Y ahora lanzamos el servidor otra vez:
vncserver

HEMOS DE SABER que el servidor vnc escucha en el puerto 5901, si lanzas otro servidor escuchará en 5902, el siguiente en 5903...
Puedes confirmarlo con netstat -pl, y ahí ves en qué puertos hay servidores vnc escuchando en la máquina.

					---EN EL CLIENTE---

Instalamos el vncviewer:

sudo apt-get install xtightvncviewer

Y ya podemos conectar al servidor con:

vncviewer <IP LOCAL>:PUERTO

Por ejemplo, si el servidor está en la 0.30 de rango local y tiene un servidor vnc escuchando en el 5901, conectamos con:

vncviewer 192.168.0.30:5901

					---CONECTAR A TRAVÉS DE UN TÚNEL SSH---
					
Una vez que tenemos el servidor VNC corriendo en el ordenador servidor, podemos mandar el tráfico de ese servidor a través de un túnel SSH:

ssh -L 59000:localhost:5901 -C -N -l <USUARIO> <IP DEL SERVIDOR>

El puerto 59000 es arbitrario: puedes poner el que te de la gana (que no tenga un servicio usándolo, claro).

En teoría, esto debeía permitir que el servidor salga a internet por un puerto abierto, para poder acceder remotamente a la máquina.
Pero eso lo dejo para más adelante. 

***********Montar un DSK de Mac antiguo, o un ADF de Amiga******************************************************************************

Para el DSK de MAC antiguo:

sudo mount -o loop disc_image.dsk directorio_montaje

Y para el ADF de Amiga:

sudo mount -t affs -o loop disc_image.adf directorio_montaje

Y para covertir un fichero de texto de MAC antiguo a Linux:

tr '\r' '\n' < macfile.txt > unixfile.txt

Y el proceso contrario:

tr '\n' '\r' < unixfile.txt > macfile.txt

***********Editar el AUTOEXEC.BAT de MSX en Linux**************************************************************************************

Se puede editar como cualquier otro fichero, pero debes guardarlo en formato DOS antes de salir, así:
:set ff=dos
:wq

***********Montar un archivo .toast de MAC***********************************************************************************************

mount -o loop -t hfsplus imagename.toast [mount point]

Y si da error prueba con hfs en lugar de hfsplus.

También sirve para montar img de diskettes de mac.

***********Quitar un servicio que no sabemos quién lo lanza********************************************************************************

Has mirado en /etc/init.d y has intentado que no se lance el script de inicio de un servicio: lo has intentado con
sudo update-rc.d -f <servicio> remove
Pero ahí sigue si haces un TOP.
Pues puedes hacer dos cosas: o desinstalas el paquete al que pertenece el servicio, o desactivas el servicio que a su vez lo está lanzando.
Y esto lo puedes hacer con un grep a todo lo de /etc/init.d, con el nombre del servicio.

***********CONEXIÓN SSH LENTA*************************************************************************************************************

Edita /etc/ssh/sshd_config y descomenta la línea "UseDNS no"

***********OTRAS NOTAS DE CONFIGURACION DE RASPEBBRY PI OS 11 (BULLSEYE)******************************************************************

-Ponemos la fuente de la consola: dpkg-reconfigure console-setup
-Ponemos los LOCALES con: dpkg-reconfigure locales. Elegimos que se generen en_US.UTF8 y es_ES.UTF, y dejamos puesto en_US.UTF8.
ESTO nos quita errores de teclado a través de SSH, ya que necesitamos los LOCALES de la máquina cliente también.
Otra manera más sencilla de evitar esos errores por SSH es editar /etc/ssh/sshd_config y comentar:
	# Allow client to pass locale environment variables
	# AcceptEnv LANG LC_*
Si lo haces así no necesitas regenerar es_ES.utf8, con en_US.utf8 vale.

-Ponemos el idioma del teclado con raspi-config, y expandimos el filesystem, overclocking y demás movidas. El layout del teclado no se cambia hasta reboot.

-Evitamos que se nos ponga la consola en negro poniendo esto en /boot/cmdline.txt:
consoleblank=0
-Para especificar el polling rate de los joysticks, para quitar latencia, con usbhid.jspoll=<polling rate>. Míratelo para entonces y añádelo.
 usbhid.jspoll=1 es un buen valor, resultando en 1000Hz de polling rate... lo que ya está muy bien.
 Se puede comprobar una vez arrancado el sistema con evhz, un programa que se baja de aquí: git clone --depth 1 https://gitlab.com/iankelling/evhz
RECUERDA que tienes que poder PRIMERO quiet, y luego loglevel: EN ESE PRECISO ÓRDEN, o el valor de loglevel será IGNORADO. Tengo cmdline.txt así:
dwc_otg.lpm_enable=0 smsc95xx.turbo_mode=N console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=noop rootwait consoleblank=0 quiet loglevel=3 fastboot logo.nologo noswap

-Si tras reiniciar no podemos entrar por ssh es porque se han perdido las keys. Lo confirmamos con systemctl status ssh y vemos que no puede leer 
un archivo de claves. Para solucionarlo, las regeneramos. Hacemos:
sudo /usr/bin/ssh-keygen -A

-Repasamos los servicios activos. Podemos ver tooodas las units y su estado con:
	systemctl list-unit-files

-Desactivamos IPV6. Esto hay que hacerlo como root, así que primero establecemos una clave de root, que aún no la tenemos:
sudo passwd
su
echo 'blacklist ipv6' >> /etc/modprobe.d/blacklist
sed -i '/::/s%^%#%g' /etc/hosts

-Evitamos que se cargue el módulo de IPV6 añadiendo esto al principio de /etc/modprobe.d/ipv6.conf :
install ipv6 /bin/true
(Si te suena raro, es un fake install: como es un módulo cargado por el kernel, tenemos que hacerle creer que se carga, pero no).
Y ahora para acabar con IPV6 del todo hacemos : 
sudo sed -i '/::/s%^%#%g' /etc/hosts
-Hacemos lo mismo con otro módulo que no usamos, metiendo en /etc/modprobe.d/bcm2835_gpiomem.conf :
install bcm2835_gpiomem /bin/true
-Los módulos que necesitamos a parte de los del kernel los cargamos nosotros a mano. Sólo nos hace falta el del chip de audio. Para ello:
sudo systemctl mask systemd-modules-load
Y añadimos a rc.local:
modprobe snd_bcm2835

-Si queremos dejar que systemd gestione la carga de módulos (es lo último que suelo venir haciendo) pero queremos quitar el módulo uio y el uio_noséqué, creamos el fichero:
/etc/modprobe.d/uio_pdrv_genirq.conf
Con el contenido
blacklist uio_pdrv_genirq
Y hacemos
depmod -ae
update-initramfs -u
Reiniciamos y ya no debería estar.

También creamos /etc/modprobe.d/bcm2835_wdt.conf con el contenido:
blacklist bcm2835_wdt
Y hacemos
depmod -ae
update-initramfs -u
Reiniciamos y ya no debería estar.

-Borramos /etc/motd
-Para quitar el lastlogin, el motd, etc... editamos sudo vim /etc/pam.d/login y comentamos las líneas:
#session    optional     pam_motd.so  motd=/run/motd.dynamic
#session    optional     pam_motd.so noupdate
#session    optional     pam_mail.so standard noenv # [1]
-Para hacer lo mismo para cuando nos conectamos por ssh, editamos sudo vim /etc/pam.d/sshd y comentamos las líneas:
#session    optional     pam_motd.so  motd=/run/motd.dynamic
#session    optional     pam_motd.so noupdate
#session    optional     pam_mail.so standard noenv # [1]

En este mismo fichero, puedes quitar otros mensajes del login, como la versión del kernel y tal.
Para ello comenta las dos líneas siguientes a esta de lastlog.
-Para quitar el delay de login editamos /etc/pam.d/common-auth y añadimos a la línea de pam_unix el "nodelay",
 dejando la línea de pam_unix.so así:
auth        required      pam_unix.so nodelay
-Para quitar la frase donde dice la versión de DEBIAN y tal, borra /etc/issue o pon allí lo que quieras que salga.

-En config.txt desactivamos el watchdog:
dtparam=watchdog=off

************Acutualizar el kernel de la Raspberry Pi sin tener las herramientas de broadcom***************************************

Porque claro, eliminaste las mierdas binarias cerradas de broadcom con sudo apt-get purge libraspberrypi*
Así que esto debería de todos modos actualizar el kernel.

sudo apt-get update
sudo apt-get full-upgrade

************Actualizar la eeprom de la raspberry Pi 4 sin tener las herramientas de broadcom**************************************

Las instalas, actualizas y desinstalas.
sudo apt-get install rpi-eeprom
(Se instalan las libraspberrypi como dependencias).
sudo rpi-eeprom-update
(Volvemos a borrar las libraspberrypi....)
sudo apt-get purge libraspberrypi*

***********Scrips para levantar la red ETHERNET y la red WIFI manualmente****************************************************************

Ya no "se lleva" levantar la red ethernet desde rc.local, se hace cuando se va a usar:
En rc.local tendrás:

echo 1-1.1:1.0 > /sys/bus/usb/drivers/smsc95xx/unbind

...para que el sistema arranque con la ethernet desasctivada.

===bin/eth0-on===

sudo sh -c 'echo 1-1.1:1.0 > /sys/bus/usb/drivers/smsc95xx/bind'
sudo ifconfig eth0 up
sudo ip addr add 192.168.5.8/24 dev eth0
sudo ip route add default via 192.168.5.7
sudo /etc/init.d/dropbear start

===bin/eth0-off===

sudo /etc/init.d/dropbear stop
sudo ifconfig eth0 down
sudo sh -c 'echo 1-1.1:1.0 > /sys/bus/usb/drivers/smsc95xx/unbind'

===bin/wifi-on===

sudo ifconfig eth0 down
sudo modprobe brcmfmac
sudo ifconfig wlan0 up

sudo wpa_supplicant -d -Dnl80211 -iwlan0 -c/etc/wpa_supplicant/wpa_supplicant.conf -B

sudo ip addr add 192.168.1.12/24 dev wlan0
sudo ip route add default via 192.168.1.1
sudo /etc/init.d/dropbear start

(Los detalles sobre el fichero wpa_supplican.conf están en otra sección de este mismo documento donde explico cómo
gestionar la wifi a mano)

===bin/wifi-on, pero con DHCP en vez de IP estática===

sudo ifconfig eth0 down
sudo modprobe brcmfmac
sudo ifconfig wlan0 up

sudo wpa_supplicant -d -Dnl80211 -iwlan0 -c/etc/wpa_supplicant/wpa_supplicant.conf -B

sudo dhclient wlan0

sudo /etc/init.d/dropbear start

===bin/wifi-off===

sudo killall wpa_supplicant
sudo ifconfig wlan0 down
sudo rmmod brcmfmac
sudo /etc/init.d/dropbear stop

***********Hacer un volcado de un disco abarcando sólo el espacio usado por las particiones***********************************************

Miramos con FDISK dónde acaba la última partición, y el tamaño de unidad:

sudo fdisk -l /dev/sdb

Disk /dev/sdb: 58 GiB, 62277025792 bytes, 121634816 sectors
Disk model: Card  Reader    
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x4f2a38d0

Device     Boot  Start     End Sectors  Size Id Type
/dev/sdb1         8192  532479  524288  256M  c W95 FAT32 (LBA)
/dev/sdb2       532480 8519679 7987200  3,8G 83 Linux

AHÍ VEMOS que UNITS es: 512 bytes
AHÍ VEMOS que LA ÚLTIMA PARTICIÓN ACABA EN 8519679
PUES BIEN: A DD LE PASAMOS EL TAMAÑO DE UNIDAD (512) Y EL NÚMERO DE UNIDADES (LE SUMAMOS 1 A 8519679, Y NOS QUEDA 8519680) Y TEMEMOS:

sudo dd if=/dev/sdb of=dump.img bs=512 count=8519680 status=progress

Y ya tenemos nuestro volcado, que ocupa lo que ocupan las particiones, sin volcar el espacio extra al final del disco.

***********Extraer una partición de un IMG que contiene la imágen de un disco completo****************************************************

Fácil. Con fdisk vemos dónde empieza y cuánto mide la partición que queremos (en sectores nos lo da directamente, que es lo que nos interesa):
sudo fdisk -l Downloads/MSX3_sd.img

Device               			                   Start    End            Sectors       Size      Id Type
Downloads/MSX3_sd.img          					   2048     1982463        1980416       967M      e W95 FAT16 (LBA)

Vemos que sólo tiene una partición, que empieza en el sector 2048 y ocupa 1982563 sectores. Con eso ya ponemos hacer:
dd if=Downloads/MSX3_sd.img of=fat16_partition.img skip=2048 count=1980416

Puedes montar el resultado para ver si te deja y está todo bien:
sudo mount -o loop fat16_partition.img /mn/hdd

Ahora, podrías volcar esa partición a otro disco, empezando en el sector 2048 como en el disco original, con:
sudo dd if=fat16_partition.img of=/dev/sdb seek=2048
PERO ESO NO TENDRÍA SENTIDO, PORQUE NO SE VERÍA LA PARTICIÓN: TEN EN CUENTA QUE TIENES QUE CREAR LA PARTICIÓN ANTES, PARA QUE SE GUARDE EN LA
TABLA DE PARTICIONES, YA QUE AL VOLCAR LA PARTICIÓN SOLAMENTE NO QUEDA GUARDADA EN LA TABLA Y ES INVISIBLE!

Efectivamente, seek sirve para posicionarse en un sector del disco de salida, igual que skip nos sirvió para lo mismo en el disco de entrada.
Se podría haber hecho todo en el mismo comando combinando seek y skip, ambos a 2048 en el ejemplo:

dd if=Downloads/MSX3_sd.img of=/dev/sdb skip=2048 seek=2048 count=1980416

***********Montar una partición individual de una imágen completa de disco***************************************************************

RECUERDA: CUANDO SAQUES UNA IMÁGEN DE UNA SD COMPLETA, TODAS SUS PARTICIONES DEBEN ESTAR DESMONTADAS ANTES DE HACER LA IMÁGEN,
O LUEGO NO PODRÁS MONTAR LAS PARTICIONES DE LA IMÁGEN RESULTANTE.

Con parted vemos dónde empieza cada partición. Tenemos que verlo en bytes:

manuel@vader:~$ parted rpi_bck.img
(parted) unit                                                             
Unit?  [compact]? B                                                       
(parted) print                                                            
Model:  (file)
Disk /home/manuel/rpi_bck.img: 7948206080B
Sector size (logical/physical): 512B/512B
Partition Table: msdos

Number  Start      End          Size         Type     File system  Flags
 1      4194304B   67108863B    62914560B    primary  fat16        lba
 2      67108864B  7948206079B  7881097216B  primary  ext4

Ya tenemos la información que necesitamos, que es el offset de la segunda partición, que es la que queremos montar. Ahora simplemente hacemos:

sudo mount -o loop,rw,offset=67108864 rpi_bck.img /mnt/hdd

Y listo!!

Para raspbian más reciente:

sudo mount -o loop,rw,offset=70254592 raspbian_AUG2016.img /mnt/hdd

***********Montar una partición AMIGA dentro de una imágen RDB, o sea, un disco completo con cabecera RDB y una o varias particiones*****

Este es el tipo de HDF que se usa, por ejemplo, en el Minimig y demás implementaciones en FPGA. Es lo mismo casi que montar cualquier otra
partición que está dentro de una imágen completa de disco.
Recurrimos a parted para pillar el offset (primer valor) y el size (último valor):

manuel@vader:~$ parted /media/manuel/MINIMIG_V1/hdf_sys31.hdf 
WARNING: You are not superuser.  Watch out for permissions.
GNU Parted 3.2
Using /media/manuel/MINIMIG_V1/hdf_sys31.hdf
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) unit
Unit?  [compact]? B                                                       
(parted) print                                                            
Pralloc = 0, Reserved = 2, blocksize = 1, root block at 737478
Model:  (file)
Disk /media/manuel/MINIMIG_V1/hdf_sys31.hdf: 754974720B
Sector size (logical/physical): 512B/512B
Partition Table: amiga
Disk Flags: 

Number  Start            End                        Size                       File system        Name           Flags
1       258048B          754919423B                 754661376B                 affs1              DH0            boot

Ahora simplemente montamos con ambos parámetros y ¡funciona!

sudo mount -t affs -o loop,rw,offset=258048,sizelimit=754661376 /media/manuel/E94A-DA9D/amiga/hdf_sys31.hdf /mnt/hdd

Y para montar la imágen del disco laserdisc.hdf donde tienes los juegos de EAROK:
sudo mount -o loop,rw,offset=258048,sizelimit=1073479680 -t affs /media/manuel/E94A-DA9D/amiga/laserdisc.hdf /mnt/hdd

***********Montar una partición HFS dentro de una imágen completa de las que usa el core FPGA MACPLus************************************

La imágen que uso es la de 100MB de aquí: http://www.savagetaylor.com/downloads/
(Aunque ponga que es de IOMEGA Zip funciona perfectamente)

Como el Mini VMAC no funciona con imágenes en las que la partición HFS empieza con un offset, la extraemos primero tirando de la info de parted:

dd if=OS_608_100MB.vhd of=OS_608_100MB_HFS.vhd skip=49152 count=94306304 iflag=skip_bytes,count_bytes

Hacemos lo que sea y la volvemos a meter:

dd if=OS_608_100MB_HFS.vhd of=OS_608_100MB.vhd seek=49152 count=94306304 iflag=count_bytes oflag=seek_bytes

***********Encoger una partición de una imágen de disco***********************************************************************************

No es simplemente acceder con parted: se tiene que operar sobre un loop para esa imágen.

Pedimos el loop (siempre que loop0 esté libre, sino tenemos que pedir uno libre antes con sudo losetup -f o usar otro de los de /dev. Mira con df 
cuáles no aparecen y por tanto están libres):

sudo losetup /dev/loop0 myimage.img
sudo partprobe /dev/loop0

Ahora mira que tengas /dev/loop0p1, /dev/loop0p2, etc...

Y ya puedes hacer: 

sudo gparted /dev/loop0

...y te dejará encoger particiones EXT4 y demás.

***********Recortar una imágen de disco (tarjeta) para que no ocupe lo mismo que tiene como capacidad el dispositivo de donde se leyó*******

Lo primero es hacerle un fdisk -l a la imágen:

manuel@vader:~$ fdisk -l raspbian_RetroArch.img 

Disk raspbian_RetroArch.img: 7948 MB, 7948206080 bytes
255 heads, 63 sectors/track, 966 cylinders, total 15523840 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x0002c262

Device                                                   Boot                          Start         End              Blocks          Id            System
raspbian_RetroArch.img1                                             8192         122879       57344            c              W95 FAT32 (LBA)
raspbian_RetroArch.img2                                            122880     4218879     2048000     83            Linux

De aquí sacamos lo siguiente: que cada sector es de 512 bytes, y que la segunda partición acaba en el sector o bloque número 4218879.
Así que realmente sólo estamos 4218879 + 1 sectores (ya que el sector 0 obviamente existe).
Hacemos:

manuel@vader:~$ sudo truncate --size=$[(4218879+1)*512] raspbian_RetroArch.img

Y listo!

***********Extraer la pista de datos (ISO) y las pistas de audio de una imágen de CD en formato CloneCD (CCD+IMG+SUB)*********************

-Convierte el ccd a un CUE:
ccd2cue -i foo.img -o foo.cue foo.ccd

-Extrae las pistas de datos y audio con bchunck:
bchunk -w tomb.img tomb.cue track
(ojo que en el tomb raider las pistas de audio empiezan por track_, no por track, así que tendrías que poner track_ para que se llamasen como deben)

-La ISO de la primera pista la puedes montar y extraer sus archivos sin problemas

-Y ahora, puedes convertir todos los WAV del directorio a OGG y a MP3 con esto:
for f in *.wav; do ffmpeg -i "$f" -c:a libmp3lame -q:a 2 "${f/%wav/mp3}" -c:a libvorbis -q:a 4 "${f/%wav/ogg}"; done

-O sólo a OGG:
for f in *.wav; do ffmpeg -i "$f" -c:a libvorbis -q:a 4 "${f/%wav/ogg}"; done

***********CONVERTIR TODOS LOS FICHEROS DE UN DIRECTORIO DE PNG A JPG CON LA MÁXIMA CALIDAD********************************************

for i in *.png ; do ffmpeg -i "$i" -q:v 1 "${i%.*}.jpg" ; done

***********CONVERTIR TODOS LOS FICHEROS DE UN DIRECTORIO DE WAV A FLAC*****************************************************************

Instalamos el paquete SOX:

sudo apt-get install sox

Convertimos:

for i in *.wav; do sox "$i" "${i%.*}.flac"; done

***********OpenLara, versión opensource del Tomb Raider********************************************************************************

PUEDES BAJARTE LOS DATOS DEL JUEGO SIMPLEMENTE DE:
http://xproger.info/projects/OpenLara/files/
...Y los pones donde tengas el ejecutable, y ya.
O te puedes complicar la vida con los siguientes consejos:

-Para extraer los archivos del juego, usa ISOBUSTER y extraelos en modo RAW!! (Esto es muy importante o los vídeos sonarán mal)
-Copia los directorios PSXDATA, DELDATA y FMV al directorio donde tengas el ejecutable.
-Las pistas de audio van en audio/1/_track*.ogg

***********ERROR: DISTCC no distribuye la compilación y no sé por qué, con otros proyectos sí lo hace****************************************

Posiblemente el Makefile está poniendo como compilador el cc.
Lo que compila con cc siempre puede compilar con gcc.
Así que la solución es MUY sencilla: nos vamos al directorio donde tenemos los tools del servidor para cross compiling, o sea, los binarios
(~/raspberrypi/tools.../bin) y hacemos "ln -s gcc cc".
Arreglado!

***********Compilación distribuida con distcc********************************************************************************************

ESTA PRIMERA OPCIÓN NO ES RECOMENDADA PARA LA PI!! Es más sencillo usar el cross compilador oficial y además tanto uno como otro tienen problemas
porque no soporta multiarch y no buscan los scripts .so para LD, librerías y haders donde deben, pero al menos al usar el oficial no tengo que pegarme con
la construcción del crosscompiler, y además ahora el crosscompiler oficial ya no produce binarios más lentos ni nada de eso.

PARTE 1-OPCIÓN A: CONSTRUYENDO NUESTRO PROPIO CROSS-COMPILER (NO recomendada en Octubre de 2015 porque podemos usar el cross-compilador oficial)
===============================================================
Empezamos en el servidor. 
Lo primero es tener la herramienta que nos permite a su ver crear el compilador cruzado. Para ello, clonamos el repo de github:
git clone --depth 1 https://github.com/crosstool-ng/crosstool-ng.git

Instalamos algunas cosas antes: gperf, flex, bison, libtool, libtool-bin, gawk, texinfo, libncurses5-dev, help2man...

Hacemos: bootstrap, configure, make, sudo make install
Ya deberíamos tener el comando ct-ng.
Ahora nos creamos ~/cross-rasp y entramos en él. 

Creamos nuestro propio .config desde cero con "ct-ng menuconfig", para ello, seguimos estas instrucciones:
http://elinux.org/RPi_Linaro_GCC_Compilation#Build_GCC_Linaro
Las adaptamos, eso sí, a la versión de EGLIBC y de las BINUTILS que tengamos. Tampoco elijas un compilador muy nuevo... un linaro 4.7 para la Pi1 está bien.
-Para la versión de BINUTILS, hacemos ld -v
-Para la versión de EGLIBC, hacemos ldd --version
-Pon el Number of Parallel jobs a 6 si estás en el PC de 4 cores.
-Si tienes los ficheros crt*.o (y otras librerías, como el script para LD libc.so) del sysroot de la raspberry pi en /opt/rpi_root/usr/lib/arm-linux-gnueabihf, 
 pues probablemente al pasarle --sysroot=/opt/rpi_root al compilador acabe buscando estas cosas en /opt/rpi_root/usr/lib y no las encontrará. Así que añade a los
 "gcc extra config" (en la sección "C compiler") esto: --enable-multiarch --target=arm-linux-gnueabihf. 
  Esto de --enable-multiarch --target=arm-linux-gnueabihf significa que <sysroot>/usr/lib/arm-linux-gnueabihf se añade a la lista de búsqueda.
-CUIDADO con no tener instalado svn antes de entrar en menuconfig, o tendrás un aviso de peligro en lo de la librería EGLIB.
-CUIDADO con EGLIBC, que está mal y trata de detectar versiones viejas del MAKE (la 3.69 o la 3.89, y yo tengo la 4.0), así que dará un error durante la construcción...
  Es una putada muy seria que se pare la construcción, pero hay solución. Editamos build.log y nos vamos al final. Vemos que nos ha dado un error con la versión de MAKE.
  Vale: pues editamos .build/src/eglibc-2_13/configure, buscamos donde detecta la versión de MAKE (buscando ac_prog_version sucesivas veces hasta que veamos que se está detectando
  la versión de MAKE y no de otra cosa), cambiamos para que detecte la nuestra (make --version en el PC) y listo. 
-SI TIENES ERRORES DE COMPILACIÓN de estos que parece que se ha corrompido la memoria por el calentón, es hora de borrar todo en ~/cross-rasp, menos .config, y volver a empezar.
Acuérdate de ajustar lo de la versión de make en  .build/src/eglibc-2_13/configure, que no existirá hasta que empiece a instalar las herramientas.

Hacemos "ct-ng build" y si este proceso se para es porque hemos elegido algo mal en el menuconfig.
Ahora, como en el config que hemos usado se especifica un directorio de destino, ya tenemos el cross compiler ARM en 
~/x-tools/arm-unknown-linux-gnueabi-gcc.

NOTA: Este proceso es muy dado a errores durante la construcción del compilador, librerías, etc.. Así que tira de leer el build.log, irte al final y pegar
el error en google, que a la gente también le pasan estas miserias.

NOTA: Para cambiar algo en la configuración, debes borrar totalmente el directorio cross-rasp y empezar de cero, o dará problemas
absurdos durante el proceso de building.

PARTE 1: OPCIÓN B (Recomendad en Octube de 2015)
================

Clonamos el repo de https://github.com/raspberrypi/tools.git y nos queda el cross-compiler en tools. Lo demás es igual sólo que la ruta de los ejecutables del compilador es:
/home/manuel/tools/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/bin
Y la tupla (para crosscompilar en local, lo que se llama host_alias en el scummvm que se cross-compila en local) es arm-linux-gnueabihf.

PARTE 2: CONFIGURANDO EL SERVIDOR Y EL CLIENTE CUANDO YA TENEMOS CROSS-COMPILER (Válido también para Rpi)
===============================================================================================

Tenemos el cross-compiler ya.
Si estamos en el caso en que estamos usando el cross-compiler oficial, habremos clonado el repo y tendremos el compilador para la Pi en:
~/tools/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/bin

PERO nos faltan los links simbólicos de nombres cortos a gcc, g++ y otras herramientas, ya que sólo tenemos
los archivos con nombres completos (o sea que tenemos "arm-unknown-linux-gnueabi-gcc"  o "arm-linux-gnueabihf-gcc" pero no tenemos "gcc" a secas).
Así que creamos el siguiente script, le damos 755 y lo ejecutamos estando dentro del directorio ~/tools/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/bin:

#!/bin/bash
for file in `ls`; do
        ln -s $file ${file#arm-linux-gnueabihf-}
done

Y ahora, ya deberíamos tener gcc, g++, etc. Compruébalo.

Ahora instalamos distcc en el cliente y en el servidor. Simplemente, sudo apt-get install distcc en ambos.

En el servidor, editamos /etc/default/distcc y ponemos:

STARTDISTCC="true"
ALLOWEDNETS="192.168.5.0/24 192.168.5.8"  <-----Esto es la IP de la red del cliente y del propio cliente, separadas por espacio.
LISTENER="192.168.5.7"
(quitamos LISTENER="127.0.0.1").

Ahora, también en el servidor, editamos /etc/init.d/distcc y en PATH añadimos delante el path donde tenemos los ejecutables de nuestro cross-compiler.
La línea en cuestión quedaría así si hemos construido nuestro cross compiler:

PATH=/home/manuel/tools/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

Lanzamos el servidor. Para ello, en un systema con systemd hacemos:

systemctl daemon-reload
systemctl start distcc
systemctl status distcc

Tienes que ver que te sale la línea en verde:
Active: active (running) since ...

Si no va, cambia lo que sea en los ficheros de configuración y a continuación haz:
systemctl stop distcc
systemctl daemon-reload
systemctl start distcc

En cambio, si estamos en un sistema viejo con sysvinit, 
Lanzamos el servidor con sudo /etc/init.d/distcc start --verbose

Ahora, en el cliente, editamos /etc/distcc/hosts, comentamos la línea de "+zeroconfig" y ponemos sin más la IP del servidor:
192.168.5.7

Ahora también en el cliente tenemos que exportar el path del compilador, que ya no queremos que sea el gcc local sino un link sombólico gestionado
por distcc. Así que dejamos así el path en ~/.profile:

# set PATH so it includes user's private bin if it exists
if [ -d "$HOME/bin" ] ; then
     PATH="/usr/lib/distcc:$HOME/bin:$PATH"
fi

Ahora en el cliente quitamos el distcc del inicio:

sudo systemctl disable distcc

...y creamos el directorio ~/.bin, que de todos modos nos va a venir bien.

Ahora comprobamos que todo está bien: 
-En el servidor, podemos confirmar que distcc escucha en el puerto 3632 de la IP 192.168.5.7, que es la der server. Para ello, haremos
sudo netstat -apn |grep 3632
Esto es lo que se llama el "binding" del servidor.
-También podemos comprobar si el puerto 3632 de server está abierto, de dos maneras: desde el cliente, con telnet 192.168.5.7 3632. Si la pantalla
sale en negro o con ASCII raros todo va bien, ya que telnet lee datos crudos por ese puerto.
O bien desde el propio servidor, o desde el cliente, con "nmap -p 3632 192.168.5.7". Nos tiene que salir que el puerto 3632 TCP está abierto. 

***********Las voces en OSMAND+ (osmand) en Android**********************************************************************************

Este tema siempre da algo de guerra.
Debes instalar un motor de TTS en el sistema, que las versiones libres de Android no suelen traerlo. Instala el AHOTTs de la Aurora Store (Clon libre de la PlayStore).
Elígelo como motor TTS en la configuración del teléfono, en accesibilidad. 
Ya te debería ir en OSMAND.

***********Actualizar gcc 4.6 a gcc 4.7 en raspbian****************************************************************************************

Tras hacer un apt-get update y un apt-get upgrade, y sin eliminar NADA, o sea, dejando gcc-4.6 ya que tiene muchas dependencias, hacemos
¡¡¡¡¡¡CUIDADO E INSTALA AMBOS!!!!!!
sudo apt-get install gcc-4.7
sudo apt-get install g++-4.7

Creamos el script /usr/bin/gcc-set-default-version con el contenido:

#!/bin/bash 
usage() {
        echo 
        echo Sets the default version of gcc, g++, etc
        echo Usage:
        echo 
        echo "    gcc-set-default-version <VERSION>"
        echo 
        exit
}
cd /usr/bin
if [ -z $1 ] ; then 
        usage;
fi 
set_default() {
        if [ -e "$1-$2" ] ; then 
                echo $1-$2 is now the default
                ln -sf $1-$2 $1
        else 
                echo $1-$2 is not installed
        fi
}
for i in gcc cpp g++ gcov gccbug ; do 
        set_default $i $1
done

Le damos permisos de ejecución (755 sirve), y hacemos:

sudo gcc-set-default-version 4.7

Y ya debería estar. Nos dirá que no tenemos instalado gccbug-4.7, pero eso no es importante.

Instalamos VIM y le ponemos el ~/.vimrc que tienes en la sección de apuntes del VIM...
Y ahora, para que VIM recuerde la última posición en que estábamos cuando abrimos un fichero dado por última vez, editamos /etc/vim/vimrc
y descomentamos esto, que viene comentado por defecto:

" Uncomment the following to have Vim jump to the last position when
" reopening a file
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

SI ESTO NO FUNCIONA, comprueba los permisos de ~/.viminfo. Debe pertenecer al usuario actual, si no es así, probablemente no vuelva a la última
posición cuando reabrimos un fichero.

***********Comparar ficheros con VIM***************************************************************************************************

Puedes abrir dos ficheros en modo comparación con 

vim -d fichero1 fichero2

Las líneas de guiones en uno son líneas que el otro tiene pero ese no, y de ese modo líneas iguales aparecen a la misma altura!.

***********La utilidad LOCATE**********************************************************************************************************
Efectivamente, sirve para buscar archivos en todo el disco, tirando de base de datos en lugar de buscar físicamente.
Así que lo instalamos con:

apt-get install locate

y antes de usarlo hacemos

sudo updatedb

Y ya se supone que podemos usarlo.

***********TIC-80, una consola imaginaria para Pi************************************************************************************************

Clonamos su repo y actualizamos los submódulos para poder compilar:
git clone --depth 1 --recurse-submodules -j8 https://github.com/nesbox/TIC-80.git

Creamos el dir de compilación, entramos, configuramos y compilamos:
mkdir b3
cd b3
cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_LIBRETRO=ON -DBUILD_SDL=OFF -DDISABLE_NETWORKING=TRUE \
-DCMAKE_C_FLAGS="-march=native -mtune=native" ..
make -j4

***********Compilar RAZE, el engine de Duke Nukem, Blood, Exhumed, etc para Linux****************************************************************

-Instalamos una dependencia previa:
sudo apt-get install libvpx-dev

-Primero, necesita OpenAL. Tienes las instrucciones de instalación en este documento.

-Segundo, necesita ZMUSIC. Vamos con ZMUSIC pues:
---Instalamos dependencias previas: apt-get install libmpg123-dev libvorbis-dev.
---Clonamos su repo (las versiones que hay en "releases" buscan versiones de FluidSynth viejas así que no irán):
git clone --depth 1 https://github.com/ZDoom/ZMusic.git
---Creamos el directorio de compilación, entramos y configuramos, compilamos e instalamos:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native"
make -j4
sudo make install

-Vamos a por RAZE en sí.
Nos bajamos la última estable de: https://github.com/ZDoom/Raze/releases

--Creamos el directorio de compilación, entramos, configuramos y compilamos:

mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native" -DVULKAN_USE_XLIB=0
make -j10

--Creamos ~/raze y metemos allí el ejecutable resultante ("raze"), raze.pk3, el directorio soundfonts, y los ficheros de datos del BLOOD.

Para que vaya a 60FPS sólidos, puedes desactivar TODO el antialiasing, activar el VSYNC, poner FPS a UNLIMITED,
y sobre todo lanzarlo con "taskset -c 0,1 raze" si estás en un sistema con procesadores asimétricos.

************ProTracker en GNU/Linux**********************************************************************

--Bajamos la última estable de: https://github.com/8bitbubsy/pt2-clone/releases
--Le damos permisos de ejecución a "make-linux-noflac.sh", lo ejecutamos, y se compilará con los flags correctos. 
--Creamos nuestro directorio ~/pt, y allí copiamos el ejecutable y el .ini que se nos han generado:
cp release/other/pt2-clone release/other/protracker.ini ~/pt
--Editamos ~/pt/protracker.ini y ponemos "FULLSCREEN" a "TRUE"

************Schismtracker en GNU/Linux*******************************************************************

-Bajamos la última estable de:
https://github.com/schismtracker/schismtracker/releases

-Instalamos dependencias previas:
apt-get install libutf8proc-dev

-Configuramos con:

autoreconf -i
CFLAGS="-O2 -march=native -mtune=native" ./configure --without-flac

-En PC, ejecutamos con:
AUDIODEV="default" ./schismtracker
(Puedes probar con "sysdefault" si "default" no funciona).
(En otros sistemas, lo suyo es pasar también AUDIODEV="hw:lo_que_sea" y asi se consiguen tamaños de buffer menores, pero en la Raspberry Pi
si usas la CARD vc4hdmi0, no se puede usar directamente el DEVICE llamado "hw" porque no soporta mas que un formato de audio raro,
y por eso falla con un "unsopported audio format" si lo intentas).
(Ya sabes que puedes ver los dispositivos con "aplay -L" y probarlos con "speaker-test -D<dispositivo>").

-En la Raspberry Pi, ejecutamos con:
AUDIODEV="sysdefault" ./schismtracker

-Para configurar el vídeo, editamos ~/.schism/config, y:
----Ponemos fullscreen a 1 e interpolation a linear.
----Añadimos la línea "want_fixed=1" (para tener aspect ratio corregido)
También podemos poner classic_mode a 1 para que las pantallas sean las del Impulse Tracker original.

////BLOQUE OPCIONAL (innecesario): Si no queremos tener que lanzar el Schismtracker con la variable de entorno AUDIODEV:

Editamos schism/audio_playback.c y, en la función _audio_open(), comentamos:
-ESTE "IF" Y LO QUE HAY DENTRO:
if (!(getenv("SDL_AUDIODRIVER") || getenv("AUDIODEV") || getenv("SDL_PATH_DSP"))
                 && (cfg_audio_driver[0] == '\0'))
                 _audio_set_envvars(driver_spec);

-ESTE "IF" Y TODO LO QUE HAY DENTRO:
if ((driver_name = SDL_GetCurrentAudioDriver()) != NULL && !strcmp(driver_name, "alsa"))

-POR SI ALGUNA VEZ LO QUIERES MODIFICAR, NECESITAS ENTENDER LO QUE PASA: La variable de entorno AUDIODEV es leida por el backend ALSA de SDL2,
y Schismtracker lo que hace es exportar AUDIODEV="hw" cuando SDL_AUDIODRIVER es "alsa". Como el dispositivo "hw" no se puede usar directamente
en la Raspberry cuando usas la tarjeta vc4hdmi porque solo soporta un formato de audio raro, falla.
Por eso se arregla cuando exportamos AUDIODEV="sysdefault": porque usamos el backend "alsa" de las SDL2 y concretamente el dispositivo "sysdefault".

/////FIN BLOQUE OPCIONAL

************GISH en GNU/Linux**************************************************************************************************************

Clonamos este repo, que tiene una versión SDL2:

git clone --depth 1 https://github.com/ScrelliCopter/gish.git

Editamos src/sdl/video.c y añadimos esta línea justo debajo de SDL_CreateWindow():
SDL_GL_SetSwapInterval(1);

Creamos el directorio de compilación y configuramos y compilamos así:

mkdir b4
cd b4
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_FLAGS="-march=native -mtune=native" ..

Para ejecutar el juego, copia los datos del juego tal cual al mismo directorio donde tengas el ejecutable.
TIENES los datos del juego listos en el disco duro de backup.

--REPOSITORIO ALTERNATIVO (NO recomendado, no te compliques)--

git clone --depth 1 https://github.com/EXL/Gish.git

Creamos el directorio de compilación y configuramos y compilamos así:
(OJO, que le tenemos que pasar un directorio concreto a CMake como ves)

mkdir b4
cd b4
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_FLAGS="-march=native -mtune=native" ../gish/src/main/cpp

Se ejecuta igual que el del otro repo.

************DUNGEON CRAWL STONE SOUP en GNU/Linux******************************************************************************************

--Instalamos dependencias previas:
apt-get install libfreetype6-dev libpng-dev fonts-dejavu-core advancecomp pngcrush

--Miramos cuál es la última versión etiquetada en: https://github.com/crawl/crawl/releases

--Clonamos la última versión etiquetada y sus submódulos (en este ejemplo estamos clonando la versión 0.32.1):

git clone --depth 1 -b 0.32.1 https://github.com/crawl/crawl.git
git submodule init
git submodule update

--Entramos en crawl-ref/source para continuar desde allí.

    ####BLOQUE COMPILAR CONTRA OPENGL 1.x####

--Editamos el Makefile, buscamos:
"LIBS += -lGL -lGLU"
y lo sustituimos por:
"LIBS += -L/usr/local/lib64 -lOpenGL"

--Compilamos con:
make -j10 TILES=y CFOPTIMIZE="-march=native -mtune=native -O2"

	####FIN BLOQUE COMPILAR CONTRA OPENGL 1.x####

	####BLOQUE COMPILAR CONTRA GLES1####

----Editamos glwrapper-ogl.cc, y allí:
--Cambiamos:
#   include <SDL_gles.h>
Por:
#   include <SDL_opengles.h>
--Cambiamos:
case GL_INVALID_FRAMEBUFFER_OPERATION:
Por:
case GL_INVALID_FRAMEBUFFER_OPERATION_OES:

--Editamos el Makefile y añadimos:
LIBS += -L/usr/local/lib64 -lGLESv1_CM  

--Compilamos con:
make -j10 GLES=y TILES=y CFOPTIMIZE="-march=native -mtune=native -O2"

	####FIN BLOQUE COMPILAR CONTRA GLES1####

Ahora creamos el directorio ~/crawl, y metemos allí el ejecutable "crawl"
Ahora copiamos los directorios "dat" y "settings" que viene dentro de "sources" a ~/crawl
(OJO!! Si al lanzar el juego te dice que te falta algún asset, bájate la versión de Windows y usa los directorios que trae esa versión,
 que viene todo seguro).

Editamos "settings/init.txt" y añadimos estas opciones:

#Para que se vea a pantalla completa, 
tile_full_screen = true
#Para que el juego se vea más grande:
game_scale=2
#Para tener filtro bilineal:
tile_filter_scaling = true
#Para que la fuente se vea más pequeña para ese tamaño de juego:
tile_font_stat_size=10
tile_font_msg_size=10
#Para que se vean más grandes los gráficos (el valor por defecto es 32):
tile_cell_pixels = 64

************AQUARIA en GNU/Linux***********************************************************************************************************

Dependencias previas: Necesita OpenAL y SDL2 en el sistema, como muchos otros sourceports.

Clonamos su repo:
git clone --depth 1 https://github.com/AquariaOSE/Aquaria.git

Creamos el directorio de compilación, entramos y configuramos con:
mkdir b4
cd b4
cmake -DAQUARIA_USE_SDL2=TRUE \
-DCMAKE_BUILD_TYPE=Release -DCMAKE_C_FLAGS="-march=native -mtune=native" -DCMAKE_CXX_FLAGS="-march=native -mtune=native" ..

Para ejecutarlo:
-Creamos nuestro directorio "~/aquaria"
-Metemos el ejecutable "aquaria" en ~/aquaria
-Metemos los datos de una instalación juego en el directorio ~/aquaria
NOTA: Tienes los datos listos ya en el disco duro de backup.
-Copiamos el contenido del directorio "files" que viene con los sources a ~/aquaria, sobreescribiendo así parte de los datos del juego.
OJO: Es el contenido de "files" lo que tenemos que copiar, no el directorio.

************ECWOLF, el mejor port del Wolfenstein 3D, en la Pi*****************************************************************************

Clonamos su repo:
git clone --depth 1 https://bitbucket.org/ecwolf/ecwolf.git

Puedes añadir en src/sdlvideo.cpp el típico
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
justo antes de SDL_CreateWindow(), para el escalado emborronado que te gusta.

Compilamos con:

mkdir b4
cd b4

cmake -DCMAKE_BUILD_TYPE=Release -DGPL=ON -DCMAKE_C_FLAGS="-march=native -mtune=native" ..
(PARA compilar en modo verbose, haz make VERBOSE=1)

Puedes establecer un buffer de audio menor con --audiobuffer 512
SÓLO SI NO TIENES VRR: Activamos el vsync es en los menús y le pasamos al ejecutable el parámetro --noadaptive

Sólo hace falta tener el ejecutable en el mismo directorio que los datos del wolfenstein (versión de ACTIVISION, NO la original de Apogee, OJO!!!), y funcionará sin más.

Pon la resolución a 320x200 en el menú, fullscreen.

NO soporta el Rise Of The Triad, sólo el Wolfenstein y el Spear of Destiny.

Para mejorar la música y los gŕaficos, yo uso el pack ECWolf_hdmus_BrainStewX para la música (tienes que tener SDL2_Mixer compilado con soporte de OGG, para lo que habrás tenido que instalar libogg-dev antes de configurar, compilar e instalar SDL2_Mixer, lo normal es que ya lo tengas porque es lo que usas para las músicas custom del SCUMMVM):
https://forum.zdoom.org/viewtopic.php?f=19&t=48633

Y el pack hi-res sencillo de aquí para los gráficos de armas y enemigos, sonidos fx, etc:
https://www.moddb.com/games/wolfenstein-3d/addons/ecwolf-rmst

Al final, mi script wolf3d contiene esta línea para lanzar el ECWOLF a mi gusto:
./ecwolf --noadaptive --audiobuffer 512 --file hdpack.pk3 hdmus.pk3

NOTA: SI USAS EL CORE DE RETROARCH, pon los datos y el EXE de la versión de ACTIVISION, NO la original de Apogee, y a Retroarch, además del core, le pasas el WOLF3D.EXE.
Y se compila con:

CFLAGS="-O2 -march=native -mtune=native -O2" cmake -DLIBRETRO=1 ..

***********Half Life (XASH3D) en GNU/Linux **********************************************************************************************

XASH3D SOPORTA AHORA TANTO OPENGL COMO GLES1 Y GLES2, SIN WRAPPERS NI NADA.
OJO; SI ESTAS INSTRUCCIONES TE DAN ERRORES, QUE SEPAS QUE PROCEDEN DE AQUÍ:
https://github.com/FWGS/xash3d/wiki/Building-and-running#cmake-recommended-for-non-windows

Instalamos una pequeña dependencia que hace falta:
sudo apt-get install --no-install-recommends libfontconfig1-dev

Clonamos el repo principal:
git clone --depth 1 --recurse-submodules -j8 https://github.com/FWGS/xash3d-fwgs.git

Configuramos y compilamos así (usa un buildsystem raro llamado WAF que viene incluido con los sources, no tienes que instalarlo):

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./waf configure -T release --64bits --disable-vgui

./waf build

Ahora, creamos el directorio donde vamos a instalar el engine y lo instalamos allí:

mkdir ~/hl
./waf install --destdir=~/hl/

Ahora vamos a por las librerías del juego: clonamos esto:
git clone --depth 1 https://github.com/FWGS/hlsdk-portable.git

Compilamos como antes usando WAF:

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./waf configure -T release --64bits

./waf build
./waf install --destdir=~/hl/

Ahora copiamos el directorio "valve" de una instalación de Half Life a ~/hl/valve
(Tienes los datos listos en el disco duro de backup, PERO si necesitas recuperar el directorio "valve" porque has perdido los datos,
 busca "half life won archive.org" y baja eso, la versión "Half Life WON v1.1.1.0 + working music" de archive.org,
 y usa el directorio "valve" que trae esa versión, ya que va perfecta).

Ahora editamos ~/hl/valve/gameinfo.txt, y dejamos la línea de gamedll_linux así:
gamedll_linux           "dlls/hl.so"
(Se trata de quitar la librería de juego de 32bits y dejar la de 64bits que hemos compilado nosotros).

Y ya deberíamos poder lanzar el juego con "./xash3d"
Si nos falla algo y quisiéramos ver los logs a ver qué pasa, haríamos: "./xash3d -dev 5"

PARA QUE NO HAGA AUTOSAVES, editamos valve/config.cfg y ponemos "sv_autosave" a "0".

NOTA ADICIONAL - SI HAS RIPEADO TÚ LOS DATOS DEL JUEGO NECESITAS UN ARCHIVO MÁS QUE NO VIENE EN EL CD:
Nos metemos en ~/hl/valve y nos bajamos el archivo "delta.lst" de los servidores de VALVE. Ya casi estamos!:
cd ~/hl/valve
wget https://raw.githubusercontent.com/ValveSoftware/halflife/master/network/delta.lst

NOTA ADICIONAL - SI QUIERES TENER MÚSICA DURANTE EL JUEGO Y HAS RIPEADO TÚ LOS DATOS DESDE UNA IMÁGEN DE CD:
Cuando ripees el CD con bchunk (porque vas a necesitar hacerlo para sacar el diretorio "valve" de la ISO) hazlo así:
bchunk -w HALF_LIFE.BIN HALF_LIFE.BIN half
Y ahora, los WAV que has obtenido los conviertes a mp3 con:
for i in *.wav; do ffmpeg -i "$i" -ab 320k "${i%.*}.mp3"; done
Los subes a ~/hl/valve/media, y editas cdaudio.txt para que las pistas se llamen como los mp3 que acabas de generar (half01.mp3, half02.mp3, etc).

NOTA ADICIONAL - Si quieres counterstrike 1.6, la librería de juego que tendrías que compilar e instalar en ~/hl/valve/dlls/ es esta:
https://github.com/FWGS/cs16-client/releases

************Half Life 2 en GNU/Linux****************************************************************************************************

--Lo primero, necesita OpenAL, mira en la sección correspondiente cómo instalarlas.

--Instalamos otras dependencias previas:
apt-get install libbz2-dev libedit-dev

--Clonamos el repo de los sources:
git clone --depth 1 --recursive https://github.com/nillerusr/source-engine.git

--Editamos togl/linuxwin/glentrypoints.cpp y allí:
----Comentamos el "#include <GL/glx.h>"
----Buscamos "glXGetCurrentDisplay" y comentamos todo lo del bloque "#elif" donde está, que empieza con:
#elif !defined ( OSX ) && !defined( __ANDROID__ ) 

--Desde el raiz de los sources, configuramos y compilamos:
./waf configure -T release --prefix=hl2 --build-games=hl2 --disable-warns
./waf build -p -v

Queda meter los datos del juego y demás.

************SABER QUÉ CFLAGS USAR*******************************************************************************************************

Para saber qué hace GCC cuando le decimos que use "-march=native" en nuestra plataforma, hacemos:
gcc -### -E - -march=native 2>&1 | sed -r '/cc1/!d;s/(")|(^.* - )|( -mno-[^\ ]+)//g' 

Y para saber qué hace GCC cuando decirmos que use "-mtune=native" en nuestra plataforma, hacemos:
gcc -### -E - -mtune=native 2>&1 | sed -r '/cc1/!d;s/(")|(^.* - )|( -mno-[^\ ]+)//g'

Así que un set de flags neutral para Pi3 y Pi4, 32 o 64bit, con un GCC moderno en el que NATIVE funciona ya bien, sería:

CFLAGS="-march=native -mtune=native -O2"

************Parchear con XDelta en Linux************************************************************************************************

SI ES UN PARCHE XDELTA (como el del Xenogears al castellano):
xdelta patch parche_CD1_con_videos.xdt Xenogears\ \(USA\)\ \(Disc\ 1\).bin Xeno1.bin


SI ES UN PARCHE XDELTA3:

En este caso, puedes usar el DeltaPatcher si estás en un sistema con escritorio:
https://github.com/marco-calautti/DeltaPatcher/releases/

O bien usar el comando xdelta3, que se instala con "sudo apt install python xdelta3" y se usa así:
xdelta3 -d -s original parche resultado

************Wolf4SDL (Wolfenstein 3D) en GNU/Linux*************************************************************************************

Compilaro y hacerlo funcionar me llevó un rato. Editamos "version.h" y nos vamos a los "defines used for different versions", donde dejamos descomentados
estos solamente:
#define GOODTIMES
#define CARMACIZED 

Luego nos bajamos la versión de Activision de emuparadise o donde nos de la gana, y pasamos a minúsculas todos los ficherso WL6 y el EXE.
Los metemos en el mismo directorio que el ejecutable de wolf4sdl (wolf3d), y ya debería ir (Excepto por temas de las SDL, ya que por defecto
el juego intenta reutilizar el modo de vídeo actual y eso está mal: editamos el código y lo ponemos a 320x200 en 16bpp).

Si aún así no tira, edita Makefile y cambia el DATADIR a ./, de tal manera que desde ahora simplemente metes los ficheros de datos del juego en el mismo
directorio que el ejecutable que acabas de compilar y los encuentra.

Otra cosa: los scripts de configuración del juego usan sdl-config --libs (o lo que es lo mismo, pkg-config --libs sdl) para ver dónde están tanto las
librerías libSDL1.2 como las SDL_mixer. Así que si tienes las SDL1.2.x en /usr/local/lib/armhf-gnueabi, no va a encontrar las SDL_mixer, ya que estas
están en /usr/local/lib y sdl-config o pkg-config sólo devuelven las rutas de las libSDL1.2.x y se asume que ahí van a estar las SDL_mixer también.
Así que mírate los apuntes sobre SDL1.2.x que hay más arriba, para instalar SDL y SDL_Mixer ambas en /usr/local/lib, y luego ejecuta ldconfig --verbose, etc.

************MÉTODO STANDARD PARA EJECUTAR PRGRAMAS AL INICIO O LANZAR SERVICIOS: DEPENDENCY BASED BOOTING SEQUENCE*************

Estos son los apuntes para sistemas que cumplen con DDBS de la FFS, como Debian, Raspbian y demás distribuciones "legales".

Si simplemente queremos que algo se ejecute como root al inicio, justo antes de que se lancen las ttys de usuario, pues con ponerlo
en /etc/rc.local antes del "exit 0", nos vale. 
Pero si queremos lanzar un SERVICIO que se quedará corriendo de fondo en lugar d un programa que retore y sigamos con una secuencia de comandos 
(cosa que no se  puede hacer si el servicio no retorna al prompt, cosa que no tiene por qué hacer), así un control más fino sobre en qué cambio de runlevel 
queremos que se ejecute, lo que es interesante a la hora de lanzar servicios, necesitamos un script de inicio.

Los scrips de inicio están en /etc/init.d, y la utilidad que los coloca en la scuencia de arranque lo que hace es crear links simbólicos a esos scrips en los dirs
/etc/rcN.d, siendo N un runlevel en que ese servicio estará activo. Así, un servicio que estará activo en los runlevels "normales" de un sistema debian, tendrá 
links simbólicos a su script de incio en los directorios /etc/rc2.d, /etc/rc3.d, /etc/rc4.d y /etc/rc5.d. Pero esto es algo que gestiona la herramienta que se
encarga de ponerlos y quitarlos del inicio, que es "insserv", y que ANTIGUAMENTE era update-rc.d, que ya NO SE USA.

El formato de un script de inicio para insserv es este:

#!/bin/bash

### BEGIN INIT INFO
# Provides:          fsynthserv
# Required-Start:    fluidsynth
# Required-Stop:     fluidsynth
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: binds MIDI ports
# Description:       binds MIDI ports

### END INIT INFO

# Cosas que se ejecutan si las pedimos específicamente pasando parámetros al script
case "$1" in
  start)
    #Espero a que esté listo Fluidsynth. Aunque se lance antes su script, el sinte tarda en estar listo.
    sleep 4
    echo "Estableciendo conexión del sintetizador con el secuenciador de red"
    aconnect 128:0 129:0
    ;;
  stop)
    echo "Deshaciendo conexión del sintetizador con el secuenciador de red"
    aconnect -x
    ;;
  *)
    echo "Usage: /etc/init.d/fsynthserv {start|stop}"
    exit 1
    ;;
esac
exit 0

La única novedad reseñable pero imprescindible es la cabecera, INIT INFO, que determina cómo colocará insserv este script de inicio. 
Los campos más importantes a este propósito son:

# Provides:          fsynthserv

¿Qué nombre en el sistema tiene el servicio que activamos? Esto sirve luego para que otros scripts dependan de él y nos podamos referir a él.

# Required-Start:    fluidsynth

¿Qué servicios tienen que estar activos ANTES de lanzar este? Esto es LO MÁS IMPORTANTE, pues es lo que usa insserv para ponerlo después de 
otros servicios, para establecer el orden de arranque. 
MUCHO CUIDADO: si este servicio depende de un script que está en /etc/init.d, con poner el nombre del script TAL CUAL no vale. NO hay que poner
un $ delante del nombre. PERO SI SE TRATA de nombres abstractos de características del sistema, como $time, $local_fs, $network... pues sí se pone.
Por ejemplo, $time indicaría que se ha establecido la hora de sistema por el método que sea, $network implicaría los niveles inferiores de metworking
como la tarjeta ethernet, etc.
PERO TEN MUCHO CUIDADO y si simplemente quieres que se ejecute este script TRAS otro script que está en /etc/init.d, pon simplemente el nombre 
del otro script sin ninguna $. MUCHO cuidado con poner la $ cuando no hace falta, porque NO FUNCIONARÁ e insserv no establecerá el orden correcto.

# Required-Stop:     fluidsynth

Esto es menos importante: se trataría de los servicios que deben estar activos cuando se desactive este.

El resto de campos se entienden bien, ya sabes de qué van y no los voy a explicar porque no hace falta.

Ahora simplemente haríamos:

sudo insserv fsynthserv

para poner el servicio en el arranque (se supone que el servicio fluidsynth, o sea, el script del mismo nombre, ya está en el arranque puesto).
O bien 

sudo insserv -r fluidsynth

para quitarlo del arranque. Olvídate de los nombres de los symlinks, que si S99, que si K01... Nada, eso ya NO IMPORTA Y NO SE USA. Ahora todo va con
dependency based booting sequence.

LA MEJOR guía para esto la tienes en este mismo directorio como "Orden de arranque o inicio de scripts (DBBS)" y procede de la página
http://www.openredes.com/2011/05/13/orden-de-arranque-o-inicio-de-scripts-de-etcinit-d-en-debian-squeeze-6-0-solucion-a-update-rc-d-using-dependency-based-boot-sequencing/ 

************MÉTODO ANTIGUO para ejecutar programas o scripts al inicio como root: LUBUNTU (NO DEBIAN)************************

¡¡¡CUIDADO!!! ESTO SÓLO SIRVE PARA DISTROS BASADAS EN UBUNTU, QUE NO CUMPLE EL "DEPENDENCY BASED BOOTING SEQUENCE" DE LA FSS.
ASÍ QUE EN RASPBIAN O DEBIAN NO SE USA ESTO. 

Si simplemente queremos que algo se ejecute como root al inicio, justo antes de que se lancen las ttys de usuario, pues con ponerlo
en /etc/rc.local antes del "exit 0", nos vale. 
Pero si queremos lanzar un SERVICIO que se quedará corriendo de fondo en lugar d un programa que retore y sigamos con una secuencia de comandos 
(cosa que no se  puede hacer si el servicio no retorna al prompt, cosa que no tiene por qué hacer), así un control más fino sobre en qué cambio de runlevel 
queremos que se ejecute, lo que es interesante a la hora de lanzar servicios, pues seguimos estos pasos:

-El formato de un script de inicio de servicio es este:

#! /bin/sh
# /etc/init.d/blah
#

# Cosas que se ejecutan siempre
touch /var/lock/blah

# Cosas que se ejecutan si las pedimos específicamente pasando parámetros al script
case "$1" in
  start)
    echo "Iniciando script blah "
    echo "Aquí se podrían hacer más cosas"
    ;;
  stop)
    echo "Deteniendo script blah "
    echo "Aquí se podrían hacer más cosas"
    ;;
  *)
    echo "Usage: /etc/init.d/blah {start|stop}"
    exit 1
    ;;
esac

exit 0

-Creamos nuestro script, lo metemos en /etc/init.d que es el "almacén" de scripts, y le damos permisos de ejecución. Un 755 está bien.
-Ahora tenemos dos opciones: o le decimos que lo meta en uno o varios runlevels automáticamente usando algo tipo:
"update-rc.d <nombre_script_en_/etc/init.d> defaults", o creamos nosotros los link simbólicos de cada runlevel siguiendo una nomencleatura:
por ejemplo, si queremos que se inicie el servicio al entrar en el runlevel 2 y que se pare al entrar en el runlevel 6, que es el de reiniciar el sistema, 
y en el 0, que es el de haltear el sistema, haremos estos links:
"ln -s /etc/init.d/blah /etc/rc2.d/S66blah"
"ln -s /etc/init.d/blah /etc/rc0.d/K66blah"
"ln -s /etc/init.d/blah /etc/rc6.d/K66blah"
La "S" es de "start" y la "K" es de "kill", lógicamente. Así, si se cambia a alguno de esos dos runlevels, se hará lo que se tenga que hacer según corresponda.
El número determina el órden en que se ejecuta el script (iniciando o deteniendo el servicio) dentro del runlevel en cuestión. A mayor número, menor
prioridad. Así, un link simbólico llamado S99 asegura que se ejecutará el script de inicio del servicio en último lugar respecto a los demás de ese runlevel.

ANEXO:
-Para saber en qué runlevel estamos, simplemente tenemos el comando "runlevel".
-Los runlevels importantes son: 0 para haltear el sistema, 1 es el modo single-user para reparaciones, 2 al 5 son los normales o modos multiusuario
(en raspbian empezamos al logarnos en modo texto en el runlevel 2) y el 6 es reiniciar el sistema.

*************Conectarse a una BBS desde GNU/Linux*************************************************************

--Lo primero es instalar un terminal BBS (que correrá dentro de nuestro emulator de terminal, no va independiente)
que se llama Syncterm:
----Clonamos su repo: git clone --depth 1 https://gitlab.synchro.net/main/sbbs.git
----Editamos src/xpdev/xp_dl.c y en la primera vez que vemos esta línea:
sprintf(fname, "lib%s.so.%d", name, major);
la dejamos así:
sprintf (fname, "libSDL2-2.0.so.0", NULL);
----Compilamos con:
cd src/syncterm
make RELEASE=1 WITH_SDL=1 USE_SDL_AUDIO=1 -j10
----Instalamos a mano (no hay "make uninstall", por eso instalamos a mano!!):
cp gcc.linux.x64.exe.release/syncterm /usr/local/bin/
----Para ponerlo a pantalla completa y en modo gráfico (por defecto se inicia en modo CURSES,
que no entiende de pantallas completas ni de nada) nos vamos a "Program Settings->Video Output Mode" y lo ponemos a "SDL Fullscreen".

*************Raspberry Pi y establecimiento de modos de vídeo tras el arranque: tvservice*********************

Para listar los modos de vídeo de una categoría:

tvservice --modes=CEA
tvservice --modes=CEA

Para cambiar de modo de vídeo:

Apagamos el monitor:

tvservice -o

Lo encendemos con un modo concreto:

/opt/vc/bin/tvservice --explicit="CEA 1 HDMI"

O si quisiéramos encenderlo sin más, 

tvservice -p

Y se nos ve la pantalla en negro. PERO si lanzas un programa, ya se ve :O

Estos scripts, además, permiten que no se quede la pantalla en nego y adaptan el tamaño del framebuffer, con lo que el cambio de
resolución es perfecto:

/opt/vc/bin/tvservice --explicit="CEA 1 HDMI"
sudo chvt 3
sudo chvt 1
sudo fbset -xres 320 -yres 240

/opt/vc/bin/tvservice --explicit="DMT 39 HDMI"
sudo chvt 3
sudo chvt 1
sudo fbset -xres 1360 -yres 768

*************INSTALAR FluidSynth desde sources (sin depender de x11-common)********************************************

Instalamos unas dependencias que tiene. Necesita glib porque el threading multiplataforma se hace gracias a glib. Es inevitable.

apt-get install libglib2.0-dev --no-install-recommends

Bajamos la última versión estable de fluidsynth de aquí:
https://github.com/FluidSynth/fluidsynth/releases

Configuramos y compilamos:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
cmake .. -DCMAKE_BUILD_TYPE=Release -Denable-dbus=0 -Denable-ipv6=0 -Denable-aufile=0 -Denable-network=0 -Denable-oss=0 -Denable-sdl2=0 ..

*************MIDI remoto con fluidsynth o timidity (MIDI over LAN)*************************************************************

SERVIDOR 
========

aseqnet  &

fluidsynth --audio-driver=alsa -s merlin_gold.sf2
o bien
timidity -iA -Os1 -B 2,3 &

manuel@vader:~$ aseqdump -l
 Port    Client name                      Port name
  0:0    System                           Timer
  0:1    System                           Announce
 14:0    Midi Through                     Midi Through Port-0
128:0    Net Client                       Network

manuel@vader:~$ aplaymidi -l
 Port    Client name                      Port name
 14:0    Midi Through                     Midi Through Port-0
128:0    Net Client                       Network
129:0    FLUID Synth (4309)               Synth input port (4309:0)

aconnect 128:0 129:0

CLIENTE
=======

aseqdump -l
aseqnet 192.168.5.8 &
aseqdump -l
aplay -p 128:0 nombre.mid

Para scummvm, podemos exportar SCUMMVM_PORT="128:0", o bien usar el parámetro de configuración alsa_port.

Para compilar fluidsynth podemos hacerlo desde los sources estables antiguos que hay en su página o desde svn:

-DESDE LOS SOURCES ESTABLES:

Editamos configure y quitamos los O2 y los -g que encontremos antes de ejecutar configure.
Ahora ya ejecutamos configure así:

CFLAGS="-O2 -march=armv6 -mfpu=vfp -mfloat-abi=hard" CXXFLAGS="-O2 -march=armv6 -mfpu=vfp -mfloat-abi=hard" ./configure  --prefix=/usr --disable-aufile-support --disable-oss-support --disable-dbus-support

Y POR ÚLTIMO compilamos.

-DESDE SVN:

Antes de nada necesitamos libtool.
sudo apt-get install libtool

Clonamos su repo:
git clone --depth 1 git://git.code.sf.net/p/fluidsynth/code-git

Editamos configure.ac y añadimos:
m4_pattern_allow([AC_LIB_PROG_LD_GNU])

Ejecutamos autogen.sh

Editamos configure y quitamos los O2 y los -g que encontremos antes de ejecutar configure.
Ahora ya ejecutamos configure así:

CFLAGS="-O2 -march=native -mtune=native" CXXFLAGS="-O2 -march=native -mtune=native" ./configure --prefix=/usr --disable-oss-support --disable-aufile-support  --disable-dbus-support

Y POR ÚLTIMO compilamos.

Para automatizar todo esto y hacernos un sinte que automáticamente haga estas cosas:
-Se lance el aseqnet y escuche en red en la IP 192.168.5.10 o la que nos de la gana.
-Fluisynth se lance al inicio como servicio
-Conectamos el aseqnet con fluidsynth para pasarle a fluidsynth los comandos MIDI que le llegan a aseqnet

Esto lo he resuelto con dos scripts de inicio de sistema, ya que fluidsynth es un servidor y no retorna al prompt, lo que tiene bastate sentido.
Estos dos escripts van en /etc/ini.d y son los siguientes:
/etc/init.d/fluidsynth:

#!/bin/bash

### BEGIN INIT INFO
# Provides:          fluidsynth
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Required-Start:
# Required-Stop:
# Short-Description: Sintetizador midi por software
# Description:       Un sintetizador MIDI por software
### END INIT INFO

# Cosas que se ejecutan si las pedimos específicamente pasando parámetros al script
case "$1" in
  start)
    echo "Iniciando fluidsynth"
    aseqnet &
    /usr/local/bin/fluidsynth -i -l -s /home/pi/merlin_gold.sf2 &
    ;;
  stop)
    echo "Deteniendo fluidsynth"
    killall fluidsynth
    ;;
  *)
    echo "Usage: /etc/init.d/fluidsynth {start|stop}"
    exit 1
    ;;
esac

exit 0



Y /etc/init.d/fsynthserv

#!/bin/bash
### BEGIN INIT INFO
# Provides:          fsynthserv
# Required-Start:    fluidsynth
# Required-Stop:     fluidsynth
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: binds MIDI ports
# Description:       binds MIDI ports
### END INIT INFO

# Cosas que se ejecutan si las pedimos específicamente pasando parámetros al script
case "$1" in
  start)
    #Espero a que esté listo Fluidsynth. Aunque se lance antes su script, el sinte tarda en estar listo.
    sleep 4
    echo "Estableciendo conexión del sintetizador con el secuenciador de red"
    aconnect 128:0 129:0
    ;;
  stop)
    echo "Deshaciendo conexión del sintetizador con el secuenciador de red"
    aconnect -x
    ;;
  *)
    echo "Usage: /etc/init.d/fsynthserv {start|stop}"
    exit 1
    ;;
esac
exit 0



Como puedes ver, fsynthserv depende para ejecutarse de fluidsynth, por lo que al hacer 
insserv fluidsynth
insserv fsynthserv
el comando insserv los pondrá en el orden correcto. 
He puesto "Required-Start:    fluidsynth" sin $ en el script de fsynthserv porque fluidsynth es un servicio que está en /etc/init.d y NO un servicio
virtual del sistema como $time o $network. MUCHO cuidado con poner la $ cuando no hace falta, porque NO FUNCIONARÁ.


*************Entendiendo ALSA*******************************************************************************************

Esto es una idea un poco general, ya que no entiendo del todo como va el asunto, pero sirve como una explicación superficial. Tampoco esperes 
entenderlo bien.

Centrándonos en la estructura de ~/.asoundrc (o /etc/asound.conf, siendo ambos ficheros leídos desde /usr/share/alsa/alsa.conf en la Rpi y ninguno de ellos
ignorado), podemos entender bastantes cosas de cómo funciona este sistema.

Todo está basado en plugins. Los plugins tienen definidos nombres o aliases en los ficheros de /usr/share/alsa o en la librería, y usando !<alias> podemos
redefinir el valor que corresponde a un alias.

Las aplicaciones suelen usar el plugin "default", con lo que bastaría redefinir su valor para que usaran una u otra cosa en realidad. SE SUPONE que si no
configuramos nada, el valor del plugin default debería ser "hw:0,0", o sea, la primera tarjeta, primer dispositivo.

Así, por ejemplo, imagínate que quieres que el plugin "default" sea un enchufe que mande el audio NO directamente al hardware sino a la entrada de
otro plugin que sería el dmixer, y que a su vez ya se encangará de enviar el audio donde esté definido que lo mande.
Pues haríamos esto:

pcm.!default {                          //Redefinimos el plugin default
	type plug                           //Decimos que es de tipo plug, o sea que mandará el sonido a otro sitio
	slave.pcm "dmix:0,0"   //Y concretamente lo mandará a un slave, cuyo valor será dmix:0,0, o sea dmix que mandará el sonido tras resamplearlo y mezclarlo
                                                       //a través de la primera tarjeta, primer dispositivo.
}

Y si quisiésemos redefinir el plugin "default" de tal manera que al usarlo una aplicación se estuviese enviando el sonido directamente al hardware,
concretamente a la primera tarjeta, primer dispositivo, haríamos:

pcm.!default {				//Redefinimos el plugin default
	type hw				//Decimos que no es un enchufe como antes, sino directamente acceso hardware  		
	card 0					//El hardware al que accede es primera tarjeta,
	device 0				//primer dispositivo.
}

También es posible que nosotros definamos nuestro propio plugin, y luego lo usemos. Por ejemplo, nos a inventar un plugin llamado "mymixer"
que en realidad enviará el sonido a través de dmix pero nos sirve de ejemplo. Como el tipo de plugin "dmix" ya está definido, será el tipo que tenga.
Redefiniremos default de tal modo que envíe el sonido a través de ese nuevo plugin.

pcm.!mymixer {
	type dmix
	slave {
		pcm "hw:1,0"
		period_size 512
		buffer_size 4096
		rate 48000
	}
}

pcm.!default {
	type plug
	slave.pcm mymixer
}

Si usamos dmixer y queremos cambiar la frecuencia de muestreo de salida para que coincida con la más común de entrada, editamos
/usr/share/alsa/alsa.conf y cambiamos "defaults.pcm.dmix.rate 48000" a 44100.

*************Grabar audio (grabar sonido) de ALSA, sin usar PULSEAUDIO PARA NADA*************************************************

En la mayoría de los sitios se dice que es imposible, porque el audio de ALSA es enviado a la salida y se pierde, al no pasar por ningún sitio en medio donde sea copiado.
Pero es posible lograrlo, usando simplemente arecord. Y es MUY MUY fácil.

Lo primero es entender que podemos ver los dispositivos de los que podemos grabar con arecord así:
arecord -l
Y vemos:
card 0: PCH [HDA Intel PCH], device 0: ALC269VC Analog [ALC269VC Analog]
card 1: Camera [USB 2.0 PC Camera], device 0: USB Audio [USB Audio]

Así de entrada no tenemos ningún dispositivo que nos sirva, así que lo primero insertamos este módulo:
sudo modprobe snd-aloop

Ahora volvemos a mirar con
arecord -l
Y vemos que tenemos:
card 0: PCH [HDA Intel PCH], device 0: ALC269VC Analog [ALC269VC Analog]
card 1: Camera [USB 2.0 PC Camera], device 0: USB Audio [USB Audio]
card 2: Loopback [Loopback], device 0: Loopback PCM [Loopback PCM]
card 2: Loopback [Loopback], device 1: Loopback PCM [Loopback PCM]

Los dispositivos loopback son los que nos interesan.
El que me funciona es el:
card 2: Loopback [Loopback], device 1: Loopback PCM [Loopback PCM]

Así que grabamos de la tarjeta 2 dispositivo 2 con:
arecord -f CD -r 44100 --device="hw:2,1" grabación.wav

Podría ser necesario usar otro dispositivo de loopback en otras tarjetas distintas, claro.

*************GEMRB : Engine para Baldur's Gate 1 & 2*******************************************************************************

Dependencias previas:

-sudo apt-get install libpython-dev --no-install-recommends

-HAY que tener instalado OpenAL, porque aunque tiene soporte para SDL2 sin OpenAL, faltan los sonidos ambientales si usas SDL2.
Cuando acabes de compilar e instalar OpenAL, haz:
sudo rm /etc/ld.so.cache
sudo ldconfig
...O el plugin de audio no podrá ser cargado.

Cambia en gemrb/plugins/SDLVideo/SDL20Video.cpp:
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "nearest");
por
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");

Hay que leer el INSTALL para saber cómo se compila, pero esencialmente:

cmake .. -DCMAKE_BUILD_TYPE=Release -DSDL_BACKEND=SDL2 -DOPENGL_BACKEND=None -DDISABLE_WERROR=1 \
-DUSE_SDLMIXER=0 -DUSE_OPENAL=1 -DUSE_LIBVLC=0 -DDISABLE_VIDEOCORE=1 \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native"

make -j4

El renderer OpenGL es experimental, no se está desarrollando y NO APORTA NADA. No te molestes en usarlo por ahora.

Instalar con sudo make install, el uninstall funciona bien. NO INTENTES JUGAR INSTALÁNDOLO A MANO, ES UN LIOTE Y NO MERECE LA PENA, INSTALA EL ENGINE SIN MIEDO, QUE SE DESISTALA SIN PROBLEMAS.

Ahora te creas un directorio, por ejemplo ~/baldurs, y dentro creas bg2_data, que es donde meterás el baldurs 2 instalado tal cual.
Ahora te copias el cfg de ejemplo, que viene en build/gemrb, a ~/baldurs también, lo editas y le pasas la ruta del baldurs 2 instalado, relativa a ~/baldurs.
También tienes que descomentar las líneas del .cfg:
GUIScriptsPath=/usr/local/share/gemrb
PluginsPath=/usr/local/lib/gemrb/plugins
GemRBOverridePath=/usr/local/share/gemrb
GemRBUnhardcodedPath=/usr/local/share/gemrb
...O habrá muchas cosas que no encuentre y NO DEBES copiarlas a mano ni nada, las tiene que encontrar.

Le puedes pasar el cfg con -c, en plan gemrb -c game.cfg

Por ejemplo, dejaríamos el path de los datos del BG2 como:
GamePath=./bg2_data
Ahí puedes poner fullscreen a 1 también si quieres.

Las ediciones que necesitas de GOG son las COMPLETE (Baldurs Gate Original Saga que es el Baldurs 1, Baldurs Gate 2 Complete que es el 2), NO LAS ENHANCED. Las ENHANCED NO SIRVEN.

Si no se te oye mira a ver qué plugin está cargando. Si está cargando NullSound comprueba que tienes SDLAudio.so en la ruta de los plugins.

PARA CUSTOMIZAR LAS FUENTES (vamos a verlo con el Baldur's Gate 1 como ejemplo)
1- Copia un fichero de configuración de fuentes al directorio de overrides del juego, así:
cp /usr/local/share/gemrb/unhardcoded/bg1/fonts.2da /usr/local/share/gemrb/override/bg1/
2- Copia una fuente .TTF a /usr/local/share/gemrb/override/bg1/
2- Edita el fichero de configuración de fuentes:
vim /usr/local/share/gemrb/override/bg1/fonts.2da
...Y en la columna FONT_NAME pones el nombre SIN EXTENSIÓN del .TTF que quieras usar.
PARA más información sobre la customización de fuentes, mira en:
https://gemrb.org/Fonts.html
LA MEJOR FUENTE es SHERWOOD.TTF, que es la que usa el juego pero en TTF.

PARA USAR LA RESOLUCIÓN QUE QUERAMOS tenemos que aplicar el parche widescreen, que lo puedes bajar de aquí:
https://www.gibberlings3.net/mods/tools/widescreen/
Lo primero, nos bajamos el parcheador "weidu" desde aquí:
http://www.weidu.org/~thebigg
Extraes los ejecutables weidu, weinstall y tolower, y los mandas a /usr/local/bin
Ahora extraes el parche de widescreen, y el directorio "widescreen" con todo dentro lo metes tal cual en el directorio donde tengas instalado el juego que quieres parchear.
Ahora haces "weinstall widescreen" en el directorio del juego (recuerda que a parte de los datos del juego tendrás el directorio "widescreen" ahí metido, NO sus contenidos sino el directorio en sí con todo dentro) y vas respondiendo a las preguntas.
Para X Coordinate e Y Coordinate, usa 854x480. Para el tamaño máximo del juego, usa 1920x1080. Habilita lo de las múltiples resoluciones.

*************Compilar openadventure*********************************************************************************************

Instalar cosas:
sudo apt-get install libedit-dev pyhton-yaml
editar el makefile para añadir los cflags. Compilar y listo.

*************Core Cannonball (OutRun engine) en la Rpi*****************************************************************************************

Necesitamos un directorio /roms donde metemos las roms del juego (es el romset del MAME y si te falta una eprom, es del SET B)
donde metemos también el directorio /res que viene con los sources.
Es decir, /res quedaría como /roms/res.
En /roms, creamos un archivo vacío llamado outrun.game, y lanzaríamos el core como:
retroarch -L ~/.config/retroarch/cores/cannonball-libretro.so roms/outrun.game

*************Compilar Cannonball (OutRun engine) versión SDL2 en Rpi***************************************************************************

Clonamos su repo:
git clone --depth 1 https://github.com/djyt/cannonball.git

Necesitamos libboost, eso lo primero. Concretamente, te vale con libboost-dev
sudo apt-get -y install libboost-dev --no-install-recommends
AL ACABAR DE COMPILAR, PUEDES DESINSTALAR LIBBOOST:
sudo apt-get -y purge libboost-dev && sudo apt-get -y autoremove && sudo apt-get -y clean

mkdir build
cd build
cmake ../cmake -DTARGET=pi4-opengles.cmake -DCMAKE_BUILD_TYPE=Release

-Copiamos el ejecutable "cannonball" a ~/outrun
-Creamos el directorio ~/outrun/roms y metemos ahí las ROMs del OutRun de MAME descomprimidas.
(Si te falta una eprom, es del SET B)
-Copiamos el directorio "res" que viene con los sources a ~/outrun/res
-Movemos res/config.xml a ~/outrun (es decir, lo sacamos de ~/outrun/res y lo movemos a ~/outrun, para que el ejecutable lo encuentre).
-Editamos config.xml a nuestro gusto.
-Hacemos un "touch hiscores.xml" para que no se queje de que no existe.
-La música custom va en wav, en ~/outrun/res, y sólo tienes que activarla en el config.xml

Si al ejecutarlo te sale que no encuentra las SDL, mira con un ldd sobre el ejecutable, y si efectivamente no las encuentra, es que las has instalado
en una ruta que no está en los path que usa el sistema para buscar libs en tiempo de ejecución.
Así que ejecuta sudo lddconfig -v y echa un vistazo. Mírate la parte de los apuntes de SDL1.2.x

Si te da un segfault al salir, quita la llamada a renderer->disable() de Video::~Video() en src/main/video.cpp, ya que no pinta nada en un destructor... Y pon esa llamada a renderer->disable() en quit_func(), que está en src/main/main.cpp

Si no quieres que ande bajando el volúmen de los WAVs, usa los que tienes que ya tienen el volúmen bajado, y vete a Audio::load_wav en
src/main/sdl2/audio.cpp y deja entre el LockAudio y el UnlockAudio sólo esto:

SDL_LockAudio();

	wavfile.data = (int16_t*) data;
	wavfile.length = length / 2;
	wavfile.pos = 0;
	wavfile.loaded = 2;

	resume_audio();

SDL_UnlockAudio();

============CLONAR UN REPOSITORIO DE GITHUB USANDO EL NUEVO Y ASQUEROSO SISTEMA DE PERSONAL ACCESS TOKENS (PAT)===============

git clone --depth 1 https://<TOKEN_DE_MIERDA>@github.com/vanfanel/ppsspp.git

Así ya no necesitamos meter username, ni contraseña, ni nada, al hacer updates.

============ACTUALIZAR UN REPOSITORIO DE GITHUB USANDO EL NUEVO Y ASQUEROSO SISTEMA DE PERSONAL ACCESS TOKENS (PAT)===============

-Creamos un token nuevo. Para ello, nos vamos a la foto de perfil de github (arriba a la derecha),
settings -> developer settings -> personal access tokens
y generamos el token de los cojones. Es una cadena de caracteres de mierda. La copiamos y la guardamos.
NO LA USES COMO PASSWORD, TE DEJA HACERLO UNA VEZ Y LUEGO YA NO VALE Y TIENES QUE GENEARAR OTRA.

-Nos metemos en el reposiorio que queremos actualizar y hacemos:
git remote remove origin

-Ahora le metemos un origin nuevo que incluya nuestro token, así:
git remote add origin https://vanfanel:<TOKEN_DE_MIERDA>@github.com/vanfanel/LBE_DOCS.git

-Ahora ya podemos actualizar con git push las veces que quieras desde tu copia local ese repo.

************Actualizar repositorio github****************************************************************************************

Lo primero es poner la fecha: el formato es

sudo date mes|día|hora|minuto

Actualizamos en la copia local así:

git add .
git commit -m "made some changes"

Y ahora subimos los cambios:

git remote add origin git@github.com:yourusername/yourreponame.git
git push origin master

la primera línea sólo es necesaria si es la primera vez que voy a subir algo (??)
De todos modos, en ~/.gitconfig tengo:

[user]
          name  = vanfanel
          email = redwindwanderer@gmail.com

y sólo me pide el nombre de usuario (vanfanel) y el password (Manuel22) al hacer el push, y va sin problemas.

GIT REWIND
Si queremos modificar cosas de n proyecto de alguien, hacemos un fork a mi git de ese proyecto, clonamos mi fork en local,
y luego publicamos los cambios en mi fork y hacemos un Pull Request.
Si metemos la pata y queremos dejar mi fork como cuando lo creé, hacemos
git reset HEAD^ --hard
git push -f origin master

************Deshacer un commit que hemos hecho mal*****************************************************************************

Para deshacernos del último commit, suponiendo que no hemos hecho aún un push, sencillamente:
git reset --soft HEAD~ 

************Deshacer un push que hemos hecho mal********************************************************************************

Nos vamos al branch donde queremos corregir el push:
git checkout master

Lo ponemos en el último commit bueno:
git reset --hard cc4b63bebb6

Hacemos un push forzado:
git push -f origin master

Y listo. Ya hemos vuelto en local y en el server al último commit/push bueno.

************Actualizar MI FORK con los cambios del repo original del proyecto (upstream)*********************************************

Lo primero añadimos un remote que vamos a llamar upstream como podríamos llamarlo pepito, pero para entendernos:

git remote add upstream https://github.com/libsdl-org/SDL.git

Ahora descargamos todos los branches de upstream:

git fetch upstream

Nos aseguramos de estar en el branch master de nuestro fork. Seguramente ya estaremos ahí de todos modos..

git checkout main
(si falla, cambia main por master, pero se tiende a que todo sea main)

Hacemos que nuestro fork pase a tener todo lo de upstream: lo convertimos en una copia limpia de upstream, vamos.

git reset --hard upstream/main
(lo mismo: si falla, cambia main por master)

Hacemos un push forzado a mi repo para que efectivamente quede como el upstream:

git push -f origin main
(lo mismo: si falla, cambia main por master)

Hacemos los cambios que tengamos que hacer....

<edit files...>

Hacemos commit de los cambios

git add .
git commit -m "blah blah blah"

Hacemos un push forzado a nuestro fork:

git push -f origin main
(lo mismo: si falla, cambia main por master)


Y luego ya haríamos el pull request.

SQUASHEAR TODOS LOS COMMITS DE UN PULL REQUEST EN UN SOLO COMMIT
================================================================

Suponiendo que estamos en el branch donde hemos hecho los commits, que en este ejemplo se llama "cursor_constraint", hacemos:

git reset --soft master
git add .
git commit -m  "Add pointer constraint functionality."
git push -f origin cursor_constraint

MODIFICAR UN COMMIT DEL PASADO (QUE YA HEMOS PUSHEADO Y TODO)
=============================================================

LO PRIMERO, NO DEBEMOS HABER CLONADO EL REPO CON "--depth 1" PORQUE ENTONCES NADA DE ESTO FUNCIONA.

Empezamos un rebase. El número 2 es el número de commits que vamos a retroceder desde el actual, pueden ser los que queramos.
Un rebase lo que hace es presentarnos en un editor los commits, y el que queramos cambiar lo pasamos de "pick" a "edit":

git rebase -i HEAD~2

Ahora hacemos los cambios o correcciones que queramos en ese commit...Y una vez hechos los cambios, hacemos:

git add .
git commit --amend

Y ahora finalizamos el rebase así, y ya quedamos en el último commit que hicimos:
git rebase --continue

Ahora si queremos subimos los cambios con:
git push -f origin master

============PROBAR UN PULL REQUEST QUE AÚN NO SE HA MERGEADO===============

Clonamos el repo que sea.

Ahora hacemos:
git fetch origin pull/<NUMERO_DE_PR>/head:<NOMBRE_NUEVO_BRANCH>
git checkout <NOMBRE_NUEVO_BRANCH>

Y ya estaríamos en el nuevo branch con los cambios del PR.
NOTA: En lugar de <NOMBRE_NUEVO_BRANCH> podemos poner el nombre del branch principal (MAIN, MASTER, lo que sea)
y de ese modo no se nos crea un nuevo branch y no hace falta que hagamos el checkout.

HACER PULL REQUESTS EN EL LUS QUE SE VEAN DESDE EL SOH
======================================================

Se supone que hemos hecho unos cambios en el LUS, y queremos que se vean desde el SOH para probar que compilar y que funcionan bien.

PARTE LUS
---------

En github, forkeamos el proyecto original, y en nuestro fork, creamos un nuevo branch, que vamos a llamar "remove_glew_windows"

Ahora ya empezamos con git en nuestra máquina local.
--Clonamos nuestro fork:
git clone https://<PAT>@github.com/vanfanel/libultraship.git
--Nos colocamos en el nuevo branch:
git checkout remove_glew_windows
--Hacemos los cambios que queramos, y los subimos al branch:
git add .
git commit -m "Remove remains of GLEW on Windows."
git push origin remove_glew_windows
--Nos vamos a github y creamos el Pull Request, verificando tras hacerlo que compila para todas las plataformas.

PARTE SOH
---------

En github, forkeamos el proyecto original, y en nuestro fork, creamos un nuevo branch, que vamos a llamar "remove_glew_windows"
Ahora ya empezamos con git en nuestra máquina local.
--Clonamos nuestro fork, incluyendo sus submódulos ya que LUS es un submódulo de SOH:
git clone --recurse-submodules https://<PAT>@github.com/vanfanel/shipwright.git
--Nos colocamos en el nuevo branch de SOH:
git checkout remove_glew_windows
--Nos vamos al directorio libultraship, y añadimos nuestro fork de LUS como remote (llamamos al remote "vanfanel" pero lo podríamos llamar pepito)
  y lo descargamos:
cd libultraship
git remote add vanfanel https://github.com/vanfanel/libultraship.git
git fetch vanfanel
--Nos colocamos en el nuevo branch de LUS:
git checkout remove_glew_windows
--Nos salimos a SOH, y subimos los cambios al nuevo branch de SOH:
git add .
git commit -m "Remove remains of GLEW on Windows."
git push origin remove_glew_windows

************DESCARGAR DE CDROMANCE**************************************************************************************************************

Nos vamos a la ficha del juego en cdromance.com, buscamos su CDR_TICKET, nos vamos a cdromance.org, y lo pegamos allí. ¡Listo!

************RECUPERAR PARTIDAS EN EL GABRIEL KNIGHT DE SCUMMVM**********************************************************************************

A los datos del juego les falta el archivo
VERSION
Con el contenido
01.100.000

Sin este archivo, podrás salvar pero luego no te deja recuperar la partida porque dice que es de otra versión. Así que lo creamos a mano y listo.

************Otro caso práctico de git: actualizar mi master branch al master de upstream, luego ponerme en otro branch y merger mi branch master actualizado en el branch secundario*********

O sea, el objetivo es actualizar mi branch secundario de manera que quede con los cambios del branch master de upstream. Mi branch secundario es dispmanx.

-Añado el upstream. Lo llamo upstream como lo podría llamar pepito:

git remote add upstream https://github.com/scummvm/scummvm.git

Ahora descargamos todos los branches de upstream:

git fetch upstream

Nos aseguramos de estar en el branch master de nuestro fork. Seguramente ya estaremos ahí de todos modos..

git checkout master
o si dice que no encuentra el archivo:
git checkout origin/master

Ahora hacemos el merge del master de upstream con nuestro master:

git merge upstream/master

Ahora nos ponemos en el branch que realmente queremos actualizar:

git checkout dispmanx

...Y hacemos el merge de nuestro branch master sobre nuestro branch dispmanx:

git merge master

Ahora ya haríamos el push al branch dispmanx:

git push origin dispmanx

...Y quedaría probar a compilar y ver qué desaguisados se han montado debido al merge!

************Arreglar texto de commits en github************************************************************************************

Nos ponemos en el branch donde están los commits que queremos cambiar:

Hacemos lo que se llama un rebase interactivo, que nos sacará un editor para cambiar el texto de los commits.

git rebase -i origin/HEAD
(o bien git rebase -i origin/HEAD~3 si quisiéramos incluir los 3 commits anteriores por debajo de HEAD, o sea, commits que ya no son de mi fork sino que ya venían. Con HEAD sin más
debería valernos)

Cambiamos pick por reword en cada mensage que queramos cambiar, pero NO los cambiamos aún.

Cerramos el editor, y nos saltará una edición por cada commit que hayamos marcado con reword. Cambiamos, ahora si, el texto de cada uno.

Hacemos un push forzado:

git push --force origin/dispmanx

https://help.github.com/articles/changing-a-commit-message/

************Probar un pull request (PR) que no ha sido mergido en mainline aún******************************************************

git fetch origin pull/213/head:pr-213
git checkout pr-213

...donde 213 es el número de PR, obviamente.

************Renombrar ficheros del directorio actual de mayúsculas a minúsculas*****************************************************

for SRC in `find ./ -depth`
do
    DST=`dirname "${SRC}"`/`basename "${SRC}" | tr '[A-Z]' '[a-z]'`
    if [ "${SRC}" != "${DST}" ]
    then
        [ ! -e "${DST}" ] && mv -T "${SRC}" "${DST}" || echo "${SRC} was not renamed"
    fi
done

*************MiniVMAC en GNU/Linux******************************************************************************************

NOTAS PREVIAS:

-La info sobre los modos de vídeo de los modelos de Mac fue sacada de:
http://adb.arcadeitalia.net/lista_mame.php buscando por el fabricante Apple y des-marcando la casilla "MameCab only".

El primer Mac (Macintosh 128), usa un modo de vídeo de 512x342@60.14742 Hz.
El primer Mac en color (Macintosh II) usa 640x480@66.662467

El Lemmings no suena bien con vsync activado (es decir, si le pasas PRESENTVSYNC a SDL_CreateRenderer),
incluso si la frecuencia de refresco es la correcta del host es la correcta (66.662467 Hz, ya que salió para Mac II).

El Prince sólo va bien en modo de 60Hz la versión con la velocidad arreglada que hay en este hilo:
https://forum.princed.org/viewtopic.php?t=3009
(Está al final de la tercera página del hilo, lo tienes en el disco de backup también)

EL EMULADOR EN SÍ:

Clonamos los sources de:
git clone --depth 1 https://github.com/minivmac/minivmac.git

Para SDL2:

-t larm -api sd2 -var-fullscreen 0 -fullscreen 1 -speed 1

luego he editado src/MYOSGLUE.c y he cambiado el bpp de SetVideoMode() de 8 a 16.
Para la velocidad original del Macintosh plus, tendrías que poner "-speed z"

Compilar con los flags en el makefile así:
mk_COptions = -c -Wall -Wmissing-prototypes -Wno-uninitialized -Wundef -Wstrict-prototypes -O2 -march=native -mtune=native

Para hacerte un HFV con juegos y programas, bájate los system disks de la 6.0.8 de aquí:
http://www.gryphel.com/c/sw/system/sys60/index.html
Sigue este tutorial de aquí (tienes que extraer los .data antes de conseguir "System Startup" y "System Additions", usando stuffit para Linux):
http://www.emaculation.com/forum/viewtopic.php?t=6801&mobile=on
El Stuffit para Linux es una versión vieja precompilada para i386 pero nos vale:
http://web.archive.org/web/20060205025441/http://www.stuffit.com/downloads/files/stuffit520.611linux-i386.tar.gz

Luego BORRA por completo el disco del Dark Castle, que es como formatearlo. Para ello arranca el MiniVMac con ambos discos de instalación metidos,
para lo cual le pasas ambos como parámetro, y el disco duro:

./minivmac DC.hfv System\ Startup System\ Additions

Instalas el system 6.0.8 en el disco recién formateado, luego copias el Dark Castle y el Beyond DC, metes los juegos que quieras y listo.
Pero vamos, lo mejor es que no pierdas la imágen HFV...

************MiniVMAC en X86*****************************************************************************************************

Para generar el tar con los sources para Linux X64 paso estas opciones:
-t lx64 -api sdl

*************Cómo usar pkg-config y dpkg******************************************************************************************

Estas herramientas hacen cosas distintas, pero pueden llegar a ser complementarias.
pkg-config se usa mucho en los scripts de configuración, para obtener los flags y localizaciones de librerías necesarias para compilar un 
programa contra una librería determinada. Así, por ejemplo, para compilar un programa que va a usar glib2.0, tendremos que saber contra que librerías 
por nombre vamos a linkarlo y qué rutas para includes hay que pasarle (parámetros -l<nombre_librería> y -I<ruta_includes>, recuerda, está explicado más abajo.)  

Por ejemplo, si hacemos: 
manuel@vader:~$ pkg-config --libs glib-2.0
-lglib-2.0  
manuel@vader:~$ pkg-config --cflags glib-2.0
-I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include  

pk-config usa los archivos .pc que instalan los paquetes de programas al ser instalados con dpkg (o indirectamente con apt-get, que a su vez usa dpkg). 
El nombre que tenemos que pasarle a pkg-config es sin prefijo lib, pero por si acaso, puedes mirar el nombre del .pc del paquete en cuestión.
Podemos ver mediante locate que tenemos .pc en: 
/usr/lib/pkgconfig/
/usr/share/pkgconfig/
/usr/lib/x86_64-linux-gnu/pkgconfig/
Se supone que la variable de entorno $PKG_CONFIG_PATH tiene estas rutas pero yo no lo veo, así que mirando estos directorios y tirando de locate
es como he sacado el nombre exacto que hay que pasarle a pkg-config.
Al no encontrar el configure el resultado de pkg-config, lo que se nos sugiere es exportar la información de "pkg-config --cflags glib-2.0" y de
"pkg-config --libs glib-2.0" a variables de entorno que el script leerá, $GLIB_CFLAGS y $GLIB_LIBS. Es fácil saber qué ponemos a cada variable:
GLIB_CFLAGS="-I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include"
GLIB_LIBS="-lglib-2.0"

Para saber qué paquetes tenemos instalados, por ejemplo cuando queramos hacer limpieza, hacemos "dpkg -l" que se puede combinar con grep
para buscar unas y otras cosas.

MUY IMPORTANTE: podemos localizar en qué paquete está un fichero, de manera que podemos eliminar el pquete en cuestión. Se hace con
"dpkg -S stdio.h" o con "dpkg -S /usr/include/stdio.h".

*************Cómo hacer que el directorio actual siempre esté en el PATH, para no tener que escribir ./archivo *******************

Edita ~/.bashrc y añade la línea
PATH=$PATH:.

*************Obtener información sobre los paquetes*******************************************************************************

Para conocer la versión, developer, maintainer. etc, de un paquete antes de instalarlo (o instalado), podemos hacer "apt-cache show <nombre_paquete>",
donde nombre_paquete puede ser una parte del mismo. Es muy útil si tenemos varias versiones del mismo paquete (con distinto maintainer, una libre
y la otra no, distintas versiones...) y queremos saber cuál instalar.
 
*************Extraer archivos .sit de mac en Linux***********************************************************************************

te bajas esta cosa : http://web.archive.org/web/20060205025441/http://www.stuffit.com/downloads/files/stuffit520.611linux-i386.tar.gz
y con unstuff lo haces.

*************Los parámetros y flags de GCC y del linker******************************************************************************
Cuando falle una compilación (porque no se encuentra un fichero de cabecera en un include o porque no se encuentra algo que debería estar
definido en un fichero que cabecera que no se ha incluído)

-l<nombre_librería> : Indica contra qué librería se va a linkar por el nombre de librería, sin el prefijo lib: por ejemplo, -lmath, -lSDL... Los nobres
los puedes sacar con un simple ls a /usr/lib o a donde esté la librería. Si no está en /usr/lib, acuérdate de darle la ruta de sus includes y de sus
binarios, parámetros que se explican a continuación.

-I<directorio> : Es una i latina mayúscula. añade el directorio a los paths de búsqueda de los includes para el compilador. A partir de ese momento, ya podemos usar rutas
relativas para hacer includes de los ficheros de cabecera de ese directorio, en plan #include <GLES/gl.h> en lugar de tener que hacer 
#include "/opt/vc/include/GLES/gl.h". Como lo normal es que los programas vengan con includes con rutas relativas, esto suele ser necesario.

-L<directorio> : añade el directorio a los de búsquera de librerías dinámicas del linker, o sea que es un parámetro para el linker. Por ejemplo, para
linkar cualquier programa que use las SDL2, lo que se hace es usar sdl2-config para obtener en qué directorios buscan las SDL2 las librerías que 
usan sus backends: en el caso de la Raspberry Pi, si compilas un programa que use las SDL2, las SDL2 a su vez usan librerías que están en /opt/vc/lib, 
por lo que de un modo u otro, al programa que intentas compilar hay que pasarle la ruta de esas librerías para que las encuentre en tiempo de
linkado. Así que si dicho programa no usa sdl2-config a la hora de configurar el linker, le tienes que pasar la ruta de las librerías nativas de la Rpi a mano.
Sin ser tan extremos, cualquier programa que use unas librerías dinámicas contra las que se vaya a linkar que no estén en /usr/lib, necesita este 
parámetro para encontrarlas. 

-D<nombre macro>: define (o sea, activa) una macro del preprocesador. Si por ejemplo hacemos en un programa:
#ifdef DEBUG
	fprintf (fp, "...");
#else
	....
#endif
y luego hacemos "gcc -DDEBUG", estaremos activando esa macro en compilación y se hará en fprintf.

-rpath=<path> (O lo que es lo mismo, -Wl,-rpath,<ruta>    , la explicación de esto es que -Wl nos permite pasar una serie de parámetros y sus valores, separados
por comas).
Esto sirve para pasar la ruta de manera que el ejecutable resultante busque una librería en esa ruta en tiempo de ejecución (que es DISTINTO al tiempo de
linkado: o sea que UN PROGRAMA PUEDE ENCONTRAR UNA LIBRERÍA EN TIEMPO DE EJECUCIÓN PERO NO ENCONTRARLA EN TIEMPO DE LINKADO,
O VICEVERSA!)
A veces nos encontraremos con ejecutables que podemos linkar bien contra librerías que luego no encuentrar en tiempo de ejecución.
LO PRIMERO es hacer un ldd al ejecutable y confirmar que dicha librería aparece como NOT FOUND.
Esto es porque, aunque le pases con -L<ruta> la librería que quieres que encuentre en linkado, para que la encuentre en tiempo de ejecución necesitarías
pasarle "-Wl,-rpath,<ruta>".
Aunque lo normal es que no tengas que hacer esto tampoco, sino que la librería esté en una ubicación donde el sistema busque por defecto.
Para asegurarnos de esto, hacemos "ldconfig --verbose", y se actualizarán los directorios donde se buscan las librerias que usan los programas.
Así que si has instalado una librería pero no la encuentra un programa en tiempo de ejecuciçon, puedes pasarle el -rpath o hacer un ldconfig y listo.


*************DISTCC se cuelga en el cliente (Rpi) en el punto en que va a reintentar una compilación localmente y no da el error***********

-En el servidor, inicia el servidor distcc como: 
sudo /etc/init.d/distcc start --verbose
-En el cliente, si es la Rpi, no te olvides de ponerle un swap con
sudo swapon /dev/sda1


*************Qué librerías usa un ejecutable****************************************************************************************

ldd <nombre_del_ejecutable>

*************VanillaConquer: Command and Conquer en GNU/Linux***********************************************************************

Notas previas:
-El C&C original se llama "tiberian dawn". Así que el ejecutable es vanillatd, mientras que vanillara es para el RED ALERT.
-El juego usa OpenAL, busca las instrucciones para instalarlo antes.

Clonamos el repo con:
git clone --depth 1 https://github.com/TheAssemblyArmada/Vanilla-Conquer.git

Editamos common/video_sdl2.cpp y:
-En SDL_CreateRenderer() añadimos el flag SDL_RENDERER_PRESENTVSYNC.

Configuramos y compilamos con:

mkdir b4
cd b4

cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native" ..

make -j4

Creamos el directorio ~/cconquer, y metemos ahí los datos del juego.

Copiamos el ejecutable (vanillatd para el C&C original, o vanillara para el RED ALERT) al directorio del juego, y listo!

La primera vez que ejecutemos vanillatd o vanillara, se nos creará .config/vanilla-conquer/[vanillatd|vanillara]/conquer.ini
(A NO SER que tengamos un conquer.ini entre los datos del juego, en cuyo caso lo primero es borrar ese conquer.ini).
Editamos ese conquer.ini y ponemos Scaler a "linear", el ratio a 4:3, etc.

**********************SonicMania Decomp en GNU/Linux********************************************************************************

NOTA: Si tienes algún problema en GNU/Linux con este engine, entra en discord y cita a Mephiles, que es un dev y usuario
de Linux, y a Stxtic que es el desarrollador principal de la parte de frontend.

-Instalamos otra dependencia previa: GLFW, que solo va sobre Wayland, no tiene backend KMS/DRM.
	---Dependencia previa: apt-get install --no-install-recommends extra-cmake-modules
	---Nos bajamos la última estable de GLFW de: https://www.glfw.org/
	---Configuramos, compilamos e instalamos GLFW:
	mkdir b4
	cd b4
	cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=1 \
	-DGLFW_BUILD_WAYLAND=1 -DGLFW_BUILD_X11=0 -DGLFW_BUILD_EXAMPLES=0 -DGLFW_BUILD_TESTS=0 \
	-DCMAKE_C_FLAGS="-DEGL_NO_X11 -march=native -mtune=native"

-Instalamos otra dependencia previa: LIBTHEROA, que si la instalamos desde APT nos instala CAIRO, que a su vez depende de
las mierdas de X11. (Nosotros instalamos un CAIRO sin X11 a mano porque el metacompositor WLROOTS usa CAIRO).
	--Nos bajamos la última estable: wget https://downloads.xiph.org/releases/theora/libtheora-1.2.0.tar.xz
	--Configuramos, compilamos e instalamos:
	CFLAGS="-march=native -mtune=native" CXXFLAGS="-march=native -mtune=native" \
	./configure --build=aarch64-unknown-linux-gnu --disable-examples --disable-encode --disable-sdltest
	make -j4
	make install

--VAMOS A POR EL JUEGO EN SI:

--Clonamos el repo (incluye tanto el juego como el engine):
git clone --recursive --depth 1 https://github.com/Rubberduckycooly/Sonic-Mania-Decompilation.git
--Editamos dependencies/RSDKv5/RSDKv5/RSDK/Audio/Audio.hpp y dejamos la línea:
#define MIX_BUFFER_SIZE (0x800)
como:
#define MIX_BUFFER_SIZE (0x200)

--Configuramos y compilamos asi:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native" -DCMAKE_CXX_FLAGS="-march=native -mtune=native"

Copiamos RSDKv5 a ~/sonicmania:
cp dependencies/RSDKv5/RSDKv5U ~/sonicmania/

Copiamos libGame.so a ~/sonicmania/Game.so:
cp libGame.so ~/sonicmania/Game.so

Metemos Data.rsdk también en ~/sonicmania

Como el juego sólo soporta gamepads y no joysticks en general, para que reconozca el mando de N64 (Saffun) en modo XBOX360 y el adaptador de SNES:
creamos en ~/sonicmania el fichero "gamecontrollerdb.txt" con el contenido:
030000005e0400008e02000072050000,Xbox 360 Controller,platform:Linux,crc:b881,a:b0,b:b2,x:b1,y:b3,back:b8,start:b6,leftshoulder:a2,rightshoulder:b5,dpup:h0.1,dpdown:h0.4,dpleft:h0.8,dpright:h0.2,misc1:b7,leftx:a0,lefty:a1,
03000000412300003680000001010000,LLC Arduino Leonardo,a:b0,b:b1,x:b2,y:b3,back:b6,start:b7,leftshoulder:b4,rightshoulder:b5,dpup:-a1,dpdown:+a1,dpleft:-a0,dpright:+a0,platform:Linux,

RECUERDA que estas cadenas de los mandos para el "gamecontrollerdb.txt" se sacan de la utilidad "controllermap" que viene
en el directorio "tests" de los sources de SDL2.

-Para tener shaders(las instrucciones originales son de https://github.com/Rubberduckycooly/RSDKv5-Decompilation/blob/master/dependencies/ogl/README.md#shaders):
	---Creamos el directorio mods/GLShaders/Data
	mkdir -p ~/sonicmania/mods/GLShaders/Data
	---Creamos mods/modconfig.ini con este contenido:
	[Mods]
	GLShaders=y
	---Dentro de mods/GLShaders creamos mod.ini con este contenido:
	Name=GLShaders
	Description=GL3 shaders to enable filters and stuff
	Author=Ducky
	Version=1.0.0
	TargetVersion=5
	---Clonamos este repo: git clone --depth 1 https://github.com/Rubberduckycooly/RSDKv5-Decompilation.git
	---Copiamos el directorio de Shaders del repo que acabamos de clonar al directorio Data del mod:
	cp -R ~/src/RSDKv5-Decompilation/RSDKv5/Shaders ~/sonicmania/mods/GLShaders/Data/
	---NOTA: Si el mod no carga, podemos activar el dev menu añadiendo "devMenu=1" en Settings.ini, en la sección [Game],
	y desde ahí nos deja activar los mods que tengamos instalados. Esto lo que hace en realidad es crearnos el fichero
	mods/modconfig.ini que hemos creado a mano antes, pero por si acaso pues aquí queda anotado.

Ajustes del juego:

-Editamos Settings.ini, que el juego crea en el mismo directorio donde tengamos el ejecutable, y allí:
----Ponemos "windowed" a "n" (OJO: exclusiveFS no hace nada en Wayland, es para X11, DirectX, etc. Desactívalo también).
----Ponemos "disableFocusPause" a "y", no necesitamos que se pause al hacer Alt+TAB.
----Ponemos "faceButtonFlip" a "y", para que la X y el O en el mando actuen como esperamos para confirmar y cancelar.

NOTAS ADICIONALES SOBRE EL ENGINE:

--SI NECESITAS EXTRAER LOS DATOS DE UN .RSDK, USA ESTO: https://github.com/MainMemory/RSDKv5Extract/releases
  FUNCIONA CON MONO, NO LO INTENTES HACER FUNCIONAR CON WINE PORQUE NO VA.	
--SE PUEDE COMPILAR SIN GLFW, USANDO SDL2 EN SU LUGAR, PASÁNDOLE A CMAKE "-DRETRO_SUBSYSTEM=SDL2", PERO ENTONCES NO HAY SHADERS.

--(!!!)SE PODRÍA COMPILAR CON PORTAUDIO EN LUGAR DE USAR EL AUDIO DE SDL2 (NO APORTA NINGUNA VENTAJA USAR PORTAUDIO). PARA ELLO:
-----Instalamos manualmente PORTAUDIO (Se podría instalar desde APT pero tiene a su vez dependencias que no queremos).
	 Para ello:
     ---Bajamos su última release estable de aquí: https://github.com/PortAudio/portaudio/releases
     ---Configuramos e instalamos con:
 	     mkdir b4
 	     cd b4
 	     cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_FLAGS="-march=native -mtune=native" -DPA_USE_JACK=OFF
     ----CONFIGURARÍAMOS EL ENGINE ASÍ, ES DECIR, SIN DECIRLE QUE USE EL AUDIO DE SDL2: 
	     cmake .. -DCMAKE_BUILD_TYPE=Release \
         -DCMAKE_C_FLAGS="-march=native -mtune=native" -DCMAKE_CXX_FLAGS="-march=native -mtune=native"

*************SONICCD EN EL ENGINE RSDK5*******************************************************************************************

-Cogemos el ejecutable RSDKv5U y lo copiamos en ~/soniccd

-Cogemos el fichero "SonicCDu.rsdk" del Sonic Origins y lo copiamos en ~/soniccd con el nombre "Data.rsdk" 

-Clonamos este repo: git clone --depth 1 https://github.com/Rubberduckycooly/Sonic-CD-2011-Script-Decompilation.git
 Y copiamos el directorio "Scripts" a ~/soniccd/

-En Settings.ini ponemos "datafile=SonicCDu.rsdk" y ponemos "gameType=1", porque estamos usando los datos de la versión ORIGINS.

-Metemos los mods que queramos en ~/soniccd/mods, y los cargamos desde el "dev menu" (tienes que tener "devMenu=y"
en Settings.ini y darle a ESC para acceder a él)
Tienes el mod de audio y vídeo del Sonic CD para RSDKv5U en el disco duro de backup, ya preparado.
Con el mod de shaders cargado, para elegir el shader simplemente entra en el DEV MENU, selecciona el shader que quieras,
ponte en "Confirm" y dale a ALT, y así se queda salvado.

		***SOLO NECESARIO PARA VOLVER A CREAR EL MOD DE AUDIO Y VIDEO: SECCIÓN PARA RECREAR EL MOD DE AUDIO Y VÍDEO DEL SONIC CD EN RSDKv5U***

Vamos a crear un MOD que nos permite que suenen los efectos de sonido, las músicas y se vean los vídeos del juego.
Esto es necesario porque el .rsdk del SonicCD versión Origins no incluye estas cosas dentro.

-Creamos los directorios ~/soniccd/mods/CD_FMVS_RSDKv5/Data

-Extraemos los datos del .rsdk del SonicCD versión 2011 usando:
https://github.com/MainMemory/RSDKv5Extract/releases
y copiamos los directorios "Music" y "SoundFX" a ~/soniccd/mods/CD_FMVS_RSDKv5/Data
(Nos faltará un fichero llamado "DropDash.wav", que viene en los datos del SonicMania. No te hace falta porque el SoniCD
no lo va a usar, pero si quieres pues lo puedes sacar del .rdsk del Sonic Mania).

-Copiamos los vídeos en OGV escalados a 1024x512 en ~/soniccd/mods/CD_FMVS_RSDKv5/Data/Videos
(se tienen que llamar, con sus mayúsculas y minúsculas: "Opening.ogv", "Bad_Ending.ogv", "Good_Ending.ogv", "Pencil_Test.ogv").
-Metemos los audios de los vídeos en OGG de 44100Hz en ~/soniccd/mods/CD_FMVS_RSDKv5/Data/Music.
Se tienen que llamar como los vídeos pero con extensión .ogg

-Ahora vamos a retocar los scripts para que se reproduzcan los vídeos en OGV con audio OGG externo
(es la única manera de tener los vídeos con su música).
Para ello, copia estos ficheros de ~/soniccd/Scripts a ~/soniccd/mods/CD_FMVS_RSDKv5/Data/Scripts
(tienes que crear sus directorios, claro):
Title/Select.txt
R8/FadeScreen.txt
Menu/LoadSaveMenu.txt
Menu/MenuControl.txt
Menu/ExtrasMenu.txt
Y ahora los vamos modificando. La idea es sencilla: Donde veas una carga de un vídeo, como por ejemplo:
LoadVideo("Opening")
...Lo sustituyes por un bloque así que carga su .ogg antes:
SetMusicTrack("Opening.ogg", 0, 0)
PlayMusic(0)
LoadVideo("Opening")

-Por último, creamos ~/soniccd/mods/CD_FMVS_RSDKv5/mod.ini con este contenido:
Name=CD_FMVS_RSDKv5
Description= Sonic CD FMVs that work with RSDKv5U
Author=Vanfanel
Version=1.1
TargetVersion=3
TxtScripts=1

Y ya sólo es cargar el mod desde el dev menu (tienes que tener "devMenu=y" en Settings.ini y darle a ESC para acceder a él),
reiniciar con el mod cargado y debería ir.

NOTA: SI NO TE VA EL MANDO, mira que no tengas más de un mando en gamecontrollerdb.txt.

INFO POR SI TIENES QUE VOLVER A PREPARAR LOS VÍDEOS Y LA MÚSICA DE LOS VÍDEOS:

Extraer sólo el audio de la versión de PC (el RSDKv5 necesita audio en 44100 pero los vídeos de PC vienen en 48000):
ffmpeg -i Opening.ogv -vn -ar 44100 Opening.ogg

Extraer sólo el vídeo de la versión de PC, escalándolo a 1024x512 que es lo que necesita el RSDKv5:
(Pongo la calidad de vídeo a 9 porque a 10 sale un frame corrupto al principio)
ffmpeg -i Opening.ogv -q:v 9 -vf scale=1024:512 -an Opening.ogv

*************Sonic 3 AIR en GNU/Linux*********************************************************************************************
(PENDIENTE: Que librmx compile contra libglew del sistema en vez de contra la mierda de libglew reducido que lleva)

--Nos bajamos los últimos sources de: https://github.com/Eukaryot/sonic3air/tags

--Editamos Oxygen/sonic3air/build/_cmake/CMakeLists.txt, buscamos la línea:
find_package(OpenGL REQUIRED)
...Y justo encima ponemos:
set(OPENGL_USE_OPENGL ON)
...Y buscamos todas las ocurrencias de "OpenGL::GL" y las cambiamos por "OpenGL::OpenGL"

--Editamos librmx/source/rmxmedia/_glew/GL/glew.h y borramos todo el bloque /*----GLU----*/

--Compilamos con:
cd ./Oxygen/sonic3air/build/_cmake

mkdir b4
cd b4

cmake -DCMAKE_BUILD_TYPE=Release -DSDL_SHARED=ON ..
make -j10

*************HYDRA CASTLE LABYRINTH EN GNU/Linux**************************************************************************************

Clonamos su repo:

git clone --depth 1 https://github.com/ptitSeb/hydracastlelabyrinth.git

Editamos src/sdl2/graphics.c y allí:
-Añadimos SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
-SÓLO SI NO TIENES VRR:
-----Quitamos la sección de "implement some crude frameskiping" y el "while" con el SDL_Delay() que hay al final de la función,
     ya que al no tener VRR queremos que todo el juego se sincronize con el VSYNC.
-----En la llamada a SDL_CreateRenderer(), añadimos SDL_RENDERER_PRESENTVSYNC

-Para controlarlo mejor con teclado usando Z y X, editamos src/sdl2/input.c, y dejamos las líneas:
case SDLK_x:        bFaceDown = w; break;
case SDLK_s:        bFaceLeft = w; break;
Así:
case SDLK_z:        bFaceDown = w; break;
case SDLK_x:        bFaceLeft = w; break;
O si quisiéramos usar controles más estilo MSX, con SPACE y CTRL, podríamos hacer:
case SDLK_LCTRL:        bFaceDown = w; break;
case SDLK_SPACE:        bFaceLeft = w; break;
(OJO! Hay que borrar otra línea con SDLK_SPACE que hay debajo, que es redundante porque podemos entrar en el menú usando ESC).

Editamos src/sdl2/audio.c y:
-Cambiamos el 4096 en Mix_OpenAudio() por 1024.

Compilamos con:

mkdir b4
cd b4

cmake -DUSE_SDL2=ON -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" ..

make -j4

Copiamos el directorio data que viene con los sources al mismo directorio donde metamos el ejecutable.

Para que se ejecute en modo fullscreen, sin cambiar resolución, sin escalado XBRZ y con escalado 1x, ejecutamos con:
./hcl -f -d -x1 --no-xbrz

CÓMO TENER VELOCIDAD CORRECTA CON VRR

Si tenemos VRR, como el juego utiliza el VSYNC para sincronizarse, el juego irá a toda hostia.
Así que editamos "src/sdl2/graphics.c", buscamos la función "PHL_EndDrawing" y al principio de la función añadimos:

uint32_t tnext = tframe + 1000/60;

...Y al final añadimos:

while((tframe = SDL_GetTicks())<tnext)                                                                                         
	SDL_Delay(10);

...lo hemos sacado de la versión de la función "PHL_EndDrawing" de SDL1.x (que está en "src/sdl/graphics.c") ya que en SDL1.x
no hay VSYNC y se sincroniza con timings internos como tenemos que hacer con VRR. 

*************CELESTE nativo en GNU/Linux**************

Clonamos su repo:
git clone --depth 1 https://github.com/lemon32767/ccleste.git

Editamos el Makefile, y en la línea de las CFLAGS quitamos el -g y ponemos los flags de la Pi4, que son:
-march=native -mtune=native -O2

Editamos sdl12main.c y allí:
-Comentamos toda la sección donde aparece SDL_Delay(), todo el bloque de principio a fin.

Editamos sdl20compat.inc.c y allí:
-En SDL_Flip(), duplicamos el bloque:
  SDL_RenderClear(sdl2_rendr);
  SDL_RenderCopy(sdl2_rendr, sdl2_screen_tex, NULL, NULL);
  SDL_RenderPresent(sdl2_rendr);
(Para que el juego vaya a 30FPS pero sincronizados con el VSYNC).
-Añadimos como único flag SDL_WINDOW_FULLSCREEN_DESKTOP a SDL_CreateWindow(), quitamos cualquier otro que haya.
-Añadimos antes de la llamada a SDL_CreateRenderer(): SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
-Añadimos estos flags a SDL_CreateRenderer(): SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC

Compilamos, y copiamos el ejecutable a ~/celeste/
Copiamos también el directorio "data" que viene con los sources a ~/celeste/

Lo lanzamos con:
CCLESTE_START_FULLSCREEN=1 ./ccleste

Se sale con la tecla DELETE

*************MightyMike en GNU/Linux*********************

git clone --recurse-submodules --depth 1 -j8 https://github.com/jorio/MightyMike.git

Editamos src/Heart/Window.c y allí metemos todo el bloque de
SDL_UpdateTexture, SDL_RenderClear, SDL_RenderCopy y SDL_RenderPresent dentro de esta condición:
if (gSDLTexture && gSDLRenderer) { }

Configuramos y compilamos:
mkdir b4
cd b4

cmake .. \
-DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native"

Copiamos el ejecutable MightyMike y el directorio "Data" que viene con los sources a ~/mightymike

*************Nanosaur en GNU/Linux*********************

Clonamos su repo:

git clone --recurse-submodules --depth 1 https://github.com/jorio/Nanosaur.git

Configuramos y compilamos:
mkdir b4
cd b4

cmake .. \
-DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native"

Copiamos el ejecutable Nanosaur y el directorio "Data" que viene con los sources a ~/nanosaur

*************Commander Genius en GNU/Linux*************

Podemos bajarnos una release (lo más recomendado), la última de aquí:

https://gitlab.com/Dringgstein/Commander-Genius/-/releases

O si decidimos clonar el repo, se requieren tres pasos:

git clone --depth 1 --recurse-submodules -j8 https://gitlab.com/Dringgstein/Commander-Genius.git

creamos un directorio de compilación y entramos en él:
mkdir b4
cd b4

Ahora configuramos:

cmake .. -DUSE_OPENGL=0 -DDOWNLOADER=OFF -DUSE_VIRTUALPAD=OFF -DDISABLE_HOVER=ON -DUSE_BOOST=OFF -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native"

Ya sólo es hacer make -j4 en el directorio de compilación y debería ir.

El resultado queda en src/CGeniusExe

Nos creamos ~/keen
Ahora editamos ~/.CommanderGenius/cgenius.cfg, y dejamos el primer searchpath así:
SearchPath1 = ${HOME}/keen
Ahora, creamos ~/keen/games, y metemos el directorio keen1 (que contrendrá los archivos del keen1) ahí, en ~/keen/games/keen1
Y ya lo tiene que ver el cargador.

Si queremos lanzar un juego directamente sin pasar por el lanzador, es con:
./CGeniusExe dir=games/keen1

Y si quieres tener música en keen1, gráficos mejorados, etc... te vas al directorio hqp que viene con los sources de gitlab,
y copias el directorio hqp/global a ~/keen, y luego lo que hay en hqp/keen1 a ~/keen/games/keen1,
lo que hay en hqp/keen2 a ~/keen/games/keen2, etc...

También puedes editar cgenius.cfg, y poner EnableLogfile=false para que no te genere un log en HTML cada vez que se ejecuta el juego.

*************Doomretro en GNU/Linux*************************************************************************************

Bajamos la última stable de https://github.com/bradharding/doomretro/releases

Si queremos que la resolución interna sea 320x200:
Entramos en src, editamos doomdef.h y ponemos SCREENSCALE a 1.

Si por el contrario dejamos que se renderize en alta resolución, pasamos "-nosplash" al ejecutable para que no salga el splash screen,
ya que sólo sale en alta resolución.

Editamos el Makefile y añadimos en OPTFLAGS: "-march=native -mtune=native", y quitamos el -g.
Compilar y listo.

En doomretro.cfg, ponemos:
vid_scalefilter a "linear"
gp_thumbsticks 2 si tenemos dos analógicos, y gp_sensivity_horizontal a 32 (la mitad que la vertical, vamos, que si no
es imposible apuntar bien en horizontal).

La música tiene que ir en un WAD (no valen PK3 ni movidas de esas) y tienen que estar los .ogg, los .mp3 o los .flac ahí dentro sin estar en ningún directorio ni nada, con sus extensiones y nombres originales. Y debes haber compilado SDL_Mixer con soporte para ogg o flac, claro.
Vengo usando estas músicas, que ya vienen en WAD y todo listas: https://zandronum.com/forum/viewtopic.php?t=97

Para usar el SIGIL, usa la versión COMPAT del WAD, y créate otro WAD a parte con la música en MP3, OGG o lo que sea, tal como se indica
en el párrafo anterior.

Para el 8Bitdo receiver, los botones son:
bind gamepad4 +fire
bind gamepad3 +use
bind leftshoulder +tun
Cuidado particularmente con no tener ya puesto leftshoulder a alguna otra función!

*************Problemas 8BITDO SN30******************************************************************************************

¡Tienes que encenderlo (START) y emparejarlo (SELECT) cada vez que cambias de modo!
Se cambia de modo apagando el mando (mantener START pulsado), y luego se entra en los diferentes modos al encenderlo:
START+B es el modo Dinput y es el único modo que te interesa. 
Los demás son:

B + START : Dinput mode, for Android devices or PC
X + START : Xinput mode, for PC
Y + START : Switch mode
A + START : MacOS mode, for Apple computers (NOT PHONES/TABLETS)

*************Abbaye des morts************************************************************************************************

Clonamos su repo:
git clone --depth 1 https://github.com/nevat/abbayedesmorts-gpl.git

Editamos src/main.c, y ponemos fullscreen = 1 y grapset = 1, y en Mix_OpenAudio() ponemos el tamaño de buffer a 1024 o 512.

Compilamos con:
make PLATFORM=rpi4_64 -j4

Para hacerlo funcionar, copiamos estos directorios que vienen con los sources al mismo directorio donde metamos el ejecutable:
data graphics screenshots sounds xcf

Puedes asignar el botón en src/base.h
Para usar el 8bitdo SN30, usa JUMP_BUTTON 0.

*************System Shock en la Pi con Shockolate****************************************************************************

Clonamos su repo:

git clone --depth 1 https://github.com/Interrupt/systemshock.git

Creamos el directorio de compilación, entramos, configuramos y compilamos:
cd systemshock
mkdir b4
cd b4
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_FLAGS="-march=native -mtune=native" -DENABLE_SDL2=ON -DENABLE_SOUND=ON -DENABLE_FLUIDSYNTH=ON -DOpenGL_GL_PREFERENCE=GLVND ..
make -j4

Ahora creamos ~/sshock y ahí dentro:
Copiamos el directorio shaders que viene con los sources a ~/sshock/shaders
Metemos los datos del juego en ~/sshock/res/data

Ejecutamos con:
./systemshock -nosplash

*************Chocolate DOOM en GNU/Linux**********************************************************************

Usamos el branch sdl2-branch, que clonamos con:

git clone --depth 1 -b sdl2-branch https://github.com/chocolate-doom/chocolate-doom.git 

Editamos src/i_video.c y cambiamos 
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "nearest"); 
por 
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");

Ahora editamos configure.ac ponemos el optimization level a 3 y quitamos y el -g que encontremos.
Ahora configuramos con 
CFLAGS="-march=native -mtune=native" CXXFLAGS="-march=native -mtune=native" ./configure
NO LE PASES el -O2 al script de configuración: ya lo has puesto en el configure.ac.

Compilamos con
make -j8 V=1
Verificamos que no hay -g, que se compila con -O2 y que los flags de cpu son correctos.
Listo!

NOTA: La opción de configuración de los gráficos en chocolate-setup peta. Da igual.

**************ACTUALIZAR MESON***************************************************************************************************

sudo apt-get purge meson
sudo apt-get purge ninja-build
sudo apt install python3-pip --no-install-recommends
sudo pip install -U ninja
sudo pip install -U meson
PATH="/usr/local/bin:$PATH"

Si nos da el error ese de "This environment is externally managed", editamos /etc/pip.conf y añadimos:
[global]
break-system-packages = true

**************Regenerar caché LDD************************************************************************************************

sudo rm /etc/ld.so.cache
sudo ldconfig

**************SWAP de emergencia*************************************************************************************************

Algunos sistemas, como la Raspberry Pi, no usan swap normalmente porque nos cargaríamos la SD rápido.
Así que, si necesitamos un swap de emergencia para algo concreto, como compilar o linkar un programa grande que por razones de falta de 
RAM no se puede compilar en la Pi ni con distcc (esto suele pasar con el linkado, que siempre se hace de manera local), lo mejor es usar un swap
de emergencia en un disco duro mecánico, conectado por USB. Es tan simple como esto:

mkswap /dev/sdx
swapon /dev/sdx

También podemos hacer un archivo de swap si no queremos cargarnos una partición:

dd if=/dev/zero of=/path/to/swapfile bs=1M count=1024 # For 1GB swap file
swapon /path/to/swapfile

Al acabar con el swap, siempre

swapoff <device>

si no queremos colgar el sistema.

Podemos comprobar cómo se usa la swap con "free" mientras se linka.

**************Establecer un modo de vídeo "al vuelo" en GNU/Linux con KMS/DRM***************************************************

modetest -M vc4 -s 32:640x480 -d

El truco está en el "-d", que hace que modetest "suelte" el master (drop master) con lo que el siguiente programa aparece en
el modo que le hayamos dicho mientras modetest esté corriendo.

**************Text to speech en GNU/Linux con ESPEAK****************************************************************************

Nos bajamos la última release estable de:
https://github.com/espeak-ng/espeak-ng/releases

Configuramos con:
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native" -DCMAKE_C_FLAGS=="-march=native -mtune=native"

ALTERNATIVA: flite

apt-get install flite --no-install-recommends

flite -voice slt -t "hello pal"
(Para ver la lista de voices es con -vl)

**************Rise of the Triad en GNU/Linux************************************************************************************

Usamos el sourceport "taradino".
-Clonamos su repo: git clone --depth 1 https://github.com/fabiangreffrath/taradino.git
-Compilamos con:

mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

-Creamos el directorio ~/rott y ahí metemos el ejecutable y los datos del juego.
Los archivos de datos que necesitas son:
darkwar.wad
darkwar.rtl
darkwar.rtc
remote1.rts

-Nos bajamos la fuente FluidR3_GM.sf2, y la metemos en el directorio ~/rott
(El juego la busca por defecto en "/usr/local/share/soundfonts", pero vamos, que es más cómodo tenerla en el mismo directorio del juego).

-Lanzamos el juego así para tener música (RECUERDA que hay que compilar el SDL2_Mixer con soporte para fluidsynth,
 para lo cual hay que tener fluidsynth instalado antes de compilar SDL2_Mixer):
SDL_SOUNDFONTS=./FluidR3_GM.sf2 ./taradino

-Si quieres poner la resolución a 320x200 o cosas así, lo más cómodo es editar ~/.local/share/taradino/darkwar/config.rot
 y ajustar allí lo que quieras.

		BLOQUE DE INTENTOS DE MOVIMIENTO SUAVE SIN VRR (NO VA BIEN, USA VRR O NADA)

-Editamos rott/isr.h y cambiamos el valor de VBLCOUNTER de 35 a 40 (queremos que el juego vaya a 40fps para poner el monitor a 40Hz!)
-Editamos rott/modexlib.c, buscamos la llamada a SDL_SetHint(), y cambiamos "nearest" por "linear".
-Dado que el juego corre a 40.0000FPS necesitamos ponernos en un modo de 40.0000Hz, así que lanzamos el juego así:
wlr-randr --output HDMI-A-1 --custom-mode 1920x1080@40                                                                                           
sleep 1                                                                                                                                          
SDL_SOUNDFONTS=/usr/local/share/soundfonts/FluidR3_GM.sf2 ./taradino                          
wlr-randr --output HDMI-A-1 --custom-mode 1920x1080@60

**************Tyrian en GNU/Linux con OpenTyrian********************************************************************************

-Clonamos su repo: git clone --depth 1 https://github.com/opentyrian/opentyrian.git

-Editamos src/video.c y añadimos SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear"); antes de la llamada a SDL_CreateRenderer()

-Editamos src/keyboard.c y comentamos entera la sección que dice "Show system mouse pointer if outside screen",
que es simplemente un SDL_ShowCursor() que sobra totalmente.

-Editamos src/opentyr.c y comentamos la llamada a intro_logos()

Compilamos con:
CFLAGS="-march=native -mtune=native" CPPFLAGS="-march=native -mtune=native" make WITH_NETWORK=false -j4

Metemos el ejecutable "opentyrian" en ~/tyrian, y los datos del juego en ~/tyrian/data,
y ejecutamos con:
opentyrian --data=data

Puedes bajar el original de:
https://exodos.the-eye.us/public/eXo/
Los archivos originales de DOS vienen todos en mayúsculas, los puedes pasar a minúsculas con:
sudo rename 'y/A-Z/a-z/' * 

			BLOQUE VÍDEO SUAVE SIN VRR

Editamos src/nortsong.c y en la función setDelaySpeed() dejamos delayPeriod = 0
(Con esto conseguimos que no se espere a ningún timer interno).

Editamos src/video.c, y allí:
-Repetimos la secuencia de llamadas:
       SDL_RenderClear(main_window_renderer);
       SDL_RenderCopy(main_window_renderer, main_window_texture, NULL, &dst_rect);
       SDL_RenderPresent(main_window_renderer);
(Con esto conseguimos que cada frame se pinte dos veces, con lo que el juego va a la mitad de frames que nuestro modo de vídeo,
así que irá a unos 30FPS suaves que no está mal).
-Añadimos SDL_RENDERER_PRESENTVSYNC a SDL_CreateRenderer()

**************Extraer datos de CUALQUIER ejeculable*******************************************************************************

Usa Universal Extractor:
https://github.com/Bioruebe/UniExtract2/releases

Es de Windows, usa WINE.

**************CONEXIÓN PERMANENTE AL IRC******************************************************************************************

Para OFTC: https://riot.im/app/#/room/#_oftc_#apertium:matrix.org
Para LIBERA: https://riot.im/app/#/room/#libera-matrix:libera.chat

Nos conectamos (tienes cuenta allí).

Para cambiar de nick es con !nick, para entrar en un canal es !join #canal, etc...
No sé cómo ver quién está en el canal, para eso hay que entrar en paralelo desde el IRSSI.

**************VIM autocompletion**************************************************************************************************

Ya era hora de tener esto pasado a un fichero de texto!

Instalamos exhuberant-ctags, que es el programa que genera paquetes de tags a partir de ficheros de cabecera:

sudo apt-get install exuberant-ctags

Creamos el directorio donde vamos a guardar los paquetes de tags generados a partir de los ficheros de cabecera:

mkdir -p ~/.vim/tags

Nos bajamos el plugin de VIM para autocompletion de aquí:
(si lo cambian de sitio, busca eso, el plugin de VIM para autocompletion)

http://www.vim.org/scripts/script.php?script_id=1520 

Lo mandamos a ~/.vim, y lo descomprimimos ahí con unzip omnicpp*zip. Nos crea directorios y tal, como un mini-sistema vim.

Nos bajamos también las cabeceras de C++ standard de aquí, para poder generar sus tags:

http://www.vim.org/scripts/script.php?script_id=2358 

Las descomprimimos en ~/.vim también, por ejemplo, con tar xvjpf cpp_src.tar.bz2

..y estando en ~/.vim, empezamos a generar los paquetes de tags:

ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ --sort=1 -f tags/INC /usr/include
ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ --sort=1 -f tags/STL cpp_src
ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ --sort=1 -f tags/SDL /usr/include/SDL
ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ --sort=1 -f tags/BCM /opt/vc/include   
(Esta de BCM es para la Rpi, dispmanx y tal)

Ahora, dejamos el /etc/vim/vimrc.local de esta guisa:

=====================================================

syntax on

" Para que no nos cargue los valores por defecto si no existe ~/.vimrc                                         
let g:skip_defaults_vim = 1 

" Para que NO nos transforme 8 espacios en un TAB
set noexpandtab

set number
set ls=2
set sw=1
set noswapfile

filetype plugin on
set tags+=~/.vim/tags/INC
set tags+=~/.vim/tags/STL
set tags+=~/.vim/tags/SDL
set tags+=~/.vim/tags/BCM

" para que se abra y se cierre automáticamente el menú desplegable de preview e info  
au CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif
set completeopt=menuone,menu,longest,preview

"para regenerar los tags de nuestro proyecto, los que no incluimos de base, con F12 
map <F12> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .<cr><cr>

"para desactivar la autoinserción de comentarios, que es lo que nos jode cuando copiamos código desde el navegador
"Es fundamental que esté colocada esta línea después de la de filetype plugin on,
"porque esa línea activaría de nuevo la autoinserción.
autocmd FileType * setlocal formatoptions-=c formatoptions-=r formatoptions-=o

colo torte

set encoding=utf-8                     "Estas líneas son para poder poner tildes, eñes y demás. 
setglobal fileencoding=utf-8

" Esto es para que no entremos en modo VISUAL al usar un ratón desde SSH
set mouse-=a

" Esto es para cambiar entre buffers. Para cambiar entre ventanas (vimdiff) es con CTRL+W.
" Es para cuando se tienen dos ficheros abiertos a la vez. La exclamación es para poder cambiar entre buffers sin guardar cambios.
map <S-w> :bnext!<cr>

" tap indent movement 
vmap <Tab> >gv
vmap <S-Tab> <gv

" para que cuando estás en modo visual y mueves el texto con < y >, no se pierda la selección.
vnoremap < <gv
vnoremap > >gv

" Para que VIM no cree ficheros raros si no cerramos un fichero, que son una molestia.
set nobackup       "no backup files
set nowritebackup  "only in case you don't want a backup file while editing
set noswapfile     "no swap files

" Para que VIM recuerde la última posición
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

===========================================================

Y cambiamos el ownership de ~/.viminfo al usuario, ya que viene como propiedad del root y así no funciona lo que pongas en vimrc.
Y si aún así no funciona, comenta todo lo que has puesto en ~/.vimrc, debería funcionar. Entonces ve descomentando líneas y comprobando qué setting de .vimrc es el que
impide que funcione. Sí, esto me ha pasado.

===========================================================

Para que VIM no entre en modo VISUAL cada vez que pinchamos con el ratón, editamos /usr/share/vim/vim90/defaults.vim y
cambiamos
set mouse=a
por
set mouse-=a
(O SIMPLEMENTE BORRAMOS TODA ESA SECCIÓN!!!)

SI NO SABES dónde se está configurando lo del mouse, haz:
:verbose set mouse
y te lo dirá.

**************Traducir en tiempo real la consola desde una codificación distinta de UTF-8 a UTF-8***************************************

Por ejemplo, en este caso nos conectamos por telnet a un servidor que "emite" en ISO-8859-1, y de este modo vemos tildes y todo:

luit -encoding ISO-8859-1 telnet rlmud.org

**************Abrir varias ventanas en VIM y cambiar entre ellas***********************************************************************

Con el comando Sex (ESC, : Sex, Enter) y luego se cambia entre ellas con CTRL+ww
También podemos partir la ventana en dos con CTRL+ws y luego cambiar entre ellas!

**************Convertir archivos de DOS a UNIX**************************************************************************************

Para procesar todo un árbol de directorios quitando esos ridículos ^M de los documentos que generan los tontos que usan Windows:

find ./ -name '*.cpp' | xargs dos2unix

**************VIM con color en la TTY***********************************************************************************************

Tan simple como crear .vimrc en mi carpeta de usuario y añadir

syntax on
set number

**************Compilar un programa que da errores en la fase de linkado porque no encuentra las librerías********************************

Si da errores de que no encuentra los ficheros de cabecera de las librerías, tendremos que añadir -I<ruta de los  .h que necesita> a los CFLAGS 
y/o a los CXXFLAGS. Esto sería un error de compilación, no un error en el linkado. No te confundas.

Si lo que pasa es no encuentra las liberías en el linkado ("undefined reference"), tendrás que añadir, en teoría, -L<ruta de la librería> a los LDFLAGS.

**************Localizar dónde está instalada una librería******************************************************************************

ldconfig -p

**************Script que procesa varios ficheros, en este caso canciones, y las va reproduciendo******************************************
#!/bin/bash

PLAYER="omxplayer -o hdmi"
PLAYLIST="play.pls"

# Play arguments on command line if they exist
if [ $# -ne 0 ]
then
    for file
    do
        $PLAYER "$file"
    done
    exit
fi

# Play the playlist if it exists
if [ -e "$PLAYLIST" ]
then
    IFS=$'\012'
    for file in $(cat "$PLAYLIST")
    do
        $PLAYER "$file"
    done

# Play the directory structure otherwise
else
    for file in *
    do
       $PLAYER "$file"
    done
fi 


***************Compilar e instalar un programa que usa unas librerías que están instaladas en una ubicación no estándar******************

Para compilar las librerías, habremos hecho:

./configure --prefix=/home/manuel/sidplay
make -j5
make install

...con lo que acabaremos con las librerías en /home/manuel/sidplay/lib

Y para compilar el programa que las usa, en este caso un sid player, lo que le decimos es dónde está el archivo .pc de la librería, NO dónde está
la propia librería:

PKG_CONFIG_PATH=/home/manuel/sidplay/lib/pkgconfig ./configure --prefix /home/manuel/sidplay/

(En este caso concreto, el player se empeña en compilar con PULSEAUDIO, así que alteramos el script "configure", NO el Makefile, ojo, para cambiar a pkg_failed a yes justo antes
de la parte de script que lo comprueba, ya que no hay manera de desactivarlo de otra manera).
Le podríamos anteponer también la variable de entorno LDFLAGS, para decirle al linker dónde están las librerías contra las que tiene que linkad el ejecutable, 
con lo que quedaría:

LDFLAGS+=-L/home/manuel/sidplay PKG_CONFIG_PATH=/home/manuel/sidplay/lib/pkgconfig ./configure --prefix /home/manuel/sidplay

PERO esto es redundante, ya que dentro del fichero .pc de las librerías que compilamos antes, y que le pasamos mediante PKG_CONFIG_PATH, ya
sabe el linker dónde están esas librerías.
No nos sirve LDFLAGS como solución para decirle dónde están las librerías en tiempo de ejecución, ya que LDFLAGS es sólo para indicarlo en
tiempo de compilación. En tiempo de ejecución no nos quedará más remedio que usar LD_LIBRARY_PATH, como siempre, ya que está definido en el 
sistema cuáles son las localizaciones donde pueden estar las librerías, y NO es el ejecutable el que las busca.

Ahora: 

make -j5
Y para ejecutar

LD_LIBRARY_PATH=/home/manuel/sidplay/lib ./sidplayfp <tema>.sid
 
***************Rogue en Linux**************************************************************************

Descarga los últimos sources de
git clone --depth 1 https://github.com/gillesdami/rogue.git

Antes de nada, instala las libncurses5-dev, antes de hacer el configure.
sudo apt-get install libncurses5-dev --no-install-recommends

Ahora actualiza el config.guess, que el que trae el rogue es viejo y no detecta bien el sistema:
wget 'http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD' -O config.guess

Configurar y compilar:
CFLAGS="-O2 -march=native -mtune=native" ./configure
make -j4

Ayuda de teclas con shift+?

Puedes pasarle un nombre de jugador, un archivo de salvado, etc.. usando la variable de entorno ROGUEOPTS. Como por ejemplo así:
ROGUEOPTS="name=Manuel,file=manuel.save" ./rogue.bin -r

***************ClassicRogue en GNU/Linux*****************************************************************

Nos bajamos los últimos sources del correo electrónico (busca "rogue") o del disco duro de backup.
El fichero se llama "Source_SDL_JS_Rogue Linux with Makefile.zip"

Lo descomprimimos (puedes descomprimir el .zip sin miedo, queda todo en un directorio).

Editamos shared/shared.cpp y:
-En la llamada a SDL_CreateWindow(), añadimos el flag: SDL_WINDOW_FULLSCREEN_DESKTOP
y justo antes añadimos: SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
-En la función InitInterface() comentamos la línea:
atexit(ShutdownInterface)
-Vamos a la función os_get_input() y justo antes añadimos el prototipo:
void ShutdownInterface(void);
Y justo antes de "exit(0);" ponemos la llamada: void ShutdownInterface(void);

***************Borrar un archivo con nombre que contiene caracteres extraños*****************************

Lo primero, buscamos su inode:
ls -il

(el número largo que aparece a la izquierda del todo es el inode de cada archivo)

Ahora, usamos find para encontrarlo por inode y borrarlo

find . -inum 14071947 -exec rm {} \;

Si el problema es que el archivo lleva un par de guiones al inicio de su nombre, lo que hacemos es:

rm -- --*

ya que el primer -- indica a rm que no se le van a pasar mas parámetros, por lo que ya no interpretaría el nombre del
archivo como tales.

***************Configurar la salida de audio de la Raspberry para que use el jack*****************************

sudo amixer cset numid=3 1

Lo pones una vez y ya queda configurado en los valores de ALSA.

Y para el audio por HDMI otra vez:

amixer cset numid=3 2

***************Gestión avanzada de acceso a ficheros en Linux********************************************

Para ver qué procesos tienen algún fichero abierto en un directorio, a quién pertenecen, etc:

lsof +D /var
lsof +D /etc
...

Para ver los números de los procesos que tienen algún fichero abierto en un directorio, a quién pertenecen, etc:

lsof -t +D /var
lsof -t +D /etc
...

Para matar los procesos que tienen algún fichero abierto en un directorio:

lsof -t +D /var | xargs kill
lsof -t +D /etc | xargs kill
...

Para matar todos los procesos de un usuario:

killall -u <usuario>

Para matar todos los procesos lanzados por un proceso (por ejemplo todos los procesos lanzados por un script):

pkill -P <PID_del_proceso_padre>

Por ejemplo, yo mato todos los procesos lanzados por el proceso con PID 1, que es mi script mínimo de inicio, con:

pkill -P 1

***************Sidplay no encuentra /dev/dsp*************************************************************

sudo modprobe snd-pcm-oss 

***************Sacar copia de seguridad del sistema*******************************************************

Del rootfs. Si hay partición de arranque, va a parte.

sudo tar -cvpzf backup.tar.gz --exclude=/backup.tar.gz --one-file-system /

Y para restaurar:

sudo tar -xvpzf backup.tar.gz -C /media/whatever --numeric-owner

***************Bajarse los sources de un programa en Debian***********************************************

Lo primero que necesitamos es una entrada de sources en el /etc/apt/sources.list, del tipo:

deb-src http://mirrordirector.raspbian.org/raspbian/ wheezy main contrib non-free rpi

Hacemos un 

sudo apt-get update

Y luego ya podemos hacer 

apt-get sources timidity

NO HAY que ser root para hacer esto, ya que los sources NO se instalan sino que se descargan en el directorio actual y ya.

****************Bajarse los sources de un kernel en debian/ubuntu******************************************

Pongamos que uname -r te dice que usas el kernel

linux-image-3.4.0-1490-omap4

Entonces, para bajarte los sources de ese kernel, haces:

apt-get source linux-image-3.4.0-1490-omap4

Si estás compilando justo este kernel, al compilar los módulos te dira no sé qué.
Deactiva CONFIG_BINFMT_AOUT y vuelve a compilar.

-Podemos extraer una configuración de un kernel previo con

./extract-ikconfig ~/panda/boot/uImage > ~/panda/.config

O bien podemos crear una muy básica que arranca, por ejemplo, en todos los OMAP, con

make ARCH=arm omap2plus_defconfig

make ARCH=arm menuconfig 

-Compilamos el kernel

make -j4 ARCH=arm CROSS_COMPILE=~/x-tools/arm-unknown-eabi/bin/arm-unknown-eabi-  uImage

-Compilamos los módulos del kernel:

make -j4 ARCH=arm CROSS_COMPILE=~/x-tools/arm-unknown-eabi/bin/arm-unknown-eabi- modules

-E instalamos los módulos:

sudo make ARCH=arm modules_install INSTALL_MOD_PATH=/media/manuel/LINUX/

-Y lo mismo el kernel:

sudo cp arch/arm/boot/zImage /media/manuel/BOOT/


****************Extraer la configuración de un kernel*******************************************************

Para extraer un .config de un kernel que sabemos que funciona, en el directorio scripts de los kernel sources tenemos un script apropiado que funciona así:
./extract-ikconfig ~/panda/boot/uImage > ~/panda/.config

****************INSTALAR GLMARK2****************************************************************************

Instalamos dependencias previas:
apt-get install libpng-dev libjpeg-dev

Clonamos su repo:
git clone --depth 1 https://github.com/glmark2/glmark2.git

Configuramos con:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" CXXFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Dflavors=drm-glesv2,gbm-glesv2,wayland-glesv2 ..

***************INSTALAR VKMARK*******************************************************************************

Instalamos dependencias previas:
apt-get install libglm-dev libassimp-dev --no-install-recommends

Clonamos su repo:
git clone --depth 1 https://github.com/vkmark/vkmark.git

Configuramos con:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" CXXFLAGS="-march=native -mtune=native" \
meson setup .. -Dbuildtype=release

***********Recuperar un archivo corrupto de Abiword u otro procesador de textos que se niega a abrir*********

Nos instalamos ipython 

sudo apt-get install ipython

Y vamos haciendo las siguientes cosas, una por línea:

data = open('current_events.abw', 'r').read()

from lxml import html

doc = html.fromstring(data)

doc

print ''.join(doc.xpath('//text()'))

Listo. Lo copiamos de la consola a un editor en condicioes y arreglado.
(Sacado de http://stephenmw.wordpress.com/2011/01/18/abiword_recovery/)


********Instalar FSV, el navegador de archivos en 3D****************

Clonamos el repo
https://github.com/mcuelenaere/fsv
e instalamos: 
sudo apt-get install libgtk2.0-dev
Ya sólo queda un -/config y make, y a correr.

*********Averiguar qué paquete contiene un archivo dado***************

dpkg -S filename

*********************Versión que tenemos instalada de un paquete******

dpkg -l |grep libgbm-dev

*********************Buscar un archivo recursivamente a partir de un punto del sistema de ficheros***********

find ./ -name '*gtk*'

************Tabla de permisos de Unix*****************

Esto lo deberías tener en la cabeza, pero se te suele olvidar.
Las tres posiciones de los números corresponden con OWNER, GROUP (del owner) y OTHER USERS.
Y los valores de los números son decimales de tres bits. Estos tres bits pueden estar activos o inactivos (¿no me digas?) configurando así el valor.
Su órden es R, W, X. (Lectura, escritura y ejecución).
Así, si queremos que el propietario tenga permisos de ejecución y lectura, será un 101 binario, que inmediatamente sabemos que es un 5.
Si queremos que el grupo tenga permisos de lectura solamente, será un 100, que es un 4.
Y si queremos que el resto sólo tengan permisos de ejecución, será un 001, que es un 1.
O sea que haremos chmod 541 nombrearchivo y nos quedaremos tan anchos.

***************Escanear las Ips conectadas en red local (la misma del equipo en que estoy)***********************

nmap -sn 192.168.1.0/24

Esto escanearía las Ips conectadas a la red 192.168.1.x, que es lo que seguramente quieres hacer.
Fácil y muy, muy útil.

****************Arrancar Lubuntu en modo texto**********************

Editamos /etc/default/grub y añadir “text” a los parámetros de la línea  GRUB_CMDLINE_LINUX_DEFAULT

Ejecutamos sudo update-grub


******************El sistema se empeña en que tenemos 0 bytes free en partición EXT4*******

Borramos archivos pero no recuperamos el espacio!
Esto es porque se reserva un 5% por defecto para el root. Para cambiar esto, simplemente hacemos:

tune2fs -m 1 <device>

y de este modo sólo se reserva el 1%. Solucionado.

******************Cambiar el tamaño del texto y la fuente en la consola**********************

sudo dpkg-reconfigure console-setup

*******************Limpiar Lubuntu de los "procesos malditos", whoopsie y apport**********

Esta pareja de hijos de puta gusanos de la fundación Canonical se tiene que ir de cualquier sistema con Lubuntu que yo instale.
Así que empieza la fiesta del dpkg...

dpkg -r --force-depends apport-gtk
dpkg -r --force-depends apport
dpkg -r --force-depends whoopsie

y por último, aunque te suene raro, desinstalamos lubuntu-desktop porque el paquete queda con sus dependencias rotas y 
nos estaría avisando el gestor de paquetes en cada arranque si no lo desinstalamos:

dpkg -r --force-depends lubuntu-desktop

Ya veremos qué pasa si intento instalar algo que dependa de lubuntu-desktop.. si empiezan a fallar las cosas, es hora de
pasar a Debian.

*******************Autologin en modo texto en Lubuntu************************************

Con systemd. 
Sabemos que el fichero principal de la unit de getty@tty1.service está en:

/lib/systemd/system/getty@.service

Vale. Tenemos varias alternativas. Podemos editar /lib/systemd/system/getty@.service y cambiar lo que necesitemos, o podemos crear un drop-in, que es 
como un parche para cambiar cosas de la unit sin cambiar la unit. 
Vamos a hacer esto segundo, a usar un drop-in. Para ello, creamos el fichero (y los directorios precedentes si hiciese falta):

sudo vim /etc/systemd/system/getty@tty1.service.d/autologin.conf

Metemos en ese fichero esto:

[Service]
ExecStart=
ExecStart=-/sbin/agetty --autologin username --noclear %I 38400 linux

Salvamos, recargamos la configuración de los daemons:

systemctl daemon-reload

y reiniciamos el servicio:

systemctl start getty@tty1.service

Para ver que todo va bien, podemos hacer:

systemctl status getty@tty1.service

FALLO GORDO: que la ruta de agetty sea incorrecta. Si no lo es, no puede funcionar el servicio, lógicamente.
Así que comprueba que tienes /sbin/agetty y que efectivamente este ejecutable existe.

Añadimos una segunta tty que se lance automáticamente (los agetty sobre tty1, tty2, tty3, etc.. se lanzan por activación
de socket, pero sólo viene que se lance el primero, así que añadimos otra agettty sobre tty2):

-Creamos la UNIT para agetty sobre tty2:
sudo ln -sf /usr/lib/systemd/system/getty@.service /etc/systemd/system/getty.target.wants/getty@tty2.service

-Creamos eo drop-in override para autologearnos en tty2 también:

sudo vim /etc/systemd/system/getty@tty2.service.d/override.conf

con el contenido:
[Service]
ExecStart=
ExecStart=-/sbin/agetty --autologin manuel --noclear %I 38400 linux

-Recargamos settings y reiniciamos el servicio:
systemctl daemon-reload
systemctl start getty@tty2.service

Fuentes:

https://wiki.archlinux.org/index.php/Automatic_login_to_virtual_console
https://wiki.archlinux.org/index.php/Systemd_FAQ#How_do_I_change_the_default_number_of_gettys.3F

Para cambiar la fuente de letra, de momento hacemos setfont Lat15-TerminusBold24x12 en .bash_profile y listo.

Ya que estás, puedes quitar más mierdas:

sudo systemctl disable NetworkManager-wait-online
sudo systemctl disable apparmor
sudo systemctl disable ModemManager
sudo systemctl disable whoopsie
sudo systemctl disable apport

fuente:

http://www.samplerbox.org/article/fastbootrpi

INFO ANTIGUA DE ANTES DE SYSTEMD

Editamos /etc/init/tty1.conf y añadimos -a username a la línea donde se lanza la consola tty1. Quedaría así:

exec /sbin/getty -8 38400 tty1 -a <nombre_usuario>

******************Desactivar tap to click en el synaptics trackpad en Lubuntu*********************************************

Entramos en Preferences->Default Applications for LXSession->Autostart, y añadimos 

synclient MaxTapTime=0

bajo la categoría "Manually Autostarted Applications". Le damos a + y ya.

*****************Gestor de conexiones no aparece************************************************************

Añadir nm-applet en el mismo lugar que cabamos de mencionar, en Preferences->Default Applications for LXSession->Autostart

*******************Desactivar servicio de los que se lanzan en arranque en Lubuntu****************************

Es un poco distinto que en Debian. 
Modemmanager se quita con un apt-get install purge modemmanager.
Por ejemplo, para deshabilitar el network manager, movemos /etc/init/network-manager.conf a /etc/init/network-manager.conf-disabled

Para volverlo a habilitar, pues lo movemos donde estaba.

Otra manera es hacer 

sudo update-rc <nombre_servicio> disable

De hecho, lo mejor es hacer ambas.

Ahora tendrás que especificar la configuración de red a piñón en /etc/network/interfaces

iface eth0 inet static
address 192.168.1.35
netmask 255.255.255.0
gateway 192.168.1.1


Y NO TE OLVIDES de añadir eth0 a la linea auto, quedando

auto lo eth0

O si no, tendrás que andar haciendo a mano ifup eth0 en cada arranque. 
Y si ves que tienes salida a internet pero no resuelve nombres, tienes dos opciones:

1)

Añadir en el propio /etc/network/interfaces

dns-nameservers 208.67.222.222 8.8.8.8

El primero es el de OpenDNS, y el segundo el servidor DNS de google, o sea que mejor usar el primero.

2)

Deshabilitar el servicio resolvconf, moviendo /etc/init/resolvconf.conf a /etc/init/resolvconf.conf-disabled, 
para que /etc/resolv.conf no sea sobreescrito. 
Ahora ya sólo queda borrar /etc/resolv.conf que es un link duro a un fichero del servicio resolvconf (concretamente, antes de borrarlo vemos 
que /etc/resolv.conf -> ../run/resolvconf/resolv.conf, por si lo quieres restaurar), editar un nuevo /etc/resolv.conf y añadirle ahí nuestros servidores DNS:

nameserver 208.67.222.222 
nameserver 8.8.8.8

Mola más este segundo estilo, ya que lo dejamos todo más sencillo y más estándar.

****************Usar SUDO sin password***************************

Hacemos sudo visudo y la línea del grupo sudo la dejamos así:

%sudo ALL=NOPASSWD: ALL 

*****************Desactivar tarjeta gráfica ATI********************

En /etc/rc.local:

echo OFF > /sys/kernel/debug/vgaswitcheroo/switch

*****************Configurar un servidor SAMBA y un share. Montar el share.********************

En el servidor:

-Instalamos el paquete samba

sudo apt-get install samba

-Editamos /etc/samba/smb.conf
 En la sección [global] dejamos el workgroup por defecto y descomentamos la línea “security = user”, para que se puedan logar usuarios.

-Al final del fichero, añadimos un share. MUY IMPORTANTE, atento al nombre que le pones al share entre corchetes porque es el nombre que necesitas luego para acceder a él a través de la IP del servidor SAMBA.
Nosotros lo hemos llamado [biblio], porque contendrá la base de datos de este programa, para que distintas instancias a través de la red accedan a la misma base de datos.
Nos queda así nuestro primer share:

[biblio] 
    comment = Biblio Database
    path = /home/edu/database
    browsable = yes 
    guest ok = yes 
    read only = no 

-En este caso, el directorio del share no tenemos que crearlo porque ya lo crea la instalación del Biblio, pero si no, habría que crearlo.
Lo que sí tenemos que hacer es cambiarle el propietario y los permisos:

sudo chown nobody.nogroup /home/edu/database
sudo chmod -R 0777 /home/edu/database

En este caso lo he hecho para .wine y todos sus subdirectorios y funciona. Es un poco radical, pero había que resolver el tema.

Relanzamos el servidor SAMBA:

sudo restart smbd 
sudo restart nmbd 


En el cliente:

-Instalamos las cifs-utils
sudo apt-get install cifs-utils
-Ya deberíamos ser capaces de montar el share con

sudo mount -t cifs -o username=edu,password=marta //192.168.1.35/biblio fakebase/

-Habremos creado previamente el directorio fakebase dentro de la instalación local de Biblio (/home/vader/.wine/drive_c/Biblio/fakebase)
y habremos hecho un link simbólico (soft) al fichero Biblio.mdb de fakebase, de manera que cuando Biblio accede a su Biblio.mdb, en realidad lo hace al Biblio.mdb del share Biblio del servidor de ficheros SAMBA.
O sea que, estando en home/vader/.wine/drive_c/Biblio, hacemos un

ln -s fakebase/Biblio.mdb Biblio.mdb 

-Ahora podemos automatizar el montaje del share en los clientes, añadiendo a /etc/fstab las líneas:

#El servidor de ficheros con la base de datos de BIBLIO 
//192.168.1.35/Biblio /home/manuel/.wine/drive_c/Biblio/fakebase cifs username=corchetema,password=enfermera 0 0 

Por supuesto, para esto deberíamos tener una IP fija en el servidor.
No hace falta acceso sin user/pass ni nada, va bien así y no hay problemas especificando el user/pass en el fstab.

Y ya podemos dar de alta libros desde dos instancias del programa sobre la misma base de datos. Enjoy!

*****************************Error recalcitrante con “sdb write cache” en Lubuntu***************************

Es un problema de los drivers del lector de tarjetas. 
Ubuntu no hace caso a los parámetros que se le pasan a los módulos en /etc/modules e ignora las entradas en /etc/modprobe.d/blacklist.conf, así que al final tuve que añadir a /etc/rc.local la línea sudo rmmod ums_realtek. 


******************************Añadir repositorio en Ubuntu************************************************ 

sudo add-apt-repository <repo_address>

*****************************Cómo instalar pyrit + módulo CUDA (Nvidia) en Lubuntu************************

Lo primero que hay que tener claro que pyrit funciona por defecto usando la CPU, y que para que use la gráfica hay que instalar unas cosas de nvidia (además del driver propietario) y luego un módulo de pyrit para cuda.

Lo primero es instalar el driver propietario de NVIDIA, ya que nouveau NO VALE para esto:
sudo apt-get install nvidia-current

El siguente paso a lo mejor no es necesario, aunque yo lo hice. Probablemente todo esto se instale al instalar los cachivaches de nvidia:

sudo apt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libgl1-mesa-glx libglu1-mesa libglu1-mesa-dev

Instalamos python-dev y otras cosas:

sudo apt-get install python-dev 
sudo apt-get install libpcap-dev
sudo apt-get install libssl-dev 

Ahora instalamos las cosas de nvidia:

sudo apt-get install nvidia-cuda-dev
sudo apt-get install nvidia-cuda-toolkit

Hacemos el siguiente link simbólico, ya que libcuda se instala en una localización por defecto distinta de donde la buscará el módulo cuda de pyrit, y si no lo hacemos, no la encuentra, con el consiguiente error:

ln -s /usr/lib/nvidia-304/libcuda.so /usr/lib/libcuda.so

Nos bajamos el pyrit y los módulos:

wget http://pyrit.googlecode.com/files/cpyrit-cuda-0.4.0.tar.gz
wget http://pyrit.googlecode.com/files/pyrit-0.4.0.tar.gz

Empezamos instalando el módulo, entrando en el directorio de cpyrit-cuda y poniendo:

python setup.py build
sudo python setup.py install
Estas cosas no deberían darme ningún error. Si dice algo de unas cabeceras que hacen falta pero no se encuentran y continuing anyway, pasamos del tema.

Entramos en el directorio de pyrit y hacemos la misma:

python setup.py build
sudo python setup.py install

El binario de pyrit se instala en /usr/local/bin/pyrit, así que le hacemos un 

ln -s /usr/local/bin/pyrit /usr/bin/pyrit

Y ya debería estar. Lanzamos

pyrit list_cores

y deberíamos ver algo como:

The following cores seem available...
#1:  'CUDA-Device #1 'GeForce 9400''
#2:  'CPU-Core (SSE2)

Ahora lanzamos un 

pyrit benchmark

...y vemos si merece la pena o no...A la gente le da 3000 y pico, con máquinas decentes.

Ahora usamos el pyrit para romper una contraseña:

pyrit -r “84:9C:A6:A3:8E:8F-01.cap” -b "84:9C:A6:A3:8E:8F" -e "Orange-8E8D" -i <diccionario.txt> attack_passthrough

**************************Tirar el servidor gráfico (Xorg) en Lubuntu************************************

sudo service lightdm stop

y para volver, obviamente, start.

**********Configuración óptima de RetroArch (En Wayland)************

-VÍDEO
NOTA PREVIA: Aunque tengamos un monitor con AdaptiveSync/FreeSync/VRR,
no vamos a usar nunca "SYNC TO EXACT CONTENT FRAME" porque nunca va a ser tan suave como usar sólo VSYNC,
así que lo que hacemos es poner por defecto un modo de vídeo de 120Hz en el compositor, y usar VSYNC,
lo que nos va a permitir tener VSYNC de juegos de sistemas de ~60Hz sobe un modo de 120Hz con un refresco perfectamente suave
y sin el input lag inducido por el VSYNC al estar en 120Hz.
EN SETTINGS->VIDEO, ACTIVA "VSYNC" y DESACTIVA "SYNC TO EXACT CONTENT FRAME" Y PON "VIDEO->SYNCHRONIZATION->VSYNC SWAP INTERVAL" a "AUTO"
EN SETTINGS->VIDEO->OUTPUT, DEJA QUE SE DETECTE LA FRECUENCIA CORRECTA Y ESTABLÉCELA.
EN SETTINGS->AUDIO->SYNCHRONIZATION, PON "MAXIMUM TIMING SKEW" A UN VALOR ELEVADO COMO "0.300".

-AUDIO: driver ALSATHREAD, 48000 Hz, 32ms, resampler quality normal.
(IMPORTANTE!!! Si tienes VRR/AdaptiveSync, recuerda desactivar "Synchronization"!!!)
(Si usas otra frecuencia de audio, modifícalo también en las opciones del core FBNeo)

-SCALING: "Integer Scale" a "ON", con "Integer Scale Scaling" a "Smart".
(De lo contrario hay patrones en las scanlines que sólo se ven en fondos azulados o blancos, etc).

Para el core de SEGA, debido al tema del dithering y tal, tenemos varias opciones:

1) RECOMENDADO: El shader CRT-CONSUMER con "Pre-Scale Sharpening" a 1.00, "Convergence X" a 1.00, "Corner Size" a 0.00,
   "Mask Type" a 0, y "Vignette" a "1.00".
2) El shader CRT-LOTTES-FAST con el parámetro SHARPNESS puesto al mínimo (que es 1) y CRT GAMMA puesto a 3.40.
3) El shader ZFAST_CRT_COMPOSITE con los parámetros: CURVATURE a 0, CONVERGENCE X-AXIS al máximo,
   SCANLINE LOW a 0.10 y SCANLINE HIGH a 0.05, MASK EFFECT AMOUNT a 0.50, SATURATION a 1.10, y FLICKERING a 5.00. 
   Para evitar patrones de las scanlines, activa también en Settings->Video->Scaling el INTEGER SCALE y el INTEGER SCALE OVERSCALE,
   y sálvalo como un override pero sólo para MegaDrive (o sea, usando "Save Content Directory Override").
4) Una combinación de GDAPT (está entre los shaders "Dithering") y FAKELOTTES.
   Para ello, primero pon el número de pasadas a 2, en la pasada 1 carga el shader GDAPT PASS 0, y en la pasada 2 carga el FAKELOTTES.
   Para que las sombras en el Comix Zone no se vean tramadas sobre algunos colores, hay que ajustar algún parámetro.
5) El shader crt-Cyclon con los parámetros de convergencia al máximo. Lo malo de esta opción es que se ve un poco "granuloso" todo.

APUNTES SOBRE CORES ESPECÍFICOS:

PARA CORES DE ORDENADOR QUE NECESITAN TODO EL TECLADO, la idea es usar el "GAME FOCUS", para lo cual
NO DEBEMOS TENER ACTIVADO el "HOTKEY ENABLE", ya que son dos funcionalidades que se solapan
y si tuvieses ambas la "HOTKEY ENABLE" no funcionaría al tener activo el "GAME FOCUS" que dedica todas las teclas al core.
Así que hacemos esto:
-En Settings->Input, pon "Auto Enable Game Focus" a "Detect".
-En Settings->Input->Hotkeys, pon en "Game Focus (Toggle)" la tecla Windows ("lsuper" se llama).
-En Settings->Input->Hotkeys, NO PONGAS NINGUNA TECLA en "Hotkey Enable".

PARA EL CORE SWANSTATION, ACUÉRDATE DE PONER EL RENDERER DEL CORE EN "SOFTWARE" (No le eches la culpa al shader si hay audio dropouts)...
Y EL "CPU EXECUTION MODE" A "CACHED INTERPRETER" (Contrariamente a lo que parece, es más rápido que "RECOMPILER")
Y EL "CD-ROM SEEK SPEED UP" PON "INFINITE/INSTANTANEOUS"
Y RESPECTO AL RUNAHEAD:
--SI USAS EL RENDERER SOFTWARE, PUEDES ACTIVAR EL RUNAHEAD DE RETROARCH CON "USE SECOND INSTANCE"
(DE LO CONTRARIO HAY PROBLEMAS DE AUDIO).
--SI USAS EL RENDERER HARDWARE, USA EL RUNAHEAD INTERNO DEL CORE, EN CORE OPTIONS.
(DEBERÍAS USAR EL RUNAHEAD INTERNO DEL CORE DE TODOS MODOS AUNQUE USES EL RENDERER SOFTWARE).

PARA EL CORE PPSSPP Y PARA EL CORE FLYCAST, ACUÉRDATE DE QUITAR EL RUNAHEAD, O DARÁN ERRORES DE INSTRUCCIONES NO VÁLIDAS,
PANTALLAZOS A NEGRO, ETC...
Para ello, simplemente crea el archivo .config/retroarch/config/PPSSPP/PPSSPP.cfg
o el archivo .config/retroarch/config/Flycast/Flycast.cfg
con el contenido: run_ahead_enabled = "false

PARA EL CORE DE GB (Gambatte) y para el de GBA (mGBA), si usas RunAhead activa lo de "Use second instance", o tendrás pequeños droputs o
distorsiones de audio.
Para el Gambatte, además, sube Audio Latency a 40ms o usa ALSATHREAD, para evitar los típicos dropouts en en Mario Land al entrer en tuberías.
(Parece que hay algo raro en el buffering del audio en el core Gambatte...)

PARA EL CORE DE NES (NESTOPIA) USA LA PALETA "CXA2025AS", O LA CONFIGURACIÓN DE SHADERS SE VERÁ MUY RARA.
Si quieres usar el ratón como Zapper, pon "QUICK MENU->CONTROLS->PORT 2 CONTROLS->DEVICE TYPE" a "ZAPPER",
y "QUICK MENU->CORE OPTIONS->INPUT->ZAPPER DEVICE" a "POINTER".

PARA EL CORE DE PC-ENGINE, INITIAL_SCANLINE=10, LAST_SCANLINE=232

PARA EL CORE DE SATURN NECESITAS, O BIEN UN KERNEL CON LAS TÍPICAS OPTIMIZACIONES PARA JUEGOS, ES DECIR:
	--General Setup->Preemption model->Preemptible Kernel (Low-Latency Desktop)
	--Processor Type and Features->Timer Frequency->300Hz
..O BIEN LANZAR EL CORE CON "taskset -c 0,1" PARA QUE SE EJECUTE EN LOS P-CORES SOLAMENTE.
Y ADEMÁS, DEBES USAR LOS SIGUIENTES OVERRIDES:
	--Desactiva el Runahead por completo!
	--SI LA PANTALLA NO SOPORTA 100Hz: Backend de audio ALSA con 42ms de buffer

PARA EL CORE DE NINTENDO DS, ten en cuenta que no hay CPU para hacer Runahead.

PARA EL CORE "GENESIS PLUS GX", usa RunAhead PERO NO USES "SECOND INSTANCE MODE", o algunos juegos (Comix Zone, por ejemplo)
irán a tirones laaaargos y se quedará parada la imágen a veces.

PARA EMULAR GAMEGEAR Y LYNX, el mejor shader es "handheld/sameboy-lcd" combinado con INTEGER SCALING.

PARA EMULAR GAMEBOY Y GAMEBOY COLOR, si usas el GAMBATTE pon "Core Options->Color Correction" a "GBC Only",
y usa el shader "handheld/sameboy-lcd" combinado con INTEGER SCALING. 

PARA EL CORE GEOLITH (emulador muy preciso de NEOGEO) mete "aes.zip" y "neogeo.zip" en ~/.config/retroarch/system
Como por defecto se inicia en modo AES, lo más importante para que funcione es tener "aes.zip".
Las ROMs son en formato ".neo", las tienes en el disco duro de backup, o busca el pack LunaGarlic en Archive.org  
NO USES RUNAHEAD CON ESTE CORE, o el sonido y el vídeo se empiezan a desincronizar cada vez más. No tiene RUNAHEAD interno tampoco.
Para el escalado, si usas integer scaling en modo "smart", debes poner el "Viewport Anchor Bias Y" a 85 o así
para que se vea el marcador de créditos del Puzzle Bobble, etc.

PARA EL CORE DE AMIGA, deja siempre que puedas el sistema por defecto (Amiga 1200, 8MB FAST) ya que es para lo que viene configurada
la exactitud de ciclo del emulador y con un A600+FAST te salen errores en los juegos a no ser que pongas la exactitud de ciclo a FULL.
IMPORTANTE: "SYNC TO EXACT" NO FUNCIONA CORRECTAMENTE NI PARA PAL NI PARA NTSC (si dudas, mira el scroll de texto de la "Phenomena")
así que para los juegos PAL pon un modo de 100Hz antes de entrar y crea un fichero ~/.config/retroarch/config/PAL.cfg con este contenido: 
video_refresh_rate = "100.000000"
config_save_on_exit = "false"
...Y luego lo cargas así:
wlr-randr --output DP-1 --mode 1920x1080@100
retroarch -L ~/.config/retroarch/cores/puae_libretro.so --appendconfig ~/.config/retroarch/config/PAL.cfg "$1"
wlr-randr --output DP-1 --preferred

NO USES EL CORE BSNES: tendrías que desactivar el Runahead de RetroArch y activar el Runahead interno de BSNES,
o se quedará en una pantalla en negro.
A parte, tiene problemas de buffering y no va bien con latencias de sonido bajas, hagas lo que hagas.

SI USAS INTEGER SCALING Y QUIERES UN BORDE PARA LA PANTALLA:
-Clona el repo https://github.com/libretro/common-overlays.git, y mete los overlays que quieras en ~/.config/retroarch/overlay
-Ve a QUICK MENU->ON-SCREEN OVERLAY, activa DISPLAY OVERLAY, y selecciona un overlay preset de los que has copiado.
(Se podría activar y ajustar también en SETTINGS->ON-SCREEN DISPLAY->ON-SCREEN OVERLAY, estableciendo así un solo overlay
para todos los cores, pero como cada core aparece de un tamaño en pantalla al usar INTEGER SCALING, nos conviene gestonarlo
aquí en QUICK MENU para que quede configurado core a core).

PARA CORES DE ORDENADOR QUE NECESITAN TODO EL TECLADO, la idea es usar el "GAME FOCUS", para lo cual
NO DEBEMOS TENER ACTIVADO el "HOTKEY ENABLE", ya que son dos funcionalidades que se solapan
y si tuvieses ambas la "HOTKEY ENABLE" no funcionaría al tener activo el "GAME FOCUS" que dedica todas las teclas al core.
Así que hacemos esto:
-En Settings->Input, pon "Auto Enable Game Focus" a "Detect".
-En Settings->Input->Hotkeys, pon en "Game Focus (Toggle)" la tecla Windows ("lsuper" se llama).
-En Settings->Input->Hotkeys, NO PONGAS NINGUNA TECLA en "Hotkey Enable".

*********INPUT LAG EN RETROARCH: EL TEST DEL DOBLE CURSOR************

Asigna una tecla a "TOGGLE MOUSE GRAB", yo suelo usar la M.
Ahora, entra en el menú de RetroArch y pulsa M: verás a la vez el cursor de sistema y el cursor de RetroArch.
Al mover el ratón, se moverán ambos cursores. Dado que el cursor de sistema no tiene lag, deberían ir casi pegados todo el tiempo.
Si se separan bastante, es que tienes bastante lag. Si se mantienen casi juntos, es que no tienes casi lag.

En lugar del cursor de RetroArch, se puede usar el cursor del crosshair para juegos de disparos de los cores SNES9X o GenesisPlusGX,
de manera que se tenga en cuenta también el valor de FRAME DELAY (con el cursor de RetroArch, no se tiene en cuenta).

*********No funcionan los input en RetroArch**********

PARA que haya input con el driver udev (input_driver = "udev") debemos crear /etc/udev/rules.d/99-evdev.rules con el contenido:
KERNEL=="event*", NAME="input/%k", MODE="666"
Ahora podemos hacer
sudo udevadm control --reload-rules
sudo chmod 666 /dev/input/event*
o simplemente reiniciar.

*********Conservar la asignación de mandos a los puertos de RetroArch***************************************

La idea es que, si tenemos dos mandos por ejemplo, uno de ellos sea siempre el del puerto 1 de RetroArch y el otro sea el del puerto 2 de RetroArch.

¡¡¡NO HACE FALTA ANDAR CON REGLAS DE UDEV!!!

Nos vamos a SETTINGS->INPUT->PORT 1 CONTROLS y en DEVICE INDEX seleccionamos el mando que queramos que sea siempre
el del puerto 1.
Repetimos para  SETTINGS->INPUT->PORT 2 CONTROLS y su DEVICE INDEX.

Puedes quitar y poner los mandos como quieras, etc... y la configuración se conserva siempre. Si inicias RetroArch con uno solo de los dos mandos
conectado, tampoco hay problema y sigue en su puerto correcto.

**********RETROARCH no salva las partidas de SRAM a veces**************************

Hay que tener en cuenta que RETROARCH no salva la SRAM automáticamente, sino que vuelca la SRAM al salir del core que sea.
Para tener algo parecido a un volcado de SRAM automático, activa SETTINGS->SAVING->SaveRAM Autosave Interval,
que por defecto deberían ser unos 10s.
Sólo escribe en disco si encuentra diferencias en la SRAM (así que no escribe continuamente!) e incluso así, es una tarea que
va en su propio thread si tienes activada la opción SETTINGS->USER INTERFACE->Threaded Tasks (cosa que SIEMPRE deberías tener activada).

****************************Para configurar PINN después de actualizarlo***********

Montamos /dev/sdb1, y ponemos en config.txt:

disable_splash=1
disable_overscan=1

Para establecer una espera en segundos, puedes añadir en recovery.cmdline:
bootmenutimeout=60

Y para que no busque actualizaciones, puedes añadir en recovery.cmdline:
no_update

Tienes todas las posibles opciones de recovery.cmdline en:
https://github.com/procount/pinn/blob/master/README_PINN.md#cmdline-options

****************************Cómo compilar libmodplug*******************************

Cambia automake-1.13 a automake-1.11 en el Makefile.
Configura con: 
CFLAGS="-O2 -march=native -mtune=native" CXXFLAGS="-O2 -march=native -mtune=native" ./configure --enable-static

****************************Cambiar la resolución al vuelo en KMSDRM*******************

Se haría con switchres, que puede ser un programa que tienes aquí para bajar y compilar:

git clone --depth 1 https://github.com/antonioginer/switchres.git

Editamos custom_video_drmkms.cpp y ponemos drm_name[15] a "/dev/dri/card1" y más abajo comentamos la línea donde hace
drm_name[13] = '0' + num;

También podemos comentar el drmDropMaster() más abajo para que no nos diga "[ERROR] limited DRM rights on this screen"
(aunque funciona igual, vamos).

Y luego es simplemente:
switchres 1280 720 50 -s -k
(OJO!! -k hace los cambios permanentes!!)

...O bien compilando RetroArch con soporte para SwitchRes y luego configurando la resolución que queramos en:
Settings->Video->CRT SwitchRes

****************************CONFIGURACIÓN DEL MONITOR VIEWSONIC XG2401*******

VIEWMODE: Standard
BLACK STABILIZATION: 5
ADVANCED DCR: 0

****************************Actualizar firmware 8bitdo en GNU/Linux**********
INFO SACADA DE: 

--Miramos el productID y el vendorID con "lusb".
  Si vemos "2dc8:5200", entonces 2dc8 es el vendorID y 5200 es el productID

--Editamos el registro de WINE con "wine regedit" y allí nos vamos a "HKLM\System\CurrentControlSet\Services\winebus"
  y añadimos un DWORD llamado "Enable SDL" con valor "0".
  Esto es MUY IMPORTANTE para que WINE permita acceder a los USBs para flashear.

--Creamos /etc/udev/rules.d/71-8bitdo-boot.rules con el contenido (adaptando el vendorID y el productID, naturalmente):
SUBSYSTEM=="hidraw", ATTRS{idProduct}=="5200", ATTRS{idVendor}=="2dc8", TAG+="uaccess"

--Instalamos la fuente de mierda de Windows que usan esta basura de programas cerrados:
git clone --depth 1 https://github.com/mrbvrz/segoe-ui-linux
cp segoe-ui-linux/font/* $HOME/.wine/drive_c/windows/Fonts/  
(ALTERNATIVAMENTE se puede instalar usando el script de instalación que hay en https://github.com/mrbvrz/segoe-ui-linux)

--Instalamos el runtime de VisualC que necesita esta basura:
winetricks vcrun2015

--(NO NECESARIO PARA EL RETROKEYBOARD, YA QUE EL FLASHEADOR TRAE SU PROPIO FIRMWARE)
   Nos bajamos la versión del firmare que queramos con este script: https://github.com/fwupd/8bitdo-firmware
----Para ver la lista de productos: ./8bitdo-firmware.py -l
----Para ver la lista de firmwares de un producto, en este caso el 80: ./8bitdo-firmware.py -l 80
----Para descargar una versión del firmware del producto 80, en este caso el 1.04: ./8bitdo-firmware.py -f 80 1.04
----Cambia la extensión de del firmware descargado de .DAT a .BIN

--Nos descargamos el flasheador manual, que es un archivo llamado "RetroKeyboard177.zip" de https://tempfiles.8bitdo.com/HOT/
  Lleva incluidos un par de firmwares y podemos flashear la versión más reciente.

--Creamos el directorio ~/.wine/drive_c/8bitdo y mandamos el flasheador y el firmware allí (si es que hemos descargado un firmware a parte),
para que no tenga que acceder a nada en la unidad Z que es el raiz de Linux.

--Usamos el flasheador: wine 8Bitdo_Update.exe
  ...Seleccionamos el firmware (.BIN) y esperamos. Se hace aunque no nos diga nada.  

NOTA: Debería ser posible flashear el firmware sin usar nada de 8BitDo, usando el protocolo DFU.
Para ello, primero instalaríamos "dfu-util": sudo apt-get install dfu-util
Y ahora tendría que aparecer nuestro hardware al hacer "dfu-util --list"
Flashealo sería algo como:
dfu-util -d 2dc8:5200 -a 0 -s 0x08000000:leave -D RetroKeyboard177.bin
(El 0x08000000 es la dirección de memoria más común para microcontroladores ARM)
EL PROBLEMA POR AHORA ES QUE NO APARECE, ASÍ QUE NO LO PODEMOS FLASHEAR DESDE DFU-UTIL, QUE SERÍA LO IDEAL.

****************************Milkytracker en Linux****************************

Para evitar undefined symbols en tiempo de linkado, hacemos:

CFLAGS="-O2 -march=native -mtune=native -lasound" CXXFLAGS="-O2 -march=native -mtune=native -lasound" ./configure

***************************Menú XBM en RetroArch con carátulas, autolanzado de cores, etc...**********************************

OJO: Para tener el menú XMB funcionando con sus fuentes, mostrando iconos en lugar de cuadros negros. etc...

-Si no quieres shimmering en las letras del RGUI, tienes que irte a SETTINGS->USER INTERFACE->APPEARANCE
y activar LINEAR FILTERING.

-Tienes que habilitar el soporte para PNG (rpng) al configurar

-Necesitas los assets de aquí: https://github.com/libretro/retroarch-assets
De ese repo, copia los directorios xmb y ozone en el directorio de assets a ~/.config/retroarch/assets

-Si quieres que RetroArch te ofrezca con qué emulador quieres correr una ROM, tienes que clonar este repo:
git clone --depth 1 https://github.com/libretro/libretro-super.git
Y mandar el contenido del directorio libretro-super/dist/info a ~/.config/retroarch/cores. Sí, junto con los cores. Así:
cp -R libretro-super/dist/info/* ~/.config/retroarch/cores/
Ahora en RetroArch, en Settings->Core, desactiva "Cache core info files".
Y elimina ".config/retroarch/cores/core_info.cache".
(Si no haces estas últimas dos cosas, no funcionará, y no sabrás por qué).

-Para que el mando se autoconfigure (si es un mando conocido o compatible con uno conocido: la mayoría de ellos los reconoce como XBOX360 PAD)
tienes que clonar:
git clone --depth 1 https://github.com/libretro/retroarch-joypad-autoconfig.git
Y meter el directorio "udev" en ~/.config/retroarch/autoconfig/
Esto es imprescindible en consolas sin teclado, porque si no, no tienes manera de configurar el mando al arrancar el RetroArch al principio.

-Para poder tener las opciones de escanear directorios y tal, de modo que se nos creen las playlists que es lo que permite que al cargar una ROM
 se cargue automáticamente su core, tienes que activar libretrodb.
 Además, tienes que tener las databases de libretro, de manera que pueda comparar tus roms contra las de las databases.
 Así que te bajas las databases de este repo:
 clone --depth 1 https://github.com/libretro/libretro-database.git
 Copiamos el directorio "rdb" a "~/.config/retroarch/database" (quedará como ~/.config/retroarch/database/rdb)
 Ahora ya debería escanear las ROMS y sacártelas ordenadas por icono de sistema en la parte de arriba, pero si intentas lanzar una te dirá
 que "not cores found".
 Pues vale, nos vamos a settings->playlist, y ahí podemos asociar los playlists con cores,
 de tal manera que el playlist de NES cargue el nestopia, etc...
 Por CADA directorio de ROMs escaneado, XMB te va a crear una playlist, donde todas las ROMs de esa playlist se van a abrir con un determinado core. 
 Estas playlist son archivos.lpl que los crea al principio en ~/.config/RetroArch/playlists, pero tenemos el setting playlist_directory.
 Yo lo que he hecho ha sido configurar playlist_directory para que apunte a ~/retro/db/playlists, y ahí he metido las playlists que ya tenía, y ahí meterá XMB las nuevas
 que vaya creando.

-Si además quieres fotos de las carátulas, etc.. en las playlist, pues te bajas los thumbnails de aquí: https://thumbnails.libretro.com/
 Los mandas a donde quieras, hay que descomprimir el zip. y luego apuntas el setting thumbnails_directory a ese directorio. Por ejemplo, yo me creé ~/home/pi/retro/db/thumbnails,
o sea, mandé los thumbnails a un directorio bajo retro/db, y ahí dentro tengo Atari\ -\ 7800, etc...
Pues  pongo thumbnails_directory apuntando a ~/home/pi/retro/db/thumbnails. Así de sencillo. Lo puedes hacer desde el propio XMB en Settings > Directory

-Si quieres poner RA en autoarranque, ~/.profile es una buena opción.. PERO desactiva el autologin en la segunda TTY, o estarás lanzando dos instancias de RA
 y las cosas irán LENTAS.

-Para que se autoarranque, pero no se intente lanzar cuando entres por ssh, pon esto en .profile:

if [ -z "$SSH_TTY" ] ; then  
    cd retro
    ./retroarch-xmb -c cfg/xmb.cfg &> /dev/null && sudo poweroff
fi

-Si ves que al cargar varios juegos tienes errores de EGL, pon gpu_mem=256 en el config.txt

RETROARCH EN UN PC GENÉRICO SOBRE X11
=====================================

Dependencias previas:
sudo apt-get install libasound2-dev glslang-dev glslang-tools spirv-tools \
xcb libxcb-xkb-dev x11-xkb-utils libx11-xcb-dev libxkbcommon-x11-dev

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure --disable-ibxm --disable-vg --disable-sdl2 --disable-al --disable-cheevos --disable-ffmpeg \
--disable-networking --disable-netplaydiscovery --disable-libretrodb --enable-udev --disable-sdl --disable-pulse --disable-oss \
--disable-freetype --disable-7zip --disable-imageviewer --disable-rjpeg --disable-rbmp --disable-rtga --disable-flac \
--disable-qt --disable-materialui --disable-xmb --enable-rgui --disable-ozone --disable-gfx_widgets --disable-langextra \
--disable-cdrom --disable-accessibility --disable-tinyalsa --disable-rpiled \
--enable-opengl --enable-vulkan

Ahora ya compilamos:
make -j8 V=1
El V=1 es para ver las líneas de compilación y comprobar que nuestros flags se están usando, etc

Si quieres compilar en modo debug, haz:
make -j6 DEBUG=1 V=1
y se le pasará -O0 -g al compilador, y nada de -O2 ni -O2

COMPILAR CUALQUIER CORE DE LIBRETRO
===================================

CFLAGS="-march=native -mtune=native -fomit-frame-pointer -DALIGN_LONG" \
CXXFLAGS="-march=native -mtune=native -fomit-frame-pointer -DALIGN_LONG" make -j10

DESCARGAR CORES PRECOMPILADOS DE LIBRETRO
=========================================

http://buildbot.libretro.com/stable
http://buildbot.libretro.com/nightly

COMPILAR EL CORE MELONDS DE LIBRETRO
====================================

Clonamos su repo:
git clone --depth 1 https://github.com/JesseTG/melonds-ds.git

Configuramos con:

mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" -DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DENABLE_OPENGL=OFF

COMPILAR EL CORE HATARIB DE LIBRETRO
====================================

Clonamos su repo:

git clone --depth 1 https://github.com/bbbradsmith/hatariB.git

Compilamos con esta línea de compilación (es así de larga porque por defecto intenta usar unas SDL2 y libzip que trae incluidas,
y en su lugar queremos que use las instaladas en el sistema):

Para X86_64:

CFLAGS="-march=native -mtune=native -fomit-frame-pointer" CXXFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
make -j6 MULTITHREAD= SDL2_INCLUDE=/usr/local/include/SDL2 SDL2_LINK=/usr/local/lib/libSDL2.so \
ZLIB_INCLUDE=/usr/include ZLIB_LINK=/usr/lib/x86_64-linux-gnu/libz.so

Para Raspberry Pi (respecto a X86_64 sólo cambia el directorio donde está libz del sistema):

CFLAGS="-march=native -mtune=native -fomit-frame-pointer" CXXFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
make -j4 MULTITHREAD= SDL2_INCLUDE=/usr/local/include/SDL2 SDL2_LINK=/usr/local/lib/libSDL2.so \
ZLIB_INCLUDE=/usr/include ZLIB_LINK=/usr/lib/aarch64-linux-gnu/libz.so

PARA QUE LA MÚSICA DE AMBERSTAR NO SUENE DESACOMPASADA, activa la opción CORE OPTIONS->ADVANCED->CYCLE-EXACT CACHE EMULATION.

LA MEJOR FUENTE DE TOS ROMS ES ESTA PÁGINA RUSA: https://avtandil.narod.ru/tose.html
(Vienen ordenadas por máquina, que es lo más importante).

NOTA: El Dungeon Master tarda muchísimo en cargar después de abrir la puerta. Usa la versión disponible aquí:
https://atari.8bitchip.info/ASTGA/D/dungmast.php

PARA INSTALAR JUEGOS EN DISCO DURO:
(Tienes muchos aquí: http://d-bug.me/, y aquí https://atari.8bitchip.info/fromhd3.php#DL)
Simplemente mete el juego en el directorio que quieras (ese directorio a su vez debes meterlo
en ~/.config/retroarch/hatarib/system para que el core lo vea), pon el tipo de disco duro como GEMDOS, y ya se puede acceder a él
tanto desde Atari TOS a partir de la 1.04, como desde EMUTOS, sin hacer nada más ni instalar drivers de disco ni nada.

Para que el juego se autoarranque, simplemente en el raíz del disco crea un directorio llamado AUTO y mete ahí el ejecutable del juego.
O sea, crearíamos amberstar/AUTO, y ahí copiaríamos amberstar/AMBRSTAR/AMBRSTAR.PRG.
Además, activamos la opción de "Boot hard disk" en las opciones del core.
OJO!!! Si el ejecutable es un .TOS, le cambiaremos el juego a .PRG para que se autoarranque, si se llama .TOS no se autoarrancará!!!
OJO!!! Ponle unos 4MB de RAM al equipo si no quieres que algunos de los juegos parpadeen durante el juego como el Amiga con el WHDLOAD con poca RAM.

PARA USAR UN DIRECTORIO A MODO DE DISCO DURO: Para esto, tenemos que configurar el tipo del disco como GEMDOS, elegir una ROM adecuada
como la EmuTOS 192us, y crear un archivo dummy de extensión .gem junto al directorio.
O sea que si tenemos:
~/roms/atari/gods
...entonces creamos:
~/roms/atari/gods.gem
Y ya ponemos hacer:
retroarch -L ~/.config/retroarch/cores/hatarib.so ~/roms/atari/gods.gem
Y RECUERDA que para el juego se autoarranque, tendrías que crear ~/roms/atari/gods/AUTO y meter ahí el RUNME.TOS,
renombrado a RUNME.PRG (o al nombre que quieras, pero .PRG).

PARA ARRANCAR DESDE DISCO DURO "COMPLETO" (Para luego lanzar cada juego "a mano" desde el sistema Atari)
Lo más fácil (y compatible con los juegos que te interesan, como Captain Blood, Viking Child, Ishar...)
es, en CORE OPTIONS->SYSTEM:
TOS ROM -> EmuTOS 192us
Machine Type -> ST
ST Memory Size -> 4 MB
Hard Disk Type -> GemDOS
Hard Disk Boot -> ON
Es recomendable que el directorio que contiene el disco duro "completo" se llame "C", porque así el HatariB lo montará en el Atari emulado
como disco "C".
Tenemos que crear, junto al directorio del disco duro, un archivo dummy que se llame igual que el directorio donde está el disco duro "completo".
O sea que si tenemos:
~/roms/atari/C
...entonces creamos:
~/roms/atari/C.gem
Y ya ponemos hacer:
retroarch -L ~/.config/retroarch/cores/hatarib.so ~/roms/atari/C.gem
Si queremos que se autolanze el command.prg para arrancar a consola de comandos en vez de arrancar al GEM, lo metemos en el directorio AUTO y ya.

Tienes MUCHOS juegos instalados en disco duro aquí: https://atari.8bitchip.info/fromhd3.php
(Busca por nombre del juego, y si tiene una "D" azul en esa fila, pincha en ella para ir a la ficha y descargarlo).

PARA CARGAR JUEGOS PAL A 100Hz:
-Añade "PAL" al nombre del juego. Por ejemplo, "gods" pasaría a ser "godsPAL", lo mismo con su .gem
-Crea un script /usr/local/bin/atari como este, que en caso de ser PAL el juego, ponga el monitor a 100Hz si el juego es PAL y además
cargue las opciones necesarias para poner RetroArch en modo PAL desde ~/.config/retroarch/PAL.cfg:
############SCRIPT DE CARGA DE JUEGOS NTSC/PAL DE ATARI ST#############################################################
if [[ "$1" == *"PAL"* ]]; then
  wlr-randr --output HDMI-A-1 --mode 1920x1080@100
  retroarch -L ~/.config/retroarch/cores/hatarib.so --appendconfig ~/.config/retroarch/config/PAL.cfg "$1"
  wlr-randr --output HDMI-A-1 --mode 1920x1080@120
else
  wlr-randr --output HDMI-A-1 --mode 1920x1080@120
  retroarch -L ~/.config/retroarch/cores/hatarib_libretro.so "$1"
  wlr-randr --output HDMI-A-1 --mode 1920x1080@60
fi
############FIN SCRIPT DE CARGA DE JUEGOS NTSC/PAL DE ATARI ST#############################################################
-Crea ~/.config/retroarch/config/PAL.cfg con este contenido (la última línea es porque NO queremos que al quitar el juego
el RetroArch se quede a 100Hz...¡Los 100Hz son sólo una excepcionalidad para juegos PAL! Y si la pantalla no soporta 100 Hz,
tendríamos que añadir tabién audio_latency = "42"):
video_refresh_rate = "50.000000"
audio_driver = "alsathread"
config_save_on_exit = "false"
-Luego, en cada juego, creamos su propio fichero de opciones del core, con el tipo sistema Atari ST que usamos para ejecutarlo
(Recuerda que si es PAL tendrás que elegir una TOS europea), las opciones de pixel ratio que mejor le sientan, etc.

PARA TODOS LOS JUEGOS EN GENERAL es interesante tener el espacio mapeado al botón START del mando, ya que los installs de HD
usan SPACE para empezar a jugar. Esto lo puedes guardar como el core remap.
A parte, para los que usan arriba para el salto (pero no para subir escaleras), puedes mapear la flecha arriba en el botón B
del mando, y el fire en el botón Y del mando (por ejemplo, el Viking Child). 

PARA EL CAPTAIN BLOOD DESDE HDD:
-Usa la release de 42-Crew para copiarla al disco duro GEMDOS en el directorio que quieras.
Necesita la TOS 1.04 PAL como máximo: más que eso, revienta. Puedes usar versiones superiores de la TOS, o incluso EmuTOS, si son NTSC.

PARA EL AMBERSTAR DESDE HDD
Simplemente debes tener el juego metido en C:AMBRSTAR, es decir, que lo puedes meter en ~/roms/atari/ambrstar/AMBRSTAR/,
y crearíamos ~/roms/atari/ambrstar.gem

PARA QUE EL ISHAR VAYA MÁS DEPRISA
Configura el sistema como un Mega STE y usa la TOS del MegaSTE (2.05). El MegaSTE ya va de por sí a 16MHz.
(Con la CPU a 16Mhz + sistema ST sencillo + TOS de ST, la imágen HAM del cargador se ve mal. Y con EmuTOS, no se ve esa imágen HAM).

PARA EL DRAGONFLIGHT DESDE HDD, tienes dos opciones:

--OPCIÓN 1: Usar la versión de https://atari.8bitchip.info/ASTGA/D/dragonfl.php
La ventaja de esta versión es que funciona desde cualquier unidad, NO hace falta que esté en la "E:" como la original de Thalion Shrine.
Pero sí que debes tener un floppy metido en la disketera. No lo usa, pero debes tenerlo o se queda en una pantalla en negro.
Puedes crearte uno vacío con el HATARI (versión no Libretro).
Para cargar el disco GEM y el floppy a la vez, nos creamos el archivo ~/roms/atari/dragonfl.m3u, con el contenido:
dragonfl.gem
dragonfl.st
Y lo podemos cargar con:
retroarch -L ~/.config/retroarch/cores/hatarib.so ~/roms/atari/dragonfl.m3u

--OPCIÓN 2: Usar la versión oficial HDD de Thalion Shrine: http://thalion.exotica.org.uk/games/dragonflight/st/dragonflight.zip
La debes copiar a un disco GEM que tenga como letra de unidad la "E:"
Para ello, el directorio del juego debe tener un solo directorio llamado "E", donde metemos el juego.
O sea, que habría que meter el juego en ~/roms/atari/dragonfl/E/
Y debes tener un floppy cualquiera metido en la disketera. No lo usa, pero debes tenerlo.
Puedes crearte uno vacío con el HATARI (versión no Libretro).
Para cargar el disco GEM y el floppy a la vez, nos creamos el archivo ~/roms/atari/dragonfl.m3u, con el contenido:
dragonfl.gem
dragonfl.st
Y lo podemos cargar con:
retroarch -L ~/.config/retroarch/cores/hatarib.so ~/roms/atari/dragonfl.m3u

(POR SI LO NECESITAS, AUNQUE ES POCO PROBABLE: Para insertar un floppy a mano una vez que has arrancado el core habiéndole pasado el disco duro GEM,
en el menú de RetroArch debes ir a "Disk Control->Load New Disc", y después más arriba darle a "Insert Disk").

EMULANDO MACINTOSH EN ATARI ST
==============================

Usamos para ello el Spectre 3.0, que está en forma de ficheros sueltos con las ROMs de Macintosh preparadas en el disco duro de backup, y en
el segundo post de:
http://www.retrowiki.es/viewtopic.php?t=200028688

Metemos esos ficheros en un directorio que llamaremos como queramos, por ejemplo "spectre", y montamos ese directorio como un disco GEM en HATARI.
(Si usas el core HatariB en RetroArch, ya sabes que necesitas crear un fichero dummy llamado "spectre.gem" para poder montar el directorio "spectre"
como un disco GEM).
Para el disco de Macintosh: montamos en HATARI como disco duro ACSI un disco "full hard disk image", es decir, una imágen de disco de Macintosh
de las que usa MAME. Tenemos que renombrar la imágen a .acsi para que HATARI nos permita elegirla como imágen ACSI.

Tenemos que configurar el modelo de Atari ST/STE/MegaSTE que queramos en HATARI, pero eso sí, con 2MB de RAM, o se quedará colgado el Spectre
al iniciar el System 6 en el banner de "Welcome to Macintosh". Nada de 4MB ni de más ni de menos: 2MB.

ROMS ACTUALES DE SISTEMAS RETRO (LO QUE SE LLAMA "PRIVATE")
===========================================================

https://archive.org/download/no-intro-priv

COMPILAR EL CORE MUPEN64 DE LIBRETRO
====================================

Clonamos su repo:
git clone --depth 1 https://github.com/libretro/mupen64plus-libretro-nx.git

--Editamos Makefile y cambiamos "-lGL" por "-lOpenGL"

--Si hemos compilado RetroArch contra OpenGL de escritorio que es como lo hacemos ahora, compilamos con:
CFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
CXXFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
HAVE_PARALLEL_RSP=1 HAVE_PARALLEL_RDP=1 make -j10

--Si hemos compilado RetroArch contra OpenGL_ES, compilamos con:
CFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
CXXFLAGS="-march=native -mtune=native -fomit-frame-pointer" \
FORCE_GLES3=1 HAVE_PARALLEL_RSP=1 HAVE_PARALLEL_RDP=1 make -j10

NOTAS MUY IMPORTANTES PARA EL CORE:
Para este core NO USES RUNAHEAD, si lo haces se producen fugas de memoria al salir.
Y configuramos las opciones del core así:
-"RDP Plugin" a "ParaLLEI-RDP"
-"RSP Pligin" a "ParaLLEI"

COMPILAR EL CORE DIRKSIMPLE (LASERDISC EN RETROARCH!!!)
=======================================================

Clonamos su repo:
git clone --depth 1 https://github.com/icculus/DirkSimple.git

Configuramos y compilamos con:

mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DDIRKSIMPLE_SDL_DEFAULT=OFF \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

Copiamos el core a la ruta habitual.
Copiamos el directorio "data" que queda en nuestro directorio de compilación a ~/.config/retroarch/system/DirkSimple/data, así:
mkdir ~/.config/retroarch/system/DirkSimple
cp -R data system/DirkSimple/

Si no tenemos el audio/vídeo del Dragon's Lair convertido a un solo archivo, podemos hacerlo con ffmpeg así:
ffmpeg -i lair.m2v -i lair.ogg -codec:v libtheora -qscale:v 7 -codec:a libvorbis -qscale:a 5 -pix_fmt yuv420p lair.ogv

Lanzamos el core con el Dragon's Lair así (el fichero de audio/vídeo se tiene que llamar lair.ogv para que el core sepa qué juego es
y cargue el LUA necesario!):

retroarch -L ~/.config/retroarch/cores/dirksimple_libretro.so lair.ogv

COMPILAR UNA VERSIÓN MÍNIMA DEL CORE FBALPHA CON DRIVERS DESHABILITADOS
===========================================================================

Lo primero, nos vamos a
cd src/burner/libretro

En Makefile.common, quitamos los directorios de la parte de FBNEO_BURN_DRIVERS_DIR. Busca la cadena snes y ahí ves qué tipo de líneas tienes que quitar.
No hace falta que quites los directorios de los includes, esos dan igual.

Editamos Makefile y dejamos la platform definition de la pi4 asi:

   else ifneq (,$(findstring rpi4,$(platform)))
      PLATFORM_DEFINES := -march=native -mtune=native -O2
   endif

Ahora hacemos un 
make platform=rpi3 generate-files
de manera que nos genere los headers sólo con los drivers que hemos dejado en el makefile.libretro_common,

y luego ya el 
make platform=rpi3 -j4
y listo. 

COMPILAR MEDNAFEN STANDALONE CON EMULACIÓN DE SATURN SOLAMENTE
==============================================================

-Bajamos los últimos sources estables de:
https://mednafen.github.io/releases/

-Configuramos con:

CFLAGS="-O2 -march=native -mtune=native" CXXFLAGS="-O2 -march=native -mtune=native" ./configure --disable-debugger \
--disable-apple2 --disable-gb --disable-gba --disable-lynx --disable-md --disable-nes --disable-ngp \
--disable-pce --disable-pce-fast --disable-pcfx --disable-psx --disable-sasplay --disable-sms --disable-snes --disable-snes-faust \
--disable-ssfplay --disable-vb --disable-wswan

--Ejecutamos por primera vez el emulador sin cargar nada (nos sale la ayuda y ya),
y se nos creará ~/.mednafen/firmware, donde metemos la BIOS "mpr-17933.bin".

--Editamos ~/.mednafen/mednafen.cfg y ponemos estos valores así (los vamos buscando y ajustando):

sound.device sexyal-literal-default
sound.buffer_time 32
video.fs 1
video.driver opengl
video.frameskip 0
ss.stretch aspect

--Para configurar el mando, pulsamos ALT + SHIFT + 1.

COMPILAR EMULADOR DE 3DS PARA GNU/LINUX
=======================================

--Clonamos su repo: git clone --depth 1 --recursive https://github.com/azahar-emu/azahar

--Editamos "src/video_core/renderer_vulkan/vk_platform.cpp" y allí buscamos "VK_USE_PLATFORM_XLIB_KHR"
y vamos quitando lo relacionado con eso:
----Borramos el "#define VK_USE_PLATFORM_XLIB_KHR"
----En el primer "#elif defined(VK_USE_PLATFORM_XLIB_KHR) || defined(VK_USE_PLATFORM_WAYLAND_KHR)",
quitamos la parte de "defined(VK_USE_PLATFORM_XLIB_KHR)"
y el bloque entero de "if (window_info.type == Frontend::WindowSystemType::X11) {"
----En el segundo "#elif defined(VK_USE_PLATFORM_XLIB_KHR) || defined(VK_USE_PLATFORM_WAYLAND_KHR)",
quitamos todo el bloque de "case Frontend::WindowSystemType::X11:"

--Compilamos con:
mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DENABLE_QT=OFF -DENABLE_TESTS=OFF -DENABLE_WEB_SERVICE=OFF -DENABLE_SCRIPTING=OFF \
-DENABLE_SDL2=ON -DENABLE_SDL2_FRONTEND=ON \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" ..

CONFIGURAR BASH PARA TENER UN SALUDO Y LA IP AL INICIO
=======================================================

Al principio del todo de ~/.bashrc ponemos esto para evitar problemas con el saludo y el scp:
# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

Para añadir al PATH el diretorio actual, que no nos muestre todo el rato el usuario y el hostname,
y que nos muestre un mensaje de bienvenida y la IP añadimos en ~/.bashrc:
PATH=$PATH:.
PS1="\W "
MY_IP=$(ip -4 addr show wlo1 | grep -oP '(?<=inet\s)\d+(\.\d+){3}')

echo " ^_^    Welcome to Debian 12 GNU/Linux aarch64."
echo "(O,O)   Service management is done via SystemD."
echo "/)_)    This computer's local IP is $MY_IP"
echo " ¨ ¨    Have fun!"  
echo "     "

ERROR DE LANGUAGE DE PERL al acceder por ssh a una máquina
==========================================================

Esto ocurre porque la máquina desde la que accedemos exporta los settings de lenguaje a la máquina a la que estamos accediendo, y en esa no está instalado el 
soporte para el lenguaje que sea.
Para quitar los avisos de mierda de LANGUAGE de perl:

export LANGUAGE=en_US.UTF-8
export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
export LC_TYPE=en_US.UTF-8

en el .bashrc y listo. Si persiste, añadimos lo mismo a .bash_profile.

Roms FastROM preparadas y actualizadas
======================================

https://archive.org/download/sfc-speedhacks

Localizar teléfono ANDROID
==========================

https://www.google.com/android/find/

Móviles Android, SONY walkman y dispositivos MTP que fallan al funcionar en modo MTP en Lubuntu como cámaras, etc
======================================================================================================

El problema es que el PCMANFM los automonta como MTP y no van bien. Para que los monte como MSC, es decir, como pendrives normales y corrientes, simplemente ELIMINA
o mueve a otro sitio /usr/lib/gvfs/gvfs-mtp-volume-monitor
Y el PCMANFM ya no toca los huevos.

Ahora pon el móvil en modo PTP (en los ajustes de la conexión USB) y debería ir. MTP es mierda. Se cambia en las opciones de desarrollador, en "modo USB predeterminado" o algo así.

También podrías usar jmtpfs para montarlos a mano desde la línea de comandos. Es muy fácil. Creas un punto de montaje, y se lo pasas a jmtpfs, sin nodo ni nada. Él sabe qué hacer.
jmtpfs ~/mnt

Instalar la versión que queramos de IOS desde Linux en Ipad/Ipod/la basura para retrasados que sea
==================================================================================================

Se usa un opensource que se llama idevicerestore. Tiene dependencias y mierdas varias, pero cuando lo instales puedes hacer estas cosas tan... estúpidas.

sudo idevicerestore iPad2\,5_9.3.3_13G34_Restore.ipsw

LA PESADILLA SYSTEMD: COMO LIBRARNOS DE ELLA
=============================================

Podemos simplemente hacer que fncione en modo sysvinit, que es lo bueno:
apt-get install sysvinit-core systemd-sysv-

Y para saber por qué coño se nos instaló SYSTEMD al actualizar, miramos las dependencias inversas:
apt-cache rdepends systemd --installed

GUÍA RÁPIDA PARA COMPILAR UN KERNEL REALTIME (TIEMPO REAL) EN LA RASPBERRY PI  (INSTRUCCIONES DE NOVIEMBRE DE 2017)
===================================================================================================================

NOTA: NO TIENE SENTIDO compilarte un kernel realtime si puedes aislar CPUs y ejecutar tareas en ellas (aunque sí sería interesante que esas CPUs
fueran además tickless: de ese modo tienes un desempeño similar a baremetal). Es mejor esa alternativa para asegurarte de que nada va a interrumpir
tu tarea.
Por otra parte, aumentar mucho los ticks del scheduler (Kernel features->Timer frequency) tampoco tiene sentido subirlos a 1000Hz
en un sistema para emuladores: eso es para escritorios, que NO ES LO MISMO! En un escritorio quieres responsividad y hay muchas tareas
a la vez que dan soporte a los programas (un navegador, correo electrónico, mensajería instantánea, programa de diseño, reproductor de música...
lo tienes TODO a la vez y quieres que todo tenga una respuesta buena).
EN UN SISTEMA EMULADOR ese no es el caso: tienes un proceso y se acabó. NO TIENE SENTIDO un scheduler repartiendo la CPU 1000 veces por segundo,
con 100 va que chuta. 
Si quieres elige 250 por aquello de la frecuencia de polling de los USBs, que con "usbhid.jspoll=1" puedes leerlos a 1000 Hz, 
o porque para audio es algo mejor, PUES OLVÍDATE: NO TIENE SENTIDO: EL KERNEL CORRE SOBRE HRTIMERS, QUE SON TIMERS INTERNOS DE ALTA RESOLUCIÓN.
O sea que EL KERNEL NO CORRE SOBRE EL VALOR DE LOS HZ DEL SCHEDULER: ESTE VALOR SÓLO INFLUYE EN PROGRAMAS MULTITHREAD DONDE LOS THREADS
ESTÁN "ATADOS" A TIEMPO DE COMPUTACIÓN.
Así que, SÍ, PUEDES TENER UN KERNEL CON HZ_100 Y QUE A LA VER HAGA EL POLING DE LOS USBS A 200HZ (EL VALOR POR DEFECTO ES 120HZ, así que ni te molestes
con lo del polling rate de todos modos).

Tampoco te compliques con el modelo de preemption: el modelo CONFIG_PREEMPT es para escritorios de baja latencia, una vez más son muchos procesos
a la vez y quieres responsividad en todos ellos, que NO es nuestro caso. Así que CONFIG_PREEMPT_VOLUNTARY va bien, que es el valor por defecto.
Puedes usar si quieres el CONFIG_PREEMPT, que es el siguiente, y que pone que es para sistemas embedidos de baja latencia. Bueno, no nos va a aportar gran
cosa en nuestro caso.

Lo de CONFIG_PREEMPT y 250HZ NO INFLUYE en la latencia, ni en el desempeño ni en nada.
Si luego te quieres meter con CPU isolation (que es DISTINTO a que las CPUs sean tickless: las CPUs aisladas no tienen que ejecutar ticks del scheduler CUANDO NO CORRE NADA EN ELLAS,
si hay algo corriendo en varias CPUs aisladas, tienen que correr ticks del scheduler sí o sí) ya es cosa tuya, el ningún beneficio evidente es que los programas que se ejecutan en una CPU aislada
no se quedan sin CPU nunca por culpa de otros programas: combínalo con ejecutar las aplicaciones con "chrt -f 99", que le da prioridad realtime y no suelta la CPU
porque no hay otra aplicación a la que dársela con la misma prioridad (SCHED_FIFO). Luego hay SCHED_RR, que es con -r, y que genera más ticks del scheduler, así que nos conviene menos.

EL MEJOR hilo donde se habla de estas cosas es este:
https://github.com/raspberrypi/linux/issues/1216
Yo no he encontrado mejor convensación sobre este tema en internet jamás.

PERO SI AÚN ASÍ QUIERES UN KERNEL REALTIME (para emuladores fuera de las X como único proceso de usuario no tiene sentido, pero bueno), ESTOS SON
LOS PASOS (que te pueden venir bien para compilar un kernel sin más):

git clone --depth 1 https://github.com/raspberrypi/tools ~/tools

export KERNEL=kernel7
export ARCH=arm
echo PATH=\$PATH:~/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin >> ~/.bashrc
source ~/.bashrc
export CROSS_COMPILE=~/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin

git clone --depth=1 https://github.com/raspberrypi/linux

make bcm2709_defconfig

Necesitamos parchear dos cosas: lo del RT del kernel, y una movida de los USB que hace que si no el kernel RT se cuelgue aleatoriamente.
Pillamos los dos parches y los dejamos en el directorio previo al de los surces del kernel (CUIDADO: pilla el parche de RT que empieza por patch.*,
NO el que empieza por patches.*, porque fallará):

wget https://raw.githubusercontent.com/fedberry/kernel/master/usb-dwc_otg-fix-system-lockup-when-interrupts-are-threaded.patch
wget https://www.kernel.org/pub/linux/kernel/projects/rt/4.9/patch-4.9.47-rt37.patch.xz

Aplicamos ambos parches:
xzcat ../patch-4.9.33-rt23.patch.xz | patch -p1
patch -i ../usb-dwc_otg-fix-system-lockup-when-interrupts-are-threaded.patch -p1 --dry-run
patch -i ../usb-dwc_otg-fix-system-lockup-when-interrupts-are-threaded.patch -p1

KERNEL=kernel7
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2709_defconfig

Si quieres ajustar algo del kernel, ahora es el momento de hacer:
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig
Tenemos al menos que cambiar:
Kernel features->Preemption model->Fully preemptible kernel (RT)
Kernel features->Timer frequency->(lee las notas más arriba: depende de lo que necesites, 1000Hz para un sistema casi mono-proceso no tiene
ningún sentido).

make -j8 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage modules dtbs

La instalación ya te la miras en la guía de compilación oficial:
https://www.raspberrypi.org/documentation/linux/kernel/building.md
PERO ESO SÍ: RECOMIENDO COPIAR EL NUEVO KERNEL COMO "kernel7_rt.img" Y ARRANCAR OPCIONALMENTE DESDE ÉL PONIENDO
kernel=kernel-myconfig.img EN CONFIG.TXT, POR SI NO ARRANCA NUESTRO KERNEL RT.

COMPILAR GCC EN GNU/LINUX
=========================

-Instalamos dependencias previas:
apt-get install libgmp-dev libmpfr-dev libmpc-dev

-Nos bajamos la última estable de https://ftp.gnu.org/gnu/gcc

-Configuramos, compilamos e instalamos con:

./configure --disable-multilib --enable-languages=c,c++

make -j8

make install

-Añadimos esto en nuestro /etc/profile.d/custom.sh:

export CC=/usr/local/bin/gcc
export CXX=/usr/local/bin/g++

NOTA: No hace falta desinstalar el GCC por defecto de la distro, y de hecho, si lo haces, se desinstala libtool
y si lo intentas reinstalar el GCC por defecto de la distro.

-PARA DESINSTALARLO, como "make uninstall" no funciona, puedes hacer una instalación "temporal" así:
make install DESTDIR=/tmp/gccinst
...Y luego ver qué nos ha instalado en /tmp/gccinst e ir eliminando esos archivos de /usr/local, etc.
(OJO!! Hazlo a mano, no intentes usar ningún script raro que acabas borrando todo el disco duro como la última vez...)

KMSCON, EL EMULADOR DE TERMINAL PARA CONSOLA QUE USA KMS/DRM
============================================================

Instalamos una dependencia previa, libtsm (Debian no tiene ni tendra la version necesaria, ya que tiramos de forks para todo lo de kmscon):

-Clonamos su repo: git clone --depth 1 https://github.com/Aetf/libtsm.git

-Configuramos con:

cmake .. -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

VAMOS CON KMSCON EN SI:

-Clonamos su repo:
git clone --depth 1 https://github.com/Aetf/kmscon.git

-Configuramos con:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup .. -Dbuildtype=release -Dtests=false -Ddocs=disabled -Dvideo_fbdev=disabled

COMPILAR EL KERNEL CON FULL PREEMPTION Y BFS PARA LA RASPBERRY PI
=================================================================

INFO DE https://www.raspberrypi.org/documentation/linux/kernel/building.md COMPLETADA POR MÍ PARA EL TEMA DEL SCHEDULER

Clonamos el kernel, rama por defecto que ahora mismo es la 4.9:
git clone --depth=1 https://github.com/raspberrypi/linux

Yo estaba en ~/src/pi, así que lo tengo en ~/src/pi/linux
Sigo en ~/src/pi

Me bajaré los parches a ~/src/pi

Nos bajamos el parche BFS correspontiente para nuestro kernel de
http://ck.kolivas.org/patches/bfs

Nos bajamos el parche RT correspontiente para nuestro kernel de
https://www.kernel.org/pub/linux/kernel/projects/rt

Ahora aplico ambos parches. Entro en ~/src/pi/linux y hago:
patch -p1 < ../patch-4.4.9-rt17.patch
patch -p1 < ../4.4-sched-bfs-467.patch

Ahora ponemos en el path la ruta del crosscompilador:
PATH=$PATH:$HOME/tools/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/bin 
Ya deberíamos tener accesibles los binarios arm-linux-gnueabihf-

Ahora pillo la config por defecto para Pi2 y Pi3, que es la misma (estos pasos son de https://www.raspberrypi.org/documentation/linux/kernel/building.md):
KERNEL=kernel7
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2709_defconfig

Ahora, miramos http://ck.kolivas.org/patches/bfs/bfs-configuration-faq.txt y tratamos de cumplir las condiciones para mobile/netbook, o sea:
300 Hz
Tickless
Full preemption
CPU frequency scaling, ondemand default

Para ello entramos en menuconfig:
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig
Y vamos punto por punto:
-Lo de los HZ está en  KERNEL FEATURES->TIMER FREQUENCY
-Lo de Full Preemption está en KERNEL FEATURES->PREEMPTION MODEL
-Lo de Tickless está en GENERAL SETUP->TIMERS SUBSYSTEM->Timer tick handling
-Lo de CPU frequency scaling está en CPU POWER MANAGEMENT->CPU FREQUENCY SCALING
-Verifica que tienes activo el BFS en GENERAL SETUP, justo la PRIMERA opción que sale tras aplicar el parche.
 Una vez que ha arrancado el kernel, puedes comprobarlo del todo haciendo dmesg | grep scheduler y debería salir el BFS

-En menuconfig podemos quitar muchas cosas. Para saber cuáles son las mínimas mínimas para que funcione lo básico, mírate esto:
http://raspberrypi.stackexchange.com/questions/24092/kernel-config-necessary-options
EL DRIVER OTG (Synopsis DWC host support en DEVICE DRIVERS->USB SUPPORT) tiene que ir INCLUIDO, NO COMO MÓDULO, o el kernel no compilará.
EN FILESYSTEMS, deja tranquilo el AUTOMOUNT ese o systemd se quejará.

-Si quieres quitar el DEBUG_KERNEL, primero desactiva "Embedded system" en General Setup, y luego desactiva "Configure standard kernel features (expert users)"
que está un poco más arriba.
Ahora ya te puedes ir a "Kernel Hacking" y desactivar "Kernel debugging". Listo! 

Ahora compilamos:
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage modules dtbs -j8

Para instalar kernel, módulos y demás, sigue ya con: https://www.raspberrypi.org/documentation/linux/kernel/building.md

RIGEL ENGINE, Duke Nukem II en Linux
====================================

Clonamos su repo:

git clone --recurse-submodules --depth 1 -j8 https://github.com/lethal-guitar/RigelEngine.git

Creamos el directorio de compilación, configuramos y compilamos:
mkdir b4
cd b4

cmake -DUSE_GL_ES=ON -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" ..

SI QUEREMOS UNA VERSIÓN ESTABLE: Nos vamos a mirar los tags de su repositorio, que están en: https://github.com/lethal-guitar/RigelEngine/tags
Allí, buscamos la última release y nos quedamos con el nombre del tag de esa release.
Sabiendo eso, clonamos el tag de la release, e inicializamos los submódulos:
git clone --recurse-submodules --depth 1 --branch <nombre de la última release> https://github.com/lethal-guitar/RigelEngine.git

DEVILUTIONX, Diablo en Linux
============================

Dependencias previas:
sudo apt-get install libsodium-dev libbz2-dev --no-install-recommends

Si quieres que los assets del juego (incluidos con los sources, son diferentes de los DATOS del juego, los datos los tienes que poner tú)
queden en un solo fichero llamado "devilutionx.mpq" en vez de en el directorio "assets",
tu distro debe usar una versión de smpq que use una libstorm superior a la versión 9.22 ya que libstorm 9.22 está rota en aarch64:
sudo apt-get install smpq --no-install-recommends

---Vamos con DevilutionX en sí:---

Bajamos la última estable de:
https://github.com/diasurgical/devilutionX/releases

Configuramos con:
cmake -DCMAKE_BUILD_TYPE=Release -DDEBUG=OFF \
-DASAN=OFF -DDISABLE_ZERO_TIER=ON -DBUILD_TESTING=OFF \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" ..

Compilamos y metemos en el directorio ~/diablo:
-El ejecutable "devilutionx"
-El archivo "devilutionx.mpq", que se nos generará en el directorio de compilación si hemos instalado el paquete "smpq"
 en las dependencias previas.
 (Esto no podemos hacerlo en versiones antiguas de Debian en ARM64/aarch64, como Debian 11,
 porque su paquete "smpq" usa la versión de libstorm 9.22, que está rota en aarch64, así que en ese caso copiaríamos
 el diectorio "assets", que se nos crea en el directorio de compilación, que hace las veces de "devilution.mpq").
 
-El fichero de los datos del juego, que se llama "diabdat.mpq" y que tienes que conseguir por tu cuenta.

La primera vez que ejecutemos el juego, se creará el fichero de configuración en ~/.local/share/diasurgical/devilution/diablo.ini
Para saber más de su contenido, mira esto: https://github.com/diasurgical/devilutionX/wiki/DevilutionX-diablo.ini-configuration-guide

-Puedes poner Scaling Quality a 1, que es BILINEAR simplemente (viene a 2 que es anisotrópico).
-Puedes poner Buffer Size a 1024
-Si quieres que vaya a 16:9, pon "Fit to Screen=1"
(En 16:9 usa un 10% más de CPU, y upscaling es por hardware así que no usa nada de CPU extra).

Si nos da un error repetido de "Unhandled SDL Event: SDL_AUDIODEVICEADDED", ni caso. No es por el sistema sino porque el código del juego imprime eventos que no usa.
Manda la salida a /dev/null y fuera.

SM64EX, port del Mario64 para GNU/Linux
========================================

Clonamos los surces:
git clone --depth 1 https://github.com/AloUltraExt/sm64ex-alo.git

Editamos src/pc/gfx/gfx_sdl2.c y: 
-Añadimos SDL_WINDOW_FULLSCREEN_DESKTOP a los flags de SDL_CreateWindow()
-Añadimos "SDL_ShowCursor(SDL_DISABLE);" justo debajo de la llamada a SDL_CreateWindow()
-Comentamos la llamada a gfx_sdl_set_fullscreen() que hay justo debajo.

Editamos Makefile, y en la linea "OPT_FLAGS := -O2", añadimos "-march=native -mtune=native"
(Si compilas con TARGET_RPI=1 esto se hace solo, pero para el resto de sistemas tienes que añadirlo).

Hay que tener baserom.us.z64 en el directorio raiz.

Se compila asi:
make USE_GLVND=1 HIGH_FPS_PC=1 RUMBLE_FEEDBACK=0 BETTERCAMERA=0 -j10

El ejecutable queda en build/us_pc/sm64.us.f3dex2e

No hay que activar el VSYNC si estás usando ZINK, ya que en Vulkan no hace falta y produce stuttering.

Le puedes tocar el tamaño de buffer de audio en src/pc/audio/audio_sdl.c, busca 32000 y a partir de ahí ves todo. Pero vamos, viene en 512, si lo tocas será para subirlo a 1024.

Las versiones más antiguas, como el sm64-ex original, piden algunas dependencias que sólo necesita en la máquina donde se extraen
los datos del juego, que puede ser un PC de escritorio y luego compilar en la Pi.
Si al compilar en la Pi te da errores con las tools que se hayan compilado antes en X86_64, haz todo esto:

rm tools/aifc_decode
rm tools/aiff_extract_codebook
rm tools/vadpcm_enc
rm tools/textconv
rm tools/skyconv
rm tools/n64graphics
rm tools/n64cksum
rm tools/audiofile/libaudiofile.a
make clean

Si aun así da error, borra el fichero con el que da error (el tool que da el error seguramente ya lo hayas borrado antes).

Para usar el mando Saffun N64 2.4G, no hace falta que exportemos ningún SDL_GAMECONTROLLERCONFIG, basta con ponerlo en modo X-Input,
lo cual se hace pulsando START + B durante 3 segundos.

SM64-COOP, SUPER MARIO 64 COOPERATIVO EN GNU/LINUX
==================================================

Clonamos su repo:

git clone --depth 1 https://github.com/djoslin0/sm64ex-coop

Metemos la ROM en el directorio raiz de los sources como "baserom.us.z64"

Compilamos así:

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
make TARGET_RPI=1 DISCORD_SDK=0 -j4

----PARA HOSTEAR O CONECTARNOS A UNA PARTIDA----

Busca e instala, en Aurora Store, el "FWD PORT FORWARDER".
(Es totalmente opensource y está en github, solo que no está en FDRoid).

ZELDA OOT EN GNU/LINUX
======================

--Instalamos dependencias previas:
apt-get install libbz2-dev libpng-dev lsb-release libzip-dev zipcmp zipmerge ziptool \
libtinyxml2-dev nlohmann-json3-dev libspdlog-dev

--Clonamos su repo:
git clone https://github.com/HarbourMasters/Shipwright.git --depth 1 --recurse-submodules
Si quisié la última versión estable del repo, y si por ejemplo fuese la 9.0.2, haríamos:
git clone https://github.com/HarbourMasters/Shipwright.git --depth 1 --recurse-submodules -b 9.0.2 

--Editamos "libultraship/cmake/dependencies/common.cmake", buscamos la línea "find_package(OpenGL QUIET)" y justo encima ponemos:
set(OPENGL_USE_OPENGL ON)

--Configuramos y compilamos con:

mkdir b4
cd b4

cmake .. -GNinja \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_BUILD_TYPE=Release

ninja -j10

NOTA: Para Pi5, usa -j2
(No hace falta disco de swap. Y recuerda NO pasarle más de -j2, porque en la Pi5 fallará aunque le metas gigas y gigas de swap).

PARA EXTRAER LOS DATOS DEL JUEGO PARA LA VERSIÓN DE SOH/LUS QUE ACABAMOS DE COMPILAR:
--Nos bajamos la ROM de No-Intro llamada "Legend of Zelda, The - Ocarina of Time (Europe) (GameCube).zip", extraemos la ROM del ZIP
y la copiamos a "OTRExporter/baserom.z64"
--En el mismo directorio donde acabamos de compilar el juego, hacemos:
cmake --build . --target ExtractAssets -j4
--Copiamos los archivos "oot.otr" y "soh.otr" al mismo directorio donde tenemos el ejecutable "soh.elf":
cp soh/*.otr ~/zelda64/

ALTERNATIVA PARA EXTRAER LOS DATOS DEL JUEGO SIN COMPILAR EL JUEGO:
--Nos bajamos la ROM de No-Intro llamada "Legend of Zelda, The - Ocarina of Time (Europe) (GameCube).zip", extraemos la ROM del ZIP
y la copiamos a "OTRExporter/baserom.z64"
--Hacemos:
mkdir assets (lo podemos llamar como queramos, lo llamo "assets" por llamarlo de alguna manera)
cd assets
cmake ..
cmake --build . --target ExtractAssets -j4
--Copiamos los archivos "soh.otr" y "oot.otr" al mismo directorio donde tenemos el ejecutable "soh.elf":
cp soh/*.otr ~/zelda64/

--NOTAS ADICIONALES--

PARA QUE NO DE TIRONCILLOS EN WAYLAND+AdaptiveSync, limita la tasa de frames del juego a 60 y activa el VSYNC.

PARA QUE NO DESAPAREZCAN OBJETOS DEL ESCENARIO AL LLEGAR A LOS BORDES EN MODO 16:9, habilitamos "Enhancements->Graphics->Widescreen Actor Culling"

PARA USAR MODS, creamos el directorio ~/zelda64/mods y los metemos ahí.
Si el MOD tiene directorios, da igual, lo metes tal cual con sus directorios.
Ahora activamos "Enhancements->Graphics->Mods->Use Alternate Assets" y ya se cargan y se utilizan.
Si usas el Djipi's 3DS Experience debes tener activados:
Enhancements->Graphics->Mods->Disable Grotto Fixed Rotation
Enhancements->Graphics->Enable 3D dropped items / projectiles
Y desactivado:
Enhancements->Fixes->Out of Bounds Textures

--TRADUCCIÓN AL CASTELLANO--

GENERAR EL MOD DE TRADUCCIÓN

--OPCIÓN RECOMENDADA:
----Nos bajamos la ROM traducida al castellano: https://archive.org/download/legend-of-zelda-ocarina-of-time-esp-v-2.22
----Nos bajamos el script de extracción de la traducción.
	Para ello, nos vamos a https://github.com/xoascf/OTRMod?tab=readme-ov-file y buscamos "same script", y ahí está el link a script.
----Nos vamos a: https://soh.xoas.eu.org y allí ponemos la ROM traducida y el script de extracción, y nos genera el mod.
----Podemos editar los textos en la propia página. Para ello, vamos a la sección "Text Editor", cargamos el OTR,
    modificamos lo que queramos, y generamos otro OTR que ya tendrá las modificaciones que hayamos hecho.
	OJO: Tenemos que sustituir los REPLACES por los que tienen en el canal de la traducción en Discord,
	o luego se verán mal los acentos y otros símbolos especiales.

--OPCIÓN ALTERNATIVA (Generar el MOD de traducción localmente)
-Nos bajamos la última versión de la herramienta de creación de mods (bajamos el que acaba en .EXE):
https://github.com/xoascf/OTRMod/releases
-Lo ejecutamos con WINE, y nos pide la ROM traducida y el script de extracción, y ya.

Para usar el mando Saffun N64 2.4G, no hace falta que exportemos ningún SDL_GAMECONTROLLERCONFIG, basta con ponerlo en modo X-Input,
lo cual se hace pulsando START + B durante 3 segundos.

ZELDA MAJORA'S MASK en GNU/Linux
================================

--Instalamos dependencias previas:
apt-get install lsb-release

--Clonamos su repo:
git clone --depth 1 --recurse-submodules https://github.com/HarbourMasters/2ship2harkinian

--Editamos "libultraship/cmake/dependencies/common.cmake", buscamos la línea "find_package(OpenGL QUIET)" y justo encima ponemos:
set(OPENGL_USE_OPENGL ON)

--Configuramos y compilamos:

mkdir b4
cd b4

cmake .. -GNinja \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_BUILD_TYPE=Release

ninja -j10

mkdir ~/majora
cp mm/2s2h.elf ~/majora/

PARA QUE NO DE TIRONCILLOS EN WAYLAND+AdaptiveSync, limita la tasa de frames del juego a 60 y activa el VSYNC.

PARA QUE NO DESAPAREZCAN OBJETOS DEL ESCENARIO AL LLEGAR A LOS BORDES EN MODO 16:9, habilitamos "Enhancements->Graphics->Widescreen Actor Culling"

	----EXTRACCIÓN DE LOS DATOS----

--Bajamos la ROM USA 1.0 (Nos vale la ROM americana que hay en CDRomance), y la metemos en OTRExporter.
--En el mismo directorio donde acabamos de compilar el juego, hacemos:
cmake --build . --target ExtractAssets -j10
--Copiamos los archivos de datos a su sitio:
cp mm/mm.o2r mm/2ship.o2r ~/majora/

STARFOX64 EN GNU/LINUX
======================
NOTAS PREVIAS:
---Este port no tiene soporte GLES, así que como vas a ver, retocamos ligeramente el CMakeLists.txt para que compile contra GLVND.
---Por ahora no podemos pasarle ni "CMAKE_C_FLAGS", ni "CMAKE_CXX_FLAGS" ni "-DCMAKE_BUILD_TYPE=Release",
porque entonces el ejecutable resultante nos da errores.

--Clonamos su repo:
git clone --depth 1 --recurse-submodules https://github.com/HarbourMasters/Starship.git
--Si queremos una versión estable (en este caso la 2.0.0,
podemos sacar el número de las versiones estables mirando https://github.com/HarbourMasters/Starship/tags):
git clone --depth 1 --recurse-submodules https://github.com/HarbourMasters/Starship.git -b v2.0.0

--Editamos "CMakeLists.txt", buscamos "find_package(OpenGL REQUIRED)", y justo encima ponemos:
set(OPENGL_USE_OPENGL ON)

--Configuramos y compilamos con:
mkdir b4
cd b4
cmake .. -GNinja
ninja -j10

PARA QUE EMPIEZE A PANTALLA COMPLETA:
Activa la opción de "Windowed Fullscreen" o añade en "starship.cfg.json" esto a capón:
"Fullscreen": {"Enabled": true},

PARA EVITAR LOS "CLICKS" CUANDO EMPIEZAN Y TERMINAN LAS CONVERSACIONES DE RADIO: baja el "Master Volume" a ~80%
en el menú del configuración del engine.
Si no se salva al volver a entrar (hay un bug con esto, ya lo he reportado), ponlo a capón editando "starship.cfg.json"
que se crea solo en el directorio donde tienes el ejecutable.

	BLOQUE EXTRACCIÓN DE LOS DATOS
	
--La ROM necesaria es "Star Fox 64 (USA) (Rev 1).z64" con SHA1: 09f0d105f476b00efa5303a3ebc42e60a7753b7a
  La renombramos a "baserom.z64" y la metemos en el directorio raíz de los sources, y en el directorio donde acabamos de
  compilar el engine hacemos:
  cmake --build . --target ExtractAssets
  cmake --build . --target GeneratePortO2R -j10
  ...Y copiamos el archivo resultante "sf64.o2r" al mismo directorio que el ejecutable (yo lo meto todo en "~/starfox64").

PARA QUE NO DE TIRONCILLOS EN WAYLAND+AdaptiveSync, limita la tasa de frames del juego a 60 y activa el VSYNC.

GAMBARE GOEMON 64 (Goemon64, Mystical Ninja 64) en GNU/Linux
============================================================
NOTA: La documentación original está aquí --> https://github.com/klorfmorf/Goemon64Recomp/blob/modding/BUILDING.md

--Instalamos dependencias previas: sudo apt-get install cmake ninja-build libsdl2-dev libgtk-3-dev lld llvm clang
--Clonamos el repo: git clone --depth 1 --recurse-submodules https://github.com/klorfmorf/Goemon64Recomp.git

NOTA: Ahora mismo falla la compilación final con CLANG 19, que es la versión de CLANG que se nos instala con DEBIAN
al instalar el paquete "clang". Así que si el comando "clang --version" no te da que estás en la versión 18, haz esto:
apt-get purge clang
apt-get install clang-18
sudo update-alternatives --install /usr/bin/clang clang /usr/bin/clang-18 100
sudo update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-18 100
ESTO DENTRO DE UN TIEMPO NO DEBERÍA SER NECESARIO (lo tienen que arreglar desde el recomp).

BLOQUE DE DESCOMPRESIÓN DE LA ROM

--Instalamos dependencias previas: sudo apt install build-essential python3 git binutils-mips-linux-gnu
--Clonamos el repo: git clone --depth 1 --recurse-submodules https://github.com/klorfmorf/mnsg.git
--Entramos en el raiz los sources, y allí creamos un entorno Python virtual, entramos en él e instalamos las dependencias de Python necesarias:
cd mnsg
python3 -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
--Metemos la ROM USA del Mystical Ninja 64 como "baserom.us.z64" en el raiz de los sources (es decir, en la raiz de "msng").
--Extraemos los assets de la ROM:
make setup VERSION=us
--Reconstruimos la ROM:
make VERSION=us
--Copiamos el fichero resultante "baserom.us.decompressed.z64" al raiz de los sources de Goemon64Recomp como "mnsg.us.decompressed.z64":
cp baserom.us.decompressed.z64 ~/src/Goemon64Recomp/mnsg.us.decompressed.z64

BLOQUE "N64RECOMP"

--Clonamos su repo: git clone --depth 1 --recurse-submodules https://github.com/N64Recomp/N64Recomp.git
--Compilamos con:
mkdir b4
cd b4
cmake ..
make -j10
--Copiamos los ejecutables "N64Recomp" y "RSPRecomp" al raiz de los sources de Goemon64Recomp

BLOQUE DE RECOMPILACIÓN

--Nos vamos al raiz de los sources de Goemon64Recomp y hacemos:
./N64Recomp mnsg.us.toml
./RSPRecomp aspMain.us.toml

--Aplicamos unos parches:
cp N64ModernRuntime.patch lib/N64ModernRuntime
cd lib/N64ModernRuntime
git apply N64ModernRuntime.patch

cp rt64.patch lib/rt64
cd lib/rt64
git apply rt64.patch

--Compilamos para nuestra arquitectura al fin:
cmake -S . -B build-cmake -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_COMPILER=clang -G Ninja -DCMAKE_BUILD_TYPE=Release
cmake --build build-cmake --target Goemon64Recompiled -j$(nproc) --config Release

BLOQUE DE EJECUCIÓN

Creamos el directorio ~/goemon64, y allí copiamos:
-El ejecutable "Goemon64Recompiled"
-El directorio "assets" que viene con los sources
-La ROM original USA del Goemon64.
Y ya deberíamos poder ejecutar "Goemon64Recompiled", y en el menú que nos sale seleccionar la ROM y jugar.

MAGIC CARPET 2 HD (antes remc2) en GNU/Linux
============================================

Instalamos dependencias previas:
sudo apt-get install libboost-system-dev libboost-dev --no-install-recommends

clonamos su repo:
git clone --depth 1 --recurse-submodules -j8 https://github.com/thobbsinteractive/magic-carpet-2-hd.git

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
cmake -DCMAKE_BUILD_TYPE=Release ..

Ahora crea ~/carpet2, y mete ahí:
-el ejecutable "remc2".
-el fichero "config.ini", que viene con los sources.
-el directorio "font" que viene con los sources. Está en "magic-carpet-2-hd/x64/Debug/font".

PARA INSTALAR LOS DATOS DEL JUEGO (NO NECESARIO YA QUE TIENES LOS DATOS PREPARADOS EN EL DISCO DURO DE BACKUP):
-Copia el directorio "NETHERW" de los datos del juego instalado a "~/carpet2/NETHERW"
(Es decir, los datos del juego deben estar en "~/carpet2/NETHERW").
-Crea el directorio "~/carpet2/CD_Files" y copia allí los contenidos de la ISO del CD original
PERO renombrando TODOS los archivos a mayúsculas.

FLARE, un engine RPG libre en GNU/Linux
=======================================

Clonamos el repo del engine y del juego:
git clone --depth 1 https://github.com/flareteam/flare-engine.git
git clone --depth 1 https://github.com/flareteam/flare-game.git

creamos el directorio de compilación, entramos en él, configuramos y compilamos:
mkdir b4
cd b4
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native" ..
make -j4

creamos ~/flare y mandamos el ejecutable flare allí.

entramos en flare-game, copiamos el mod default de flare-engine al directorio de mods de flare-game, y copiamos el directorio mods a ~/flare
cd flare-game
cp -R ../flare-engine/mods/default mods/
cp -R mods ~/flare

Ahora ya podemos ejecutar el juego y activar la campaña.

EXULT, Ultima VII en GNU/Linux
==============================

Cosas que debemos instalar previamente:
sudo apt-get install autoconf automake libtool

Clonamos

git clone --depth 1 https://github.com/exult/exult.git

---MODIFICACIONES AL CÓDIGO

Editamos exult.cc, comentamos la línea
std::atexit(SDL_Quit);
Y añadimos SDL_Quit() al final de la función Play(), antes del return(0).

---CONFIGURACIÓN DEL CÓDIGO

Instalamos dependencias: apt-get install automake autoconf autoconf-archive libtool

Configuramos con:

autoreconf -v -i

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure --disable-all-hq-scalers --disable-nxbr --disable-tools \
--disable-timidity-midi --disable-alsa --disable-sdl-parachute \
--enable-lto --with-optimization=normal --prefix=$HOME/ultima7

PODRÍAS PONER --with-optimization=heavy EN LUGAR DE --with-optimization=normal, PERO ESO CAUSA SEGFAULTS A VECES.

Compilamos con make -j4

---INSTALACIÓN DEL JUEGO

Hacemos:
make install
...Esto creará:
~/ultima7/bin, donde la instalación que acabamos de hacer mete el ejecutable "exult" y el fichero "exult.cfg",
~/ultima7/share, donde la instalación que acabamos de hacer meterá unas cosas, y nosotros meteremos a mano los datos del juego,
siguiendo las instrucciones a continuación.

Creamos el directorio ~/ultima7/share/exult/forgeofvirtue
Copiamos los directorios "static" y "gamedat" de nuestra instalación de Ultima 7 a ~/ultima7/share/exult/forgeofvirtue

Para tener música y efectos de sonido, bájate el ZIP all-in-one de aquí:
http://exult.sourceforge.net/download.php
Y simplemente mete los contenidos del zip en ~/ultima7/share/exult, ahí a saco sin más. No hay que añadir nada en el CFG, va solo con lo que tienes.

La pantalla lo mejor es dejarla así:
Full Screen: Enabled
Display Mode: La resolución nativa del monitor
Scaler: Interlaced
Scaling: 2x
Game Area: Auto
Fill Quality: Point
Fill Mode: Fit
AR Correction: Disabled

Y listo!

LOVE2D en GNU/Linux (love)
==========================

Bajamos los últimos source estables de:
https://github.com/love2d/love/releases

--Instalamos dependencias previas
sudo apt-get install --no-install-recommends libmodplug-dev libphysfs-dev libtheora-dev libmpg123-dev libluajit-5.1-dev luajit

--La otra dependencia es OpenAL (tienes instrucciones para compilarlas e instalarlas).

--Editamos CMakeFiles.txt, buscamos "OpenGL" y borramos las dos llamadas a "find_package()" donde aparece,
y añadimos esto fuera de cualquier condición:
set(LOVE_LINK_LIBRARIES ${LOVE_LINK_LIBRARIES} OpenGL)

--Configuramos love con:
cmake -DCMAKE_C_FLAGS="-march=native -mtune=native -O2" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2" ..

--Para instalarlo, copia el ejecutable "love" junto con la librería "libliblove.so" donde quieras.

--Los juegos se lanzan con nombre de directorio! No lances un .love directamente, porque así no funciona.

INSTALAR JACKD2 GNU/LINUX
=========================
FUENTES: http://jrigg.co.uk/linuxaudio/jack2debian7.html
		 http://jackaudio.org/faq/linux_rt_config.html

NO debes usar el gestor de paquetes para esto, porque la versión de libjack, jackd2, etc.. que trae Debian
está compilada con soporte para basuras varias, como X11 o DBUS.
Así que toda compilar a instalar la nuestra:
Bajamos los últimos sources estables de: https://github.com/jackaudio/jack2/releases
cd jack2
./waf configure --alsa --prefix=/usr
./waf -j4
sudo ./waf install
Instala tanto las librerías, como los las headers para desarrollo, como jackd.

Ahora añadimos el overlay que permite que el audio i2s funcione con mmap de verdad:
dtoverlay=i2s-mmap
(Esto es si estás usando una tarjeta de audio conectada por i2s, como la hifiberry)

Ahora añadimos mi usuario al grupo audio (probablemente ya esté):

sudo adduser pi audio

Y editamos /etc/security/limits.conf, añadiendo unas cosillas para quitar ciertas limitaciones a los miembros de ese grupo:
@audio   -  rtprio     99
@audio   -  memlock    unlimited

Comprobamos que tenemos quitados esos límites con:
ulimit -r -l
Nos tiene que salir algo como:
real-time priority (-r) 99
max locked memory (kbytes, -l) unlimited
¡¡¡CUIDADO!!!! COMPRUEBA ESTO EN LOCAL Y NO POR SSH, porque POR SSH PUEDE NO FUNCIONAR Y SÍ EN LOCAL.
En el caso de DROPBEAR, que es el servidor SSH que usamos nosotros, NO ESTÁ LINKADO con libpam, así que 
LOS SETTINGS DE limits.conf son directamente IGNORADOS SI NOS CONECTAMOS POR SSH si usas dropbear.

Puedes lanzar jackd a mano para que empieze a escuchar con:
jackd -R -P 70 -d alsa -r 48000 -n 2 -p 1024

--BLOQUE ERROR RECALCITRANTE--
SI TE DA UN ERROR COMO ESTE:
Cannot bind server to socket err = No such file or directory
Server channel open error
JackServer::Open failed with -1
..:SIGNIFICA QUE TE FALTA /dev/shm, ASÍ QUE DEBERÍAS TENER ESTO EN EL CUSTOM INIT SCRIPT QUE LEVANTA TU SISTEMA:

mkdir /dev/shm
mount -t tmpfs tmpfs /dev/shm
--FIN BLOQUE ERROR RECALCITRANTE--

También puedes lanzar retroarch compilado con soporte para jack y funciona muy bien, con una latencia por defecto de 21ms
que hasta donde yo sé no se puede cambiar porque la opción de la latencia de audio no hace nada, siempre son 21ms (lo dice retroarch al iniciarse
si no has silenciado todos los mensajes).
Y aunque la pudieras bajar da igual porque la latencia de audio que tienes viene dada por dispmanx, o sea, viene del vídeo, no se puede bajar más.
Con esos 21ms hay algo de cracking, así que mejor nos quedamos con el driver ALSA y ya.

UN SCRIPT PARA DETECTAR SI ESTAMOS EN UNA RPI
=============================================

if grep -q BCM2708 /proc/cpuinfo; then
        echo "Estamos en una Raspberry Pi"
fi

INSTALAR GCC 6.3 USANDO LOS REPOS DE STRETCH EN JESSIE (RASPBIAN)
================================================================

Actualizamos la lista de paquetes y los paquetes, estando aún en jessie:
sudo apt-get update
sudo apt-get upgrade

Cambiamos jessie por stretch en 
sudo vim /etc/apt/sources.list

Actualizamos la lista de paquetes a la de stretch:
sudo apt-get update

Instalamos gcc 6:
sudo apt-get install gcc-6 g++-6

Desisntalamos gcc 4.x:
sudo apt-get purge 4.9

Volvemos a poner jessie donde estaba stretch, y actualizamos a los índices de jessie:
sudo vim /etc/apt/sources.list
sudo apt-get update

TWIN, el gestor de ventanas para TTY
=============================

Clonamos su repo de:
https://github.com/cosmos72/twin

Instalamos esta dependencia previa si queremos ratón en la consola:
sudo apt-get install gpm libgpm-dev --no-install-recommends

Configuramos e instalamos:
CFLAGS="-O2 -march=native -mtune=native -O2" \
CXXFLAGS="-O2 -march=native -mtune=native -O2" \
./configure --prefix=/usr --enable-hw-tty=yes  --enable-hw-x11=no 
make -j4
sudo make install

Se activa el menú para moverse por él con el teclado con F12.

HEROES OF MIGHT AND MAGIC II (fheroes2) en Linux
================================================

Bajamos la última estable de:
https://github.com/ihhub/fheroes2/releases

Compilamos con:

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
WITHOUT_AUDIOCD=1 WITHOUT_XML=1 make -j4

SI TIENES MOVIMIENTO ERRÁTICO DEL RATÓN: Desconecta el mando USB.

PARA INSTALAR EL JUEGO CON SUS DATOS POR PRIMERA VEZ:
Creamos ~/heroes2
Copiamos el ejecutable a ~/heroes2
Copiamos el directorio files que viene con los sources a ~/heroes2, quedando ~/heroes2/files
Copiamos el archivo heroes2.key que viene con los sources a ~/heroes2
Copiamos los directorios DATA, MAPS, y ANIM de una instalación del Heroes 2 a ~/heroes2
(Los nombres de los directorios pueden estar en mayusculas o en minusculas, da igual eso).
Copiamos los .ogg que vienen en MUSIC de una instalación del Heroes 2 de GOG a ~/heroes2/music (los de GOG vienen desordenados,
ya que van de 01 a 42 y deberían ir de 02 a 43! Es sólo moverlas una posición adelante todas al renombrarlas, que tienes que renombrarlas a Track02.ogg, Track03.ogg, etc).
(No hace falta que les cambies el nombre ni nada, con que lleven en el nombre el número de pista, le vale).

El fichero de configuración es ~/.config/fheroes2/fheroes2.cfg
Se genera cuando ejecutas el engine por primera vez.
Ahí puedes ponerlo a pantalla completa, activar el vsync, hacer que no salga la cutre-intro con "show game intro = off", etc.

INSTALAR OPENAL en GNU/Linux
============================

Bajamos la última release de: https://github.com/kcat/openal-soft/releases
(Busca la última release en sí, no lo que pone "makemhr...").

Configuramos así:
cmake -DCMAKE_BUILD_TYPE=Release -DALSOFT_BACKEND_OSS=OFF -DALSOFT_REQUIRE_PIPEWIRE=OFF \
-DALSOFT_BACKEND_WAVE=OFF -DALSOFT_BACKEND_PORTAUDIO=OFF -DALSOFT_EXAMPLES=OFF \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" ..

STUNT CAR RACER EN GNU/LINUX
============================

Instalamos una dependencia previa (a parte de openal, justo encima lo tienes):
sudo apt-get install libglm-dev

Clonamos el repo de 
git clone --depth 1 https://github.com/ptitSeb/stuntcarremake.git

SÓLO SI NO USAS ZINK:
Editamos StuntCarRacer.cpp, y debajo de la llamada a "SDL_SetWindowTitle", añadimos:
SDL_GL_SetSwapInterval(1);

Editamos dx_linux.cpp, y justo antes de la línea:
glTexSubImage2D(GL_TEXTURE_2D, 0, j*m_fontsize, i*m_fontsize, surf->w, (surf->h>=m_fontsize)?m_fontsize-1:surf->h, GL_RGBA, GL_UNSIGNED_BYTE, surf->pixels);
...Añadimos:
glPixelStorei(GL_UNPACK_ROW_LENGTH, surf->pitch / surf->format->BytesPerPixel);

Editamos Makefile, y dejamos la línea:
LIB += -lGL -lGLU
como:
LIB += -lOpenGL

Compilamos con:
FLAGS="-march=native -mtune=native -O2" make -j10 LINUX=1 SDL=2 DEBUG=0

Creamos el directorio ~/stunt, y allí metemos el ejecutable "stuntcarracer", el archivo "DejaVuSans-Bold.ttf",
y los directorios "Bitmap", "Tracks", y "Sounds" que vienen con los sources.

Ejecutamos con:
stuntcarracer -f -d -n
..Donde "-f" es para pantalla completa, "-d" para usar la resolución actual, y "-n" para desactivar el MSAA.

ELDRITCH en GNU/LINUX
=====================

Clonamos su repo:
git clone --depth 1 https://github.com/ptitSeb/Eldritch.git

Creamos el directorio de compilación, entramos, configuramos y compilamos:
mkdir Code/b4
cd Code/b4
cmake -DGLES=ON -DWITH_SDL2=on -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" ..
make -j4

Para instalar el juego:
-Copia b4/Projects/Eld/Eld a ~/eldritch
-Copia los datos del juego (que los tienes ya preparados en el disco duro de backup) junto con el ejecutable.

SI TIENES QUE PRERARAR DE NUEVO LOS DATOS DEL JUEGO...(COSA QUE NO DEBERÍA PASAR)
Para preparar los datos del juego, tenemos que obtener el directorio Config, que tiene unos archivos .ccf dentro.
-Bájate la versión "Eldritch Reanimated 406". Instálala, y copia los archivos eldritch*.cpk a ~/eldritch. Todos.
-Cópiate eldritch-base.cpk a algún directorio de trabajo junto con la herramienta FilePacker.exe, que viene incluida con los sources
 en Eldritch/Projects/Eld/Tools/unpack.
 Descomprime eldritch-base.cpk así: wine FilePacker.exe -u eldritch-base.cpk
 Obtendrás los directorios Config, Fonts, Misc, y Shaders. Copia el directorio Config (SÓLO ESE) a ~/eldritch, junto con el ejecutable del juego.

OTRAS NOTAS 
CUIDADO porque este juego carga manualmente libSDL2.so en Code/Libraries/SoLoud/src/backend/sdl/soloud_sdl_dll.c,
en la función openDLL(). Así que si no arranca, fíjate que tu libSDL2.so (que es un link simbólico) esté apuntando
a una librería que realmente exista en el sistema (a veces hay lio con esto porque en Lubuntu desinstalas malamente
las SDL2 que vienen e instalas las tuyas para desarrollo, etc).

GZDOOM en GNU/Linux
===================

-Primero, necesita OpenAL. Tienes las instrucciones de instalación en este documento.

-Segundo, necesita ZMUSIC. Vamos con ZMUSIC pues:
--Instala libmpg123-dev y libvorbis-dev.
--Descarga los últimos sources estables de:
https://github.com/ZDoom/ZMusic/tags
--Compilamos con:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native"
make -j4

-Tercero, más dependencias previas: apt-get install libvpx-dev libwebp-dev --no-install-recommends


	VAMOS A POR GZDOOM EN SÍ


Bajamos los últimos sources estables de: https://github.com/ZDoom/gzdoom/releases

Configuramos con:

cmake .. -DCMAKE_BUILD_TYPE=Release -DVULKAN_USE_XLIB=OFF -DVULKAN_USE_WAYLAND=ON \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native"

Tenemos que copiar, al directorio de ~/doom:
gzdoom
*.pk3
soundfonts

Yo lanzo doom así:
./gzdoom -iwad doom.wad -file doom1music.wad smoothed.wad blackops.wad

MUY IMPORTANTE: Para tener el mejor rendimiento y baja latencia, desactiva VSYNC y pon "MAX FPS" a 60.

NOTA PARA RASPBERRY PI: Por defecto, va en GLES aunque le pongas Vulkan en las opciones (fallará al inicializar Vulkan).
Si te empeñas en que funcione sobre OpenGL en la Pi, puedes hacer:
MESA_GL_VERSION_OVERRIDE=3.3 MESA_GLSL_VERSION_OVERRIDE=330 ./gzdoom
...PERO va muy lento.

Si quieres un shader CRT, puedes usar este:
https://github.com/jorisvddonk/GZDoom_CRTShader
Se baja como ZIP (desde el propio github, dándole a CODE->DOWNLOAD ZIP)
y se carga el .zip directamente con "-file" como cualquier otro PWAD.

También podrías usar este, que tiene un link con la última versión en .PK3 y se carga igual:
https://github.com/dron12261games/MOD-VHS-CRT-Shader-by-DRON12261
Si usas este, se activa en un menú especial que tiene. Para acceder a él, entra en "OPTIONS->FULL OPTIONS MENU->VHS&CRT Shader Mod v2"
que está abajo del todo una vez que entras en "FULL OPTIONS MENU".

LOS SHADERS NO VAN EN LA PI5 PORQUE LE FALTA UNA EXTENSIÓN DE VULKAN Y SÓLO VA EN MODO GLES,
Y LOS SHADERS SÓLO VAN EN MODO OPENGL Y EN MODO VULKAN.
Le falta la extensión "multiDrawIndirect" que es comprobada en la función "VulkanDeviceBuilder::FindDevices", aquí:
https://github.com/ZDoom/gzdoom/blob/f369cd7f6d8c4e6dc339e51d645f410c8fc897e2/libraries/ZVulkan/src/vulkanbuilders.cpp#L1833

MODs para GZDOOM que molan:

--Doom 3: https://www.moddb.com/mods/doom-3-doom-ii-mod/downloads/doom-iii-doom-ii-mod-v10b

--Doom64 TC para GZDOOM: https://www.moddb.com/mods/doom-64-retribution
que se usa junto con este para la música: https://www.moddb.com/mods/doom-64-retribution/addons/doom-64-retribution-ogg-music-pack-v13

--Doom64 para Doom 1 y Doom 2: https://www.moddb.com/mods/doom-64-unseen-evil

--Hocus Pocus TC para Doom 2: https://www.moddb.com/mods/hocus-pocus-doom/downloads/hocus-pocus-doom1
Para que vaya bien y se vea bien, conviene tener "RESOLUTION SCALE" a "Lowest Possible Mode" y "SCREEN SIZE" a "8",
y para salvar esos settings por separado sin que afecten al resto de juegos, nos copiamos ~/.config/gzdoom/gzdoom.ini
a ~/gzdoom/hocus.ini, que cargaremos con "-config hocus.ini".

VKDOOOM EN GNU/LINUX
====================

-Primero, necesita OpenAL. Tienes las instrucciones de instalación en este documento.

-Segundo, necesita ZMUSIC. Vamos con ZMUSIC pues:
--Instala libmpg123-dev y libvorbis-dev.
--Descarga los últimos sources estables de:
https://github.com/ZDoom/ZMusic/tags
--Compilamos con:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native"
make -j4

-Tercero, otras dependencias:
apt-get install libvpx-dev

	VAMOS A POR VKDOOM EN SÍ

Clonamos su repo: git clone --depth 1 https://github.com/dpjudas/VkDoom.git

Compilamos con:

mkdir b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DVULKAN_USE_XLIB=OFF -DVULKAN_USE_WAYLAND=ON \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native"

Creamos el directorio ~/vkdoom, y allí copiamos el ejecutable vkdoom y los .pk3 que se nos generan al compilar:
mkdir ~/vkdoom
cp vkdoom *.pk3 ~/vkdoom/

Para la música, no te compliques: usa los WAD de música que usas con el Crispy o con el ZDoom así:
./vkdoom -iwad doom.wad -file doom1music.wad

NETHACK EN GNU/LINUX
====================

Se instala con:

sudo apt-get install nethack-common

Ahora creamos el fichero ~/.nethackrc con el contenido:
OPTIONS=name:Manuel
OPTIONS=number_pad:1

Eso es para que el jugador se llame Manuel, y que se use el numpad para jugar con diagonales y todo: las flechas no se deben usar
porque Nethack necesita que nos movamos en diagonal (o se gasta comida innecesariamente y no se puede ganar).

Para salir del juego, pulsa #, escribe quit, y dale al intro.

ARREGLAR JUEGOS QUE SE COMPILAN CON CMAKE Y NO ENCUENTRAN OPENGL (GLVND)
========================================================================

Lo que suele fallar es la llamada a:
find_package(OpenGL REQUIRED)
...Que debería funcionar tanto para GLX como para GLVND, pero CMAKE está mal y no funciona para GLVND.

LO PRIMERO, verifica que has creado el fichero /etc/profile.d/custom.sh con el contenido:

export CMAKE_LIBRARY_PATH=/usr/local/lib64
export PKG_CONFIG_PATH=/usr/local/lib64/pkgconfig

ESTO ES NECESARIO porque NINJA/CMAKE instala las librerías en /usr/local/lib64, y CMAKE y PKG-CONFIG no buscan
en /usr/local/lib64 por defecto (sólo en /usr/local/lib).

SI AUN ASÍ NO FUNCIONA, haz esto:
set(OPENGL_USE_OPENGL ON)
find_package(OpenGL REQUIRED)
...para que así busque GLVND en primer lugar en vez de GLX.

NOTAS SOBRE CÓMO USAR CMAKE PARA BUSCAR OPENGL (GLVND)
======================================================

CÓMO BUSCAR MANUALMENTE UNA LIBERÍA USANDO PKGCONFIG EN VEZ DE FIND_PACKAGE()

En este ejemplo, lo que hacemos es usar la función pkg_search_module() de pkg-config, en lugar de usar find_package() de CMAKE directamente.
(Es sólo un ejemplo: find_package() no debe tener problemas para encontrar GLVND si CMAKE sabe dónde buscar, mira la sección inmediatamente
anterio)
Para ello:

#Cargamos el módudo PKGCONFIG de CMAKE:
find_package(PkgConfig REQUIRED)
pkg_search_module(OPENGL REQUIRED opengl)

# Creamos el IMPORT TARGET. Lo ponemos llamar como queramos, lo hemos llamado OpenGL::OpenGL pero
lo podíamos haber llamado como nos diese la gana:
add_library(OpenGL::OpenGL INTERFACE IMPORTED)

# Establecemos las propiedades del IMPORT TARGET, sin ellas el IMPORT TARGET está vacío y no vale para nada,
# es aquí donde le decimos contra qué librerías debe linkar, etc.
set_target_properties(OpenGL::OpenGL PROPERTIES
	INTERFACE_INCLUDE_DIRECTORIES "${OPENGL_INCLUDE_DIRS}"
	INTERFACE_LINK_LIBRARIES "${OPENGL_LIBRARIES}"
)

# Luego ya le diríamos a CMAKE que linke contra nuestro IMPORT TARGET así:
target_link_libraries(${NCINE_APP} PRIVATE OpenGL::OpenGL)


	----ALTERNATIVAMENTE, se podría hacer con la función find_library() de CMAKE, que también encuentra correctamente GLVND----

#Buscamos la librería. La podemos llamar OpenGL_LIBRARY como la podemos llamar pepito:
find_library(OpenGL_LIBRARY NAMES OpenGL)

#Buscamos los directorios de inclusión de la librería:
find_path(OpenGL_INCLUDE_DIR NAMES GL/gl.h)

# Creamos el IMPORT TARGET. Lo podemos llamar como queramos, lo hemos llamado OpenGL::OpenGL pero
# lo podíamos haber llamado como nos diese la gana:
add_library(OpenGL::OpenGL INTERFACE IMPORTED)

# Establecemos las propiedades del IMPORT TARGET, sin ellas el IMPORT TARGET está vacío y no vale para nada,
# es aquí donde le decimos contra qué librerías debe linkar, etc.
set_target_properties(OpenGL::OpenGL PROPERTIES
    INTERFACE_INCLUDE_DIRECTORIES "${OpenGL_INCLUDE_DIR}"
    INTERFACE_LINK_LIBRARIES "${OpenGL_LIBRARY}"
)

BARONY, UN DUNGEON CRAWLER 3D OPENSOURCE PARA LINUX
====================================================

Nos bajamos la última estable de:
https://github.com/TurningWheel/Barony/releases

Instalamos dependencias adicionales:
sudo apt-get install libphysfs-dev rapidjson-dev --no-install-recommends

Editamos src/main.hpp y quitamos
#include <GL/glu.h>

Editamos CMakeLists.txt y cambiamos la línea
find_package(OpenGL REQUIRED)
que está debajo de 
ELSE (APPLE)
por esto:
	find_package(OpenGL QUIET)
	if(OpenGL_FOUND)
		message(STATUS "Using OpenGL GLX for OpenGL")
	else(OpenGL_FOUND)
		# If we couldn't find old GLX package, try to use modern libglvnd libOpenGL.so instead.
		message(STATUS "Using GLVND for OpenGL")
		FIND_LIBRARY(OpenGL_LIBRARY OpenGL)
		SET(EXTRA_LIBS ${OpenGL_LIBRARY})
    endif(OpenGL_FOUND)

Configuramos y compilamos con:

mkdir b4
cd b4

EDITOR_ENABLED=0 cmake -DCMAKE_BUILD_TYPE=Release -Wno-dev \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DFMOD_ENABLED=OFF -DOPENAL_ENABLED=ON  ..

make -j4

CSBWin, UN PORT DEL DUNGEON MASTER DE ATARI ST PARA LINUX
=========================================================

Esto lo lleva sin github Paul Stevens:
prsteven@facstaff.wisc.edu

Bajamos los últimos sources estables de aquí:
http://dianneandpaul.net/CSBwin/
Son los ficheros con nombre CSBwin_SRC_*, baja el de fecha más reciente.

Tiene un Makefile que se llama makefile, en minúsculas.

Editamos LinCSBUI.cpp y:
-Hacemos que la función LIN_PlaySound retorne SDL_TRUE (MUY importante, porque si no da un segfault al entrar en la mazmorra)
-Añadimos, antes de RenderCopy(), SDL_RenderClear(sdlRenderer);
Editamos CSBlinux.cpp y:
-Añadimos SDL_RENDERER_PRESENTVSYNC a los flags de SDL_CreateRenderer()
-Añadimos 
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
 antes de SDL_CreateWindow()

Editamos makefile y añadimos en el options de "ifeq ($(target), Ubuntu_SDL20)"
-O2 -march=native -mtune=native -O2

Compilamos con:
make target=Ubuntu_SDL20 -j4

Necesitamos los ficheros:
dungeon.dat
graphics.dat
..que los podemos bajar de alguna release compilada de http://dianneandpaul.net/CSBwin/

Ejecutamos con:
./CSBwin --fullscreen

CRISPY DOOM / CRISPY HERETIC
============================

--Primero instalamos una dependencia suya para que pre-convierta TODOS los efectos de sonido y así el juego no pegue tirones:
sudo apt-get install --no-install-recommends libsamplerate0-dev

--Nos bajamos la última estable de:
https://github.com/fabiangreffrath/crispy-doom/releases

--Editamos src/i_video.c, buscamos "SDL_SetHint" y ponemos todas las ocurrencias a "linear".

--Compilamos con CMAKE:
mkdir b4
cd b4

cmake -DCMAKE_C_FLAGS="-march=native -mtune=native -fsigned-char" \
-DCMAKE_BUILD_TYPE=Release ..

make -j4

--El fichero de configuración está en ~/.local/share/crispy-doom/crispy-doom.cfg

--PARA TENER ANIMACIONES SUAVES DE LAS ARMAS Y DE LOS MONSTRUOS (es posible tener ambos porque crispy-doom soporta DEHEXTRA),
usamos las versiones especiales para CRISPY-DOOM de SMOOTHED.WAD para los monstruos y BLACKOPS.WAD para las armas:
https://www.doomworld.com/forum/topic/85991-smoothed-smooth-monsters-for-doom-retro-and-crispy-doom/
https://www.doomworld.com/forum/topic/84859-black-ops-smooth-weapons-dehacked-mod/
Los cargaríamos con: ./crispy-doom -iwad doomu.wad -file smoothed.wad blackops.wad
NOTA: El smoothed.wad provoca unos warnings que simplemente hay que ignorar según el propio autor de crispy-doom.

NOTA: Si usases otro sourceport y no tuviese DEHXTRA (buuhhhh!!), puedes usar esto para las armas solamente
(de los monstruos olvídate sin DEHEXTRA):
https://www.chocolate-doom.org/wiki/index.php/Gameplay_enhancements#Vanilla_Doom_smooth_weapons_patch
Lo cargaríamos con: ./crispy-doom -iwad doomu.wad -file vsmooth.wad

PARA QUE LOS GRÁFICOS DEL HEXEN EN MODO WIDESCREEN NO SE CORTEN POR LOS LADOS:

Tenemos que cargar un WAD con los gráficos en widescreen. El único que he visto que funciona es wad que hay en "hexwide.zip" de este hilo:
https://github.com/fabiangreffrath/crispy-doom/issues/859
O sea que hacemos: ./crispy-hexen -iwad hexen.wad -file hexen_wide.wad hexen_music.wad
(O metemos hexen_wide.wad y hexen_music.wad en autoload/hexen.wad/, que los carga igual al inicio sin pasar ningún parámetro).

PARA TENER PANTALLAS DEL TÍTULO QUE OCUPEN TODA LA PANTALLA EN MODO WIDESCREEN:

Tenemos que cargar un WAD con esos gráficos en widescreen, lo que se llama "widescreen assets".
En Hexen NO es necesario porque lo hemos arreglado con lo de la sección anterior.
Para Doom, Doom2, Sigil, Heretic, etc... usamos los que vienen en el zip del primer post de este hilo: https://www.doomworld.com/forum/topic/121385-widescreen-assets-pack-and-appreciation-thread/

PARA TENER MÚSICA DIGITAL

OPCIÓN 1 (RECOMENDADA):
Simplemente usamos estos WADs ya preparados:
https://zandronum.com/forum/viewtopic.php?t=97
Se los pasamos con el parámetro "-file", por ejemplo:
./crispy-heretic -iwad heretic.wad -file heretic_music.wad

También podríamos meter en un WAD, tal cual sin directorios, los FLAC o los OGG que queramos,
PERO MUY IMPORTANTE, SIN EXTENSIÓN, en plan "E1M3" sin más.
Le puedes quitar la extensión OGG a todos los archivos de un directorio con:
find -type f -name '*.ogg' | while read f; do mv "$f" "${f%.ogg}"; done
Ahora los metes en un WAD (con SLADE en Linux vale para crear WADs)
Y le pasamos ese WAD con -file así:
./crispy-heretic -file heretic-music.wad

OPCIÓN 2: En ficheros sueltos. Nos bajamos un pack (de OGG, de FLAC o de lo que queramos y SDL_Mixer() tenga soporte para reproducir)
y lo mandamos, por ejemplo, a ~/heretic/heretic-music, dejando ahí los OGG o los FLAC tirados sin más.
Ahora editamos ~/.local/share/crispy-doom/crispy-heretic.cfg y en el setting music_pack_path ponemos el path: "/home/pi/heretic/heretic-music"
(O el que sea, vamos).
Vengo usando estas músicas, que están en OGG directamente para bajar:
https://zandronum.com/forum/viewtopic.php?t=97

PARA AJUSTAR LA GAMMA DEL JUEGO: pulsamos F11 varias veces mientras estamos jugando, hasta que esté a nuestro gusto.

PARA TENER MÚSICA GUS (COMO CURIOSIDAD: ES MEJOR MÚSICA DIGITAL), tenemos que tener SDL2-mixer compilado con soporte de Timidity,
y en crispy-heretic.ini ponemos la ruta de los patches que vienen en el directorio "base":

gus_patch_path = "/root/heretic/base/gus_patches"

AL LANZAR EL JUEGO, FÍJATE BIEN QUE AL PRINCIPIO DIGA: "Pre-caching all sounds..."

MONITORIZAR ACCESO A FICHEROS EN GNU/LINUX
===========================================

Instalamos inotify-tools si no las tienes:

sudo apt-get install inotify-tools

Y ahora, si queremos ver todos los accesos a archivos de $HOME, por ejemplo...:
inotifywait -r -m $HOME

Otra alternativa es iotop
sudo apt-get install iotop

Nos permite ver cuánto se ha escrito en disco, estadísticas después de dejarlo correr minutos u horas, etc:
iotop -oPa

OpenDUNE
=========

--Clonamos su repo: git clone --depth 1 https://github.com/OpenDUNE/OpenDUNE.git

--Editamos src/video/video_sdl2.c y allí: 
----Cambiamos todos los "SDL_FULLSCREEN" por "SDL_FULLSCREEN_DESKTOP".
----Buscamos la llamada a SDL_RenderSetLogicalSize() y le pasamos "320, 240". 

--Configuramos y compilamos con (MUY IMPORTANTE, NO NOS INTERESA EL SONIDO POR ALSA porque no soporta el formato de audio requerido
y suenan "chillidos" en vez de efectos de sonido):
./configure --with-sdl2 --with-fluid --without-asound --without-oss --without-pulse
make -j10

--Copiamos el ejecutable y el .ini que viene con los sources al directorio "~/dune2":
mkdir ~/dune2
cp objs/release/opendune ~/dune2/
cp bin/opendune.ini.sample ~/dune2/opendune.ini
En el directorio "~/dune2/data" metemos también los datos de la versión 1.07 del juego original, incluyendo el .exe
(Tienes copia de los datos preparados en el disco duro de backup).
También metemos en "~/dune2" la fuente de Fluidsynth que queramos usar, yo uso la que se llama "UHD3.sf2".

--Editamos el .ini y establecemos la fuente para fluidsynth (el único backend que soporta es ALSA) así:
fs_soundfont=/root/dune2/UHD3.sf2 

--Para ejecutarlo y que suene la música y los efectos al mismo tiempo, tenemos que activar DMIX temporalmente, así que hacemos:
echo "pcm.!default { type plug slave.pcm "dmixed" }" > /tmp/dmix.conf
./opendune
rm /tmp/dmix.conf

NOTAS TIMIDITY
==============

Para inicializarlo y que suenen a ritmo las percusiones, necesitamos los buffers más pequeños posibles, para lo que hacemos:

timidity -iA -B 4,8

Su fichero de configuración, donde le especificamos el soundfont, está en /etc/timidity++/timidity.cfg
Ahí le podemos pasar, o bien un cfg y una ruta:

dir /usr/share/timidity/freepats
source /etc/timidity++/freepats/freepats.cfg

...O bien un sounfont:

soundfont /usr/share/soundfonts/FluidR3_GM2-2.sf2

Para fluidsynth haríamos algo como:

sudo fluidsynth --audio-driver=alsa -s Downloads/WeedsGM3.sf2

INSTALAR VARIOS SISTEMAS OPERATIVOS EN LA RASPBERRY PI SIN DHCP, USANDO IP ESTÁTICA
===================================================================================

Usamos NOOBS (nos vale tanto la version light esa como la completa) pero hacemos algunas modificaciones a capón.
Arrancamos el NOOBS este y nos vamos a la consola TTY2 con CTRL+ALT+F2
Nos logueamos con root/raspberry

killall recovery

Tendremos disponible el vi, no el vim, pero nos vale.
Hacemos
		ip addr add 192.168.5.8/24 dev eth0
		ip route add default via 192.168.5.7	
Dejamos /etc/resolv.conf como:
		nameserver 8.8.8.8
Pingamos a google a ver si va.
Si tira, hacemos:

/usr/bin/recovery –qws

Listo! Nos dirá no sé qué de un sistema de settings corruptos: ni puto caso.

Para modificar el cmdline.txt o el config.txt, tienes que usar shift en el menú de arranque NOOBS, y te saldrán opciones para modificar
los ficheros de configuración de cada SO instalado. Así es como se overclockea la CPU y tal.

Para modificar el órden en que aparecen los OSes en el menú de arranque, editamos  installed_os.json que está en la partición SETTINGS, 
que en mi caso es /dev/mmcblk0p5

Para modificar el SO que arranca por defecto, editamos noobs.conf que está en una de las particiones, la llamada SETTINGS. En mi caso es /dev/mmcblk0p5
La monto desde la Pi por ssh:
sudo mount /dev/mmcblk0p5 /mnt/hdd
Y hago lo que tengo que hacer. ¡¡OJO: DESDE EL PC NO DEJA GUARDAR ESTE ARCHIVO CON SUS CAMBIOS!!
Podemos ver qué sistema arranca de qué partición consultando installed_os.json en ese misma partición. 

PARA PASAR un rootfs de Linux desde otra tarjeta, usa "rsync -av --progress <dir_orígen>/* <dir_destino>", NO USES CP -R QUE LA LIAS CON LOS PROPIETARIOS!!

COPIA DE SEGURIDAD DE UN ROOTFS, COMO EN TIEMPOS DE GENTOO!
===========================================================

Un poco de revival del 2004... Para sacar un tar del rootfs, estando en él y dejando fuera algunos directorios grandes:

sudo tar -cvpf ~/pi/cea0b7ae-2fbc-4f01-8884-3cb5884c8bb7.tar * --exclude=proc/* --exclude=sys/* --exclude=dev/pts/* --exclude=home/pi/scummvm/* --exclude=home/pi/retro/* --exclude=home/pi/src/*

Ahora, para descomprimirlo en una partición de una SD:

sudo tar -xvf cea0b7ae-2fbc-4f01-8884-3cb5884c8bb7.tar -C /media/manuel/root/

ARRANCAR LA RASPBERRY PI CON VÍDEO KMS
=======================================

Simplemente añadimos esta línea a config.txt:

dtoverlay=vc4-kms-v3d

Luego, instalamos libdrm-dev, y copiamos /usr/include/libdrm a /usr/include/drm, para que las cabeceras las encuentren bien los ejemplos (no se arregla pasando -I<ruta> ya
que depende de cabeceras que no son nuestras y en las que vienen mal las rutas), y la podemos hacer funcionar mi ejemplo 2D-KMS de atomix pageflipping.

Tenemos que instalar:
libgl1-mesa-dev
libdrm-dev
libgbm-dev
libgles2-mesa-dev

sudo apt-get install libgl1-mesa-dev libdrm-dev libgbm-dev libgles2-mesa-dev

..y el KMSCUBE original de robclark, tras añadir VC4 a la lista de drivers, tira perfectamente.

CARGAR TAP DE SPECTRUM DESDE LINUX
====================================

Lo primero cargamos el OSS:

sudo modprobe snd-pcm-oss
sudo modprobe snd_hda_intel

Ahora buscamos los sources del "playtap", tal cual, compilamos con el Makefile.linux, y hacemos
./playtap juego.tap 

Justo cuando empiece a sonar bajamos el sonido con el control de volúmen normal, como a 3/4 que si no suena muy alto y falla.

CÓMO LOGUEARSE AL SVN DE RETROGURU Y CLONAR REPOS, Y LUEGO GUARDAR LOS CAMBIOS QUE HAGAS
==============================================================================================

Lo primero es autentificarse, sólo hay que hacerlo la primera vez:
(El password es uno de los típicos que usas, tiene letras y números)
cvs -d:pserver:vanfanel@sun.hasenbraten.de:/usr/src/cvs login
El pass es: Manuel22

Y luego ya clonar el proyecto giana, por ejemplo:
cvs -d:pserver:vanfanel@sun.hasenbraten.de:/usr/src/cvs checkout giana

Una vez hechos los cambios, metemos los nuevos ficheros con
cvs add <nombre_fichero>

Si tenemos nuevos ficheros, directorios, etc, hacemos estos dos pasos porque CVS es muy espartano con esto, no hay equivalente a "git add ."
find . -type d \! -name CVS -exec cvs add '{}' \;
find . \( -type d -name CVS -prune \) -o \( -type f -exec cvs add '{}' \; \)

Y guardamos los cambios en el server con
cvs commit

COMPILAR GIANA SISTERS RETURN
==============================

Lo primero es compilar libmodplug:

O bien clonamos la última versión...
git clone --depth 1 https://github.com/Konstanty/libmodplug.git
autoreconf -i
 ./configure --enable-static

O bien usamos la 0.87 que traen los sources de los juegos, ya que en algunos casos la última versión no es compatible
CXXFLAGS="-fpermissive" ./configure --enable-static
make -j8

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure --enable-static

Buscamos libmodplug.a
find ./ -name 'libmodplug.a'
Y lo copiamos a la raiz de los sources del giana.
Así mismo, copiamos el directorio de los sources de libmodplug (llamado así, libmodplug) a la raiz de los sources del giana, porque necesita headers que buscará ahí.

Ahora, si vamos a compilar en Linux de 64 bits, tenemos que usar estos flags en nuestro Makefile, que son de Makefile_ubuntu64:
CFLAGS = $(INCLUDES) -DMODPLUG -DLINUX $(OPTIM) -Wall -DFADEINOUT -DLINUX64 -DHOME_DIR
...de lo contrario, el ejecutable resultante nos medio peta el sistema y da errores raros.

Si nos da errores de "undefined symbol" con funciones como initFPS() en main.c, añadimos fpshelper.o a nuestro Makefile en la sección de OBJS 

PARA ARREGLAR lo de la transparencia de la estrella cuando cogemos un powerup, añade:
    SDL_SetSurfaceBlendMode(scrback, SDL_BLENDMODE_BLEND);
    SDL_SetSurfaceBlendMode(star, SDL_BLENDMODE_BLEND);
justo antes de donde sea que hagas:
    SDL_SetSurfaceAlphaMod(scrback,192);
    SDL_SetSurfaceAlphaMod(star,128);
...porque estás estableciendo un nivel de transparencia sin haber dicho que quieres que esa surface sea transparente en el proceso de blitting para empezar.

Debes copiar el directorio data que viene con los sources al directorio donde metas el ejecutable.
El fichero de configuración lo crea en ~/.giana/giana.cfg.
Puedes poner ahí fast=1 para que no tengas que ver la intro, elegir idioma y todo eso.
Puedes pasarle al ejecutable  "-fs -aspect" para conservar el aspect ratio.

HURRICAN, EL TURRICAN DE LINUX
==============================

Empezamos por su dependencia libepoxy, que la tenemos que compilar a mano porque la que viene en DEBIAN depende de X11
y toda su basura:
Bajamos la última versión estable de libepoxy desde:
https://github.com/anholt/libepoxy/releases

Configuramos, compilamos e instalamos:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson setup -Dx11=false ..

ninja -j4
ninja install

AHORA VAMOS CON EL HURRICAN EN SÍ:
Clonamos su repo:
git clone --depth 1 --recurse-submodules -j8 https://github.com/HurricanGame/Hurrican.git

Editamos Hurrican/src/Main.cpp y comentamos la línea:
#  define SHOW_CRACKTRO

Configuramos y compilamos:

cd Hurrican/Hurrican
mkdir b4
cd b4

cmake -DCMAKE_BUILD_TYPE=Release -DRENDERER=GLES2 \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" ..

(Hay otros renderers disponibles, mira en el README)

make -j4 

Creamos el directorio ~/hurrican, y allí copiamos el ejecutable, junto con los directorios data y lang, que vienen con los sources.

Cargamos el juego usando su propio shader CRT en vez de usar ZINK+VKBASALT. El shader que trae no es gran cosa, pero nos vale:
./hurrican.exe --crt --colorbleed

EMULADOR MODEL 3 (SUPERMODEL) EN GNU/LINUX
==========================================

--Clonamos su repo:
git clone --depth 1 https://github.com/trzy/Supermodel.git 

--Editamos Makefiles/Rules.inc y quitamos glew.cpp, y todos los ficheros de Legacy3D.
--Editamos Makefiles/Makefile.UNIX y cambiamos -lGL por -lOpenGL, quitamos -lGLU y añadimos -lGLEW 
--Editamos Src/OSD/SDL/Main.cpp, buscamos la línea que empieza con "IRender3D" y la dejamos así:
IRender3D *Render3D = ((IRender3D *) new New3D::CNew3D(s_runtime_config, Model3->GetGame().name));
--Editamos Src/Pkgs/GL/glew.h y eliminamos toda la sección GLU.

--Compilamos con:

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
make -f Makefiles/Makefile.UNIX -j10

--Creamos el directorio ~/model3, y copiamos allí los directorios "Config" y "Assets" que vienen con los sources.
Metemos también en ~/model3 los zips que queramos de juegos, y los lanzamos con:

./supermodel -fullscreen -res=1920,1080 -channels=2 -true-hz daytona2.zip

--Le podríamos dar un modo de vídeo de 57.524Hz y pasarle "-true-hz", para que vaya a los frames originales si notas la emulación
muy justa con algún juego.
Pero NO intentes correrlo a 120Hz ni a 57.524Hz x2, porque aunque parece ir suave, luego se desincroniza (ver scroll
del banner "Rolling Start" del Daytona USA 2). No se nota ningún input lag a 60Hz, así que no te compliques.

--PARA CONFIGURAR LOS CONTROLES: Ejecuta simplemente "supermodel -config-inputs", y puedes usar las flechas ARRIBA Y ABAJO del teclado
para saltarte los controles que no te intererese configurar. Para configurar una tecla, dale a INTRO, y ya al botón o eje que sea.

--NOTA: Si no le pasas "-channels=2", no se oirá porque por defecto Supermodel intenta abrir un sistema de audio de 4 canales,
que no tenemos.

--NOTA: Cuando al iniciar un juego nos de el error "Network board not present", le damos al 6 para entrar en modo Test,
navegamos usando el 5 hasta "Game Assignments", usamos el 6 para seleccionarlo, y cambiamos la opción "Link ID" de "Master" a "Single".

--NOTA: Para poner el Daytona 2 en inglés, presiona TestA para entrar en el menú,
ahora presiona a la vez ServiceA + ServiceB, y con ellos dos presionados presiona TestB, y ya estás en el menú de elegir el país.
Y prefiero usar "Export", porque en USA sale un aviso que no nos interesa.

--NOTA: Para que el Magical Truck no se ralentize, pásale -ppc-frequency=100

AUDIO POR I2C: EL PI TOP SPEAKER
================================

Lo primero es saber que el pi top speaker (pts de ahora en adelante) va por i2c pillando el sonido del hdmi.
Para que el i2c funcione, tenemos que tener estos módulos cargados:

snd_bcm2835
i2c_bcm2835
i2c_dev

Para ello, en config.txt añade:

dtparam=i2c1=on
dtparam=i2c_arm=on

Y luego a parte en /etc/modules añade:
i2c_dev

Reiniciamos, y probamos que detecta el dispositivo en el i2c:

sudo i2cdetect -y 1

Si el i2cdetect no encuentra /dev/i2c-1, es que nos falta algo de los módulos. El pts debería estar en el 73 en la tabla que nos sale.

SELECCIONAR LA SALIDA DE AUDIO CON MPV
======================================

Podemos ver los dispositivos de salida con: mpv --audio-device=help
Y elegit el que queramos de la lista con: mpv --audio-device=<NOMBRE_DISPOSITIVO>

PROBLEMA: UN PROGRAMA NO ENCUENTRA UNA LIBRERÍA QUE SÍ ESTÁ INSTALADA Y CONTRA LA QUE SE HA LINKADO DINÁMICAMENTE SIN PROBLEMAS
================================================================================================================================

Vemos con ldd <nombre_ejecutable> que busca una librería que sí está instalada en /usr/local/...etc
Pues limpiamos la caché de ld:

sudo rm /etc/ld.so.cache
sudo ldconfig

Y ya debería ver la librería que le faltaba con ldd <nombre_ejecutable>

NOTAS HIFIBERRY
===============

En Debian Stretch, las cosas se han complicado ligeramente para poner a funcionar bien la HIFIBERRY DAC+, así que aquí voy a poner algunas notas.
Para que funcione perfectamente:
****En config.txt, mira que tengas estas cosas:***
-Comentada la línea
#dtparam=audio=on

-Añadidas las líneas:
dtoverlay=i2s-mmap
dtoverlay=hifiberry-dacplus

(!!!!!!!!!!!)Ahora, asegúrate de que, además de los módulos típicos, tengas, según lsmod, un módulo llamado "fixed". Si no, ve y quítalo de blacklist.conf...

Ahora, deberías poder ver la tarjeta con "aplay -L" y ver los controles de volúmen y ajustes de la hifiberry con "alsamixer".
Pero puede que alsamixer no guarde los cambios entre reinicios: esto es porque el servicio "alsa-restore.service" falla, lo que puedes comprobar
con "sudo systemctl status alsa-restore.service".
Y falla porque no se cumple la condición de que exista "/dev/snd/control*" cuando se intenta cargar alsa-restore.service
Si editamos completamente el unit del servicio alsa-restore.service ("sudo systemctl edit --full alsa-restore.service"), vemos que tiene la condición:
ConditionPathExistsGlob=/dev/snd/control*
...que es la que está fallando.
Pues bien: vamos a quitar esa condición. Para ello, editamos un "override" del unit, no el unit en sí (ya que esto se perdería al actualizar el sistema...).
Lo editamos con:
sudo systemctl edit alsa-restore.service
Y simplemente añadimos esa condition pero "en blanco":

[Unit]
ConditionPathExistsGlob=

Salvamos, reiniciamos, y alsamixer debería restaurar los niveles sin problemas. Comprueba que "systemctl status alsa-restore.service" se ha iniciado correctamente ahora.

CONVERTIR VÍDEO MPEG2 A MENOS RESOLUCIÓN SIN PERDER CALIDAD
============================================================

El vídeo de entrada era de 1440x1080, así que lo convierto a 720x540, que es exactamente la mitad, y así mantengo el aspect ratio.

ffmpeg -i maddog.m2v -an -qscale:v 10 -vf scale=720:540 -codec:v mpeg2video maddogsd.m2v

La parte de "-qscale:v 10" es para un variable bitrate de calidad 4 (1 es la máxima, 31 la mínima).
Podríamos, en lugar de eso, usar "-b:v 3000k" para un bitrate constante máximo de 3000k.
(OJO!!! si especificas la calidad con "-qscale:v 10", no especifiques el bitrate con "-b:v 3000k" o "-b:v 6000k", es calidad o bitrate constante,
PERO NO AMBAS. Si especificases ambas, la calidad (-qscale) prevalece).

Más información: https://trac.ffmpeg.org/wiki/Encode/MPEG-4
Más ejemplos en: https://github.com/DirtBagXon/hypseus_singe_data
Más juegos: https://archive.org/details/@dirtbagxon

COMPILAR NUESTRA PROPIA VERSIÓN DE WPA_SUPPLICANT
=================================================

La versión que viene en Debian depende de systemd para funcionar (falla si no tenemos systemd corriendo),
así que para tener un sistema mínimo sin init necesitamos compilar nuestra propria versión de WPA_SUPPLICANT.

Las instrucciones para compilar wpa_supplicant desde sus sources se han obtenido de:
https://www.linuxfromscratch.org/blfs/view/svn/basicnet/wpa_supplicant.html

¡EMPEZEMOS!

Dependencias previas:
apt-get install libnl-3-dev libnl-genl-3-dev libreadline-dev 

Bajamos la última estable de aquí (busca "source" en esa página):
https://w1.fi/wpa_supplicant/

Descomprimimos, entramos en el directorio wpa_supplicant, y creamos un fichero de configuración para la compilación que contenga
las opciones básicas para poder establecer una conexión estándar:

cat > .config << "EOF"
CONFIG_BACKEND=file
CONFIG_CTRL_IFACE=y
CONFIG_DEBUG_FILE=n
CONFIG_DEBUG_SYSLOG=n
CONFIG_DRIVER_NL80211=y
CONFIG_DRIVER_WEXT=y
CONFIG_DRIVER_WIRED=y
CONFIG_EAP_GTC=y
CONFIG_EAP_LEAP=y
CONFIG_EAP_MD5=y
CONFIG_EAP_MSCHAPV2=y
CONFIG_EAP_OTP=y
CONFIG_EAP_PEAP=y
CONFIG_EAP_TLS=y
CONFIG_EAP_TTLS=y
CONFIG_IEEE8021X_EAPOL=y
CONFIG_IPV6=n
CONFIG_LIBNL32=y
CONFIG_PEERKEY=y
CONFIG_PKCS12=y
CONFIG_READLINE=y
CONFIG_SMARTCARD=n
CONFIG_WPS=n
CFLAGS += -I/usr/include/libnl3
EOF

PARA SABER QUÉ SIGNIFICA CADA OPCIÓN, EDITA EL FICHERO LLAMADO "defconfig" Y AHÍ VIENEN DESCRITAS TODAS.

Compilamos e instalamos con:
make BINDIR=/usr/local/sbin LIBDIR=/usr/local/lib -j4
make install

Para desinstalar, es a mano porque no hay uninstall, y se haría con:
rm /usr/local/sbin/wpa_*

INSTALAR GLEW EN GNU/LINUX
==========================

GLEW es usado por los Sonic-1-2-2013 y SonicCD decompilation projects, por Scummvm para el render OpenGL de los juegos 3D
(NO para el modo OpenGL de los juegos 2D, y a parte para el render de los juegos 3D también se puede usar GLES2, así que
glew no es necesario ni para juegos 2D ni para aceleración de juegos 3D en Scummvm) y por otros programas que no recuerdo ahora. 

GLEW sólo conoce de OpenGL/ES, no sabe nada de sistemas de ventanas (X11, Wayland, KMSDRM).

Dependencias previas:

apt-get install python-is-python3

Clonamos su repo (NO USES LA ÚLTIMA ESTABLE PORQUE NO SOPORTA GLVND Y DARÁ ERROR):

git clone --depth 1 https://github.com/nigels-com/glew.git

Editamos config/Makefile.linux, buscamos la línea "LIBDIR = $(GLEW_DEST)/lib64" y quitamos el 64.
(Nos interesa que todas las librerías que compilemos e instalemos al margen del gestor de paquetes vayan a /usr/local/lib)

En el raiz de los sources hacemos:

make extensions

Y compilamos e instalamos con un solo comando, así:

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
make SYSTEM=linux-egl-glvnd -j4 install

AHORA EDITA /usr/local/include/GL/glew.h y, o bien añade:
#define GLEW_NO_GLU 1
(Añádelo debajo de "#define GLEW_OK 0"
...O bien ELIMINA TODO EL BLOQUE GLU, es decir, busca "GLEW_NO_GLU" y elimina todo lo que hay en el bloque donde está eso.
SI NO HACES ESTO, los programas que usen GLEW los tienes que compilar siempre pasándole al compilador "-DGLEW_NO_GLU"

AMBERMOON.NET EN LINUX
======================

Necesitamos un sistema Wayland funcionando, e instalar GLFW.
Nos bajamos la última estable de GLFW de:
https://www.glfw.org/

Y configuramos, compilamos e instalamos GLFW:
mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=1 -DGLFW_USE_WAYLAND=1 -DGLFW_BUILD_EXAMPLES=0 -DGLFW_BUILD_TESTS=0 \
-DCMAKE_C_FLAGS="-DEGL_NO_X11 -march=native -mtune=native"

make -j4
sudo make install

OPCIÓN 1: BAJARNOS LOS BINARIOS PRECOMPILADOS PARA AARCH64 Y USARLO DIRECTAMENTE:

Nos bajamos los últimos binarios compilados de:
https://github.com/Pyrdacor/Ambermoon.net/releases

OPCIÓN 2: COMPILARLO NOSOTROS

Clonamos su repo:

git clone --depth 1 https://github.com/Pyrdacor/Ambermoon.net.git

Nos bajamos el DOTNET SDK de nuestra arquitectura (NO hay que instalarlo). Se baja de:
https://dotnet.microsoft.com/download/dotnet/3.1
Hay dos descargas: el SDK y el RUNTIME. El SDK incluye el RUNTIME pero ocupa más. Para compilar, necesitamos el SDK,
y luego ya para jugar nos vale con el RUNTIME.

Entramos en el directorio del SDK y compilamos el proyecto Ambermoon.net con:
./dotnet build ~/src/Ambermoon.net/Ambermoon.net.sln --configuration Release

Copiamos el RUNTIME de dotnet al directorio de Ambermoon.net (el SDK completo no hace falta, pero funcionaría igual)
y ejecutamos el DLL con:
./dotnet Ambermoon.net/bin/Debug/netcoreapp3.1/Ambermoon.net.dll
(Alternativamente, podríamos ejecutar el projecto directamente sin compilar con: dotnet run -p Ambermoon.net/Ambermoon.net.csproj)
Podemos cambiar las opciones editando ambermoon.cfg

Tenemos que tener los .ADF (llamados Amber_a.adf, Amber_b.adf, etc...) en el mismo directorio que la DLL del juego.
Podemos descargarlos ya preparados desde: https://github.com/Pyrdacor/Ambermoon/tree/master/Disks/English

COMPILAR LA VERSIÓN MODERNA DEL EMULADOR DE LASERDISC HYPSEUS (HYPSEUS-SINGE)
=============================================================================

Si queremos compilar para PC:
Nos bajamos los últimos sources estables de:
https://github.com/DirtBagXon/hypseus-singe/releases

Si queremos compilar para Pi anterior a Pi5 (ya que usaba unas libmpeg2 especiales):
Clonamos el repo (usando el branch RetroPie, esto es importante para que se use el libmpeg2 del sistema!):

Ahora, configuramos pasándole a CMAKE el directorio src desde nuestro directorio de compilación (OJO que esto es
distinto a como se suele hacer!!!):

mkdir b4
cd b4

cmake ../src -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native"

make -j10

Copia al mismo directorio donde metas el ejecutable hypseus los directorios "sound", "fonts" y "pics".

SI NOS DA UN ERROR "Could not initialize SDL IMG!", es porque has compilado SDL2_image sin soporte para
uno de los formatos PNG, JPG o WEBP.

Para poner un buffer de audio más pequeño, puedes pasar el parámetro -sound_buffer 1024
(Por defecto viene puesto 2048 que es mucho).

Para tener scanlines, pasa: -scanlines

Para que el SuperDonQuixote se vea a 4:3, pasa: -force_aspect_ratio
(OJO que en este parámetro se usan guiones bajos!)

Para configurar el joystick:
Copia, al mismo directorio donde metas el ejecutable hypseus, el archivo docs/hypinput.ini,
y ahí, para configurar el joystick, fíjate en el formato de cada línea. Por ejemplo:
KEY_BUTTON1 = SDLK_LCTRL 0 0
..significa que el botón 1 del juego está en el botón 0 del mando (último campo).
Así que si queremos la espada en el botón 0 del mando, dejamos esa línea como:
KEY_BUTTON1 = SDLK_LCTRL 0 1
...ya que a los números de botón del mando hay que sumarle 1.
Los números de botón del mando los puedes sacar de jstest, del paquete de Debian llamado "joystick".
Recuerda que tienes que sumarle +1 a los números de botón que te da jstest!!!

Yo tengo las líneas relevantes así:
KEY_COIN1 = SDLK_5 0 7
KEY_COIN2 = SDLK_6 0 0
KEY_START1 = SDLK_1 0 8
KEY_START2 = SDLK_2 0 0
KEY_BUTTON1 = SDLK_LCTRL 0 1
KEY_BUTTON2 = SDLK_LALT 0 2
KEY_BUTTON3 = SDLK_SPACE 0 3

OJO! No dejes ningún botón configurado como KEY_QUIT, pon en esa línea "KEY_QUIT = SDLK_ESCAPE 0 0",
para evitar salidas accidentales.

Los detalles sobre los dip switches están en dle21.txt, que acompaña a las roms del Dragon's Lair Enhanced 2.1
Recuerda que ahí se cuentan los switches del 0 al 7. Se empieza de derecha a izquierda a contar.
Por lo demás, el banco A es el 0, y el B es el 1.

Para lanzar juegos de SINGE (es decir, conversiones nativas), tenemos que meter el directorio del juego que sea dentro del directorio singe,
y luego pasarle como parámetros el framefile del juego (como en cualquier juego de daphne) y el script del juego singe.
Es decir, timegal quedaría metido en:
~/laserdisc/singe/timegal
Y luego lo ejecutaríamos como:
./hypseus singe vldp -framefile singe/timegal/timegal.txt -script singe/timegal/timegal.singe -fullscreen -nolog

Si quieres juegos SINGE con buena calidad, están aquí: https://archive.org/details/@dirtbagxon
Pero recuerda que si están en HD, como la Pi no descomprime mpeg2 por hardware, tienes que convetir su fichero de vídeo con algo como esto:

ffmpeg -i maddog.m2v -an -qscale:v 10 -vf scale=720:540 -codec:v mpeg2video maddogsd.m2v

(OJO!!! si especificas la calidad con "-qscale:v 10", no especifiques el bitrate con "-b:v 3000k" o "-b:v 6000k", es calidad o bitrate constante,
PERO NO AMBAS. Si especificases ambas, la calidad (-qscale) prevalece).

Lo ideal sería que ambas dimensiones de salida fueran divisoras de las originales.
Libmpeg2 no tiene forma de usar aceleración de descompresión de vídeo (la última version de libmpeg2 es de 2008 y no tiene ninguna
optimización para ARM: para tener aceleración sería con libffmpeg).

Para ajustar cosas del Maddog, puedes hacerlo durante el juego pulsando 9, o editando maddog.cfg

EL CARGADOR para el Maddog para evitar desincronizaciones de audio al principio, y con los parámetros necesariospara que vaya bien, es así:

LA CONVERSIÓN DE JUEGOS DE SINGE2 (TRON, Sucker Punch, etc) PARA LA RASPBERRY PI, QUE SON 1920x1080p
(CONSISTE EN DEJARLOS EN LA MITAD DE RESOLUCIÓN Y LA MITAD DE CALIDAD).

  PARA CONVERTIR EL TRON desde mp4 de 1920x1080 a m2v de 960x540, hacemos esto:
  ffmpeg -i TRON.mp4 -vf tpad=stop_mode=clone:stop_duration=2,scale=960:540 -qscale:v 10 -c:v mpeg2video tron.m2v
  ffmpeg -i TRON.mp4 -ss 00:00:00.33 -vn -c:a libvorbis -ar 44100 -map a -b:a 160k tron.ogg
  
  (OJO!!! si especificas la calidad con "-qscale:v 10", no especifiques el bitrate con "-b:v 3000k" o "-b:v 6000k", es calidad o bitrate constante,
  PERO NO AMBAS. Si especificases ambas, la calidad (-qscale) prevalece).
  
########################
#INICIO CARGARDO MADDOG#
########################

sync

# Send the code and the audio to the cache to avoid initial desync problems.
cat singe/maddog-hd/*.singe > /dev/null
cat singe/maddog-hd/*.ogg > /dev/null

./hypseus singe vldp -framefile singe/maddog-hd/maddog-hd.txt -script singe/maddog-hd/maddog-hd.singe -fullscreen -nolog -oversize_overlay -manymouse -blend_sprites

#####################
#FIN CARGARDO MADDOG#
#####################

CREAR UN ALIAS EN LINUX DE MANERA PERMANENTE
===============================================

Lo añadimos a ~/.bashrc. Por ejemplo, para que make se ejecute siempre en las CPUs privilegiadas del 1 al 3:
alias make='chrt -r 1 taskset -c 1-3 make'

VER QUÉ PARÁMETROS ACEPTA UN MÓDULO DEL KERNEL
==============================================

Por ejemplo, con el módulo xpad:

grep -H '' /sys/module/xpad/parameters/*

Luego le pasaríamos el parámetro que sea en la línea de comandos del kernel como:
xpad.<nombre_parámetro>=<valor>

HACER ALGO EN UN SCRIPT DE LINUX SÓLO SI EXISTE UN FICHERO
========================================================

Es muy útil, por ejemplo, para montar unidades sólo si no están montadas ya, etc...

#!/bin/bash
if [ ! -f mnt/mpeg/lair/lair.txt ]
then
    echo "Montando unidad mpeg..."
    sudo mount /dev/sda1 mnt
fi

DUDA: SI USO UN KERNEL CON EL SCHEDULER PUESTO A 100HZ, ¿PUEDO ESPECIFICAR usbhid.jspoll=1 QUE HACE QUE LOS USB SE LEAN A 1000HZ?
==============================================================================================================================================

Sí. El kernel corre sobre HRTIMERS, lo de los 100HZ es la velocidad del sheduler, es decir, cuántas veces por segundo mira a ver qué se ejecuta dónde.
Son cosas distintas e independientes, la granularidad del kernel es mucho mayor que 100HZ... eso es sólo el scheduler.
Y el scheduler, en tus sistemas de no-escritorio, va de sobra a 100Hz para una cosa que ejecutas a la vez (mas el housekeeping del kernel fuera de las CPUs aisladas).
Así que sí, se puede.

COMPILAR FROTZ 
===============

Instala las ncursesw, que es una versión más mehó de las ncurses:
sudo apt-get install libncursesw5-dev libjpeg-dev
	
Si quieres sonido en modo texto (en sfrotz no hace falta ya que el sonido va por SDL2), instalamos estas dependencias previas:
apt-get install libsamplerate0-dev libsndfile1-dev libao-dev --no-install-recommends

Baja los surces de la última estable de:
https://gitlab.com/DavidGriffith/frotz/-/releases

Ahora edita src/sdl/sf_video.c:
-Añade estos FLAGS a la línea de SDL_CreateRenderer()
SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC
-Añade esta línea antes de que se creen la ventana y el renderer
SDL_ShowCursor(SDL_DISABLE);

Ahora edita src/curses/ux_init.c y comenta el bloque de "I won't run as root".

Ahora edita el Makefile y:
-Pon sound a NONE si no quieres sonido en modo texto (sin SDL). En sfrotz el sonido va por las SDL,
 así que usa SFROTZ para los juegos que tienen sonido, y ya.
-Comenta la línea de los CFLAGS del -g, y deja así la línea de los CFLAGS:
CFLAGS += -march=native -mtune=native -fsigned-char
(Los valores de align y tal no tienen sentido porque los valores son incorrectos, -O2 ya activa los valores correctos).

Ahora compila con "make frotz" (hay "make sfrotz" para SDL, etc...)
Y sudo make install

Para compilar SFROTZ, no te olvides de pasar el CFLAG -fsigned-char, o el cursor aparecerá descolocado. En el futuro no debería ser necesario.

Hay juegos con sonido, gráficos, etc.. Estos añadidos van en ficheros .BLB, que te puedes bajar de aquí ya preparados:
http://www.ifarchive.org/indexes/if-archiveXinfocomXmediaXblorb.html
Luego sólo tienes que lanzar el sfrotz (que es el que soporta gráficos, y sonido sin depender de AO) pasándole tanto el archivo del juego como
el blb, tal que así:
sfrotz SHERLOCK.Z5 SHERLOCK.BLB
OJO que para que Sherlock suene necesitas el .DAT o .Z5 (son lo mismo) de la versión de Amiga, NO la de PC.

PARA USAR SFROTZ CON vkBasalt, NO HACE FALTA CAMBIAR LA FUENTE DE LETRA NI NADA, LA QUE TRAE POR DEFECTO SE VE ESTUPENDA.
Simplemente creamos el fichero ~/.sfrotzrc con este contenido y ya:

[Window]
AcWidth = 640
AcHeight = 400 

[Fonts]
antialias=1

PARA USAR SFROTZ SIN VKBASALT, HAY QUE CAMBIAR LA FUENTE DE LETRA POR UNA TRUETYPE ESCALADA CON ANTIALIAS. PARA ELLO:

-Instalamos una fuente truetype adecuada: apt-get install fonts-jetbrains-mono 

ALTERNATIVA: Si necesitásemos una fuente con glifos, bajaríamos el zip de una fuente parcheada nerdfont de aquí:
https://www.nerdfonts.com/font-downloads
(Son fuentes que podrías instalarte como paquetes desde Debian, pero estas versiones parcheadas Nerd traen glifos
que permiten mostrar iconos gráficos en la consola.)
Por ejemplo, yo me suelo bajar JetBrainsMono. Metemos los contenidos del zip en /usr/local/share/fonts/truetype/jetbrains.

-Creamos el fichero ~/.sfrotzrc con el contenido:

[Window]
AcWidth = 1920
AcHeight = 1080

[Fonts]
fontdir=/usr/share/fonts/truetype/jetbrains-mono
textroman=JetBrainsMono-Medium.ttf@34
textbold=JetBrainsMono-Bold.ttf@34
textitalic=JetBrainsMono-Italic.ttf@34
textbolditalic=JetBrainsMono-BoldItalic.ttf@34
fixedroman=JetBrainsMono-Medium.ttf@34
fixedbold=JetBrainsMono-Bold.ttf@34
fixeditalic=JetBrainsMono-Italic.ttf@34
fixedbolditalic=JetBrainsMono-BoldItalic.ttf@34
antialias=1

NOTA: Se podrían usar valores de AcWidth y AcHeight que fuesen múltiplos de los 640x400 originales que usa sfrotz,
de manera que las imágenes gráficas se escalan correctamente y además se usa una fuente DejaVu tamaño 30 para que salgan
los mismos caracteres por línea que con la fuente VGA original.

NOTA2: Para que, al salvar partida o al cargar, SFROTZ no nos saque diálogos gráficos, sino que nos pida el filename a mano como debe ser,
le pasamos el parámetro -T.

OTRA ALTERNATIVA ES USAR ESTA FUENTE, que es la de la consola pero en TTF:
https://files.ax86.net/terminus-ttf/
(NOTA: La tienes lista en el disco duro de backup, con los nombres de archivo adecuados y todo,
mételas en /usr/local/share/fonts y listo).

El ~/.sfrotzrc quedaría así:

[Window]
AcWidth = 1280
AcHeight = 800 

[Fonts]
fontdir=/usr/local/share/fonts
textroman=TerminusTTF.ttf@34
textbold=TerminusTTF-Bold.ttf@34
textitalic=TerminusTTF-Italic.ttf@34
textbolditalic=TerminusTTF-Bold-Italic.ttf@34
fixedroman=TerminusTTF.ttf@34
fixedbold=TerminusTTF-Bold.ttf@34
fixeditalic=TerminusTTF-Italic.ttf@34
fixedbolditalic=TerminusTTF-Bold-Italic.ttf@34
antialias=1

OTRA ALTERNATIVA es usar esta fuente: https://archive.org/details/LessPerfectDOSVGA
La renombramos a dosvga.ttf, y el ~/.sfrotzrc quedaría así:

[Window]
AcWidth =  1280
AcHeight = 800 

[Fonts]
fontdir=/usr/local/share/fonts
textroman=dosvga.ttf@34
textbold=dosvga.ttf@34
textitalic=dosvga.ttf@34
textbolditalic=dosvga.ttf@34
fixedroman=dosvga.ttf@34
fixedbold=dosvga.ttf@34
fixeditalic=dosvga.ttf@34
fixedbolditalic=dosvga.ttf@34
antialias=1

PARA CONVERTIR JUEGOS DE THE QUILL A FROTZ
Puedes convertir juegos de THE QUILL a .z5 para el frotz con el unquill: https://www.seasip.info/Unix/UnQuill/
Pero el unquill recibe .SNA, y lo más que hay por ahí son .Z80, así que para pasar .SNA a .Z80 usa el spconv:
https://live.worldofspectrum.org/infoseek/utils
Una vez que tengas el .SNA, sólo tienes que hacer:
./unquill -T5 -L -OBORED1.z5 BORED1.SNA
Tienes juegos de THE QUILL en .Z80 en: http://ifmirror.russotto.net/indexes/if-archiveXgamesXspectrum.html


COMPILAR FROTZ VERSIÓN SDL, QUE SOPORTA ACENTOS, SIN INSTALAR LIBJPEG EN EL SISTEMA
===================================================================================

Empezamos compilando libjpeg-turbo, que nos va a hacer falta la versión estática de las librerías. Pillamos la última versión estable de su repo:
https://github.com/libjpeg-turbo/libjpeg-turbo/releases

Ahora creamos directorio de compilación, entramos, y configuramos con CMAKE así:
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_FLAGS="-march=native -mtune=native"

Ahora, clonamos el repo del FROTZ:
git clone --depth 1 https://github.com/DavidGriffith/frotz.git

Ahora, en el directorio de los sources del FROTZ, nos creamos un directorio llamado jpeg, donde vamos a meter las librerías estáticas y los headers de libjpeg. 
Vamos a necesitar tener en nuestro directorio jpeg dentro de los sources del FROTZ estos archivos (unos del diretorio raiz de los sources de libjpeg y otros de nuestro
directorio de compilación de libjpeg, b3 o como lo llames):
jconfig.h 
jmorecfg.h 
jpeglib.h 
libjpeg.a

Ahora, editamos el Makefile del FROTZ, y a los CFLAGS le añadimos, para que encuentre los headers de SDL2, de freetype2, de la libjpeg que hemos compilado, etc, 
quedando así la línea de CFLAGS:
CFLAGS += -I$(INCLUDEDIR) -I/usr/include/SDL2 -I/usr/include/freetype2 -I/home/pi/src/frotz/jpeg

Y la línea de LDFLAGS quedará así:
jpeg/libjpeg.a -lSDL2 -lSDL2_mixer -lz -lfreetype -lpng
(Como ves, no le pasamos -ljpeg, sino que directamente le pasamos la librería estática al linker y listo).

CONECTAR WIIMOTE EN LINUX
=========================

MÁS INFO:
https://wiki.archlinux.org/title/Wiimote
https://wiki.archlinux.org/title/XWiimote
https://wiki.archlinux.org/title/XWiimote#Cannot_connect_Wiimote

IDEAS INICIALES QUE HAY QUE ENTENDER:
El módulo del kernel es "hid-wiimote" y hay que tenerlo cargado antes de intentarnos conectar.
Nos conectamos usando "bluetoothctl" del paquete "bluez". OJO: El bluez tiene que tener el módulo wiimote, que es opcional.
Para saber si nuestro bluez tiene el módulo wiimote, hacemos: grep wiimote /usr/lib/bluetooth/bluetoothd
(En Debian, sería "grep wiimote /usr/libexec/bluetooth/bluetoothd")
Nos tiene que devolver: "grep: /usr/lib/bluetooth/bluetoothd: binary file matches"
Si no nos devuelve eso, tendríamos que compilar "bluez" con el argumento "--enable-wiimote".
Una vez conectados con bluetoothctl, debemos poder configurar el wiimote con las utilidades del paquete "xwiimote"

VEAMOS ĆOMO SE HACE:

Instalamos las cosas que necesitamos: apt-get install bluez xwiimote

Entramos en "bluetoothctl", y hacemos:
scan on  <--- (Esto es necesario para poder usar el TAB en los siguientes pasos)
pair <DIRECCIÓN MAC DEL WIIMOTE, USA TAB PARA ELEGIR UNA>
connect <DIRECCIÓN MAC DEL WIIMOTE, USA TAB PARA ELEGIR UNA>
trust <DIRECCIÓN MAC DEL WIIMOTE, USA TAB PARA ELEGIR UNA>

Si al hacer el "connect" te pide un PIN, es que tu versión de BLUEZ no tiene el plugin de Wiimote.
Si falla algo, verifica que el módulo hid-wiimote está cargado: lsmod |grep wii

Ahora, deberíamos poder ver el wiimote con: xwiishow list

	USARLO COMO UN RATÓN EN X11

sudo apt-get install -f xserver-xorg-input-xwiimote
Editamos /usr/share/X11/xorg.conf.d/60-xorg-xwiimote.conf, y en bloque de:
Identifier "Nintendo Wii Remote"
añadimos:
"Option "MotionSource" "ir"

Para saber qué otras opciones tenemos en /usr/share/X11/xorg.conf.d/60-xorg-xwiimote.conf, podemos mirar: man xf86-input-xwiimote

	USARLO COMO RATÓN EN WAYLAND
	
No nos sirve libinput porque no soporta el Wiimote.
-Lo primero, confirmamos que vemos eventos del wiimote con "evtest", que nos permitirá elegir por un lado el pad y por otro el IR.
(Vamos moviendo el mando y vemos los eventos que se generan).
Nos quedamos con el nombre del dispositivo en /dev, deberíamos ver algo como:
/dev/input/event5:      Nintendo Wii Remote IR
/dev/input/event6:      Nintendo Wii Remote

-Para mapear los eventos del Wiimote a movimientos de ratón, usamos "evsieve".
--Primero instalamos el buildsystem que necesita.
Según las instrucciones de https://www.rust-lang.org/tools/install, se hace así:
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
--Clonamos su repo: git clone --depth 1 https://github.com/KarsMulder/evsieve.git
--Compilamos: cargo build --release
--Instalamos: install -m 755 -t /usr/local/bin target/release/evsieve
--Podemos ver los eventos del IR del Wiimote con: evsieve --input /dev/input/event5 --print
--Para hacer el mapeo de los eventos de Wiimote a ratón, miramos los ejemplos en: https://github.com/KarsMulder/evsieve

-USANDO MOLTENGAMEPAD (Al usarlo como ratón se mueve solo, etc)
--Clonamos su repo: git clone --depth 1 https://github.com/jgeumlek/MoltenGamepad.git
--Editamos source/core/uinput.h, y al final de los includes del principio añadimos "#include <memory>"
--Compilamos con: make -j4
--Instalamos el binario resultante con: cp moltengamepad /usr/local/bin/
--Entramos en installation/systemuser, y ejecutamos ./install.sh
--Creamos el archivo /etc/xdg/moltengamepad/moltengamepad.cfg con el contenido:
load profiles from /home/manuel/.config/moltengamepad/profiles/mywiimote
--Creamos el archivo .config/moltengamepad/profiles/mywiimote con el contenido:
[wiimote]                                                                                                                                        
wiimote.?wm_ir_active = true
wiimote.wm_a = key(key_a)
wiimote.wm_b = key(key_b)
wiimote.wm_1 = key(key_1)
wiimote.wm_2 = key(key_2)
wiimote.wm_up = key(key_up)
wiimote.wm_down = key(key_down)
wiimote.wm_left = key(key_left)
wiimote.wm_right = key(key_right)
wiimote.wm_plus = key(key_4)
wiimote.wm_minus = key(key_3)
wiimote.wm_ir_x = mouse(rel_x)
wiimote.wm_ir_y = mouse(rel_y)
(...Y ya debería ir como ratón, pero mal).

	USARLO COMO PISTOLA EN HYPSEUS-SINGE
	
A parte de tenerlo funcionando como ratón, tenemos que pasarle al Hypseus los parámetros: "-nojoymouse -sinden 1 x"
Y para recargar dándole al botón A, en hypinput.ini tenemos que tener: "KEY_BUTTON1 = SDLK_LCTRL 0 1"

CONFIGURAR BLUETOOTH MANUALMENTE Y CONECTARSE A DISPOSITIVOS EN GNU/LINUX
=========================================================================

Instalamos los paquetes requeridos para usar hcitools y todo eso:

sudo apt-get install bluez

Insertamos los módulos necesarios del kernel y conectamos el sistema de gestión hci a nuestro hardware bluetooth:

sudo modprobe hci_uart
sudo modprobe btbcm
sudo hciattach /dev/ttyAMA0 bcm43xx 921600 noflow -

Ahora deberíamos poder ver qué dispositivos bluetooth tiene nuestro microordenador:

sudo hciconfig -a

Ahora levantamos nuestro dispositivo hci:

sudo hciconfig hci0 up

Podemos ver más información con esto:

sudo hciconfig dev

Escaneamos dispositivos bluetooth al alcance:

sudo hcitool scan

Si aparece el nuestro, nos podemos conectar con:

hcitool cc 30:23:18:DA:8A:AE
hcitool lecc 30:23:18:DA:8A:AE

Listamos las conexiones hechas con:

hcitool con

Para quitar el LAG:

sudo iwconfig wlan0 txpower off
O bien deshabilitar el WIFI en el inicio con:
dtoverlay=pi3-disable-wifi

hcitool con (para verificar que está conectado!)
sudo hcitool enc 30:23:18:DA:8A:AE off
sudo hcitool sr 30:23:18:DA:8A:AE slave

ADVENTURE ORIGINAL EN LA PI USANDO SIMH
=======================================

Clonamos el repo de simh:
git clone --depth 1 https://github.com/simh/simh.git

Editamos el makefile y comentamos toda la sección donde detecta libpng (busca png y comenta ese bloque)
También le puedes añadir los flags de la arquitectura donde se añade el -fipa-cp-clone, por ejemplo.

Compilamos sólo el simulador de pdp8 que es el que vamos a usar
make pdp8
El ejecutable queda en BIN/pdp8

Ahora necesitamos el adventure y un .ini que irá en el mismo directorio que el ejecutable pdp8. Todo eso viene en un blog:
https://raymii.org/s/articles/Running_ADVENT-on-the-PDP-8-with-SIMH.html

DESCARGAR LIBROS DE GOOGLE BOOKS EN PDF
========================================

sudo apt-get install python-glade2

git clone https://github.com/tokland/pysheng
cd pysheng
sudo python setup.py install

Y para que guarde en PDF:
pip install reportlab

EJECUTAR PROTON (PROT-ON), EL SISTEMA DE ENCRIPTACIÓN / DESENCRIPTACIÓN USADO EN LA ACADEMIA, EN GNU/LINUX
===========================================================================================================

Es posible hacerlo sin una máquina virtual.
Lo primero es bajarnos el archivo NetFx64.exe (Es parte de .NET Framework 2.0 x64, por si lo quieres hacer con Winetricks).
No especifico de dónde bajarlo, supongo que Microsoft lo tiene para bajar.
Lo instalamos usando Wine: wine NetFx64.exe
Y ya podemos instalar el PROT-ON sin errores. Al ejecutar prot-on, queda en la barra de tareas puesto, abajo a la derecha,
como si de un programa de Linux nativo se tratase, y nos permite abrir documentos y vídeos protegidos sin problemas.

DESHABILITAR SCREEN LOCK (BLOQUEO DE PANTALLA) TRAS SUSPENDER
=============================================================

No es cosa de xscreensaver, aunque se usa para bloquear.
El setting está en: 
preferences->LXQT Settings->Session settings->Lock screen before suspending

DESCARGAR VÍDEOS DE YOUTUBE EN 2024 (youtube-dl ya no funciona)
===============================================================

Se usa yt-dlp. Lo instalamos con PIP, así:

sudo apt-get install python-is-python3
sudo apt install python3-pip -y
sudo python3 -m pip install -U yt-dlp

Si nos da el error ese de "This environment is externally managed", editamos /etc/pip.conf y añadimos:
[global]
break-system-packages = true

Para seleccionar la calidad:
1) Vemos las calidades disponibles con: yt-dlp -F <URL>
2) Seleccionamos la calidad que queramos con: yt-dlp -f<NÚMERO DE CALIDAD> <URL>

MPS-YOUTUBE: CÓMO HACER QUE FUNCIONE EN RASPBIAN (Y EN GENERAL)
===============================================================

Lo primero, NO INSTALES MPS-YOUTUBE O YOUTUBE-DL DESDE APT-GET o el gestor de paquetes que sea: instálalo siempre desde pip,
pero NO hagas una instalación tipo user como dicen las instrucciones, sino exactamente así:

sudo pip3 install -U git+https://github.com/mps-youtube/mps-youtube.git

O así, si quieres la versión estable:

sudo pip3 install mps-youtube

NO OLVIDES instalar youtube-dl desde pip también, ya que es una versión de youtube-dl que se instala entre las extensiones de phyton:

pip3 install youtube-dl

Al lanzarlo puede que te diga que no encuentra mplayer, porque no puedes especificarle otro player ya que aún no lo haz lanzado. Vale, pues instala mplayer:
sudo apt-get install --no-install-recommends mplayer

Ahora entras en mps-yt y haces:
set player omxplayer
o bien
set player vlc

Y a continuación desinstala mplayer y sus dependencias:
sudo apt-get purge mplayer
sudo apt-get autoremove

Ahora, para que mps-yt te busque vídeos y no sólo audio, haz:
set search_music false
Y para que se vea el vídeo, ya que por defecto sólo reproduce el audio, haz:
set show_video true

RESTAURAR (UNDELETE) ARCHIVOS BORRADOS EN UN FILESYSTEM EXT4
============================================================

Se hace con extundelete. Desmonta la partición en la que estaba el archivo antes de pasarte extundelete.
Si no te sabes el nombre del archivo, extundelete te lo sugerirá, así que tranquilo.

sudo extundelete /dev/sdb5 --restore-file installed_os.json

Si quieres recurerar un directorio:
sudo extundelete /dev/sdb1 --restore-directory /dirname

Te lo va a guardar en RESTORED_FILES, en el directorio donde estés cuando ejecutes extundelete. Así que lo tienes que copiar a mano a donde estaba originalmente.

Si fuese en un fat32, usa testdisk.
Keep calm and... undelete!

INSTALANDO UN SISTEMA CUSTOM EN NOOBS
=====================================

Normalmente no es posible instalar un nuevo SO después de instalar NOOBS en una SD, pero bueno, yo lo he hecho y no es para tanto.
-Creamos las particiones. Necesitamos dos: una en FAT32, y otra en EXT4 (si vas a instalar un GNU/Linux propio "from scratch" por ejemplo, como un sistema de 64 bits, etc)
	Vamos a suponer que quedan como sdb8 (fat32) y sdb9 (ext4) desde el PC. Una es la partición de boot y otra la de rootfs, obviamente. Les puedes poner de nombre CUSTOM_BOOT
	y CUSTOM_ROOT, por ejemplo. Se cambia el nombre de las particiones con fatlabel para la fat32 y e2label para la ext4.
	Apunta también sus PARTUUID, que puedes averiguar con sudo blkid /dev/sdb8 y blkid /dev/sdb9

-En la partición boot copia todo lo que se necesita (kernel, dbts, overlays, ficheros de configuración, firmware, etc...). Con cp -R vale.
-En la partición del rootfs copia el rootfs del sistema a instalar, pero recuerda hacerlo con rsync -av --progress origen/* destino/ ,
NO con cp que la lías con los permisos.
-Crea una entrada nueva para el sistema en el fichero installed_os.json de la partición SETTINGS de NOOBS, es decir, en SETTINGS/installed_os.json. Por ejemplo así:
{ 
  "bootable" : true,
  "description" : "Sistema GNU/Linux de 64bits para juegos",
  "folder" : "/settings/os/debian64",
  "icon" : "/settings/os/debian64/icon.png",
  "name" : "Debian 64 bits",
  "partitions" : [
"/dev/mmcblk0p8",
"/dev/mmcblk0p9"
  ],
  "release_date" : "2018-11-13",
  "supported_models" : [
"Pi 3"
  ]
 },

^^^Como ves, ahí se le especifican las particiones que tiene. El directorio SETTINGS/os/debian64 lo creamos nosotros también y metemos ahí el icono que queramos que
se muestre en el arranque. Con el icono vale, no hace falta tener nada más en ese directorio.
El icono tendrá un tamaño de 40x40 pixels en png para no desentonar con el tamaño de los demás. Aqui tienes un ejemplo:
http://www.iconarchive.com/show/super-mario-icons-by-ph03nyx/Retro-Block-Question-icon.html 
Puedes escalar cualquien imágen con GIMP, en image->scale image, y dejarla a 40x40 que es lo que se necesita.

-Ahora edita el cmdline.txt del sistema custom que acabas de instalar, y ajusta el parámetro root= con el PARTUUID de la partición de rootfs.
-Ahora edita el /etc/fstab del sistema custom que acabas de instalar, y lo mismo, ajusta los dos PARTUUID a los de la partición boot y rootfs.
...Y ya debería arrancar sin ningún problema.
Si te sale sólo la pantalla en negro, es que el kernel necesita los módulos instalados en el rootfs para poder mostrar algo por pantalla.

USAR WIFI EN LA RASPBERRY PI 4 CON KERNEL GENÉRICO
==================================================

Asegúrate de no tener blacklisteado el módulo brcmfmac en /etc/modprobe.d. Con ese módulo cargado ya deberías poder ver el interface wlan0
con iwconfig.

O bien, déjalo blacklisteado, y lo cargas manualmente en: 

sudo modprobe brcmfmac

INSTALAR CHDMAN A MANO
======================

Para evitar dependencias absurdas de X11 y demás.

Clonamos su repo:
git clone --depth 1 https://github.com/CharlesThobe/chdman.git

Compilamos:
mkdir b4
cd b4
cmake -B build -G Ninja ..
cmake --build build

COMPRIMR CUE/BIN A CHD
======================

Necesitamos las mame-tools:
sudo apt-get install mame-tools p7zip-full

Y se comprime pasándole el CUE:
chdman createcd -i BC\ Racers.cue -o BC\ Racers.chd

Si tienes un directorio con varios 7z (cada uno de los cuales conteniendo un cue/bin), puedes convertir todos los 7z
de ese directorio usando este sencillo script:

		------
		
#!/bin/bash
#extract 7z
  for x7zFile in *.7z; do
                gameName="$(basename "$x7zFile" .7z)"
                echo "!!!!!!!!!!Extracting ${gameName}..."
                7z x "${x7zFile}" -o./"${gameName}-tmp"

                echo "!!!!!!!!!!Converting ${gameName}..."
                chdman createcd -i "./${gameName}-tmp/${gameName}.cue" -o ./"${gameName}.chd"
#rm temporary directory
                rm -R ./"${gameName}-tmp"
### uncomment below to rm the original 7z archive
#               rm ./"$x7zFile"

                echo "!!!!!!!!!!${gameName} complete..."
done
echo "All done."

		-------

Y para convertir todos los cue/bin de un directorio, usa este script:
for i in *.cue; do chdman createcd -i "$i" -o "${i%.*}.chd"; done

MÚSICA GRAVIS ULTRASOUND Y EFECTOS DE SONIDO EN DUNGEON MASTER 2 EN DOSBOX
==========================================================================

NOTA ANTES DE COMPLICARTE: Tienes el juego ya preparado con todo en el disco duro de backup.
Necesitamos el directorio ULTRASND en C:\
Y metemos el juego en C:\dm2
Si en DOSBOX montas "dm2" como C:, ya tienes ambas cosas.

Ahora, en el directorio del dm2, actualizamos el driver HMI desde el archivo de la web:
http://dmweb.free.fr/?q=node/612
Si no lo encuentras, pues copia los archivos desde el Anvil of Dawn.
Los archivos a sobreescribir para actualizar el driver son:

DRUM.BNK
HMIDET.386
HMIDRV.386  
HMIMDRV.386  
MELODIC.BNK  
SETUP.EXE  
TEST.HMI  
TEST.WAV
(CUIDADO, puedes acabar con cada archivo dos veces, una en mayúsculas y otra en minúsculas, 
así que te puedes quitar de problemas convirtiendo todo lo del dm2 a mayúsculas con: 
for f in *; do mv "$f" "${f^^}"; done
Acuérdate de convertir a mayúsculas también los archivos del subdirectorio DATA!).
Ahora ya sobreescribe los archivos desde el anvil o desde el zip de la actualización, lo que tengas más a mano.

Metemos en el directorio c:\dm2 estos archivos del Anvil of Down:
LOADPATS.EXE
PATCHES.INI

En DOSBOX, tenemos que poner: 
--SB16 (SBPRO también vale): Address 240, IRQ 5, DMA 1
--Gravis Ultra Sound:		 Address 220, IRQ 7, DMA 3
En el setup del dm2, elegimos la SB16 para efectos de sonido (OJO! poniendo bien su IRQ), y luego seleccionamos como MIDI la GUS, sólo como MIDI!
Ejecutamos LOADPATS.EXE cada vez que carguemos el dm2. Debería funcionar si tienes una GUS activada y el ULTRASND en C:\

Tengo el DM2.BAT exactamente así (si viene puesto +VS, quítalo, para que vaya a 60HZ el juego y no a 70HZ):
LOADPATS
EREGCARD
IBMIOP SKULL.EXE

Puedes (debes, por comodidad) borrar el archivo INTRO.

Y ya debería ir... Ya sabes: Sound Blaster para los efectos, y GUS para la música. Es cutre, pero funciona de momento.

TURRICAN 2 EN DOSBOX
====================

En todas las páginas viene una versión que no funciona pero que se puede arreglar fácilmente. 
Lo único que les falta a todas es establecer la variable de entorno "T2DIR" apuntando al diretorio "CFG" que viene con el juego.
Para que funcione, simplemente créate un PLAY.BAT con este contenido (suponiendo que tenemos el juego en C:\JUEGOS\T2):

@echo off
cls
set t2dir=c:\juegos\t2\cfg
oversmpl on
t2

En c:\juegos\t2\cfg debes meter los archivos que vienen en el directorio TURRICAN.CFG que viene con las copias del juego
que hay por ahí en internet.

Con esto ya te saldrá el menú con todas sus opciones, y el juego funcionará bien.
Para que vaya el audio bien, selecciona la SoundBlaster PRO, PUERTO 220, IRQ 7, DMA 1 (y que estén igual en la config del DOSBOX, claro).
NO TE MOLESTES con el audio GUS ni con SB16, suena peor que con SBPro...

PRINCE OF PERSIA 2 EN DOSBOX
============================

Para controlarlo con teclado (el control con joystick es una mierda: arriba para saltar, imagínate) pulsa ALT + K.
Pulsa Alt + O para entrar en las opciones.

ELDER SCROLLS: ARENA EN DOSBOX
==============================

Para tener música GUS, NO PUEDES usar la GUS para el sonido y para la música a la vez: tienes que tener una SB16 para el sonido
y la GUS para la música (si intentas usar la GUS para ambas cosas, el juego se colgará, se corromperán los menús, etc).
Una vez que las hayas seleccionado así en INSTALL.EXE, edita ARENA.BAT y ajusta los valores de la GUS para que coincidan con los de DOSBOX,
ya que INSTALL.EXE no detecta correctamente los valores de la GUS.

Una vez configurado con música GUS y efectos SB16, puedes deshabilitar el OPL de la SB16 porque el juego no lo usa para nada.

Todo esto es aplicable igualmente al REALMS OF ARKANIA 2: STARTRAIL.

THE IMMORTAL EN DOSBOX
======================

Si quieres música y sonido MT32, lanza el juego con IMMORTAL.EXE ROLAND

LA MEJOR PÁGINA PARA BAJAR PELÍCULAS BUENAS Y ALTERNATIVAS
==========================================================

Busca ZOOWOMAN y el nombre de la peli.

ACTUALIZAR FIRMWARE DEL 8BITDO SN30
===================================

Instalamos el programa necesario:

sudo apt-get install fwupd

Conecta el dispositivo, y escribe en la consola de comandos:

fwupdmgr get-devices

Luego haz:

fwupdmgr get-updates

Y si hay algo nuevo, pues se actualizará. Más fácil imposible.

Poner RETROARCH en el arranque de una manera moderna, basado en systemd
=======================================================================

Creamos el fichero del servicio en /etc/systemd/system/retroarch.service, con este contenido:

[Unit]
Description=Systemd service and user to run Retroarch in stand-alone mode

[Service]
User=root
Group=root
PAMName=login
WorkingDirectory=/root/retro
ExecStart=
ExecStart=-/usr/local/bin/retroarch
Restart=always

[Install]
WantedBy=multi-user.target

y activaríamos el unit con 
sudo systemctl enable retroarch.service

En realidad esto lo único que hace es copiar /etc/systemd/system/retroarch.service a /etc/systemd/system/multi-user.target.wants/retroarch.service, es decir, lo mete en el directorio del target "multiuser", que es el último, supongo, cuando se inicia el sistema. (Bueno, crea un symlink, pero ya me entiendes).

Naturalmente, "systemctl disable retroarch" hace lo contrario: borra /etc/systemd/system/multi-user.target.wants/retroarch.service.

Saber esto nos permite habilitar y deshabilitar servicios manualmente sin necesidad de que arranque el sistema, accediendo al rootfs desde otro ordenador.

Naturalmente, el ejecutable tiene que estar en /root/bin/retroarch, o donde sea pero que coincida con lo que dice el .service
Puedes quitar el Restart=always para hacer pruebas, porque al quitarlo se sale al TTY1 si tienes una consola ahí.

Si quieres tener diferentes cmdline.txt (en diferentes particiones boot) que lancen diferentes cosas, puedes:
1) NO activar el servicio
2) Entonces, puedes decirle a systemd que lance un servicio no activado desde el cmdline.txt con:
systemd.unit="retroarch.service"
3) Puedes hacer que cuando salgas del programa que sea la máquina se reinicie(y así puedes elegir otro): para ello, aniade en la sección [Unit] del .service:
SuccessAction=reboot

Algunos programas, como el Scummvm, necesitan en la sección [Service]:
WorkingDirectory=/root/scummvm
..O si no, no detecta los juegos que aniades.
Lo mismo pasa con todo lo que lances con un script en el que tienes un ejecutable al que le pasas cosas. Como no tengas un WorkingDirectory, no encontrará las cosas que le pasas.
Por ejemplo, para el doom (doomretro, siendo doom.sh un script donde a doomretro se le pasa un iwad y tal), haríamos:

[Unit]
Description=Systemd service and user to run Doom in stand-alone mode

[Service]
User=root
Group=root
PAMName=login
WorkingDirectory=/root/doom
ExecStart=
ExecStart=-/root/doom/doom.sh
Restart=always

[Install]
WantedBy=multi-user.target

OJO!!! doom.sh debe empezar con #!/bin/bash en la primera línea, o no funcionará! Esto igual para todos los scripts que lances desde units.

OPENFODDER, versión opensource de Cannon Fodder 1 y 2
=====================================================

Clonamos el repo:

git clone --depth 1 https://github.com/OpenFodder/openfodder.git

--Editamos Source/Amiga/Sound_Amiga.cpp y ponemos "desired->samples" a 0x400
--Configuramos con:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_CXX_FLAGS="-DNDEBUG -march=native -mtune=native"

Ahora, nos creamos ~/cf, y ahí:
-Copiamos el ejecutable "openfodder"
-Copiamos el archivo openfodder.ini.example a ~/cf/openfodder.ini y lo editamos a nuestro gusto.
-Descomprimimos directamente los contenidos de un ZIP de datos del engine que está aquí:
https://github.com/OpenFodder/data/releases
-Obtenemos los datos del Cannon Fodder de AMIGA. NO nos valen los datos de una instalación de WHDLOAD, los tenemos que extraer nosotros
de un set de discos de AMIGA en IPF. Descargamos los IPF de AMIGA de aquí:
https://edgeemu.net/browse-amiga-C.htm
Y compilamos esta herramienta: https://github.com/OpenFodder/SOS_Unpacker
Y metemos los IPF de AMIGA en el mismo directorio que el ejecutable SOS_Unpacker, lo ejecutamos, y nos deja los archivos extraidos en "out".
Metemos los datos de AMIGA en ~/cf/Data/Amiga, y ya nos debería detectar el juego y aparecer como "Cannon Fodder" sin más en el menú al ejecutar
el OpenFodder.

Los datos del Cannon Fodder 2 irían en ~/cf/Data/Amiga2 y simplemente hay que montar el ADF del juego (tienes instrucciones de cómo montar ADFs
en este mismo archivo) y sacarlos de ahí. Puede que te el OpenFoder te diga que el MD5 un fichero llamado MAPM1.SPT es incorrecto. En ese caso,
puedes sacar el MAPM1.SPT correcto del ADF marcado como [a]. 

PARA LANZAR DIRECTAMENTE EL CANNON FODDER ORIGINAL:
./cf -c "Cannon Fodder"

LA RESOLUCIÓN QUE MEJOR LE QUEDA PARA LOS SHADERS (=no hay shimmering durante la pantalla de las medallas) es 320x240.
O sea que usa el CRTFakelottes_320x240.fx

ABUSE en GNU/Linux
==================

--Clonamos su repo:
git clone --depth 1 https://github.com/Xenoveritas/abuse.git

--ANTES DE CONFIGURAR Y COMPILAR LOS SOURCES, DEBEMOS TENER LOS DATOS DE MÚSICA Y FX EN EL DIRECTORIO "data"
O AL NO DETECTARLOS NO NOS COMPILARÁ SOPORTE DE MÚSICA Y FX!!! Para ello:
Nos bajamos la versión de Wii ya preparada de: https://oscwii.org/library/app/abuse
La descomprimimos y copiamos el contenido de "data" al directorio "data" que viene con los sources.

--Configuramos y compilamos con:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native"

--Creamos ~/abuse y copiamos allí el ejecutable:
cp src/abuse ~/abuse/

--Copiamos el directorio "data" a ~/abuse

--Ejecutamos con:
SDL_SOUNDFONTS=UHD3.sf2 ./abuse -datadir ./data -fullscreen

JAZZ JACKRABBIT 2 (jazz2) en GNU/Linux (jazz2resurrection-native)
=================================================================

--PREVIO: Necesita libGLEW, que tienes en este documento las instrucciones para instalarla.

--Instalamos otras dependencias previas:
apt-get install libopenmpt-dev

--Clonamos su repo: git clone --depth 1 https://github.com/deathkiller/jazz2-native.git
--Configuramos con:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release -DNCINE_PREFERRED_BACKEND=SDL2 \
-DCMAKE_CXX_FLAGS="-DNDEBUG -march=native -mtune=native"

OJO!! Si no nos detecta GLVND, es porque has instalado MESA usando MESON/NINJA por lo que las librerías han acabado en /usr/local/lib64,
que es lo normal cuando se instala con MESON/NINJA y no pasa nada, pero CMAKE y PKGCONFIG no buscan en /usr/local/lib64 por defecto,
por lo que deberías haber creado el fichero /etc/profile.d/custom.sh con el contenido:
export CMAKE_LIBRARY_PATH=/usr/local/lib64
export PKG_CONFIG_PATH=/usr/local/lib64/pkgconfig

(Si quisiéramos compilar contra GLES en lugar de OpenGL, pasaríamos también "-DNCINE_WITH_OPENGLES=ON")
(OJO!! Tenemos que pasar "-DNCINE_PREFERRED_BACKEND=SDL2" porque si no, compila contra glfw, y los gamepads no van!!)

--Creamos el directorio ~/jazz2, donde metemos los datos del juego instalado en ~/jazz2/Source
y copiamos el directorio "Content" que viene con los sources, de manera que tendremos:
~/jazz2/Source  <--Los datos del juego instalado van aquí metidos todos.
~/jazz2/Content <--Esto viene con los sources.

Para que nos reconozca el gamepad si no está en la base de datos de SDL2, mete el gamecontrollerdb.txt en ~/.config/Jazz²\ Resurrection/
o en ~/jazz2/Content/

Juegos PICO8 en GNU/Linux usando el core de libretro "fake-08"
==============================================================

Clonamos el repo:

git clone --depth 1 --recurse-submodules -b libretro-core https://github.com/jtothebell/fake-08.git

cd fake-08/platform/libretr
make -j4

También podríamos compilar una versión SDL2 usando el branch principal, con:

git clone --depth 1 https://github.com/jtothebell/fake-08.git
make sdl2 -j4

HEART OF DARKNESS en GNU/Linux (HODE)
=====================================

Bajamos la última versión de los sources de:
http://cyxdown.free.fr/hode/

Editamos el Makefile:
-Quitamos el -g y añadimos en su lugar los FLAGS: -O2 -march=native -mtune=native

Editamos system_sdl2.cpp  y:

-Dejamos la línea
desired.samples = 4096;
como
desired.samples = 512;

-Añadimos SDL_RENDERER_PRESENTVSYNC a la llamada de SDL_CreateRenderer()
-Puedes ajustar los controles del joystick también en system_sdl2.cpp:
Busca SDL_CONTROLLER_BUTTON y ahí asignas como quieras. Pero OJO, si ves SDL_CONTROLLER_BUTTON_B, no es el B del mando SN30 sino el B de un mando de XBOX360 que es como se detecta el mando en el ordenador. Así que mírate una foto del mando de 360 para hacerlo.
De todos modos, yo lo tengo así, de arriba a abajo: X, A, B, Y. Así coincide con los controles de PSX.

En el directorio donde va el ejecutable, creamos hode.ini con el contenido:

[engine]

# disable animations playback
disable_paf=false

# disable monsters handling code
disable_mst=false

# disable sound handling code
disable_sss=false

# maximum number of active sounds (original engine sets to 10 if a slow CPU or low memory is detected)
max_active_sounds=16

# 0:easy 1:normal 2:hard
difficulty=0

# frame duration in milliseconds (original is 80ms, eg. 12.5hz)
frame_duration=50


[display]

# scaling factor for game graphics (base resolution is 256x192)
scale_factor=1

# scaling algorithm for game graphics ('xbr', 'nearest', 'linear' or 'none')
scale_algorithm=none

# gamma correction
gamma=1.0

# use intensity color
grayscale=false

# fullscreen display
fullscreen=true

# widescreen (16:9)
widescreen=false

-Una vez que lo tengamos todo, ejecutamos con:
./hode --datapath=data_pc
...Donde data_pc es un directorio donde están los datos del juego (ver README para saber qué archivos se necesitan).
Las teclas son las flechas F, G y H.

Neverball en GNU/LINUX
======================

Clonamos su repo en:
git clone --depth 1 https://github.com/Neverball/neverball.git

Compilamos con
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
make ENABLE_OPENGLES=1 ENABLE_FS=stdio ENABLE_NLS=0 BUILD=release -j4

VVVVVV en GNU/LINUX
===================

Entramos en su repo y clonamos

git clone --depth 1 https://github.com/TerryCavanagh/VVVVVV.git

Entramos en desktop_version, creamos b4 y configuramos con:

cmake -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-DNDEBUG -march=native -mtune=native" \
-DCMAKE_CXX_FLAGS="-DNDEBUG -march=native -mtune=native" ..

Bajamos el data.zip que viene con la versión Windows del VVVVVV, disponible aquí:
https://thelettervsixtim.es/makeandplay/
Ponemos el data.zip junto al ejecutable... Y listo!

Puedes ocultar el cursor del ratón y poner el filtro bilineal en ~/.local/share/VVVVVV/saves/settings.vvv

DESCARGAR DESDE EMUPARADISE
===========================

Con el Firefox (si no funciona, usa Chromium) nos instalamos la extensión tampermonkey.
Ahora desde el Chromium también nos vamos a abrir este script: https://gist.github.com/infval/c69b479ff0bd590f2dd7e1975fe2fcad
Le damos a RAW (es como un github), y nos saldrá un botón de INSTALL. Instalamos el script, es un script para el tampermonkey.
Ahora nos vamos a emuparadise, le damos a Download Links de lo que queramos bajar, y nos sale una opción nueva que es "download with workaround script". Le damos y empieza a bajar.

HACER QUE LOS MANDOS SEAN DETECTADOS COMO GAMEPAD POR LA API DE SDL2 (Método actual)
====================================================================

Compila los tests que vienen con los sources. Entre ellos, se creará un ejecutable llamado "controllermap".
Lo ejecutamos y tras seguir las instrucciones nos da una cadena de mapeo para que SDL2 reconozca el mando como un gamepad.

Si algún juego no nos reconoce el mando como gamepad, podemos setear una variable de entorno antes de lanzar el juego:
export SDL_GAMECONTROLLERCONFIG="03000000412300003680000001010000,LLC Arduino Leonardo,a:b0,b:b1,x:b2,y:b3,back:b6,start:b7,leftshoulder:b4,rightshoulder:b5,dpup:-a1,dpdown:+a1,dpleft:-a0,dpright:+a0,platform:Linux,"

...O bien podríamos añadir esa misma variable de entorno en en /etc/environment, y queda exportada para todos, es lo mismo.

---Cadenas de diferentes mandos---

Adaptador DaemonBite de UltimateMister para SNES:
03000000412300003680000001010000,LLC Arduino Leonardo,a:b0,b:b1,x:b2,y:b3,back:b6,start:b7,leftshoulder:b4,rightshoulder:b5,dpup:-a1,dpdown:+a1,dpleft:-a0,dpright:+a0,platform:Linux,

Adaptador DaemonBite de UltimateMister para MegaDrive:
03000000412300003680000001010000,LLC Arduino Leonardo,a:b0,b:b1,x:b3,y:b4,back:b7,start:b6,leftshoulder:b5,rightshoulder:b2,misc1:b8,leftx:a0,lefty:a1,platform:Linux,

Mando Kersu 2.4G:
030000005e0400008e02000073060000,Khensu,a:b0,b:b1,x:b2,y:b3,back:b6,guide:b8,start:b7,leftstick:b9,rightstick:b10,leftshoulder:b4,rightshoulder:b5,dpup:h0.1,dpdown:h0.0,dpleft:h0.8,dpright:h0.2,leftx:a0,lefty:a1,rightx:a3,righty:a4,lefttrigger:a2,righttrigger:a5,

Adaptador RAPHNET de mandos de Dreamcast:
030000009b2800000800000001010000,raphnet.net Dreamcast to USB,a:b10,b:b9,x:b2,y:b1,back:b0,guide:b3,start:b8,dpup:b4,dpdown:b5,dpleft:b6,dpright:b7,platform:Linux,

DESCARGAR DE MEGA POR CACHOS CON LAS MEGATOOLS
==============================================

Se usa megadl.
Podemos descargar la última estable precompilada de:
https://megatools.megous.com/builds/builds/
Es simplemente copiar el archivo ejecutable "megatools" a /usr/local/bin

Y ya podemos descargar con:
megatools dl <LINK DE MEGA>

O bien (si hemos compilado desde los sources)
megadl <LINK DE MEGA>

Se hace resume por defecto, así que no tienes que pasarle ningún parámetro para reanudar la descarga de archivos incompletos.

######BLOQUE OPCIONAL: COMPILAR DESDE LOS SOURCES######

Instalamos dependencias previas:
sudo apt-get install libglib2.0-dev libcurl4-gnutls-dev libssl-dev meson

Clonamos el repo de las megatools:
git clone --depth 1 https://megous.com/git/megatools

Creamos el directorio de compilación, entramos en él y configuramos con meson:
mkdir b4
cd b4
meson -Dbuildtype=release ..

Compilamos
ninja -j4
sudo ninja install

######FIN BLOQUE OPCIONAL: COMPILAR DESDE LOS SOURCES######

ISHAR NATIVO EN GNU/LINUX
=========================

Esta no la viste venir, ¿eh?
Compilamos su repo: git clone --depth 1 https://github.com/maestun/alis.git

Editamos src/sys/sys_sdl2.c y allí:
-Añadimos antes de la llamada a SDL_CreateWindow():
SDL_ShowCursor(SDL_DISABLE);
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
-(SÓLO SI NO VAS A USAR ZINK!!) Añadimos el flag SDL_RENDERER_PRESENTVSYNC a la llamada de SDL_CreateRenderer()

Editamos Makefile y en la línea "CFLAGS =" quitamos el "-g" y ponemos: "-O2 -march=native -mtune=native" 

Compilamos con:
make -j10

Creamos el directorio "ishar" y copiamos allí el ejecutable del engine:
mkdir ~/ishar
cp -R build/alis ~/ishar/

Dentro de ~/ishar, creamos los directorios de los diferentes juegos:
cd ~/ishar
mkdir ishar1
mkdir ishar2
mkdir crystals

Metemos los datos de los juegos (versiones DOS) en esos directorios, y para cada uno de ellos hacemos
(ojo, hay que instalar el paquete "rename" antes):
rename 'y/A-Z/a-z/' *

Ejecutamos con:
alis -f <directorio_datos>
(El "-f" es para pantalla completa)

WARCRAFT II NATIVO EN LINUX
===========================

Nos hacen falta dos cosas: el stratagus que es el engine, y el wargus que es un importador del WCII para que funcione para stratagus.

Instalamos dependencias previas:
sudo apt-get install tolua++ libluajit-5.1-dev libbz2-dev --no-install-recommends

Instalamos el stratagus:
git clone --depth 1 https://github.com/Wargus/stratagus.git
cd stratagus && mkdir b3 && cmake .. && make -j4 && sudo make install

Instalamos el wargus:
git clone --depth 1 https://github.com/Wargus/wargus.git
cd wargus && mkdir b3

Ahora atiende: configuramos stratagus pasándole el ejecutable del stratagus que tenemos instalado y el path de gameheaders, que es un directorio de los sources de stratagus. Es fácil, por ejemplo si tenemos los sources de stratagus en ~/src/stratagus, sólo hay que hacer:
cmake .. -DCMAKE_PROGRAM_PATH=/usr/local/games/stratagus -DCMAKE_INCLUDE_PATH=~/src/stratagus/gameheaders
make -j4
sudo make install

EJECUTAR EJECUTABLES DE 32BIT (armhf) EN LINU DE 64BIT (aarch64)
================================================================

Lo primero, ver si nuestro kernel soporta compat:
grep CONFIG_COMPAT= /boot/config-$(uname -r)

Ahora a ver qué arquitecturas extranjeras soporta el sistema de gestión de paquetes (nos tiene que salir armhf como mínimo):
dpkg --print-foreign-architectures

Tenemos instalado libc6 versión armhf?
dpkg -l libc6:armhf

Tenemos instalado libc++6 versión armhf?
dpkg -l libstdc++6:armhf

Si nos falta alguna, la instalamos:
sudo apt-get install libstdc++6:armhf

NO CONFUNDAS libstd con libc, son cosas distintas.

EASYRPG, EL MOTOR DE RPGMAKER EN LINUX
======================================

LO COMPILAMOS COMO UN CORE PARA LIBRETRO

Empezamos instalando libclf, que es parte del proyecto EASYRPG, así que hay que instalarla a mano:

Dependencias previas:
sudo apt-get install libexpat1-dev libpixman-1-dev libfmt-dev libsndfile1-dev --no-install-recommends

Ahora vamos a por libclf:
git clone --depth 1 https://github.com/EasyRPG/liblcf.git
mkdir b4
cd b4
cmake -DDISABLE_ICU=ON ..

Ahora vamos a por EASYRPG:
git clone --depth 1 --recurse-submodules -j8 https://github.com/EasyRPG/Player.git
mkdir b4
cd b4
cmake -DPLAYER_TARGET_PLATFORM=libretro -DBUILD_SHARED_LIBS=ON ..

Ahora lo lanzaríamos con:
retroarch -L core <.exe del juego hecho con RPG Maker>

INSTALAR DRIVER IMPRESORA CANON
===============================

Compilarlos a mano desde los sources que da Canon es imposible, porque están rotos a propósito.
Así que hay que añadir unos repos y los instalamos desde ahí con apt-get.
Las instrucciones, en castellano, aquí:

https://www.sololinux.es/instalar-drivers-de-impresoras-canon-en-ubuntu-20-04/

QUAKE 3: IOQUAKE3 EN LINUX
===========================

Clonamos los sources:

git clone --depth 1 https://github.com/suijingfeng/vkQuake3.git

mkdir ~/q3
mkdir ~/.q3a
mkdir ~/.q3a/baseq3

Entramos en los sources y, sin más, hacemos:
CFLAGS="-O2 -march=native -mtune=native -O2 -DSDL_DISABLE_IMMINTRIN_H" \
CXXFLAGS="-O2 -march=native -mtune=native -O2 -DSDL_DISABLE_IMMINTRIN_H" make -j4

En X86_64, con hacer make -j4, vale.

Cuando acabe, hacemos:
cd build/release-linux-<nombre_arquitectura>
cp oiquake3* renderer*.so ~/q3
cp -R baseq3/* ~/.q3a/baseq3/ 

Nos bajamos los pak*.pk3 desde el 1 al 8. Los puedes bajar de aquí:
https://github.com/nrempel/q3-server/tree/master/baseq3
...Y los metemos todos en ~/.q3a/baseq3

En la Pi, como NO HAY OpenGL y GLES no vale, sólo Vulkan, creamos:
~/.q3a/baseq3/q3config.cfg
Con el contenido:
seta cl_renderer "vulkan"

Y ya deberíamos poder lanzar el juego, simplemente ejecutando ~/q3/ioquake3.<nombre_arquitectura>

Para activar el renderer Vulkan, sacamos la consola con la tilde (es decir, con ~) y escribimos:
/cl_renderer vulkan
/vid_restart

Y vamos que está bien con:
/vkinfo

ACTUALIZAR RASPBERRY PI OS SIN ACTUALIZAR EL KERNEL
===================================================

Útil para cuando tenemos un kernel especial instalado, como por ejemplo el kernel realtime de: https://github.com/kdoren/linux/releases/

Se hace poniendo el paquete raspberrypi-kernel en "hold", tal que así:

-Actualizamos el índice de paquetes como siempre:
sudo apt-get update

-Ponemos el paquete del kernel en hold:
sudo apt-mark hold raspberrypi-kernel

-Actualizamos los paquetes normalmente. Como el paquete del kernel está en holdo, no se actualizará:
sudo apt-get upgrade

Opcionalmente, si quieres, puedes quitar el hold del paquete del kernel al acabar, haciendo:
sudo apt-mark unhold raspberrypi-kernel

REVENGE OF TITANS EN GNU/LINUX
==============================

Hay un tutorial aquí:
https://www.raspberrypi.org/forums/viewtopic.php?t=290589

El juego usa tres librerías cuyas versiones aarch64 necesitas: 
liblwjgl.so
libopenal.so
lwjgl.jar

Para conseguirlas, vamos al configurador online de LWJGL:
https://www.lwjgl.org/customize
Generamos el paquete, y en los *natives de cada librería tienes los .so que necesitas.
SUSTUTUYE las versiones que trae el juego con las que acabas de generar.

ACCEDER A DISPOSITIVOS USB DESDE ORACLE VIRTUALBOX
==================================================

-Añadir al usuario al grupo vboxusers:
sudo usermod -a -G vboxusers manuel

-Instalar, en el VirtualBox, las "Oracle VM Virtual Box Extension Pack", correspondiente a la versión de VirtualBox que tengas instalada
y que puedes descargar aquí:
https://download.virtualbox.org/virtualbox

-Instalar, en la máquina virtual, las "Virtual Box Guess Additions", que vienen en una ISO llamada "VBoxGuestAdditions.iso"
correspondiente a la versión de VirtualBox que tengamos instalada, y que puedes descargar aquí:
https://download.virtualbox.org/virtualbox/
Tienes que montar la ISO desde la barra superior cuando estés ejecutando la máquina, en DEVICES->OPTICAL DRIVES.

-OJO: Usa USB 2.0 en los dispositivos USB del VirtualBox (en Settings->USB), si usas USB 3.0 probablemente no funcione.

EXTRAER ARCHIVOS DE JUEGOS DE SWITCH EN LINUX
=============================================

Clonamos el repo de la herramienta que se usa:
git clone --depth 1 --recurse-submodules -j8 https://github.com/jakcron/nstool.git

compilamos:
make deps -j4
make -j4

Para extraer simplemente hacemos:

nstool -x ./extract_dir/ some_file.nsp

AMS (Advanced Mac Substitute) en LINUX
=======================================

Clonamos el repo:
git clone --depth 1 https://github.com/jjuran/metamage_1

Hacemos:
make ams-linux
(Para X11, make ams-x11)

Para lanzar el programa demo, desde el directorio de los sources:
EXHIBIT_INTERACT=interact-x11 PATH="$PWD/var/demo:$PWD/var/out:$PATH" AMS_BIN=var/links/ams-68k-bin/bin AMS_LIB=var/links/ams-68k-bin/lib AMS_MNT=var/links/ams-68k-bin/mnt var/out/minivx -Z v/bin/ams.vx

Para lanzar el Tic-tac-toe, que es otra demo, simplemente tenemos que añadir AMS_APPNAME=Tic-tac-toe
Lo mismo con "Nyanochrome Cat":

EXHIBIT_INTERACT=interact-x11 PATH="$PWD/var/demo:$PWD/var/out:$PATH" AMS_BIN=var/links/ams-68k-bin/bin AMS_LIB=var/links/ams-68k-bin/lib AMS_MNT=var/links/ams-68k-bin/mnt AMS_APPNAME=Tic-tac-toe var/out/minivx -Z v/bin/ams.vx

EXHIBIT_INTERACT=interact-x11 PATH="$PWD/var/demo:$PWD/var/out:$PATH" AMS_BIN=var/links/ams-68k-bin/bin AMS_LIB=var/links/ams-68k-bin/lib AMS_MNT=var/links/ams-68k-bin/mnt AMS_APPNAME="Nyanochrome Cat" var/out/minivx -Z v/bin/ams.vx

¿CÓMO FUNCIONA TODO ESTO?
Pues ams.vx, que es un script escrito en Varyx (??), que llama a exhibit que a su vez va llamando a otras herramientas que ya serían ejecutables nativos de Linux.
Por ejemplo, si miras los ejemplos que he puesto, interact-x11 es el frontend x11. (Idealmente habría un interact-sdl2).
Lo que nos interesa son los frontent, es decir, interact-*.

Y si quisieras instalar system-wide:

sudo make ams-linux-inst

EJECUTAR VKCUBE SIN LAS X
=========================

vkcube -m khr -k 0:0:0
(display 0, modo 0, plano 0. Usa --help para más información).

INSTALAR CERTIFICADO DIGITAL
============================

Nos vamos a https://www.sede.fnmt.gob.es/certificados/persona-fisica/obtener-certificado-software
Este va a ser nuestro índice general desde el que vamos haciendo las cosas.

-Primero nos bajamos el programa de Configuración Previa, que es un .DEB. 
¡¡¡CUIDADO!!! Antes de instalarlo, instalamos sus dependencias previas:
sudo apt-get install libcanberra-gtk3-module libcanberra-gtk3-module --no-install-recommends
####BLOQUE PARCHE PARA DEBIAN 13 (NO DEBERÍA SER NECESARIO EN EL FUTURO####
Como el Programa de Configuración Previa necesita el paquete "libcanberra-gtk-module" que en Debian 13 se llama "libcanberra-gtk3-module"
nos creamos un paquete "libcanberra-gtk-module" falso y lo instalamos.
Para ello:
	--Instalamos la herramienta necesaria: sudo apt-get install equivs
	--Creamos un fichero de texto llamado "libcanberra-gtk-module" con el contenido:

Section: misc
Priority: optional
Standards-Version: 3.9.2

Package: libcanberra-gtk-module
Version: 0.30-2
Maintainer: Tu Nombre <tu@correo.com>
Description: Paquete ficticio para satisfacer dependencias de libcanberra-gtk-module

	--Creamos el paquete ficticio y lo instalamos:
equivs-build libcanberra-gtk-module
sudo dpkg -i libcanberra-gtk-module_0.30-2_all.deb
####FIN BLOQUE PARCHE PARA DEBIAN 13###
Vamos con el programa de Configuración Previa en sí:
sudo dpkg -i configuradorfnmt_x.x.x-x_amd64.deb

-Ahora nos vamos a la parte de "Solicitud via internet de su certificado". Rellenamos el formulario y lo enviamos.
Nos llegará al correo un código, que junto con el DNI se presenta en un registro (Ayto por ejemplo) y nos dan el certificado.
(Tienes copia del certificado en el correo y en el disco duro de backup).

-Ahora nos vamos en Firefox a Settings->Privacy & Security->Certificates, y en la pestaña de "My Certificates",
importamos el certificado usando el archivo con extensión .p12

PARTE 2: AUTOFIRMA

Instalamos dependencias previas:
sudo apt-get install openjdk-23-jre libnss3-tools

Se descarga un .deb desde: https://firmaelectronica.gob.es/Home/Descargas.html
Lo instalamos con dpkg desde la consola de comandos. Este paquete instala:
-El programa Autofirma, hecho en Java. En este punto, deberíamos ser capaces de ejecutar desde la consola "Autofirma" sin errores de Java.
-Un certificado en /usr/lib/Autofirma, que nosotros tenemos que importar manualmente desde Firefox, que es lo que vamos a hacer a continuación.

Ahora nos vamos en Firefox a Settings->Privacy & Security->Certificates, y en la pestaña de Authorities,
importamos el certificado /usr/lib/Autofirma/AutoFirma_ROOT.cer

CON EL CERTIFICADO DIGITAL, ADEMÁS, PODEMOS ACCEDER A LA CARPETA CIUDADANA EN: https://carpetaciudadana.gob.es/carpeta/clave.htm
(NO TIENES QUE ANDAR CON CL@AVE: DONDE PUEDAS ACCEDER CON CL@VE PUEDES ACCEDER CON EL CERTIFICADO DIGITAL).

AUTOMONTAJE/AUTOMOUNT DE DISPOSITIVOS DE ALMACENAMIENTO USB EN GNU/LINUX
========================================================================

-Al más bajo nivel, para que cuando udev detecte el disco se active el servicio de montaje,
creamos /etc/udev/rules.d/99-local.rules con el contenido:


KERNEL=="sd[a-z][0-9]", SUBSYSTEMS=="usb", ACTION=="add", RUN+="/bin/systemctl start usbmount@%k.service"
KERNEL=="sd[a-z][0-9]", SUBSYSTEMS=="usb", ACTION=="remove", RUN+="/bin/systemctl stop usbmount@%k.service"


-Ahora creamos el servicio de montaje, que llamaremos usbmount, en /etc/systemd/system/usbmount@.service, con el contenido:


[Unit]
Description=Mount USB Drive on %i

[Service]
Type=oneshot
RemainAfterExit=true
ExecStart=/usr/local/bin/usbmount add %i
ExecStop=/usr/local/bin/usbmount remove %i


-Creamos el script de montaje, que será llamado/usado por el servicio de montaje para hacer el montaje en sí,
y que también llamaremos usbmount, en /usr/local/bin/usbmount con el contenido:


#!/bin/bash
ACTION=$1
DEVBASE=$2
DEVICE="/dev/${DEVBASE}"

# See if this drive is already mounted, and if so, where
MOUNT_POINT=$(/bin/mount | /bin/grep ${DEVICE} | /usr/bin/awk '{ print $3 }')

# Mount or dismount
case "${ACTION}" in

	add)
		# If already mounted, exit
		if [[ -n ${MOUNT_POINT} ]]; then exit 1; fi

		# Get info for this drive: $ID_FS_LABEL, $ID_FS_UUID, and $ID_FS_TYPE
		eval $(/sbin/blkid -o udev ${DEVICE})

		# Figure out the mount point to use, based on the device label
		LABEL=${ID_FS_LABEL}	
		MOUNT_POINT="/media/${LABEL}"

		# Create the mountpoint
		/bin/mkdir -p ${MOUNT_POINT}

		# Global mount options
		OPTS="rw,relatime"				

		# FAT file system specific mount options (meh)
		if [[ ${ID_FS_TYPE} == "vfat" ]]; then
			OPTS+=",users,gid=100,umask=000,shortname=mixed,utf8=1,flush"
		fi

		# Let's mount! Delete the mountpoint and exit if failed
		if ! /bin/mount -o ${OPTS} ${DEVICE} ${MOUNT_POINT}; then
			/bin/rmdir ${MOUNT_POINT}
			exit 1
		fi
        ;;

	remove)
		if [[ -n ${MOUNT_POINT} ]]; then
			/bin/umount -l ${DEVICE}
			/bin/rmdir ${MOUNT_POINT}
		fi
        ;;
esac


-Le damos permisos de ejecución al script de montaje:
chmod +x /usr/local/bin/usbmount

-Recargamos las udev rules y los servicios:
udevadm control --reload-rules
systemctl daemon-reload

...Y ya deberíamos tener los dispositivos de almacenamiento USB automáticamente montados en /media/...

ACELERACIÓN DE VÍDEO EN LA PI4 CON VLC
======================================

El repo de VLC está en:
https://code.videolan.org/videolan/vlc

--Clonamos su repo:
git clone --depth 1 https://code.videolan.org/videolan/vlc.git
--Antes de configurar:
----Instalamos libtool:
apt-get install libtool --no-install-recommends
----Ejecutamos el script "bootstrap" que viene con los sources.

--Configuramos con:
meson -Dbuildtype=release -Dwayland=enabled -Dvideolan_manager=false -Drun_as_root=true -Dssp=disabled -Dbranch_protection=disabled \
-Dqt=disabled -Dx11=disabled -Dlua=disabled -Dpulse=disabled -Ddbus=disabled -Davahi=disabled -Dgles2=enabled \
-Dtheoraenc=disabled -Ddaalaenc=disabled ..

NOTA: Si usamos el antiguo configure && make, configuramos con:
./configure --without-x --disable-xcb --enable-wayland --disable-qt --disable-ncurses --enable-v4l2 --disable-mmal \
--enable-gles2 --disable-lua --disable-a52 --disable-freerdp --disable-vnc

ARREGLAR ROMS CON ROMVAULT
==========================

-Nos bajamos el exe del RomVault de: https://www.romvault.com/
Se ejecuta con Mono: mono ROMVault36.exe

-Nos vamos bajando los .DAT de los sistemas que queramos arreglar de:
https://datomatic.no-intro.org
...Y los metemos en el directorio DatRoot del RomVault

-Metemos los juegos de los sistemas que queramos reparar en el directorio RomRoot del RomVault

-En RomVault, le damos a "Update Dats", luego a "Find Fixes" y luego a "ROM Fixes"
Te dejará las ROMs (que pueda identificar) con los nombes correctos puestos en RomRoot/<NOMBRE_SISTEMA>,
y las que no pueda identificar en ToSort/<NOMBRE_SISTEMA>
...Le puedes poner nombes de no-intro a las ROMs parcheadas, que son las que suelen acabar en ToSort,
y así RetroArch te las reconoce y les pone thumbnails.

DRICONF
=======

Es la manera de configurar cosas de los drivers MESA.
El fichero de configuración va en ~/.drirc

La manera correcta de generarlo es usando "adriconf" (necesita GTK):
git clone --depth 1 https://gitlab.freedesktop.org/mesa/adriconf

REPRODUCCIÓN DE VÍDEO EN AMD64 Y RASPBERRY PI CON MPV + FFMPEG
==============================================================
Página aclaratoria sobre el asunto: https://wiki.debian.org/HardwareVideoAcceleration

-En AMD, la decodificación por hardware funciona mediante la implementación de VAAPI de MESA VAAPI
(por eso, al compilar MESA para AMD, le pasas "-Dgallium-va=enabled -Dvideo-codecs=h264dec,h265dec,vc1dec").
-En INTEL, la decodificación por hardware funciona mediante la implementación de VAAPI de INTEL-MEDIA-DRIVER.
-En Raspberry Pi 5 NO HAY decodificación de H264 por hardware ya, la han quitado, va por software.
Y en la Raspberry Pi 4, aunque había decodificación de H264 por hardware, era más lenta que por software,
y requería usar un fork especial de ffmpeg, así que pasando.

	***PARTE 1: LIBVA***

NOTA: Aunque LIBVA es un desarrollo de Intel, es necesario tanto para VAAPI mediante INTEL-MEDIA-DRIVER (=CPUs INTEL)
como para VAAPI mediante MESA (=CPUs AMD).

Bajamos la última estable de:
https://github.com/intel/libva/releases

Configuramos con:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" CXXFLAGS="-march=native -mtune=native" \
meson setup .. -Dbuildtype=release

###########BLOQUE EXCLUSIVO DE INTEL################

	***PARTE 2: INTEL MEDIA DRIVER***
(Es para Gen8 y posteriores, para otros chips más antiguos hacen falta otros drivers específicos).

DEPENDENCIA PREVIA: libigdgmm
DEBIAN 13: apt-get install libigdgmm-dev
DEBIAN 12:
-Bajamos la última estable de aquí: https://github.com/intel/gmmlib/tags
-Configuramos con:

  mkdir b4
  cd b4

  cmake .. -DCMAKE_BUILD_TYPE=Release \
  -DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
  -DCMAKE_C_FLAGS="-march=native -mtune=native"   

Vamos con el Intel Media Driver en sí (NO podemos instalar el paquete del sistema porque depende de libva2
y a su vez para compilar ffmpeg necesitaríamos instalar libva-dev que nos instalaría toda la morralla de MESA/X11):

Bajamos la última estable de:
https://github.com/intel/media-driver/releases

Configuramos con:

mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

	***(OPCIONAL!!!) PARTE 3: VAINFO***

Necesitamos VAINFO para ver qué aceleración soporta nuestra CPU:

Bajamos la última estable de:
https://github.com/intel/libva-utils/releases

Configuramos con:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" CXXFLAGS="-march=native -mtune=native" \
meson setup .. -Dbuildtype=release

Una vez instalado, podemos ejecutar "vainfo" para ver qué métodos de aceleración soporta nuestro chip.

###########FIN BLOQUE EXCLUSIVO DE INTEL################

	PARTE 4: FFMPEG
	
SÓLO AMD/INTEL: Instalamos dependencia previa: apt-get install nasm

VAMOS CON FFMPEG EN SÍ:

Bajamos la última estable del branch más reciente de: https://www.ffmpeg.org/download.html#releases
(Ahora van por la 7.1.x)

-Configuramos con:

PARA AMD/INTEL:
CFLAGS="-march=native -mtune=native" CXXFLAGS="-march=native -mtune=native" ./configure --disable-network --disable-debug \
--disable-muxers --disable-encoders --disable-indevs \
--disable-outdev=fbdev,oss \
--disable-doc --disable-bsfs \
--disable-sdl2 --disable-stripping \
--disable-thumb --disable-mmal \
--enable-libdrm --enable-vaapi

PARA RASPBERRY PI5 (es lo mismo pero en vez de "--enable-vaapi" le pasamos "--enable-neon"):
CFLAGS="-march=native -mtune=native" CXXFLAGS="-march=native -mtune=native" ./configure --disable-network --disable-debug \
--disable-muxers --disable-encoders --disable-indevs \
--disable-outdev=fbdev,oss \
--disable-doc --disable-bsfs \
--disable-sdl2 --disable-stripping \
--disable-thumb --disable-mmal \
--enable-libdrm --enable-neon

(NOTA: para tener ffplay, activa el soporte SDL2 quitando --disable-sdl2 : ffplay está pensado precisamente como un player simple
sobre SDL2 y es el único backend que tiene).

(NOTA: SI HUBIÉSEMOS ACTIVADO EL SOPORTE DE SDL2, podríamos reproducir vídeos con ffplay, para ello:
Lo primero, vermos qué codecs puede hacer por hardware la Pi: ffmpeg -codecs | grep v4l2m2m
Y ahora elegimos un codec y reproducimos el vídeo usándolo: ffplay -codec:v h264_v4l2m2m -fs <fichero_vídeo>
PERO no es muy productivo porque reproducir vídeo fullhd sobre SDL2 es lento).

	PARTE 5: MPV
	
-Instalamos dependencias previa, libass, que está en Debian pero arrastra toda la mierda de X11
así que la compilamos nosotros.
--Nos bajamos la última estable de: https://github.com/libass/libass/releases
--Configuramos con:	

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release ..

-Instalamos otra dependencia previa, libplacebo, que está en Debian pero arrastra toda la mierda de X11
así que la compilamos nosotros.

--Clonamos su repo (no instalamos desde estable porque necesita submódulos):
  git clone --depth 1 --recurse-submodules -j8 https://code.videolan.org/videolan/libplacebo.git
--Configuramos con:	

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup -Ddemos=false -Dbuildtype=release ..

VAMOS CON MPV EN SÍ:

-Bajamos la última estable de: https://github.com/mpv-player/mpv/releases

-Configuramos con:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Dlua=disabled ..

-Creamos ~/.config/mpv/mpv.conf con el contenido:
fs=yes

En AMD/INTEL puedes añadir:
hwdec=vaapi
SI NO TIENES VRR:
video-sync=display-resample

(Para saber qué posibles métodos de sincronización tienes disponibles, puedes hacer "mpv --video-sync=help")
(NO le pases "video-sync=display-resample" a la Pi, porque no va bien de ninguna manera).
(En realidad, no poner "hwdec" es suficiente, no haría falta poner "hwdec=vaapi".

LAS INSTRUCCIONES CON TODAS LAS OPCIONES DE MPV ESTÁN EN: https://mpv.io/manual/stable/

RECUERDA: Para ver los códecs de vídeo acelerados disponibles para el decoding:
mpv --hwdec=help
También podríamos ver las salidas de vídeo disponibles con:
mpv --vo=help
También podríamos ver las APIs de la GPU disponibles con:
mpv --gpu-api=help
...con el resto de cosas de las que quieras ver qué hay disponible, igual.

--OPCIONAL SI NO TENEMOS VRR: Ponemos el refresco de pantalla a lo mismo que los frames por segundo del vídeo a reproducir,
usando para ello este script para lanzar el mpv:

####SCRIPT PARA PONER EL REFRESCO DE PANTALLA DEL VÍDEO A REPRODUCIR, LANZAR MPV Y RESTAURAR REFRESCO ORIGINAL AL ACABAR####
original_rate=`wlr-randr | grep current | cut -d ' ' -f 7`
original_res=`wlr-randr | grep current | cut -d ' ' -f 5`
new_rate=$(ffprobe -v 0 -of csv=p=0 -select_streams v:0 -show_entries stream=r_frame_rate "$1")

numerador=`echo $new_rate | cut -d/ -f 1`
denominador=`echo $new_rate | cut -d/ -f 2`

new_rate=`printf "%f\n" $((10**6 * numerador/denominador))e-6`

#echo ${original_rate}
echo "Setting rate: ${new_rate}"
wlr-randr --output HDMI-A-1 --custom-mode $original_res@$new_rate
echo "Rate set: `wlr-randr | grep current | cut -d ' ' -f 7`"

mpv "$1"

wlr-randr --output HDMI-A-1 --custom-mode $original_res@$original_rate
####FIN SCRIPT####

SHADERS CON MPV
===============

--Clonamos el repo al lugar donde se van a guardar los shaders:
mkdir -p ~/.config/mpv/shaders
git clone --depth https://git.sr.ht/~taiite/mpv-retro-shaders ~/.config/mpv/shaders/mpv-retro-shaders

--Añadimos esto al principio del fichero ~/.config/mpv/mpv.conf:
include=~~/shaders/all.conf

--Ahora ya cargaríamos un vídeo con un shader así:
mpv --profile=crt-lottes my_video.mp4

--Si queremos ajustar los parámetros de un shader, lo editamos, no hay otra manera.
Por ejemplo, para quitar la curvatura del shader crt-lottes.glsl, dejamos así el parámetro CURVATURE:
#define CURVATURE vec2(0.0, 0.0)
Y podemos ajustar el tipo de máscara dándole a SHADOW_MASK valores de 0 a 4 (casi que la mejor para contenido en 1080p es la 4).

--NOTA EXTRA: Para que un shader se active con CTRL+1, por ejemplo, creamos el fichero ".config/mpv/input.conf" con el contenido:
CTRL+1 no-osd change-list glsl-shaders set "~~/shaders/crt-lottes.glsl"; show-text "Shader engaged"
CTRL+0 no-osd change-list glsl-shaders clr ""; show-text "Shaders cleared"

NAVEGAR POR THREADS DE TWITTER/X SIN TENER CUENTA EN LA RED DEL PUTO NAZI DE MIERDA
===================================================================================

En vez de "x.com/nombre_usuario", usa "xcancel.com/nombre_usuario" y podrás navegar sin tener que loguearte por todos los twits y respuestas
de los retrasados que aún usan esa mierda de red.

U/P DE TWITCH
=============

vanfanelio
tuputamadre22
