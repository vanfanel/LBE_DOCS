FINETUNING THE SYSTEM
=====================

Una vez que hemos arrancado nativamente, tenemos mucho que hacer.

-Para configurar la WIFI una vez arrancado el sistema sin escritorio, en Debian es editando /etc/network/interfaces,
y en Raspbian es usando el raspi-config.

-RECUERDA que para poder logearte por SSH como ROOT tienes que editar /etc/ssh/sshd_config y: 
	-Poner "PermitRootLogin" a "yes"
	-Ya que estás, deja comentada la línea:
		#AcceptEnv LANG LC_*
	...lo que nos ahorra errores de LOCALES cuando usamos APT-GET por SSH.
	
-SI AÚN ASÍ SIGUES TENIENDO PROBLEMAS CON LOS LOCALES POR SSH:
--Usa "dpkg-reconfigure locales" para generar el locale "en_US.UTF-8" y sólo ese.
--Edita /etc/default/locale y déjalo así:
LANG=en_US.UTF-8                                                                                               
LC_ALL=en_US.UTF-8                                                                                             
LC_TIME=en_US.UTF-8                                                                                            
LC_MONETARY=en_US.UTF-8                                                                                        
LC_ADDRESS=en_US.UTF-8                                                                                         
LC_TELEPHONE=en_US.UTF-8                                                                                       
LC_NAME=en_US.UTF-8                                                                                            
LC_MEASUREMENT=en_US.UTF-8                                                                                     
LC_IDENTIFICATION=en_US.UTF-8                                                                                  
LC_NUMERIC=en_US.UTF-8                                                                                         
LC_PAPER=en_US.UTF-8                                                                                           
LANG="C"	

-Conexión por SSH con mucho lag: Edita /etc/network/interfaces y añade al final:
wireless-power off

-Ponemos el governor a PERFORMANCE.

OPCIÓN 1 (RECOMENDADO): Lo más sencillo es añadir a la línea de comandos del kernel: cpufreq.default_governor=performance
Y si estás en la raspberry Pi (en Debian normal de X86 no hace falta), deshabilita el servicio raspi-config,
por si establece otro valor contradictorio.
OPCIÓN 2 (EN LA RASPBERRY PI Y NO RECOMENDADO): Edita /etc/init.d/raspi-config y en la línea de CPU_DEFAULT_GOVERNOR cambiar "ondemand" por "performance". Luego obviamente NO deshabilites el servicio "raspi-config.service" porque es el que aplica el governor.
EN AMBOS CASOS, PUEDES COMPROBARLO CON:
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor

-Crear el usuario pi:
sudo adduser pi
sudo adduser pi sudo
sudo adduser pi audio
sudo adduser pi video
(Esto último es importante, porque has estado dando vueltas y el kernel sí reconocía el audio interno y la hifiberry (cat /proc/asound/cards)
pero aplay -L no listaba los dispositivos...¡porque no estabas en el grupo audio!)

-DESINSTALAMOS loggers y cosas raras, que se llevan por delante servicios que no usamos:
apt-get purge triggerhappy rsyslog cron dphys-swapfile bluetooth avahi-* fake-hwclock
(NOTA: fake-hwclock no se usa porque en su lugar uso systemd-timesyncd que sincroniza la hora al conectarase a la red
 y guarda la hora en disco al reiniciar, con lo que fake-hwclock es redundante.)

-EN RASPBIAN: Deshabilitamos estos servicios:
systemctl mask e2scrub_all.timer
systemctl mask e2scrub_reap.service
systemctl mask man-db.service
systemctl mask man-db.timer
systemctl mask rc-local.service
systemctl mask rpcbind.service
systemctl mask rpcbind.socket
systemctl mask rpi-eeprom-update.service
systemctl mask run-rpc_pipefs.mount
systemctl mask sys-fs-fuse-connections.mount
systemctl mask sys-kernel-debug.mount
systemctl mask sys-kernel-tracing.mount
systemctl mask systemd-rfkill.service
systemctl mask systemd-rfkill.socket

-EN DEBIAN: Deshabilitamos estos servicios:
systemctl mask apparmor.service
systemctl mask e2scrub_all.service
systemctl mask e2scrub_all.timer
systemctl mask fstrim.timer
systemctl mask apt-daily.service
systemctl mask apt-daily.timer
systemctl mask apt-daily-upgrade.service
systemctl mask apt-daily-upgrade.timer
systemctl mask bluetooth.target
systemctl mask dpkg-db-backup.service
systemctl mask dpkg-db-backup.timer
systemctl mask sys-fs-fuse-connections.mount
systemctl mask logrotate.service
systemctl mask logrotate.timer
systemctl mask man-db.service
systemctl mask man-db.timer
systemctl mask sys-kernel-debug.mount
systemctl mask sys-kernel-tracing.mount
systemctl mask systemd-rfkill.service
systemctl mask systemd-rfkill.socket
systemctl mask systemd-update-utmp-runlevel.service
systemctl mask rc-local.service
systemctl mask remote-fs.target
systemctl mask swap.target
systemctl mask dev-sda3.swap  

(OJO: Servicios que NO DEBES DESHABILITAR:
	-NetworkManager, que se usa para conectarse a la Wifi usando raspi-config y que deja las redes conocidas
	 en /etc/NetworkManager/system-connections, en lugar de en /etc/wpa_supplicant/wpa_supplicant.conf
	-systemd-journald, que lo usaremos para ver los mensajes de inicio del kernel y los servicios con el comando "journalctl"
	-systemd-logind, que lo usaremos para que libseat sepa que estamos logueados sin tener que usar el servicio seatd
	 (seatd lo usaremos en sistemas embedidos sin systemd). Esto sirve para poder levantar Wayland compositors.
	-El servicio raspi-config.service, porque aplica los settings del governor de la CPU que configuramos en /etc/init.d/raspi-config
	-Los servicios que preparan o limpian las tmpfiles, aunque mandes todo eso a RAM
	-El servicio system-getty.slice, que sirve para gestionar los recursos de GETTY en las TTYs,
	aunque nos spawnee una getty por cada TTY del 1 al 6.
	Si lo deshabilitas, el autologin en la TTY funciona, pero el servicio no respawnea al hacer un logout escribiendo "exit".
	El truco es dejar system-getty.slice vivo, editar /etc/systemd/logind.conf y poner NAutoVTs a 1 o 2,
	dependiendo si quieres autologin en una TTY o en dos, o vamos, en las que vayas a usar concretamente.
	De ese modo nos funciona el autologin en las TTYs que queramos, y ademas funciona el respawn al escribir "exit".
)

-Para eliminar el error de "automount point not supported", simplemente haz:
sudo depmod -a
Y reinicia. Ya no debería salir más.

-Ponemos autologin en tty1 y tty2:
	-Creamos los ficheros: 
	/etc/systemd/system/getty@tty1.service.d/autologin.conf
	/etc/systemd/system/getty@tty2.service.d/autologin.conf
	-Metemos en ambos ficheros esto:
		[Service]
		ExecStart=
		ExecStart=-/sbin/agetty --autologin root --noclear --skip-login --nonewline %I $TERM
	-Activamos los servicios:
		systemctl enable getty@tty1.service
		systemctl enable getty@tty2.service	
	-Si queremos que la consola no se limpie al acabar el inicio del sistema o al hacer logout, creamos
	/etc/systemd/system/getty@tty1.service.d/noclean.conf
	con el contenido:
		[Service]
		TTYVTDisallocate=no

-Si después de hacer lo del autologin no puedes cambiar a TTY2 (ctrl+alt+f2), es porque no has activado el servicio. Haz:
sudo systemctl enable getty@tty2.service
Y ya podrás cambiar de TTY1 a TTY2!!!

-PARA ACTIVAR EL AUTOCOMPLETION COMO ROOT:
Editamos /etc/bash.bashrc y descomentamos la sección correspondiente (busca "completion" y lo ves enseguida).

***BLOQUE ALSA****
-PARA INSTALAR ALSA:
Instalamos alsa-utils, pero NO desde el entorno chrooted sino nativamente.
Si no tienes red en la Pi, puedes descargar los paquetes en el entorno chrooted, y luego instalarlos en nativo, o sea, en dos pasos, mira:
1) En el entorno chrooted:
sudo apt-get clean (para que no haya lios con otros paquetes en /var/cache/apt/archives)
sudo apt-get install --download-only alsa-utils
2) En el entorno nativo, es decir, en la Pi sin red:
cd /var/cache/apt/archives
sudo dpkg -i *
AHORA PASA A CREAR /etc/asound.conf, cuyo contenido varía si usas la HIFIBERRY o si no la usas:

-Si usas la hifiberry, acuérdate que en config.txt tienes que tener para que funcione:
dtoverlay=hifiberry-dacplus
Y la línea del audio interno comentada, para que el kernel sólo cargue la hifiberry:
#dtparam=audio=on

ESTO ES IMPORTANTE: Para que siempre se elija la hifiberry como tarjeta por defecto, crea este /etc/asound.conf:
pcm.!default {
    type hw
    card sndrpihifiberry
}

ctl.!default {
    type hw    
    card sndrpihifiberry
}

-Ahora ajusta los niveles en ALSAMIXER, que se van a quedar como los dejes porque vamos a quitar los servicios que los guardan y los restauran

-Y ahora quita los servicios que guardan y restauran los niveles de ALSA:
sudo systemctl mask alsa-state.service 
sudo systemctl mask alsa-restore.service

Y ya van a quedar así para siempre los niveles. Si los quieres cambiar, pues unmaskeas los servicios state y restore, los cambias, reinicias y los vuelves a maskear.

****FIN BLOQUE ALSA****

-Crear el /usr/bin/netup con:
sudo ifconfig eth0 up
sudo ip addr add 192.168.5.8/24 dev eth0
sudo ip route add default via 192.168.5.7
sudo systemctl start dropbear
(OJO: dropbear ya no arranca a mano con '/etc/init.d/dropbear start')

-Instalar dropbear, generar sus claves y quitarlo del arranque sin maskearlo, porque si no luego no arranca desde mi script netup.
(Esto además instala fuentes, setup de la consola y todo eso, que nos va a hacer falta)
apt-get install dropbear
dropbearkey -t rsa -f /etc/dropbear/dropbear_rsa_host_key
sudo systemctl disable dropbear
(CUIDADO QUE SIN LAS CLAVES NO FUNCIONA!!!)

-Configuramos la consola, el teclado y los locales (NO LO HAGAS POR SSH, o fallará por culpa de los LOCALE de la máquina
desde la que te conectas y perderás un buen rato):
sudo apt-get install locales console-setup console-data keyboard-configuration
sudo dpkg-reconfigure console-setup
sudo dpkg-reconfigure locales
(Elegimos que se generen en_US.UTF8 y es_ES.UTF, y dejamos puesto en_US.UTF8. ESTO nos quita errores de teclado a través de SSH,
ya que necesitamos los LOCALES de la máquina cliente también).
sudo dpkg-reconfigure keyboard-configuration
Tras reiniciar (sí, hay que reiniciar), ya tendría que ir la Ñ, los acentos y todo eso.

Otra manera más sencilla de evitar esos errores por SSH es editar /etc/ssh/sshd_config y comentar:
	# Allow client to pass locale environment variables
	# AcceptEnv LANG LC_*
Si lo haces así no necesitas regenerar es_ES.utf8, con en_US.utf8 vale.	

Si queremos cambiar la distribución del teclado de nuevo (porque cambiamos de sistema y/o teclado) basta con volver a hacer:
sudo dpkg-reconfigure keyboard-configuration
Eso sí, asegúrate antes de que el comando "locale" nos dice que está todo a en_US.UTF-8.

-Vamos quitando los servicios con:
sudo systemctl mask <sevcio>

-Para que funcione el teclado, ratón y joystick con las SDL2, creamos /etc/udev/rules.d/99-evdev.rules con el contenido:
KERNEL=="event*", NAME="input/%k", MODE="666"
Y reiniciamos.

-SI QUITAS systemd-journald (NO RECOMENDADO)
---Para quitar el error de DMESG: "Failed to connect stdout to the journal socket"
Edita /etc/systemd/system.conf y pon LogTarget=null.
---Para quitar el error: "Failed to listen on journal socket"
Mira a ver qué sockets están activos con:
systemctl | grep socket
...Y le haces un "systemctl mask" a los que queden.
También hazle "systemctl mask" a sockets.target.
Algunos ejemplos:
systemctl mask systemd-journald.socket
systemctl mask systemd-journald-dev-log.socket
systemctl mask systemd-rfkill.socket

-Para ocultar los mensajes de systemd en el inicio, pon en cmdline.txt:
systemd.show_status=false

-Para evitar errores en el inicio relacionados con systemd-journald-audit.socket (que nosotros NO tenemos), pon en cmdline.txt:
audit=0

-Para evitar parones (stalls) en el vídeo de los juegos debido al i/o scheduler, pon en cmdline.txt:
elevator=noop

-En .bashrc, descomenta para tener el prompt en color:
force_color_prompt=yes

-El mensaje que quieras que se vea en el inicio, ponlo en /etc/issue

-PARA USUARIOS NORMALES SOLAMENTE:
TENEMOS QUE QUITAR LOS RLIMITS, o los emuladores se empezarán a quejar al llegar al 80% de uso de la CPU!
Para ello, editamos /etc/security/limits.conf, añadiendo unas cosillas para quitar ciertas limitaciones a los miembros de ese grupo:

@audio   -  rtprio     99
@audio   -  memlock    unlimited
@audio   -  nice    -20
pi   -  rtprio     99
pi   -  memlock    unlimited
pi   -  nice       -20

De este modo, no hay límites para el usuario Pi ni para nadie del grupo audio, como jackd.
Comprobamos que tenemos quitados esos límites con:
ulimit -r -l
Nos tiene que salir algo como:
real-time priority (-r) 99
max locked memory (kbytes, -l) unlimited
¡¡¡CUIDADO!!!! COMPRUEBA ESTO EN LOCAL Y NO POR SSH, porque POR SSH PUEDE NO FUNCIONAR Y SÍ EN LOCAL.

-Para configurar el audio con el driver de audio HDMI del lado de ARM (que es como lo venimos haciendo ahora):
	PREVIO: En el momento en que usamos el sistema KMS (dtoverlay=vc4-kms-v3d) obtenemos el dispositivo ALSA de audio llamado vc4hdmi,
	que mete los frames de audio en los periodos de blanking del vídeo.
	Al usar KMS, el kernel se encarga del vídeo y de meter esos frames de audio en el blanking de vídeo, así que el audio del lado del
	firmware (es decir, el audio bcm2835) NO PUEDE FUNCIONAR CON KMS.

	-Para usar el vídeo KMS, tenemos que tener en config.txt:
		dtoverlay=vc4-kms-v3d
		#dtparam=audio=on <---SE DEBE deshabilitar la carga de bcm2835.
		(Si quisiéramos desactivar el dispositivo de audio vc4hdmi a la vez que usamos KMS, usaríamos esto: dtoverlay=vc4-kms-v3d,noaudio
		 PERO OLVÍDATE de tener KMS y a la vez audio del lado del firmware (bmc2835) cargando manualmente el módulo snd_bcm2835
		 o si usamos el init por defecto descomentando la línea "dtparam=audio=on", PORQUE combinar KMS con el audio bcm2835
		 es imposible como ya se ha dicho: SI USAMOS KMS, NO PODEMOS USAR EL AUDIO BMC2835, SÓLO EL AUDIO VC4HDMI.)
	 RECUERDA que ninguno de los parámetros hdmi_* de config.txt funciona en modo KMS! El modo de vídeo, por ejemplo,
	 se establecería añadiendo a cmdline.txt algo como:
	 video="HDMI-A-1:1280x720@60"
	-Si falla speakertest, mira que tengas en /usr/share/alsa/cards/vc4-hdmi.conf la última versión que siempre está disponible
	 en: https://github.com/alsa-project/alsa-lib/blob/master/src/conf/cards/vc4-hdmi.conf
	-Si falla algo, pregunta a dom en el foro de Raspberry Pi.
     Y YA. CON ESTO TIENE QUE FUNCIONAR SÍ O SÍ. 

-Si el guardado y restauración de los valores de alsamixer falla a veces, tienes DOS opciones:

	1) LA MÁS RECOMENDABLE AHORA MISMO, Y LA QUE MÁS CONTROL TE DA: Modificar el servicio alsa-restore.service.
	   No está roto el servicio en sí, sino que cuando es lanzado, el mezclador aún no está accesible porque el driver está mal y hasta que un 
	   programa no reproduce audio, no aparece disponible el mezclador (lo puedes comprobar porque alsamixer no muestra controles hasta que
	   un programa ha reproducido algo).
	   Para "parchear" el problema, edita así el servicio de manera que no se sobreescriban los cambios en las acltualizaciones:
	
	   sudo systemctl edit --full alsa-restore.service

	   Y lo dejas con este contenido (o sea, pasas de usar "alsactc restore" y lo que haces es reproducir un sonido y a continuación
	   restauras el volúmen que te de la gana):
	   
[Unit]
Description=Restore volume

[Service]
Type=oneshot
RemainAfterExit=false
ExecStartPre=-/usr/bin/aplay /dev/zero -s 1 -q
ExecStart=-/usr/bin/amixer set PCM 230 -q
       
       El valor 230 NO se corresponde linealmente con un volúmen de 0 a 100, es 80%. Ya sabes, las cosas del audio.

       CADA VEZ que quieras ajustar el volúmen guardado, te toca hacer: sudo systemctl edit --full alsa-restore.service
       Pero vamos, que lo controlas tú todo a tu gusto.
       Puedes crearte un script en /usr/local/bin/volume con el contenido:
       sudo systemctl edit --full alsa-restore.service

	2) (Actualmente no válido porque falla "alsactl restore"). Deshabilitar el servicio alsa-restore.service (sudo systemctl mask alsa-restore.service), pon los controles a tu gusto en alsamixer, y guarda la configuración con:
		alsactl store -f /etc/asound.state
		Prueba a cargar la configuración con:
		sudo alsactl restore -f /etc/asound.state
		Si todo va bien, ALSA va a restaurar esos valores en cada arranque, leyéndolos de /etc/asound.state, sin que hagas nada y sin ningún servicio.
		Si quieres, puedes aniadir lo de alsactl restore al .profile		

	-CÓMO USAR LA HIFIBERRY: Se supone que funciona siempre porque aunque el ordering de las tarjetas puede cambiar entre arranques,
		estamos espeficicando la tarjeta por defecto en /etc/asound.conf con el contenido:
	    	pcm.!default {
    			type hw
    			card sndrpihifiberry
			}
			
			ctl.!default {
    			type hw    
    			card sndrpihifiberry
			}					
		Deshabilita el servicio alsa-restore.service, y pon en .profile:
		amixer set Digital 85% -q
		Esto lo que hace es que te pone el control llamado Digital a 55 (no a 85 como podría parecer).
		Puedes ver los controles con "amixer scontrols".
		Vamos, que esto lo que hace es que pongas a mano el valor que quieras para cada control de la tarjeta por defecto
		(también se puede elegir tarjeta y tal, mira "man amixer" si ves que te hace falta).

	-EXPERIMENTAL, NO FUNCIONA: Sería la más recomemdada: soluciona los problemas de ordering, porque tienes dos tarjetas. Para ello, crea /etc/modprobe.d/alsa-base.conf con:
		options snd_soc_hifiberry_dacplus index=0
		options vc4 index=1
	 De esta manera, el servicio de restauración de ALSA (alsa-restore.service) no debería fallar nunca, porque la primera tarjeta es siempre la hifiberry y aplicaría los
	 valores guardados correctos para cada tarjeta en el arranque, ya que el ordering de las tarjetas no cambiaría nunca.
            
Recuerda mirar las mierdas que lanza systemd en el arranque antes de ocultarlo, y mira los targets con
sudo systemctl | grep <loquesea>
Luego los vas quitando, al igual que los services, con systemctl mask <monbre service o target>
Si metes la pata y el sistema no arranca más, elimina cosas de /etc/systemd/system, que es donde pone los links a /dev/null correspondientes a los services o targets que hayas eliminado
sin deber hacerlo...

-Para conectarte automaticamente a una WIFI, lo mejor es tener activado el servicio NetworkManager y meter la red/contraseña en raspi-config,
en la seccion system->wireless lan.
Las redes conocidas quedan guardadas en /etc/NetworkManager/system-connections, en lugar de en /etc/wpa_supplicant/wpa_supplicant.conf

-Si PING te da el error "ping: socket: Address family not supported by protocol", simplemente haz:
sudo chmod 4755 /bin/ping
Y ya te irá perfectamente.

Teclado en español y con la tilde (~) en la Ñ sin tener que darle dos veces
===========================================================================

Editamos /etc/default/keyboard, y lo dejamos así:

XKBMODEL="pc105"                                                                                               
XKBLAYOUT="es"                                                                                                 
XKBVARIANT="deadtilde"                                                                                        
XKBOPTIONS=""                                                                                                  
BACKSPACE="guess"

Sin lo de "deadtilde", tenemos que darle a la Ñ dos veces para sacar la tilde, y es una mierda eso.

ACTUALIZAR EL KERNEL SIN COMPLICARNOS NADA
==========================================

Usamos el kernel XenMod. Las instrucciones proceden de aquí: https://xanmod.org/
Y son para Debian 12 Bookworm. Para nuevas versiones de Debian, habrá que actualizarlas.

-Instalamos dependencias previas: apt-get install gpg
-Nos bajamos la clave pública del repo:
wget -qO - https://dl.xanmod.org/archive.key | sudo gpg --dearmor -vo /usr/share/keyrings/xanmod-archive-keyring.gpg
-Añadimos el repo a nuestros sources de APT:
echo 'deb [signed-by=/usr/share/keyrings/xanmod-archive-keyring.gpg] http://deb.xanmod.org releases main' | sudo tee /etc/apt/sources.list.d/xanmod-release.list
-Actualizamos e instalamos el nuevo kernel:
sudo apt update && sudo apt install linux-xanmod-x64v3

ACTUALIZAR RASPBERRY PI OS SIN ACTUALIZAR EL KERNEL
===================================================

Útil para cuando tenemos un kernel especial instalado, como por ejemplo el kernel realtime de: https://github.com/kdoren/linux/releases/

Se hace poniendo el paquete raspberrypi-kernel en "hold", tal que así:

-Actualizamos el índice de paquetes como siempre:
sudo apt-get update

-Ponemos el paquete del kernel en hold:
sudo apt-mark hold raspberrypi-kernel

-Actualizamos los paquetes normalmente. Como el paquete del kernel está en holdo, no se actualizará:
sudo apt-get upgrade

Opcionalmente, si quieres, puedes quitar el hold del paquete del kernel al acabar, haciendo:
sudo apt-mark unhold raspberrypi-kernel

GUARDAR TODOS LOS LOGS EN RAM
=============================

Lo primero es desisntalar rsyslog
apt-get purge rsyslog
(RECUERDA: con systemd-journald nos vale para que nos guarde los logs de sistema,
puedes usar el comando "journalctl" sin mas para ver los mensajes de inicio/parada del kernely los servicios).

Ahora borra los logs de disco:

rm -R /tmp/* 
rm -R /var/tmp/*
rm -R /var/log/*
rm -R /var/spool/* 

Ahora, añade estas lineas a /etc/fstab:

# Added 4 lines to use RAM instead of SSD for temp and log files
tmpfs /tmp tmpfs defaults,noatime,mode=1777 0 0
tmpfs /var/tmp tmpfs defaults,noatime,mode=1777 0 0
tmpfs /var/log tmpfs defaults,noatime,mode=0755 0 0
tmpfs /var/spool tmpfs defaults,noatime,mode=1777 0 0

¡¡¡CUIDADO!!! NUNCA mandes /var a RAM, porque ahi guardan apt-get y otros programas importantes sus datos.
SOLO puedes mandar a RAM esos subdirectorios de /var que te he dicho.
Y NUNCA borres el contenido de /var, solo el contenido de esos subdirectorios que te he dicho.

SACAR EL VÍDEO Y EL AUDIO SÓLO POR HDMI-0 O SÓLO POR HDMI-1
===========================================================

dtoverlay=vc4-kms-v3d,nohdmi0

o bien

dtoverlay=vc4-kms-v3d,nohdmi1

INSTALAR MESA
=============

NOCIONES PREVIAS DE APIS, DEPENDENCIAS, Y SOPORTE DE OPENGL COMPLETO (NO GLES)

Para tener OpenGL "completo" (no GLES), Mesa se puede compilar con GLX (lo que conlleva un cojón de dependencias de X11 y es un asco), o con GLVND (libglvnd, una librería muy ligera de NVIDIA que es libre).
Compilar MESA con OpenGL completo para GLX nos produce libGL.so, y compilar MESA con OpenGL completo para GLVND nos produce libOpenGL.so  

Si compilas con OpenGL completo mediante GLVND, las SDL2 deberían ya detectar y usar libOpenGL.so en vez de libGL.so, y los programas de SDL2
que usen OpenGL completo funcionarán.
Aún así, si algún programa intenta linkar con -lGL, no lo va a encontrar, así que cambia -lGL por -lOpenGL y ya linkará sin problemas.
Si algún programa linka contra -lGLU, elimínalo y ya. No se necesita nada de ahí.

Si MESA te da un error de que no encuentra GL/glxproto.h, reinstala el paquete x11proto-dev

FIN NOCIONES PREVIAS

¡¡¡OJO!!! LO PRIMERO EN LA PI4, AÑADE AL USUARIO "pi" AL GRUPO RENDER, O TE VOLVERÁS LOCO PORQUE GLES NO IRÁ PERO DRM SÍ (o sea, modetest funciona pero MESA no puede cargar GLES). PARA ELLO, HAZ:
sudo usermod -a -G render pi

Empezamos con libDRM:

Elimimanos el libDRM del sistema, que es viejo siempre:
apt-get purge libdrm*
Instalamos estas dependencias previas:

sudo apt-get install meson xsltproc libpciaccess-dev xutils-dev libtool make cmake automake pkg-config \
gcc g++ python3-setuptools xz-utils --no-install-recommends

(libgbm NO TENEMOS QUE INSTALARLO ni nada, se compila e instala con MESA automáticamente)
Bajamos la última versión estable de:
https://dri.freedesktop.org/libdrm/
mkdir b4
cd b4

CONFIGURAMOS DRM con esto:

PARA X86_64 CON GPU INTEL XE:

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson setup -Dudev=true -Dvc4=disabled -Dintel=enabled -Dvmwgfx=disabled -Dradeon=disabled -Damdgpu=disabled -Dnouveau=disabled \
-Dfreedreno=disabled -Detnaviv=disabled \
-Dinstall-test-programs=true ..

PARA RASPBERRY PI 4/5:

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson setup -Dudev=true -Dvc4=enabled -Dintel=disabled -Dvmwgfx=disabled -Dradeon=disabled -Damdgpu=disabled -Dnouveau=disabled \
-Dfreedreno=disabled -Detnaviv=disabled \
-Dinstall-test-programs=true ..

Compilamos e instalamos:
ninja -j4
sudo ninja install

En este punto, puedes probar si libdrm te funciona bien haciendo:
modetest -s 32:1280x720
(donde 32 es un ID de conector válido: puedes ver los conectores con "modetest|grep connected").
O bien, en X86_64, usa: modetest -s 236:1280x720

¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡ATENCIÓN, ATENCIÓN!!!!!!!!!!!!!!!!!!!!!!!!!!!
SI ESTÁS EN X86_64:
1) Como NINJA/MESON instala las librerías en /usr/local/lib64, y como CMAKE y PKG-CONFIG no buscan
en /usr/local/lib64 por defecto (sólo en /usr/local/lib), creamos el fichero /etc/profile.d/custom.sh con el contenido:
export CMAKE_LIBRARY_PATH=/usr/local/lib64
export PKG_CONFIG_PATH=/usr/local/lib64/pkgconfig
ESTO ES MUY MUY MUY MUY IMPORTANTE HACERLO SIEMPRE. 
2) Añade al final de /etc/ld.so.conf.d/libc.conf la línea:
/usr/local/lib64

CUIDADO: LA ALTERNATIVA A ESTAS DOS COSAS SERÍA, ANTES DE EMPEZAR A INSTALAR NINGUNA LIBRERÍA COMPILADA POR MI,
CREAR /usr/local/lib64 COMO UN SYMLINK DE /usr/local/lib, PERO NO ES BUENA IDEA: ES UN HACK QUE PODRÍA DAR PROBLEMAS.
ASÍ QUE HAZ LAS DOS COSAS QUE ACABO DE DECIRTE.

(NOTA: Todo este lio viene porque MESON instala las cosas en /usr/local/lib64, que se supone que es el sitio correcto,
 y CMAKE las instala en /usr/local/lib.
 Queda pendienden entender por qué, o si esto cambia en futuras versiones de Debian, o qué pasa).

¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡

DEPENDENCIAS PREVIAS DE MESA:

SI QUIERES GLES Y GLES2 NECESITAS ESTAS DEPENDENCIAS:
apt-get install --no-install-recommends \
    flex bison python3-mako python3-setuptools \
    libexpat1-dev libudev-dev gettext \
    ca-certificates xz-utils \
    zlib1g-dev pkg-config

#####
DEPENDENCIAS EXCLUSIVAS PARA INTEL GALLIUM IRIS (los números de versión son para Debian 12, pueden cambian en Debian 13 y posteriores):

PARA DEBIAN 13:
apt-get install python3-ply libclang-common-17-dev libllvmspirvlib-17-dev llvm-17-dev libclang-cpp17-dev libclang-17-dev libclc-17 libclc-17-dev

SI AÚN ESTÁS EN DEBIAN 12:
apt-get install python3-ply libclang-common-15-dev libllvmspirvlib-15-dev llvm-15-dev libclang-cpp15-dev libclang-15-dev libclc-15 libclc-15-dev

¡¡¡OJO!!! ES MUY IMPORTANTE QUE COINCIDA EL NÚMERO DE VERSIÓN DE TODO. SI NO, NO COMPILARÁ Y LOS ERRORES SERÁN IMPOSIBLES DE ENTENDER.
#####

SI ADEMÁS QUIERES VULKAN NECESITAS ESTAS DEPENDENCIAS:
apt-get install libvulkan-dev libvulkan1 vulkan-tools glslang-tools --no-install-recommends

SI ADEMÁS QUIERES OPENGL COMPLETO SOBRE LIBGLVND, TIENES QUE INSTALAR LIBGLVND:
Bajamos la última estable de aquí:
https://gitlab.freedesktop.org/glvnd/libglvnd/-/tags
Y configuramos con:
CFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Dglx=disabled -Dx11=disabled ..

SI QUIERES QUE MESA FUNCIONE SOBRE WAYLAND, VE E INSTALA WAYLAND AHORA (Mira en el fichero de notas de Wayland).

NO TE OLVIDES DE AÑADIR AL USUARIO AL GRUPO RENDER:
sudo adduser pi render
(Si ves un error como "MESA-LOADER: failed to open kms_swrast", es porque no lo has hecho).

SATISFECHAS SUS DEPENDENCIAS, PASAMOS A LA COMPILACIÓN DE MESA COMO TAL:

Bajamos los últimos estables de:
https://mesa.freedesktop.org/archive/

Editamos src/broadcom/vulkan/v3dv_device.c y buscamos "destroy dumb object" y comentamos el fprintf() que lo contiene.

CONFIGURAMOS COMO LO VENIMOS HACIENDO AHORA, CON GLES, GLES2, OPENGL COMPLETO MEDIANTE GLVND Y VULKAN:

PARA X86_64 CON GRÁFICOS INTEL IRIS (=UHD,XE, etc):
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson setup -Dbuildtype=release -Dglx=disabled -Dplatforms=wayland \
-Dvulkan-drivers=intel -Dgallium-drivers=iris,kmsro,zink -Dglvnd=enabled ..

PARA PI4/5:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson setup -Dbuildtype=release -Dglx=disabled -Dplatforms=wayland -Dllvm=disabled \
-Dvulkan-drivers=broadcom -Dgallium-drivers=v3d,vc4,kmsro,zink -Dglvnd=enable ..

(Si no quieres soporte para Wayland, usa -Dplatforms='')

SI QUISIERAS GLES, GLES2 Y OPENGL COMPLETO MEDIANTE GLVND:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson -Dglx=disabled -Dglvnd=true -Dplatforms=wayland -Dllvm=disabled -Dvulkan-drivers='' -Ddri-drivers='' -Dgallium-drivers=vc4,v3d,kmsro -Dbuildtype=release ..

SI QUISIERAS SÓLO GLES Y GLES2, SIN OPENGL COMPLETO:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson -Dglx=disabled -Dplatforms=wayland -Dllvm=disabled -Dvulkan-drivers='' -Ddri-drivers='' -Dgallium-drivers=vc4,v3d,kmsro -Dbuildtype=release ..

COPIAR ARCHIVOS DESDE UN SISTEMA ANTIGUO
=========================================

Lo puedes hacer con rsync -av <origen> <destino>
Ambos sistemos deben tener instalado rsync, y se puede usar por red como scp.

INSTALAR SDL2
=============

Instalamos dependencias previas:

apt-get install libudev-dev libasound2-dev libvorbis-dev libflac-dev libmpg123-dev libmodplug-dev \
libpng-dev libjpeg-dev libfreetype6-dev --no-install-recommends

Añadimos "export SDL_VIDEO_DOUBLE_BUFFER=1" en /etc/profile.d/custom.sh

Bajamos la última versión estable de:
https://github.com/libsdl-org/SDL/releases

Ahora, para configurar:

CON GLES, GLES2, OPENGL COMPLETO y VULKAN, COMO LO HACEMOS AHORA:

CFLAGS="-march=native -mtune=native -O2 -DEGL_NO_X11" \
CXXFLAGS="-march=native -mtune=native -O2 -DEGL_NO_X11" \
./configure --enable-video-kmsdrm --disable-video-x11 --disable-dbus --disable-diskaudio --disable-oss --disable-pulseaudio --disable-video-rpi --disable-dummyaudio --disable-video-dummy --enable-video-offscreen --enable-video-opengles --enable-video-opengl --enable-video-vulkan --enable-libudev --disable-esd --disable-ime --disable-fcitx --disable-libsamplerate

CON GLES, GLES2, OPENGL COMPLETO y VULKAN, COMO LO HACEMOS AHORA, PERO EN MODO DEBUG:

CFLAGS="-O0 -ggdb -DEGL_NO_X11" \
CXXFLAGS=" -O0 -ggdb -DEGL_NO_X11" \
./configure --enable-video-kmsdrm --disable-video-x11 --disable-dbus --disable-diskaudio --disable-oss --disable-pulseaudio --disable-video-rpi --disable-dummyaudio --disable-video-dummy --enable-video-opengles --enable-video-opengl --enable-video-vulkan --enable-libudev --disable-esd --disable-ime --disable-fcitx --disable-libsamplerate

(LO DE -DMESA_EGL_NO_X11_HEADERS LO HEMOS SACADO DE /usr/lib/pkgconfig/egl.pc. Como el viejo buildsystem de las SDL2 basado en configure y make no usa pkgconfig para saber qué flags tiene que pasar cuando
se compile eglplatform.h, parte de EGL de MESA, que es donde  MESA_EGL_NO_X11_HEADERS evita intentar incluir las headers de X11, pues se lo tenemos que pasar nosotros a mano. El buildsystem de las SDL2 basado en CMAKE sí
pasa correctamente el  -DMESA_EGL_NO_X11_HEADERS de /usr/lib/pkgconfig/egl.pc, porque usa pkconfig para saber qué flags tiene que pasar cuando compila los headers de EGL).

TEMPORAL (SIN PROBAR DEL TODO) CON CMAKE POR SI UN DÍA HAY QUE CAMBIAR AL CMAKE (ESPEREMOS QUE NO!):
cmake -DCMAKE_INSTALL_PREFIX=/usr -DCMAKE_BUILD_TYPE=Release -DASSERTIONS=disabled -DVIDEO_DUMMY=OFF -DVIDEO_VULKAN=OFF -DDISKAUDIO=OFF -DDUMMYAUDIO=OFF -DOSS=OFF ..

Compilar e instalar.

No te olvides de añadir en /etc/profile:
export SDL_VIDEO_DOUBLE_BUFFER=1
Luego puedes comprobarlo con echo $<nombre_variable>, en plan:
echo $SDL_VIDEO_DOUBLE_BUFFER

Si te da un error "No available video device", y cumplas estos requisitos:
tienes libdrm instalada en /usr/local/lib/<nombre_arquitectura>/,
tienes libgbm que es instalada por MESA también en /usr/local/lib/<nombre_arquitectura>/,
tienes al usuario pi añadido al grupo "render",
...pues regenera la caché de LDD, como siempre que una librería está en un sitio, la estás viendo, pero LD no la ve:
sudo rm /etc/ld.so.cache
sudo ldconfig

Y si tienes un mando que no es detectado por las SDL2 como gamecontroller (lo sabrás porque no funciona con el Prince...),
saca su cadena de mapping de la SDL2 Gamepad Tool (http://www.generalarcade.com/gamepadtool),
y la añades en /etc/profile usando la variable de entorno SDL_GAMECONTROLLERCONFIG, tal que así:
SDL_GAMECONTROLLERCONFIG="030000009b2800000800000001010000,raphnet.net Dreamcast to USB,a:b10,b:b9,x:b2,y:b1,back:b0,guide:b3,start:b8,dpup:b4,dpdown:b5,dpleft:b6,dpright:b7,platform:Linux,"

Para SDL2_Mixer:
-Instalar antes estas dependencias: apt-get install libmpg123-dev libogg-dev libflac-dev libmodplug-dev libxmp-dev
-Instalar antes fluidsynth (tienes instrucciones en LINUX_KNOWLEDGE para instalarlas manualmente sin depender de X11)
-Nos bajamos la última versión estable de: https://github.com/libsdl-org/SDL_mixer/releases 
-Configuramos con:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure --disable-music-midi-timidity --enable-music-midi-fluidsynth

Para SDL2_Image:
-Dependencias previas: apt-get install libwebp-dev
-Nos bajamos la última versión estable de: https://github.com/libsdl-org/SDL_image/releases 
-Configuramos con:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure

Para SDL2_ttf:
-Nos bajamos la última versión estable de: https://github.com/libsdl-org/SDL_ttf/releases
-Configuramos con:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure --without-x --disable-freetype-builtin --disable-harfbuzz

Para SDL2_net:
-Nos bajamos la última versión estable de: https://github.com/libsdl-org/SDL_net/releases 
-Configuramos con:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure

INSTALAR RETROARCH
===================

Instalamos dependencias previas:
apt-get install libasound-dev glslang-dev glslang-tools spirv-tools

SI ESTÁS EN RASPBERRY PI, LO PRIMERO HAZ ESTO O EL CONFIGURE FALLARÁ:
apt-get purge libraspberrypi*

INNECESARIO (ya que usamos el driver "GLCORE"): Si queremos que el driver "GL" use OpenGL de escritorio en lugar de GLES,
editamos qb/config.libs.sh, y cambiamos "-lGL" por "-lOpenGL".
(Esto es para que el driver GL use OpenGL en lugar de GLES2, cosa que es necesaria para que HARD SYNC funcione con el driver GL,
 ya que si te fijas en Makefile.common y en gfx/drivers/gl2.c, resulta que HAVE_GL_SYNC sólo se activa si NO usamos GLES,
 así que si queremos que la opción del backen OPENGL llamada "Hard GPU Sync" haga lo que se supone que hace, tenemos que usar OpenGL y no GLES.
 "Hard GPU Sync" equivale a max_swapchain puesto a 2: recuerda que no puedes configurar el max_swapchain si usas el backend OpenGL en Wayland,
 en Wayland sólo puedes configurar max_swapchain si usas el backend Vulkan).
TODO ESTO INNECESARIO porque el driver GLCORE va sobre GL3 o GLES3 y ya soporta HARD SYNC directamente.

Ahora, para configurar RetroArch con soporte de OPENGL y VULKAN, como lo venimos haciendo:

CFLAGS="-march=native -mtune=native -O2 -DEGL_NO_X11" \
CXXFLAGS="-march=native -mtune=native -O2 -DEGL_NO_X11" \
./configure --disable-ibxm --disable-vg --disable-x11 --disable-sdl2 --disable-al --disable-cheevos --disable-ffmpeg \
--disable-netplaydiscovery --enable-udev --disable-sdl --disable-pulse --disable-oss \
--disable-freetype --disable-7zip --disable-imageviewer --disable-rjpeg --disable-rbmp --disable-rtga --disable-flac \
--disable-qt --disable-materialui --disable-xmb --enable-rgui --enable-ozone --disable-gfx_widgets --disable-langextra --disable-discord \
--disable-cdrom --disable-accessibility --disable-tinyalsa --disable-rpiled --disable-v4l2 \
--enable-egl --enable-opengles --enable-opengles3 --enable-vulkan

(NO le pases --enable-neon ni --enable-floathard, o fallará el configure porque dlopen() no va bien)
(NO le pases --disable-builtinglslang, porque entonces fallará la compilación de shaders al cargar un segundo juego sin salir de RetroArch)

(Si quisieras OpenGL de escritorio, en lugar de "--enable-opengles --enable-opengles3" pásale "--enable-opengl",
y además edita qb/config.libs.sh y cambia -lGL por -lOpenGL, sólo hay una ocurrencia que cambiar,
pero NO es necesario porque el driver GLCORE (GL3, GLES3) soporta HARD SYNC,
no necesitas usar el driver GL (GLES2, GL2) que sólo soporta HARD SYNC con OpenGL de escritorio y no con GLES2).

(NO le pasamos "--disable-networking" ni "--disable-libretrodb" porque si lo hacemos no tendremos el "Online Updater"
que es lo que nos permite que se descarguen automáticamente los thumbnails para las playlist. Hacerlo a mano es horroroso.)

PARA COMPILAR CUALQUIER CORE:

CFLAGS="-march=native -mtune=native -fomit-frame-pointer -DALIGN_LONG" \
CXXFLAGS="-march=native -mtune=native -fomit-frame-pointer -DALIGN_LONG" make -j4

		Configuración óptima de RetroArch (En Wayland)

VIDEO: Driver VULKAN, con VIDEO->SYNCHRONIZATION->VSYNC SWAP INTERVAL en AUTO, porque si lo tienes a 1
es cuando el vsync rate sale a la mitad (es decir, te detecta 30Hz en pantallas a 60Hz),
y con VIDEO->SYNCHRONIZATION->MAX SWAPCHAIN IMAGES a 2.
ALTERNATIVA: Driver GLCORE (necesario para que funcione HARD SYNC), VSYNC ON, HARD SYNC ON, HARD SYNC FRAMES 0
AUDIO: driver ALSATHREAD, 44100 Hz, 36ms, resampler quality normal
(Si usas otra frecuencia de audio, modifícalo también en las opciones del core FBNeo)

SHADER: usamos FAKELOTTES, que tiene una mask increíble.

LATENCY: RunAhead con 1 frame y "second instance" activado.

Si no quieres shimmering en las letras del RGUI, tienes que irte a SETTINGS->USER INTERFACE->APPEARANCE
y activar LINEAR FILTERING.

Si quieres que aparezcan las opciones de SAVE/LOAD STATE, tienes dos opciones:
-Activar la opción settings->core->"bypass core info save states"
-O bien instalar los core info files, que se hace así:
	--Clonamos el repo: git clone --depth 1 https://github.com/libretro/libretro-core-info.git
	--Copiamos los .info a ~/.config/retroarch/cores, junto con los cores (suponiendo que tengamos ese directorio puesto
	  como path para los core info, es la ruta por defecto).

Si quieres que te salgan iconos en el menú OZONE o XMB, en lugar de cuadrados negros,
necesitas los assets de aquí: git clone --depth 1 https://github.com/libretro/retroarch-assets.git
Copia los directorios "ozone", "fonts" y "xmb" (aunque no vayas a usar el XMB, cópialo o te faltarán cosas) a ~/.config/retroarch/assets/ 

Si quieres que RetroArch te ofrezca con qué emulador quieres correr una ROM, tienes que clonar este repo:
git clone --depth 1 https://github.com/libretro/libretro-super.git
Creamos el directorio ~/.config/retroarch/info
Copiamos el contenido del directorio libretro-super/dist/info a ~/.config/retroarch/info
cp -R libretro-super/dist/info/* ~/.config/retroarch/info/
Editamos ~/.config/retroarch/retroarch.cfg, y ponemos la variable "libretro_info_path" asi:
libretro_info_path = "~/.config/retroarch/info"
Por ultimo: Eliminamos el archivo "core_info.cache" (busca en todo .config/retroach) para que se recree el nuevo, o no funciona.
Ahora en RetroArch, en Settings->User Interface->File Browser, desactiva todo y activa "Filter Unknows Extensions"

Para añadir juegos de CONSOLA a una PLAYLIST:
-Las ROMs deben estar en un directorio cuyo nombre coincida con el nombre del sistema en no-intro.
 Puedes sacar los nombres correctos de los directorios de https://github.com/libretro/libretro-database
-Los nombres de las ROMs deben coincidir con los nombres de las ROMs de no-intro, o no se identificarán correctamente al construir la playlist,
y luego no se encontrarán los thumbnails para ellas desde el Online Updater.
-Clonamos este repo: git clone --depth 1 https://github.com/libretro/libretro-database
y metemos el contenido del directorio "rdb" en ~/.config/retroarch/databases/rdb/
-Vamos a IMPORT CONTENT->MANUAL SCAN y ahí:
 -En CONTENT DIRECTORY, seleccionamos el directorio que queremos escanear
 -En SYSTEM NAME elegimos "Content Directory"
 -En DEFAULT CORE elegimos el core que queramos usar para esa playlist.
 ...Y una vez que lo tenemos todo le damos a START SCAN abajo del todo y esperamos.

Para añadir juegos ARCADE a una PLAYLIST, lo vamos a ver con los juegos arcade de FBNeo como ejemplo.
Vamos a IMPORT CONTENT->MANUAL SCAN y ahí:
-En CONTENT DIRECTORY, seleccionamos el directorio que queremos escanear
-En SYSTEM NAME elegimos "FBNeo - Arcade Games"
-En DEFAULT CORE elegimos "Arcade (Final Burn Neo)"
-En ARCADE DAT FILE elegimos la última versión del fichero "Final Burn Neo (ClrMame Pro XML, Arcade only)" que nos podemos bajar de:
https://github.com/libretro/FBNeo/tree/master/dats
(Yo suelo meter el DAT en /storage/roms/Downloads)
...Y una vez que lo tenemos todo le damos a START SCAN abajo del todo y esperamos.
Esto tenemos que hacerlo contra ROMs descargadas de https://www.retroroms.info, yéndonos a "FBNeo" y luego a "currentroms",
ya que son las más actuales y se supone que son contra las que se ha creado el DAT.

Para tener carátulas (thumbnails) debes hacer que RetroArch añada los juegos a una PLAYLIST (lo acabo de explicar),
y luego desde dentro de RetroArch, vamos a Main Menu->Online Updater->Playlist Thumbnail Updater para que se descarguen solas
las carátulas de la playlist que queramos.
(Hacer esto depende de que tengamos las funcionalidades de "networking" y "libretrodb" compiladas en RetroArch:
Libretrodb para que se hagan correctamente las playlists identificándose los juegos, y networking para tener el Online Updater).

Si quieres configurar un tema del XMB o del RGUI, tienes que irte a SETTINGS->USER INTERFACE->APPEARANCE.
En RGUI, para que se ponga el tema que elijas con CUSTOM THEME PRESET, tienes que poner MENU COLOR THEME en CUSTOM.
En XMB, puedes desactivas el lazo de fondo en SETTINGS->USER INTERFACE->APPEARANCE si quieres.
Para XMB, un buen tema es el Systematic ("SETTINGS->USER INTERFACE->APPEARANCE->MENU ICON THEME")

PARA CUALQUIER PROBLEMA de librerías no encontradas pero que sí están instaladas, RECUERDA REGENERAR LA CACHE DE LDD:
sudo rm /etc/ld.so.cache
sudo ldconfig

Si quieres filtros por software, entra en gfx/video_filters y haz make, y copias los .so y los .filt a ~/.config/retroarch/filters/video/
y luego los seleccionas en retroarch.

KERNEL CACHYOS Y SCHEDULER LAVD EN DEBIAN (NO APORTA NADA, ES PARA TENER MÁS FPS MIENTRAS COMPILAS O ALGO ASÍ EN SEGUNDO PLANO)
===============================================================================================================================

PREVIO: Antes de hacer estos experimentos, edita /etc/default/grub, pon un timeout distinto de 0, y ejecuta "update-grub",
para que si un nuevo kernel no arranca, seas capaz de arrancar el kernel original del sistema y desinstalar el nuevo.

	###PARTE 1: INSTALACIÓN DE UN KERNEL QUE SOPORTE SCX (SCHED-EXT): EL KERNEL CACHYOS###

-Instalamos una dependencia previa que es necesaria para compilar el kernel con la opción "Generate BTF typeinfo" (CONFIG_DEBUG_INFO_BTF)
 activada: apt-get install pahole
-Usamos un script que nos descarga el kernel y nos permite pre-configurarlo (hay que activar SCHED_CLASS_EXT a mano antes de compilar):
 Clonamos su repo: git clone --depth 1 https://github.com/CachyOS/linux-cachyos-deb
(No te olvides de poner el governor a PERFORMANCE en las opciones que nos presenta el script!)
(NO COMPILAMOS EL KERNEL AÚN, lo vamos a hacer después a mano con "make", ya que tenemos que activar CONFIG_SCHED_CLASS_EXT).
-Hacemos "make menuconfig" y hacemos estos cambios (RECUERDA que si una opción no aparece, puedes darle a la Z
 para que aparezca y poder ponerte sobre ella y darle a la "?" para ver qué tienes que tener activado/desactivado para que aparezca): 
	--Activamos "General Setup->Extensible Scheduling Class" (esto activa lo más importante: CONFIG_SCHED_CLASS_EXT).
	--Activamos "Kernel hacking->Compile-time checks and compiler options->Generate BTF type information"
	(Para lo cual tenemos que tener "Debug Information" puesto a "Rely on the toolchain's implicit default DWARF version")
	--Activamos "Device Drivers->Sound card support->Advanced Linux Sound Architecture -> HR-timer backend support"
	--Activamos "General Setup->Some kernel tweaks by CachyOS"
¡¡RECUERDA que usando "/" puedes localizar la opción que quieras!!

-BLOQUE OPCIONAL DE ADELGAZAMIENTO DEL KERNEL USANDO MODPROBED-DB
(La información está adaptada de: https://wiki.archlinux.org/title/Modprobed-db)
--Clonamos su repo: git clone --depth 1 https://github.com/graysky2/modprobed-db.git
--Entramos en el directorio de los sources y simplemente hacemos "make install" y ya se instala.
(Para desinstalarlo simplemente se usa "make uninstall" y ya).
--(OJO!! ESTO HAZLO CON UNA UNINDAD DE ALMACENAMIENTO USB CONECTADA O LUEGO NO TENDRÁS LOS MÓDULOS NECESARIOS! Y NO FUNCIONARÁN!!)
Ejecutamos "modprobed-db" y se nos creará el archivo "~/.config/modprobed-db.conf"
Este archivo nos permite añadir módulos que NO queremos que se tengan en cuenta aunque estén cargados, para lo cual
añadiríamos en él una línea estilo "IGNORE=(nvidia vboxdrv..."
--Ejecutamos "modprobed-db store" y se nos creará el archivo "~/.config/modprobed.db", que es donde quedan reflejados los módulos
que tenemos cargados en nuestro kernel actual. Podemos consultar qué módulos tenemos cargados con "modprobed-db list".
--Nos vamos al directorio de los sources del kernel (que ya tenemos configurados de antes) y hacemos:
make LSMOD=~/.config/modprobed.db localmodconfig
(Te preguntará cosas: dile a todo que NO, no nos interesa, gracias).
--Hacemos "make menuconfig" y nos aseguramos de tener activado "Device Drivers->USB support->USB Mass Storage support"
  (Esto es por si no teníamos una unidad de almacenamiento USB cuando previamente ejecutamos "modprobed-db store" y por tanto
   no se detectó el módulo como cargado)
--Podemos aprovechar para volver a hacer "make menuconfig" y aligerar funcionalidades internas del kernel,
como desactivar "Mitigations for speculative execution vulnerabilities",
quitar todo lo que puedas de "Security Options", en Device Drivers los "Multiple devices driver support (RAID and LVM)"
y los "Macintosh Device Drivers",
En "Enable the block layer->Partition Types" quitamos todas las particiones que no necesitamos.
En "Drivers->Network device support->Ethernet driver support" y "Drivers->Network device support->Wireless LAN"
quitamos todo el hardware que no tengamos (habremos hecho "lscpi" antes para averiguar cuál sí necesitamos,
POR EJEMPLO en el N100 hay que dejar los Ethernet de REALTEK y los WIFI de INTEL, y ya).
Activamos "Device Drivers->Graphics support->Intel Xe Graphics", que no lo detecta modprobed-db.
Usando "/", buscamos ANDROID, AMAZON, MICROSOFT, GOOGLE... Y nos aseguramos de que todas las opciones están desactivadas,
¡nos dice cómo llegar a cada opción!.
Cuidado: no andes quitando cosas de "Kernel Hacking" o los schedulers externos no funcionarán.
--(OPCIONAL PARA NO NECESITAR UN INITRAMFS) metemos en el kernel (incluidos en el kernel, o sea con el [*], no como módulos con la [M])
las cosas necesarias para que el propio kernel pueda montar el rootfs, es decir, los drivers de dispositivo y el filesystem EXT4,
que en un sistema actual de 2024 con NVME son:
----"File Systems->The Extended 4 (ext4) filesystem"
----"Device Drivers->Memory Technology Device (MTD) support"
----"Device Drivers->NVME Support->NVM Express block device"

(OJO no desactives el DEBUGFS o no compilará el driver gráfico de Intel)
(RECUERDA que si en un submenú no encuentras una opción que debería estar ahí, puedes darle a Z y te aparecerá para poder darle a "?" sobre ella
 y así averiguar de qué depende).
(RECUERDA que puedes usar "/" para buscar la opción que quieras, te dice cómo llegar a cada opción).
 
-FIN DEL BLOQUE OPCIONAL DE ADELGAZAMIENTO DEL KERNEL

-Ahora ya sí: Compilamos el kernel y los módulos con "make -j6".

-Instalamos los módulos del kernel (para desinstalarlos, simplemente borramos el directorio "/lib/modules/6.9.0"):
cd linux-6.9.0
make INSTALL_MOD_STRIP=1 modules_install

-Instalamos el kernel en sí (RECUERDA que hay que instalar los módulos antes, cosa que hemos hecho en el paso anterior,
ya que esto nos crea el initramfs del kernel que lleva dentro módulos necesarios para el arranque del kernel):
make install
update-grub
(Si no necesitas el initramfs porque tienes las funcionalidades necesarias para montar el rootfs metidas en el kernel [*] en vez de como módulos [M],
 simplemente borra /boot/initramfs-6.9.0 antes de ejecutar "update-grub".
 Busca ahí arriba en "OPCIONAL PARA NO NECESITAR UN INITRAMFS" para saber cuáles son en un sistema actual de 2024 con disco duro NVME)

-(PASOS NORMALMENTE NO NECESARIOS: NORMALMENTE AL INSTALAR EL KERNEL ESTAS COSAS SE HACEN SOLAS)
--Creamos un initramfs para el nuevo kernel:
update-initramfs -c -k 6.9.0
--Actualizamos grub para que tenga localizado el nuevo kernel: update-grub
Y editamos /etc/default/grub para poner el TIMEOUT a un valor distinto de 0, de manera que nos presente el menú de arranque.
--Reiniciamos, y en el menú de arranque de GRUB entramos en "Advanced Options" y elegimos el nuevo kernel y arrancamos.
(La próxima ver que arranquemos, GRUB recordará esta opción y arrancará en el nuevo kernel).

	###PARTE 2: INSTALAR LOS SCHEDULERS EXTERNOS###

--Previo: Para evitar problemas y confusiones luego, asegúrate antes de seguir de que estas opciones
las tienes todas así en el .config del kernel:
CONFIG_BPF=y
CONFIG_SCHED_CLASS_EXT=y
CONFIG_BPF_SYSCALL=y
CONFIG_BPF_JIT=y
CONFIG_BPF_JIT_ALWAYS_ON=y
CONFIG_BPF_JIT_DEFAULT_ON=y
CONFIG_DEBUG_INFO_BTF=y

--Previo: Instalamos el buildsystem que necesita.
----Instalamos rust desde su repositorio (si usamos el apt-get nos instalará una versión demasiado antigua, como siempre)
Según las instrucciones de https://www.rust-lang.org/tools/install, se hace así:
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
----Instalamos clang desde su repositorio (si usamos el apt-get nos instalará una versión demasiado antigua, como siempre)
apt install lsb-release wget software-properties-common gnupg
bash -c "$(wget -O - https://apt.llvm.org/llvm.sh)"
ln -s /usr/bin/clang-18 /usr/bin/clang
--Previo: Instalamos dependencias previas:
apt-get install jq libzstd-dev

VAMOS CON SCHED_EX EN SÍ...
--Bajamos la última release de: https://github.com/sched-ext/scx/releases
--Configuramos y compilamos con:
mkdir b4
cd b4

CFLAGS="-O2 -march=native -mtune=native -O2" \
CXXFLAGS="-O2 -march=native -mtune=native -O2" \
meson setup -Dbuildtype=release ..

ninja -j6
ninja install

--Para lanzar el LAVD y que no nos maree con estadísticas, editamos el fichero /etc/default/scx y lo dejamos así:
SCX_SCHEDULER=scx_lavd
SCX_FLAGS='-s 0'

--Activamos el servicio scx:
systemctl enable scx.service
systemctl start scx.service
...Comprobamos que está corriendo correctamente con:
systemctl status scx.service

--Alternativamente, sin habilitar/lanzar ninigún servicio, podemos lanzar a mano el scheduler externo que queramos:
escribe "scx" y dale al tabulador para ver los que hay disponibles.
Si no quieres que te esté mareando con información todo el rato, pásale el parámetro "-s0".

AUTOLOGIN EN DEBIAN CON ESCRITORIO LXQT
=======================================

Creamos el archivo /etc/sddm.conf.d/autologin.conf (hay que crear el directorio /etc/sddm.conf.d) con el contenido:
# autologin
[Autologin]
User=manuel
Session=lxqt.desktop

Y ya. Reiniciar y listo.

KERNEL REALTIME EN DEBIAN
=========================

Lo primero que debes saber es que ya no hace falta un kernel RT especial: la funcionalidad de RT está en el kernel vanilla 6.x.

--Comprobamos que el kernel que tenemos está preparado. Para ello, hacemos: cat /boot/config-$(uname -r) |grep PREEMPT
Nos interesa tener "CONFIG_PREEMPT_DYNAMIC=y"
--Añadimos a la línea de comandos del kernel:
  "threadirqs preempt=full nohz_full=1-3 cpufreq.default_governor=performance mitigations=off audit=0"
--Reiniciamos, hacemos "dmesg | grep Preempt" y comprobamos que vemos: "Dynamic Preempt: full"
--Añadimos nuestro usuario al grupo "audio": usermod -a -G audio <nombre_usuario>
--Podemos comprobar qué CPUs tenemos en modo tickless con: cat /sys/devices/system/cpu/nohz_full

--Ahora vamos con la prueba definitiva del desempeño realtime de nuestro equipo, usando "rtcqs". Para instalar "rtcqs":
	--Nos vamos a https://codeberg.org/rtcqs/rtcqs/releases y nos bajamos el último binario release estable.
	--Le damos permisos con "chmod +x" y lo ejecutamos.
	  Debería salirnos todo en verde. Podemos ignorar el fallo sobre el kernel "tickless" (se supone que nohz_full=1-3 se encarga de eso,
	  pero el test no se ha actualizado y comprueba otro parámetro del kernel que no es necesario tener activado).
