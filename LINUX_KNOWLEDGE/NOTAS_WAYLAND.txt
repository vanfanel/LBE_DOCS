PREVIO: EL LIO DE LOS SEAT MANAGERS Y LOS DIRECTORIOS COMO XDG_RUNTIME_DIR
==========================================================================

El metacompositor (sirve para hacer compositores) WLROOLS depende de LIBSEAT.
LIBSEAT al instalarse instala seatd, un servicio que administra seats, pero NO establece el valor de XDG_RUNTIME_DIR,
así que con WLROOTS y un compositor recién instalados, el compositor no funcionará hasta que le demos un valor a XDG_RUNTIME_DIR
PARA ELLO, normalmente haremos esto en .bashrc:
##################################
rundir="/run/user/0"                                                                                    
if [[ ! -e $rundir ]]; then                                                                                    
    mkdir -p $rundir                                                                                           
fi                                                                                                             
export XDG_RUNTIME_DIR=$rundir
##################################

Si no queremos tener que establecer XDG_RUNTIME_DIR así a mano, podemos activar el servicio SYSTEMD-LOGIND,
pero claro, eso ya depende de DBUS, etc...

Actualmente, para lanzar labwc sin necesidad de tener SYSTEMD-LOGIND funcionando, lo que hago es que desde mi labwc.service
llamo a un script de lanzamiento que he creado como "/usr/local/bin/launch-labwc" donde se establece XDG_RUNTIME_DIR antes de ejecutar labwc.
Míralo en la sección correspondiente a cómo lanzar labwc como servicio.

La alternativa para sistemas embedidos es elogind, que se encarga del seat management y de establecer XDG_RUNTIME_DIR.

Si quieres ver cómo me aclaré con esto: https://docs.voidlinux.org/config/session-management.html

INSTALAR WAYLAND
================

Lo primero: para correr COMPOSITORS BASADOS EN WLROOTS (DWL, TINYWL, SWAY, WAYBOX, CAGE) necesitas WAYLAND y WLROOTS, ya que la mayoría de los compositores se basan en WLROOTS.
A su vez, WLROOTS necesita WAYLAND-PROTOCOLS y LIBSEAT.
LUEGO A PARTE ESTÁ WESTON, QUE NO ESTÁ BASADO EN WLROOTS NI LO NECESITA.
***LIBSEAT ES NECESARIO PARA COMPOSITORES BASADOS EN WLROOTS Y AHORA TAMBIÉN PARA WESTON (ANTES NO HACÍA FALTA, PERO AHORA, WESTON NECESITA
O BIEN LIBSEAT O BIEN, SI USAS SYSTEMD, EL SERVICIO SYSTEMD-LOGIND ACTIVO: UNA DE LAS DOS COSAS).
***LIBSEAT SÓLO ES NECESARIO SI NO TENEMOS CORRIENDO EL SERVICIO "LOGIND" QUE EN SYSTEMD ES "systemd-logind"
   Y QUE EN OTROS INIT DISTINTOS DE SYSTEMD ES "elogind".
   LÓGICAMENTE, EN UN SISTEMA "MINIMAL" DE LOS MIOS, PARA USAR UN COMPOSITOR BASADO EN WLROOTS, LIBSEAT HACE FALTA PORQUE NO TIENES
   NINGÚN SERVICIO DE LOGIN CORRIENDO!

WLROOTS tiene un renderer Vulkan, que desde WESTON no puedes aprovechar por no basarse en WLROOTS.

PARTE 1: WAYLAND EN SÍ (libwayland)
-----------------------------------

Instalamos dependencias previas:
apt-get install libffi-dev libexpat1-dev --no-install-recommends

Bajamos la última release estable de:
https://gitlab.freedesktop.org/wayland/wayland/-/releases

Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Ddtd_validation=false -Ddocumentation=false ..

ninja -j4
sudo ninja install

PARTE 2: WAYLAND-PROTOCOLS
--------------------------
Bajamos la ultima release estable de:
https://gitlab.freedesktop.org/wayland/wayland-protocols/-/releases

Cofiguramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Dtests=false ..

ninja -j4
sudo ninja install

PARTE 3: INSTALAR WLROOTS (NO NECESARIO PARA WESTON!!)
------------------------------------------------------
-Previamente necesitamos KMS/DRM funcionando. Así que deberías ser capaz de ejecutar los tests de SDL2 sobre KMSDRM.

-Instalamos dependencias previas:
sudo apt-get install libseat-dev libpixman-1-dev libxkbcommon-dev hwdata \
libinput-dev glslang-dev glslang-tools --no-install-recommends

-Instalamos otra dependencia previa (no disponible en Debian 12), libdisplay-info.
--Bajamos la última versión estable de: https://gitlab.freedesktop.org/emersion/libdisplay-info/-/releases
--Configuramos, compilamos e instalamos con:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release

ninja -j4
sudo ninja install

VAMOS CON WLROOTS EN SÍ:
--Bajamos los últimos sources de WLROOTS estables de aquí: https://gitlab.freedesktop.org/wlroots/wlroots/-/releases
--Configuramos, compilamos e instalamos:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Dexamples=false -Dxwayland=disabled \
-Dbackends=drm,libinput -Drenderers=gles2,vulkan -Dxcb-errors=disabled ..

ninja -j4
sudo ninja install

RECUERDA que WLROOTS soporta renderizado con Vulkan, por lo que los renderers basados en WLROOTS (como LABWC, DWL, SWAY, WAYBOX...) pueden usarlo.
Para usarlo, lanzaríamos el compositor que queramos con:
WLR_RENDERER=vulkan <compositor>
(OJO!! WESTON NO USA WLROOTS!!)

=================================================================
PARTE 4: INSTALAR WESTON (EL COMPOSITOR DE REFERENCIA DE WAYLAND)
=================================================================

-Instalamos dependencias previas, libinput-dev:
sudo apt-get install libinput-dev libseat-dev --no-install-recommends

-Instalamos manualmente una dependencia previa, CAIRO, ya que el paquete de DEBIAN viene con dependencias de X11:
--Instalamos dependencias previas de CAIRO: apt-get install libfontconfig-dev
--Bajamos los últimos sources estables de: https://gitlab.freedesktop.org/cairo/cairo/-/releases
--Configuramos con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dzlib=disabled -Dtests=disabled -Ddwrite=disabled ..

-Instalar WESTON en sí:
Bajamos los últimos sources estables de:
https://gitlab.freedesktop.org/wayland/weston/-/tags

Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Dbackend-headless=false -Dbackend-rdp=false -Dscreenshare=false -Dremoting=false -Dpipewire=false \
-Dbackend-drm-screencast-vaapi=false -Dbackend-vnc=false -Dbackend-x11=false \
-Dxwayland=false -Dsystemd=false -Dpipewire=false -Dshell-ivi=false \
-Dcolor-management-lcms=false -Dcolor-management-lcms=false -Dtools=terminal -Dwcap-decode=false \
-Dtest-junit-xml=false -Dimage-webp=false -Ddoc=false -Dbackend-drm-screencast-vaapi=false -Ddemo-clients=false \
-Dwcap-decode=false -Dbackend-pipewire=false ..

ninja -j4
sudo ninja install

// BLOQUE PARA USUARIOS NORMALES NO ROOT
Ahora hacemos setuid-root al ejecutable weston, creamos el grupo weston y añadimos al usuario al grupo weston:
sudo chmod 4755 /usr/local/bin/weston
sudo gropuadd weston
sudo usermod -a -G weston pi
// FIN BLOQUE PARA USUARIOS NORMALES NO ROOT

Ahora creamos ~/.config/weston.ini con este contenido:
(RECUERDA que weston.ini puede estar en cualquier ruta que exportes en $XDG_CONFIG_HOME)
(RECUERDA que puedes ver los modos de vídeo disponibles con: modetest |grep -50 modes
 PERO lo mejor es poner mode=current y así no hay cambio de modo.)
(RECUERDA que si, como en este ejemplo, tienes puesto el cursor-theme llamado adwaita, tienes que instalarlo con:
 apt-get install adwaita-icon-theme).

#
# Contenido de weston.ini
#

[core]
# El valor por defecto de "shell" es "desktop". Kiosk es un shell más ligero,
# que sólo es para que se ejecute un programa, en nuestro caso el foot.
shell=kiosk
idle-time=0

[shell]
locking=false
binding-modifier=alt
animation=zoom
startup-animation=fade
cursor-theme=adwaita
cursor-size=24
background-image=none
background-color=0xFF555555

[terminal]
font=monospace
font-size=18

[launcher]
icon=/usr/local/share/weston/terminal.png
#path=/usr/local/bin/weston-terminal --shell=/bin/bash
path=/usr/local/bin/foot

[input-method]
path=/usr/local/libexec/weston-keyboard

[output]
name=HDMI-A-1
mode=current

[keyboard]
keymap_layout=es
vt-switching=false

[autolaunch]
# Podríamos poner "watch" a "true" si usamos el shell "kiosk" en la sección [core],
# ya que así Weston termina al cerrar el foot (y se reinicia o se apaga el sistema).
path=/usr/local/bin/foot
watch=false

#
# Aquí acaba el contenido de weston.ini
#

// BLOQUE SÓLO PARA DEBIAN CON SYSTEMD, PARA LANZAR WESTON COMO SERVICIO

Creamos /etc/systemd/system/weston.service con el contenido:

#############

[Unit]
Description=weston - User service

[Service]
User=root
Group=root
PAMName=login
WorkingDirectory=%h
ExecStart=
ExecStart=-/usr/local/bin/weston
Restart=always

[Install]
WantedBy=graphical.target

#############
*NOTA: El WorkingDirectory puesto a "%h" significa usar nuestro $HOME, que sera /root si no eres otro usario. 
*NOTA: Si tuvieramos que añadir mas servicios, irian con:
[Install]
WantedBy=default.target
...en vez de graphical.target, porque lo que nos interesa es que esos servicios se lancen sea cual sea el target
que tengamos puesto como default, NO nos interesa que se lancen solo cuando el target puesto como default sea graphical.
El caso de un compositor wayland es especial, porque solo se tiene que lanzar cuando el target sea graphical).
*NOTA
-Podemos ver los targets activos con: systemctl list-units --type target
-Podemos ver los targets que hay en el sistema, aunque no esten activos, mirando en /lib/systemd/system

Establecemos graphical.target como target por defecto:
systemctl set-default graphical.target
Podemos comprobarlo con:
systemctl get-default
(Si alguna vez quisieramos volver a un modo de texto, estableceriamos el target multi-user como target por defecto:
systemctl set-default multi-user.target
Y NO HARIA FALTA VOLVER A DESACTIVAR EL SERVICIO WESTON, YA QUE NOS QUEDAMOS EN EL TARGET MULTI-USER Y DE ESE MODO
NO SE CARGA EL SERVICIO WESTON).

Ahora activamos el servicio WESTON con:
systemctl enable weston.service
(Recuerda que lo que hace esto es crear el symlink /etc/systemd/system/graphical.target.wants/weston.service apuntando
a /etc/systemd/system/weston.service, que es logico porque el target graphical.target necesita weston.target tal como hemos
especificado en la UNIT de weston). 

Desactivamos el autologin en TTY con:
systemctl disable getty@tty1

// FIN BLOQUE SÓLO PARA DEBIAN CON SYSTEMD

Podemos lanzar WESTON con:
weston -f '' -l ''
(Lo de -f '' -l '' es para que no mande logs a la consola ni a ningún lado).
(Se sale con Ctrl+Alt+Backspace)

SI TE DA EL ERROR: "Error: Failed to connect to parent Wayland compositor: No such file or directory"
...Es porque estás exportando WAYLAND_DISPLAY=... (posiblemente en bashrc, para debugear programas por ssh) y Weston interpreta
que ya hay un servidor Wayland corriendo, y peta. No lo exportes y funcionará.

############################################################
# SI NECESITAS AYUDA CON WAYLAND:                          #
# -https://gitlab.freedesktop.org/wayland/weston/-/issues  #
# -DRM/KMS: Canal #dri-devel en irc.oftc.net               #
# -WESTON:  Canal #wayland en irc.oftc.net                 #
# -WLROOTS: Canal #sway-devel en irc.libera.chat		   #
############################################################

Investigar si se puede hacer simplemente:
sudo -E weston -t /dev/tty7 -u pi

QUITAR ERRORES DE WESTON
========================

--Para quitar los errores:
	could not load cursor 'dnd-move'
	could not load cursor 'dnd-copy'

	Instalamos:
	apt-get adwaita-icon-theme --no-install-recommends

	Y añadimos en .config/weston.ini, en la sección [shell]:

	[shell]
	cursor-theme=adwaita
(Se podría usar otro tema más ligero, pero no lo conozco).

AÑADIR ATAJOS DE TECLADO A WESTON
=================================

Editamos desktop-shell/shell.c y allí:
-Nos vamos a shell_add_bindings() y añadimos estos key bindings:

// Close windows with ALT+F4
weston_compositor_add_key_binding(ec, KEY_F4, mod, force_kill_binding, shell);
// Launch terminal
weston_compositor_add_key_binding(ec, KEY_T, MODIFIER_CTRL | MODIFIER_ALT,
	terminal_binding, ec);

-Nos vamos a force_kill_binding() y debajo de esa función añadimos nuestra función que lanza la terminal:
static void
terminal_binding(struct weston_keyboard *keyboard,                                                                                     
		const struct timespec *time, uint32_t key, void *data)                                                                         
{
	pid_t tmp_pid = -1;

	tmp_pid = fork();
    if (tmp_pid == -1) {
		return;
	} else if (tmp_pid == 0) {
		//cleanup_for_child_process();
		execl("/usr/local/bin/foot", "/usr/local/bin/foot", NULL);
		_exit(1);
	}
}
 
CONSTRUIR UN ESCRITORIO COMPLETO BASADO EN WAYLAND
==================================================

NOTA PREVIA: Mucha de la información viene de aquí: https://github.com/natpen/awesome-wayland

---PARTE 1 - EL COMPOSITOR---

-Elegimos un compositor que sea stacking, no tiling.
Si insistes en usar Weston, puedes añadir nuevos keyboard shortcuts con esto:
https://github.com/tarvi-verro/weston-binder

---PARTE 2 - EL TOOLKIT---

-Compilamos un toolkit que soporte Wayland.
Básicamente elegimos entre GTK y QT. GTK es más ligero y sencillo de compilar (QT son varios paquetes).

Para compilar GTK3 (la versión más compatible con programas actualmente y que a la vez tiene soporte WAYLAND es GTK3)
-Bajamos los últimos sources estables de: https://download.gnome.org/sources/gtk/
-Configuramos como:
mkdir b4
cd b4
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson .. -Dbuildtype=release \
-Dwayland-backend=true -Dx11-backend=false -Dmedia-ffmpeg=disabled -Dmedia-gstreamer=disabled -Dprint-cups=disabled \
-Dprint-cloudprint=disabled -Dvulkan=enabled -Dxinerama=disabled -Dintrospection=disabled -Ddemos=false \
-Dbuild-examples=false -Dbuild-tests=false
ninja -j4
sudo ninja install

Para compilar GTK4 sería:
-Bajamos los últimos sources estables de: https://download.gnome.org/sources/gtk/
mkdir b4
cd b4
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson .. -Dbuildtype=release \
-Dwayland-backend=true -Dx11-backend=false -Dmedia-ffmpeg=disabled -Dmedia-gstreamer=disabled -Dprint-cups=disabled \
-Dvulkan=enabled -Dintrospection=disabled -Ddemos=false -Dbuild-examples=false -Dbuild-tests=false 
ninja -j4
sudo ninja install

---PARTE 3 - LAS APLICACIONES---

-Compilamos un file browser que soporte GTK. Elegimos pcmanfm, que soporta tanto GTK como QT. Otra alternativa sería thunar.
Para compilar PCMANFM:

Empezamos con una dependencia, libfm:
-Bajamos los últimos sources estables de: https://github.com/lxde/libfm/releases

Ahora vamos con PCMANFM en sí:
-Bajamos los últimos sources estables de: https://github.com/lxde/pcmanfm/releases

INSTALAR DWL, EL COMPOSITOR DE ESCRITORIO BASADO EN WLROOTS MÁS BÁSICO QUE HAY (DOCS: "EVERY FRAME IS PERFECT")
===============================================================================================================

Clonamos su repo:

git clone --depth 1 https://github.com/djpohly/dwl.git
(OJO, para compilarlo contra la última versión de los sources de WLROOTS en lugar de la versión estable,
tendríamos que clonar el branch "wlroots-next"). 

Aplicamos este parche para que el confinamiento del puntero funcione (para no tener puntero pegajoso en los lados
en Scummvm a pantalla completa):
https://github.com/djpohly/dwl/wiki/pointerConstraints
patch -p1 < <NOMBRE_PARCHE>

Editamos dwl.c, nos vamos a la función createmon() y comentamos las llamadas a wlr_output_enable() y wlr_output_set_mode() que hay allí,
ya que ambas causan full modesettings y por tanto apagado y encendido de la pantalla (AKA flickering).
(Si piensas que un compositor debería detectar si un output ya está enabled antes de llamar wlr_output_enable() sobre él, recuerda
que según emersion, detectar si un conector está activado NO ES FIABLE, por eso los compositores llaman wlr_output_enable() por sistema).

Compilamos con:
CFLAGS="-O2 -march=native -mtune=native" \
CXXFLAGS="-O2 -march=native -mtune=native" \
make -j4

Se sale de dwl con ALT+SHIFT+Q

Si al compilar da un error de que no encuentra "wlr/backend/libinput.h" es porque compilaste WLROOTS sin pasarle libinput
a -Dbackends. Deberías pasarle tanto "drm" como "libinput", así: -Dbackends=drm,libinput.
Lo tienes en las instrucciones de compilación de WLROOTS.

Para quitar el borde rojo cuando la ventana está activa, edita config.h y en "focuscolor" quita la componente roja.

INSTALAR TINYWL+, UN COMPOSITOR BASADO EN TINYWL PERO CON MÁS FUNCIONES
=======================================================================

https://cppdig.com/c/a-simple-stacking-wayland-compositor-based-on-tinywl

INSTALAR CAGE, UN COMPOSITOR PARA APLICACIONES EMBEDIDAS
========================================================

Clonamos ultimos los sources con:
git clone --depth 1 https://github.com/cage-kiosk/cage.git

Compilamos con:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup .. --buildtype=release -Dxwayland=disabled

ninja -j4
sudo ninja install

Lanzaríamos el programa que queramos así:
-Lo primero, lanzamos el seatd, para loguear al usuario Pi en un asiento y poder lanzar el cage:
sudo seatd -u pi &
-Ahora lanzamos el cage y le pasamos el ejecutable que queramos:
cage <nombre_ejecutable>
Y si es con parámetros, usamos -- entre cage y el nombre del ejecutable, así:
cage -- <nombre_ejecutable> <parámetros>

INSTALAR WAYFIRE, EL COMPOSITOR DE WAYLAND POR DEFECTO DE RASPBERRY PI OS
=========================================================================

-Instalamos dependencias previas:
apt-get install libglm-dev nlohmann-json3-dev

-Instalamos manualmente una dependencia previa, CAIRO, ya que el paquete de DEBIAN viene con dependencias de X11:
--Instalamos dependencias previas de CAIRO: apt-get install libfontconfig-dev
--Bajamos los últimos sources estables de: https://gitlab.freedesktop.org/cairo/cairo/-/releases
--Configuramos con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Dzlib=disabled -Dtests=disabled -Ddwrite=disabled ..

-Instalamos otra diferencia previa, PANGO, ya que la que trae Debian depende de mierdas de X11:
--Instalamos dependencias previas: apt-get install libglib2.0-dev libfontconfig-dev
--Desinstalamos el pango del sistema: apt-get purge libpango* && apt-get autoremove
--Bajamos los últimos sources estables de: https://github.com/GNOME/pango/tags
--Configuramos con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Dlibthai=disabled -Dxft=disabled ..

	VAMOS CON EL WAYFIRE EN SÍ:

Nos bajamos la última estable de: https://github.com/WayfireWM/wayfire/releases

Configuramos con:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup .. --buildtype=release -Dxwayland=disabled -Dtests=disabled -Dprint_trace=false

PARA EVITAR EL ERROR "Unable to drop root":
Editamos src/main.cpp, buscamos "LOGE("Unable to drop root" y comentamos esa parte para que no retorne con "false" si somos el root.
Aparece dos veces, pero con que comentemos la segunda es suficiente.

Por defecto, se puede salir con CTRL+ALT+BACKSPACE.

Copiamos el archivo wayfire.ini que viene con los sources a ~/.config/wayfire.ini, lo editamos, y ahí:

--Para activar VRR, nos vamos a la sección "[output]" (viene como "[output:eDP-1]" por defecto, lo tendrás puesto a "HDMI-A-1")
y añadimos "vrr = true"

--Si queremos teclado en español, nos vamos a la sección "[input]" que está comentada, la descomentamos y la dejamos así:
[input]                                                                                                                                
xkb_layout = es                                                                                                                        
xkb_variant = deadtilde

--Buscamos "Start a terminal" y lo dejamos así:
binding_terminal = <ctrl> <alt> KEY_T                                                                                                  
command_terminal = foot

--Buscamos [fast-switcher] y la línea de debajo la dejamos así:
activate = <alt> KEY_TAB
...Y buscamos "plugins =" y quitamos el llamado "switcher", que es un swicther en 3D que nos sobra.
Nos vamos a la lista de plugins y dejemos sólo los plugins que necesitamos, que son:
plugins = \                                                                                                                            
  alpha \                                                                                                                              
  animate \                                                                                                                            
  autostart \                                                                                                                          
  command \                                                                                                                            
  decoration \                                                                                                                         
  fast-switcher \                                                                                                                      
  move \                                                                                                                               
  place \                                                                                                                              
  resize \                                                                                                                             
  wobbly

--Para que se nos autolance una terminal al iniciar, buscamos [autostart] y debajo ponemos:
1 = foot

--Eliminamos las secciones [wrot], [fisheye], [zoom], etc.. que corresponden a plugins que no tenemos habilitados en la lista de plugins.

--Para ocultar el cursor cuando no se está moviendo (PCSX2 Standalone...) usamos "plugins-extra":
-Clonamos su repo: git clone --depth 1 https://github.com/WayfireWM/wayfire-plugins-extra.git
-Configuramos, compilamos e instalamos con:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup .. --buildtype=release

ninja -j8
ninja install
-Editamos ~/.config/wayfire.ini y en "plugins =" añadimos "hide-cursor"
-Si queremos ajustar el tiempo que tarda en ocultarse el cursor, podemos editar /usr/local/share/wayfire/metadata/hide-cursor.xml 
-Para ocultar/desocultar el cursor a nuestro gusto, hacemos:
#Ocultar:
sed -i "s/plugins =/& hide-cursor/g" ~/.config/wayfire.ini
#Desocultar:
sed -i "s/ hide-cursor//g" ~/.config/wayfire.ini

--(NO NECESARIO: SÓLO NECESARIO PARA "MAX_SWAPCHAIN=2"/DOBLE BUFFER, COSA QUE NO USAMOS YA PORQUE, EN VULKAN, "MAX_SWAPCHAIN=3"/TRIPLE BUFFER
   CON EN VSYNC DESACTIVADO NOS DA LA MISMA LATENCIA QUE "MAX_SWAPCHAIN=2"/DOBLE BUFFER)
En la sección "[core]" podemos ajustar "max_render_time" (MRT de ahora en adelante).
Yo lo suelo dejar por ahora a 8, que no reduce a la mitad la tasa de fotogramas de RetroArch cuando usamos Vulkan + max_swapchain a 2
ni tampoco reduce a la mitad la tasa de fotogramas de los efectos del escritorio. 
MRT es la antelación con la que el compositor debe componer el frame RESPECTO AL SIGUIENTE VBLANK QUE ES CUANDO SE ENVÍA PARA PONER EN PANTALLA.
CUANTO MÁS TARDE COMPONGAMOS EL FRAME, MÁS RECIENTE SERÁ RESPETO AL INPUT DEL USUARIO: NOS INTERESA COMPONERLO LO MÁS TARDE POSIBLE.
O sea que si nuestra pantalla va a 60Hz, con un MRT de 6 componemos el frame 6ms antes de mandarlo a presentar,
Con un MRT de 8, componemos el frame 8ms antes de mandarlo a presentar (es menos reciente),
Con un MRT de 10, componemos el frame 10ms antes de mandarlo a presentar (es menos reciente aún...), etc etc
Por tanto, si nos pasamos poniendo un MRT demasiado bajo, no le da tiempo a componer el frame, y ya nos lo muestra en el el siguiente vblank,
con lo que estaremos de hecho aumentando la latencia y además lo veremos todo a la mitad de fotogramas.
Pero por otra parte, si es demasiado alto (el valor de MRT por defecto sería 16 en un monitor a 60Hz, es decir, que se componga el frame
tan pronto como sea posible) puede que al intentar escribir un segundo frame, en un sistema de dos buffers no nos queden buffers porque
ya estamos renderizando el siguiente desde el principio (y por tanto tenemos "candado" el segundo buffer, el que no tenemos en pantalla),
de manera que la tasa de fotogramas queda recortada a la mitad.
Esto explica que si en RetroArch usas max_swapchain=2 en Vulkan y no ajustas el MTR (con lo cual el segundo buffer está ocupado desde
el primer momento de cada periodo entre vblanks), la tasa de fotogramas sea la mitad, es decir, 30fps en un modo de vídeo de 60Hz. 

INSTALAR FOOT, UN EMULADOR DE TERMINAL PARA WAYLAND
===================================================

Instalamos dependencias previas:
apt-get install libfontconfig-dev libncurses-dev libtllist-dev libfcft-dev --no-install-recommends

Bajamos la última versión estable de aquí:
https://codeberg.org/dnkl/foot/releases

Configuramos y compilamos con:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Ddocs=disabled -Dgrapheme-clustering=disabled -Dtests=false -Dime=false ..

ninja -j4
ninja install

Creamos ~/.config/foot/foot.ini con este contenido:
(OJO: Puedes tener foot/foot.ini donde quieras si exportas un valor de $XDG_CONFIG_HOME).

[main]
shell=bash
term=xterm-256color
font=monospace:size=20
title=Command Console

initial-window-size-chars=98x24
#initial-window-mode=fullscreen
#initial-window-mode=maximized

-Para tener una fuente chula en vez de la monospace por defecto:
	-Instalamos: apt-get install fonts-jetbrains-mono
	-En el foot.ini: font=JetBrainsMono:size=20

-Para tener un cursor como el de la TTY (aunque yo prefiero últimamente style=block):
[cursor]
style=underline
blink=yes

-Para que no nos ponga el nombre en una barra arriba (es decir, para quitar las decorations):
[csd]
preferred=none

-Para configurar los colores etc, podemos:
---OPCIÓN 1, COMO LO VENIMOS HACIENDO AHORA: Usar un tema modificado a mi gusto. Para ello, metemos esto en el foot.ini:

[cursor]
style=block
blink=yes
color=126e00 126e00
                                                                                                               
[colors]                                                                                                       
alpha=0.90
background=101010
foreground=126e00
regular0=101010  # black
regular1=fa5355  # red
regular2=126e00  # green
regular3=c2c300  # yellow
regular4=4581eb  # blue
regular5=fa54ff  # magenta
regular6=33c2c1  # cyan
regular7=adadad  # white
bright0=545454   # bright black
bright1=fb7172   # bright red
bright2=67ff4f   # bright green
bright3=ffff00   # bright yellow
bright4=6d9df1   # bright blue
bright5=fb82ff   # bright magenta
bright6=60d3d1   # bright cyan
bright7=eeeeee   # bright white
selection-foreground=202020
selection-background=1a3272

---OPCIÓN 2: Usar un tema, para lo cual añadiríamos esto al final de la sección [main]:
include=/usr/local/share/foot/themes/NOMBRE_TEMA
...Donde NOMBRE_TEMA es el nombre de un tema de los que tienes en /usr/local/shared/foot/themes

INSTALAR ALACRITTY, UN EMULATOR DE TERMINAL PARA WAYLAND ESCRITO EN RUST
========================================================================

--Primero instalamos el buildsystem que necesita.
Según las instrucciones de https://www.rust-lang.org/tools/install, se hace así:
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

--Instalamos dependencias previas:
apt-get install cmake pkg-config libfreetype6-dev libfontconfig1-dev libxcb-xfixes0-dev libxkbcommon-dev python3 --no-install-recommends

--Bajamos la última versión estable de: https://github.com/alacritty/alacritty/releases

--Compilamos con:
RUSTFLAGS="-C target-cpu=native" \
cargo build --release --no-default-features --features=wayland

(NO te asustes con lo de la actualización de CRATES, es como se llaman las librerías en RUST)

--Instalamos simplemente haciendo:
cp target/release/alacritty /usr/local/bin/

--Creamos ~/.config/alacritty/alacritty.toml con este contenido:
(Tenemos todas las posibles opciones de configuración aquí: https://alacritty.org/config-alacritty.html)

[window]                                                                                                                                         
                                                                                                                                                 
#startup_mode = "Windowed"                                                                                                                       
#startup_mode = "Maximized"                                                                                                                      
startup_mode = "Fullscreen"                                                                                                                      
opacity = 0.8                                                                                                                                    
                                                                                                                                                 
[font]                                                                                                                                           
                                                                                                                                                 
size = 18                                                                                                                                        
                                                                                                                                                 
[colors]                                                                                                                                         
                                                                                                                                                 
[colors.primary]                                                                                                                                 
background="#101010"                                                                                                                             
foreground="#126e00"                                                                                                                             
                                                                                                                                                 
[cursor]                                                                                                                                         
                                                                                                                                                 
style = { blinking = "on" }                                                                                                                      
blink_timeout = 0 

INSTALAR KITTY, UN EMULADOR DE TERMINAL PARA WAYLAND
====================================================

--Requisito previo: GLFW, que es lo que usa Kitty para dibujar en pantalla.
Nos bajamos la última estable de GLFW de:
https://www.glfw.org/

Y configuramos, compilamos e instalamos GLFW:
mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=1 -DGLFW_USE_WAYLAND=1 -DGLFW_BUILD_EXAMPLES=0 -DGLFW_BUILD_TESTS=0 \
-DCMAKE_C_FLAGS="-DEGL_NO_X11 -march=native -mtune=native"

make -j4
sudo make install

AHORA VAMOS A POR KITTY EN SÍ...

--Clonamos su repo, configuramos y compilamos:

git clone --depth 1 https://github.com/kovidgoyal/kitty

CFLAGS="-march=native -mtune=native" \
./configure

make -j4

--Lo lanzamos en modo fullscreen con:
kitty --start-as fullscreen
(NO, no falta ningún guión).

--Para ajustar la fuente, podemos editar su configuración. Para ello, desde dentro de Kitty, hacemos CTRL+SHIFT+F2,
cambiamos lo que sea y guardamos.
De este modo, se nos crea ~/.config/kitty/kitty.conf, que podemos editar luego y cambiar lo que queramos.

DEBUGEAR PROGRAMAS SOBRE WAYLAND POR SSH
========================================

LO PRIMERO ES ENTENDER cómo va esto.
Los programas que corren en Wayland necesitan XDG_RUNTIME_DIR (que en nuestro sistema mínimo apunta a /run, almacenado en RAM),
para así poder encontrar el fichero "wayland-0", o "wayland-1" o lo que sea, que estará en XDG_RUNTIME_DIR cuando haya una sesión wayland en marcha.
Y del otro lado, el compositor debe exportar WAYLAND_DISPLAY=wayland-0, WAYLAND_DISPLAY=wayland-1...

Vamos, que tenemos que tener seteadas correctamente las variables de entorno XDG_RUNTIME_DIR y WAYLAND_DISPLAY
en el PC normal.

Se hace asi:
Miramos en el sistema "servidor" el valor de las variables:
env | grep XDG_RUNTIME_DIR
env | grep WAYLAND_DISPLAY

Exportamos en el PC de debugueo:
export XDG_RUNTIME_DIR=/run                 <---(Sólo si, NO USANDO systemd, hemos exportado XDG_RUNTIME_DIR=/run en /etc/minimal).
export WAYLAND_DISPLAY=wayland-1

(Puedes elegir que valor exporta Weston en WAYLAND_DISPLAY con el parametro -S).
(Normalmente, si usasemos SSH usaría PAM y pillaría las mismas variables de entorno para todas las sesiones de un usuario).

HABILITAR LOGS DE DEBUGGING DE DRM
==================================

echo 0x19F | sudo tee /sys/module/drm/parameters/debug

dmesg -C

DEBUGUEAR O INVESTIGAR PROBLEMAS DE WLROOTS
===========================================

-Activamos el modo debug del driver DRM del kernel, con 
echo 0x19F | sudo tee /sys/module/drm/parameters/debug
-Con GDB, nos ponemos en atomic_commit(), y justo antes de que se ejecute drmAtomicCommit(), hacemos un "dmesg -C" para limpiar dmesg,
ejecutamos drmAtomicCommit(), y ejecutamos dmesg. Vemos qué propiedades se van a modificar: son las de las líneas en que pone: "Added..."
-Si ahí no vemos errores ni propiedades problemáticas, volvemos a iniciar el compositor con GDB y nos vamos a atomic_crtc_commit(), y
vamos viendo cúales de las llamadas de atomic_add() se ejecutan entre atomic_begin() y atomic_finish(), y ahí ya vemos clarísimamente qué
propiedades del CONNECTOR o del CRTC se van a modificar en la siguiente llamada a atomic_commit(). Porque recuerda que todas estas funciones
están double-buffered, es decir, no tienen efectos hasta que haya una llamada a atomic_commit().


* Un problema muy típico es que se modifiquen propiedades que necesitan full modeset sin que se esté haciendo un full modeset,
es decir, sin que se esté activando el flag DRM_MODE_ATOMIC_ALLOW_MODESET.
Las propiedades que necesitan un full modeset son:
-Que se cambie el CRTC de un conector
-Que se cambie el modo de vídeo de un CRTC
-Que se cambie el estado entre ACIVO/INACTIVO de un CRTC
-...Y que hayamos averiguado por las malas, que se cambie el max_bpc de un CONNECTOR

NNN, FILE MANAGER LIGERO PARA EMULADOR DE TERMINAL
==================================================

Clonamos los últimos sources (la stable tiene problemas con los iconos):
git clone --depth 1 https://github.com/jarun/nnn.git

Compilamos e instalamos con:
CFLAGS="-march=native -mtune=native" make O_NORL=1 O_NERD=1 -j4
make install

Para tener iconos gráficos junto a los nombres de archivo, tenemos que tener una fuente puesta en el emulador de terminal que los soporte,
es decir que por ejemplo el emulador de terminal FOOT tiene que tener una fuente parcheada con NERD:
	-Bajamos el zip de una fuente parcheada nerdfont de aquí: https://www.nerdfonts.com/font-downloads
	 (Son fuentes que podrías instalarte como paquetes desde Debian, pero estas versiones parcheadas Nerd traen glifos
	 que permiten mostrar iconos gráficos en la consola.)
	 Por ejemplo, yo me suelo bajar JetBrainsMono. Metemos los contenidos del zip en /usr/local/share/fonts/truetype/jetbrains.
	-Instalamos la herramientra que nos permite regenerar la caché de fuentes del sistema: apt-get install fontconfig
	-Regeneramos la caché de fuentes del sistema, y confirmamos qué fuentes de la famila JetBrains están reconocidas en él:
		fc-cache -f -v
	    fc-list | grep JetBrains
	-Supongamos que queremos, de entre las fuentes listadas que tenemos en la caché, la llamada "JetBrainsMono Nerd Font". Pues pondremos:
	    -En el ~/.config/foot/foot.ini: font=JetBrainsMono Nerd Font:size=10

Si no te salen iconos al lado de los ficheros a pesar de haber instalado la nerdfont, simplemente reinicia la terminal
y vuelve a lanzar nnn, y ya deberían salir.

PARA QUE LANCE SCRIPTS EJECUTABLES, TENEMOS QUE DARLES LA EXTENSIÓN .run:

1) Copiamos el contenido del directorio "plugins" que viene con los sources a ~/.config/nnn/plugins/
(El directorio ~/.config/nnn/plugins/ se crea la primera vez que ejecutamos nnn).

2) La idea es que no se pueda ejecutar cualquier cosa, sino sólo los .run que nosotros creemos. A tal efecto,
editamos ~/.config/nnn/plugins/nuke y añadimos, debajo de la sección "Log files", por ejemplo, nuestra propia sección para lanzar archivos .run:
## Run files
        run)
            /usr/bin/sh "${FPATH}"
            exit 0;;

3) Ahora tenemos que decirle a nnn con qué plugin queremos abrir los archivos. Para ello, creamos un script que setee ciertas
variables de entorno y luego lance el nnn, que llamaremos /usr/local/bin/n, con el contenido:

PATH=$PATH:$HOME/.config/nnn/plugins NNN_OPENER=nuke nnn

(NOTA: NO podemos añadir el seteo de estas variables de entorno a .bash_profile, ni a /etc/profile ni a /etc/environment porque
todos esos ficheros son leidos por un bash, que nosotros no lanzamos porque lanzamos directamente nnn: por eso las seteamos
en el script de lanzamiento de nnn, ese tal /usr/local/bin/n).

4) Como la idea es que si usamos nnn sea nuestro shell y no tener que escribir comandos, añadimos a ~/.config/foot/foot.ini:
shell=n

PARA QUE LANCE AUTOMÁTICAMENTE ROMS DE SISTEMAS EMULADOS

Donde hemos añadido lo de los archivos .run, añadimos debajo cosas como estas:

        ## NES files
        nes)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/nestopia_libretro.so -- "${FPATH}"
            exit 0;;

        ## Master System, Megadrive, GameGear and SG-1000 files (Don't use .md extension because               
        ## these are  markdown text files!)                                                                    
        smd|sms|gg|sg)                                                                                         
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/genesis_plus_gx_libretro.so -- "${FPATH}"    
            exit 0;;

        ## PCE files
        pce)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/mednafen_pce_libretro.so -- "${FPATH}"
            exit 0;;

        ## Gameboy & Gameboy Color files
        gb|gbc)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/gambatte_libretro.so -- "${FPATH}"
            exit 0;;

        ## GBA files
        gba)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/mgba_libretro.so -- "${FPATH}"
            exit 0;;

        ## SNES files
        smc|sfc)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/mednafen_supafaust_libretro.so -- "${FPATH}"
            exit 0;;

        ## LYNX files
        lnx)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/mednafen_lynx_libretro.so -- "${FPATH}"
            exit 0;;

        ## FBNEO files
        fbneo)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/fbneo_libretro.so -- "${FPATH}"
            exit 0;;

        ## MSX files
        msx)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/fbneo_libretro.so --subsystem=msx -- "${FPATH}"
            exit 0;;

		## PSX files (Eliminamos la extensión .psx y añadimos la extensión .chd, porque en realidad cargamos los .chd).
        psx)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/swanstation_libretro.so -- "${FPATH%.psx}.chd"
            exit 0;;
            
        ## MCD files (Eliminamos la extensión .mcd y añadimos la extensión .chd, porque en realidad cargamos los .chd).
        mcd)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/genesis_plus_gx_libretro.so -- "${FPATH%.mcd}.chd"
            exit 0;;

		## PCD files (Eliminamos la extensión .pcd y añadimos la extensión .chd, porque en realidad cargamos los .chd).
        pcd)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/mednafen_pce_fast_libretro.so -- "${FPATH%.pcd}.chd"
            exit 0;;

		## Virtual Boy VB files (Ponemos un modo de vídeo de 50Hz)
        vb)
            wlr-randr --output HDMI-A-1 --custom-mode 1920x1080@50
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/mednafen_vb_libretro.so -- "${FPATH%}"
            wlr-randr --output HDMI-A-1 --custom-mode 1920x1080@60
            exit 0;;

		## Amiga HDF files (Ponemos un modo de vídeo de 50Hz)
        hdf)
            wlr-randr --output HDMI-A-1 --custom-mode 1920x1080@50
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/puae_libretro.so -- "${FPATH%}"
            wlr-randr --output HDMI-A-1 --custom-mode 1920x1080@60
            exit 0;;

		## ST files (Ponemos un modo de vídeo de 50Hz)
        st|msa)
            wlr-randr --output HDMI-A-1 --custom-mode 1920x1080@50
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/hatarib.so -- "${FPATH}"
            wlr-randr --output HDMI-A-1 --custom-mode 1920x1080@60
            exit 0;;

...Y para crear los .fbneo, nos vamos al directorio de arcade o de neogeo o de lo que sea y creamos un link simbólico de cada .zip, así:
for file in *.zip; do ln -s -- "$file" "${file%.zip}.fbneo"; done

...Y para crear los .msx, nos vamos al directorio de msx y creamos un link simbólico de cada .zip, así:
for file in *.zip; do ln -s -- "$file" "${file%.zip}.msx"; done

...Y para crear los .psx, nos vamos al directorio de PlayStation y creamos un link simbólico de cada .chd, así:
for file in *.chd; do ln -s -- "$file" "${file%.chd}.psx"; done

...Y para crear los .mcd, nos vamos al directorio de MegaCD y creamos un link simbólico de cada .chd, así:
for file in *.chd; do ln -s -- "$file" "${file%.chd}.mcd"; done

...Y para crear los .pcd, nos vamos al directorio de PCE-CD y creamos un link simbólico de cada .chd, así:
for file in *.chd; do ln -s -- "$file" "${file%.chd}.pcd"; done

NOTAS PARA PODER USAR WAYLAND EN EL FUTURO
==========================================

Actualmente no es alternativa de uso diario porque todo lo de Vulkan va a tener lag debido a que siempre va a darnos un swapchain de 4:
https://github.com/libretro/RetroArch/issues/13812
Que da lugar a esta issue en gitlab:
https://gitlab.freedesktop.org/mesa/mesa/-/issues/6249
Hasta que no se resuelvan esas dos issues, Wayland no sirve para Vulkan sin latencia.

Es un problema común de TODAS las implementaciones de Vulkan en Wayland, da igual que sea AMD, VC4, INTEL...
Todo se reduce a que se haga un merge de esto en MESA:
https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/12086

Se podría usar GLES2 para RetroArch en lugar de Vulkan, pero el backend de contexto WAYLAND de RetroArch tampoco tiene un
mecanismo explícito para esperar a que se complete el eglSwapBuffers() que hacemos en gfx_ctx_wl_swap_buffers()
en gfx/drivers_context/wayland_ctx.c, así que simplemente se está haciendo eglSwapBuffers() y el driver decide. Mal.

INTENTO DE COMPILAR MUTTER, EL COMPOSITOR DE GNOME
==================================================

Instalamos dependencias previas:
apt-get install libgraphene-1.0-dev --no-install-recommends
(OJO: para desinstalar libgraphene y sus dependencias, tenemos que hacerlo manualmente así o nos deja basura:
apt-get purge gir1.2-freedesktop gir1.2-glib-2.0 gir1.2-graphene-1.0 gobject-introspection libgirepository-1.0-1 libgirepository1.0-dev libgraphene-1.0-0 libgraphene-1.0-dev python3-markdown)

apt-get install python3-docutils libatk1.0-dev libgdk-pixbuf2.0-bin --no-install-recommends

Instalamos otra dependencia previa, gtk3+ (OJO, es GTK3+, NO GTK3 NI GTK4!!!, SINO QUE DEBE SER EL QUE LLEVA EL "PLUS"):
-Nos bajamos los últimos sources estables de: https://download.gnome.org/sources/gtk+ 
(Yo uso https://download.gnome.org/sources/gtk+/3.24/gtk%2B-3.24.34.tar.xz , ya que es lo que indica Linux From Scratch
 que hace falta para compilar mutter).
-Configuramos gtk3+ con:
meson .. -Dbuildtype=release -Ddemos=false -Dx11_backend=false -Dintrospection=false -Ddemos=false -Dexamples=false

Instalamos otra diferencia previa, PANGO, ya que la que trae Debian depende de mierdas de X11:
-Instalamos dependencias previas: apt-get install libglib2.0-dev libfontconfig-dev
-Desinstalamos el pango del sistema: apt-get purge libpango* && apt-get autoremove
-Bajamos los últimos sources estables de: https://github.com/GNOME/pango/tags
-Configuramos con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Dlibthai=disabled -Dxft=disabled ..

AHORA VAMOS CON MUTTER EN SÍ
-Clonamos su repo:
git clone --depth 1 https://github.com/GNOME/mutter.git
-Configuramos con:
meson -Dbuildtype=release ..

INSTALAR SWAY, COMPOSITOR TILING (Y STACKING CON UN TRUCO)
==========================================================

Instalamos dependencias previas:
apt-get install libjson-c-dev --no-install-recommends

Instalamos otra diferencia previa, PANGO, ya que la que trae Debian depende de mierdas de X11:
-Instalamos dependencias previas: apt-get install libglib2.0-dev libfontconfig-dev
-Desinstalamos el pango del sistema: apt-get purge libpango* && apt-get autoremove
-Bajamos los últimos sources estables de: https://github.com/GNOME/pango/tags
-Configuramos con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dlibthai=disabled -Dxft=disabled ..

Ahora vamos a por SWAY en sí:
-Bajamos la última estable o RC de: https://github.com/swaywm/sway/releases
-Configuramos con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Dswaybar=false -Dswaynag=false -Dgdk-pixbuf=disabled \
-Dfish-completions=false -Dzsh-completions=false -Ddefault-wallpaper=false -Dman-pages=disabled ..

Copiamos el fichero "config" que viene con los sources a ~/.config/sway/config, y hacemos ahí los cambios que queramos, como por ejemplo:
(Vamos buscando los comentarios y dejamos debajo los valores que queramos)

-Para tener una fuente con glifos: En el ~/.config/sway/config: font JetBrainsMono Nerd Font 14
(Ver en la sección del nnn cómo instalar estas fuentes).

-Para que la tecla MOD sea ALT, de manera que todos los demás atajos funcionen:
# Logo key. Use Mod1 for Alt.
set $mod Mod1

-Para que se use el modo de vídeo actual:
output HDMI-A-1 resolution 1920x1080@60 position 0,0

-(NECESARIO PARA USAR MAX_SWAPCHAIN 2 SIN FRAMERATE HALVING)
Para controlar el max_render_time (el tiempo que le damos a los clientes, es decir, los programas que usan Wayland, para presentar sus frames
antes del scanout: a menor max_render_time menos latencia, se supone) añadimos a la línea de output:
output HDMI-A-1 max_render_time 12

-Para tener el teclado en castellano:
input type:keyboard {
        xkb_layout es
		xkb_variant deadtilde
}

-Para lanzar el terminal con CTRL+ALT+T:
# Start a terminal
bindsym Ctrl+$mod+t exec $term

-Para cerrar ventanas con ALT+F4:
# Kill focused window
bindsym $mod+f4 kill

-Para cerrar SWAY con CTRL+ALT+BACKSPACE, sin confirmación ni chorradas:
# Exit sway (logs you out of your Wayland session)
bindsym $mod+Ctrl+backspace exec swaymsg exit

-Para ocultar el cursor del ratón cuando no lo estamos usando (al cabo de 3 segundos en este ejemplo):
seat seat0 hide_cursor 3000

-Para lanzar el terminal "foot" al arrancar Sway:
exec swaymsg "workspace 1; exec foot;"

-Para escalar la fuente monospace por defecto:
font monospace 16
	
-Para evitar que las ventanas maximizadas tengan bordes, que sobre todo los verticales quedan muy feos (se puede poner
vertical, horizontal o both):
hide_edge_borders both

-Para que las ventanas no tengan el nombre arriba:
default_border none

-Para que no haga eso tan molesto de que cada vez que pones el raton en una ventana, esa ventana pilla el foco:
focus_follows_mouse no

-Para que las ventanas no tengan borde ni nombre ni nada:
default_border none

-Para que las ventanas sean "floating windows" en lugar de tiling:

for_window [app_id=".*"] floating enable
for_window [app_id=".*"] border normal

-Para implementar un ALT+TAB que cambia a la ventana de la izquierda, y con ALT+SHIFT+TAB a la ventana de la derecha, 
añade en la seccion "Key bindings":
bindsym $mod+Tab focus left
bindsym $mod+Shift+Tab focus right

--Para tener fondo de pantalla:
Nos bajamos la última estable de aquí: https://github.com/swaywm/swaybg/releases
Configuramos, compilamos e instalamos con:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Dgdk-pixbuf=disabled -Dman-pages=disabled ..

Y en ~/.config/labwc/autostart:

exec swaymsg "workspace 1; exec swaybg -i atari.png &;"

(NOTA: Acepta sólo PNG a no ser que lo compiles con gdk-pixbuf habilitado, así que con PNG nos vale).

-PARA MAS OPCIONES: https://manpages.ubuntu.com/manpages/focal/man5/sway.5.html

INSTALAR LABWC, COMPOSITOR WINDOW-STACKING (NECESITA WLROOTS)
=============================================================

Instalamos dependencias previas:
apt-get install libxml2-dev libglib2.0-dev --no-install-recommends

-Instalamos manualmente una dependencia previa, CAIRO, ya que el paquete de DEBIAN viene con dependencias de X11:
--Instalamos dependencias previas de CAIRO: apt-get install libfontconfig-dev
--Bajamos los últimos sources estables de: https://gitlab.freedesktop.org/cairo/cairo/-/releases
--Configuramos con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Dzlib=disabled -Dtests=disabled -Ddwrite=disabled ..

Instalamos otra diferencia previa, PANGO, ya que la que trae Debian depende de mierdas de X11:
-Instalamos dependencias previas: apt-get install libfribidi-dev libharfbuzz-dev libglib2.0-dev libfontconfig-dev --no-install-recommends
-Desinstalamos el pango del sistema: apt-get purge libpango* && apt-get autoremove
-Bajamos los últimos sources estables de: https://github.com/GNOME/pango/tags
-Configuramos con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Dlibthai=disabled -Dxft=disabled ..

Instalar labwc en sí:

Bajamos la última release estable de aquí:
https://github.com/labwc/labwc/releases

(PARA SOLUCIONAR LO DE LOS PROGRAMAS DE SDL2 EN MODO DE PANTALLA COMPLETA)
Editamos src/xdg.c, y al final de la función handle_commit(), bajo el comentario que empieza "wlroots retains the size"...,
comentamos esto que hay:

struct wlr_xdg_toplevel *toplevel =
						xdg_toplevel_from_view(view);
						toplevel->scheduled.width = view->current.width;
						toplevel->scheduled.height = view->current.height;

Configuramos con:

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Dxwayland=disabled ..

PARA PODER LANZAR LABWC O CUALQUIER COMPOSITOR, ANTES TENEMOS QUE AÑADIR A ~/.bashrc:
rundir="/run/user/0"
if [[ ! -e $rundir ]]; then
    mkdir -p $rundir
fi
export XDG_RUNTIME_DIR=$rundir

Podemos lanzar un programa a la vez que el compositor con:
labwc -s foot
Pero lo suyo es meterlo en ~/.config/labwc/autostart así:
/usr/local/bin/foot >/dev/null 2>&1 &

////BLOQUE CONFIGURACIÓN DE LABWC////
(info sacada de esta guía: https://labwc.github.io/getting-started.html)
(para ver todas las opciones posibles: https://github.com/labwc/labwc/blob/master/docs/rc.xml.all)

--Para teclado en español creamos ~/.config/labwc/environment con el contenido:
XKB_DEFAULT_LAYOUT=es
XKB_DEFAULT_VARIANT=deadtilde
Para teclado en inglés sin deadkeys de manera que la "~" salga correctamente sería:
XKB_DEFAULT_LAYOUT=us
XKB_DEFAULT_VARIANT=altgr-intl

--Para que se lanze el foot automáticamente, creamos ~/.config/labwc/autostart con el contenido:
/usr/local/bin/foot >/dev/null 2>&1 &

AHORA CREAMOS  ~/.config/labwc/rc.xml Y LE VAMOS AÑADIENDO COSAS:

<?xml version="1.0" ?>
<labwc_config>

	<core>
		<reuseOutputMode>yes</reuseOutputMode>
	</core>

	<keyboard>
		<keybind key="C-A-t"><action name="Execute" command="foot" /></keybind>
		<keybind key="C-A-KP_Delete"><action name="Execute" command="reboot" /></keybind>
		<keybind key="C-A-BackSpace"><action name="Exit" /></keybind>
		<keybind key="A-Tab"><action name="NextWindow" /></keybind>
		<keybind key="A-F4"><action name="Close" /></keybind>
	</keyboard>

	<theme>
    	<name>BL-Lithium</name>
    	<cornerRadius>0</cornerRadius>
    	<font> 
                <name>JetBrainsMonoNerdFont</name>
                <size>14</size>
        </font>
	</theme>

</labwc_config>

--Para poder ver los eventos de teclado, podemos verlo desde un ordenador con X11 (son los mismos eventos),
pero si nos empeñamos en verlo desde wayland, podemos usar wev:
git clone --depth 1 https://git.sr.ht/~sircmpwn/wev
CFLAGS="-march=native -mtune=native" make -j4
make install

--Para ver más acciones de labwc (como lo de Execute, Exit, etc...) que podrías asignar a combinaciones de teclado:
https://labwc.github.io/labwc-actions.5.html

--Para ver ejemplos de atajos de teclado posibles:
https://github.com/labwc/labwc/blob/master/docs/rc.xml.all

--Para activar el Adaptive Sync / FreeSync / VRR (las tres cosas son lo mismo), añadimos esto en la sección <core>:
<core>                                                                                                                                   
    <adaptiveSync>yes</adaptiveSync>                                                                                                 
</core>

--Para instalar temas:
----Metemos los temas que queramos en ~/.local/share/themes. Cada tema debe incluir un directorio llamado "openbox-3".
    Por ejemplo, el tema "BL-Lithium" tendrá que estar en "~/.local/share/themes/BL-Lithium" y dentro tendrá un directorio "openbox-3"
    Vamos a instalar un pack de temas muy buenos:
    git clone --depth 1 https://github.com/BunsenLabs/bunsen-themes.git
    cd bunsen-themes/themes
    cp -R * ~/.local/share/themes 
----Ahora, en rc.xml, ponemos el nombre del tema que queramos usar en la etiqueta <name>nombre_tema</name> de la categoría <theme>
    Por ejemplo: <name>Dragon</name>
----OPCIONAL: Si te gusta un tema y quieres modificar cosas, edita su fichero "themerc", todos tienen uno.
	Por ejemplo, algunos temas no ponen bordes a las ventanas. Puedes cambiar eso poniendo border.width a 4 o así.

--Para tener fondo de pantalla:
Nos bajamos la última estable de aquí: https://github.com/swaywm/swaybg/releases
Configuramos, compilamos e instalamos con:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Dgdk-pixbuf=disabled -Dman-pages=disabled ..

Y en ~/.config/labwc/autostart:

swaybg -i atari.png >/dev/null 2>&1 &

(NOTA: Acepta sólo PNG a no ser que lo compiles con gdk-pixbuf habilitado, así que con PNG nos vale).

LANZAR WAYLAND COMO SERVICIO DE SYSTEMD
=======================================

Creamos /usr/local/bin/launch-wayfire (o el compositor que sea) con el contenido:

#############

#!/bin/bash
rundir="/run/user/0"
if [[ ! -e $rundir ]]; then
    mkdir -p $rundir
fi
export XDG_RUNTIME_DIR=/run/user/0
/usr/local/bin/wayfire

#############

HACEMOS EJECUTABLE /usr/local/bin/launch-wayfire:
chmod +x /usr/local/bin/launch-wayfire


Creamos /etc/systemd/system/wayland.service con el contenido:

#############

[Unit]
Description=Wayland compositor

[Service]
User=root
Group=root
PAMName=login
WorkingDirectory=%h
ExecStart=
ExecStart=-/usr/local/bin/launch-wayfire
Restart=always

[Install]
WantedBy=graphical.target

#############
*NOTA: Tal como está, está pensado para que al salir de LABWC el sistema se apague. Esto nos interesa porque puede que no
 arranquemos a una consola de comandos y por tanto no tendríamos manera de apagarlo a mano sin esto.
 Si quisiésemos que al salir de LABWC se volviese a levantar el servicio, pondríamos Restart=always y quitaríamos las líneas
 de Type=oneshot y ExecStartPost=...
*NOTA: El WorkingDirectory puesto a "%h" significa usar nuestro $HOME, que sera /root si no eres otro usario. 
*NOTA: Si tuvieramos que añadir mas servicios, irian con:
[Install]
WantedBy=default.target
...en vez de graphical.target, porque lo que nos interesa es que esos servicios se lancen sea cual sea el target
que tengamos puesto como default, NO nos interesa que se lancen solo cuando el target puesto como default sea graphical.
El caso de labwc es especial, porque solo se tiene que lanzar cuando el target sea graphical).
*NOTA
-Podemos ver los targets activos con: systemctl list-units --type target
-Podemos ver los targets que hay en el sistema, aunque no esten activos, mirando en /lib/systemd/system

Establecemos graphical.target como target por defecto:
systemctl set-default graphical.target
Podemos comprobarlo con:
systemctl get-default
(Si alguna vez quisieramos volver a un modo de texto, estableceriamos el target multi-user como target por defecto:
systemctl set-default multi-user.target
Y NO HARIA FALTA VOLVER A DESACTIVAR EL SERVICIO LABWC, YA QUE NOS QUEDAMOS EN EL TARGET MULTI-USER Y DE ESE MODO
NO SE CARGA EL SERVICIO LABWC.)

Ahora activamos el servicio WAYLAND con:
systemctl enable wayland.service
(Recuerda que lo que hace esto es crear el symlink /etc/systemd/system/graphical.target.wants/labwc.service apuntando
a /etc/systemd/system/labwc.service, que es logico porque el target graphical.target necesita labwc.target tal como hemos
especificado en la UNIT de labwc). 

Desactivamos el autologin en TTY con:
systemctl disable getty@tty1

Ahora ya configuramos el BASH.
Al principio del todo de ~/.bashrc ponemos esto para evitar problemas con el saludo y el scp:
# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

Para añadir al PATH el diretorio actual, que no nos muestre todo el rato el usuario y el hostname,
y que nos muestre un mensaje de bienvenida y la IP añadimos en ~/.bashrc:
PATH=$PATH:.
PS1="\W "
MY_IP=$(ip -4 addr show wlan0 | grep -oP '(?<=inet\s)\d+(\.\d+){3}')

echo "                                               "
echo " ^_^    Welcome to Debian 12 GNU/Linux aarch64."
echo "(O,O)   Service management is done via SystemD."
echo "/)_)    This computer's local IP is $MY_IP"
echo " ¨ ¨    Have fun!"  
echo "     "

Para poder ejecutar por ssh programas que corran sobre Wayland:
rundir="/run/user/0"
if [[ ! -e $rundir ]]; then
    mkdir -p $rundir
fi
export XDG_RUNTIME_DIR=$rundir
export WAYLAND_DISPLAY=wayland-1
(OJO: Si no funciona con estos valores, mira qué valores tienen estas variables de entorno en el sistema "servidor").

Para que no se vea el cursor parpadeante de la TTY, añadimos a cmdline.txt:
vt.global_cursor_default=0

RELOJ EN WAYLAND
================

git clone --depth 1 https://git.sr.ht/~leon_plickat/wlclock

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release ..

ninja -j4
ninja install

Y en ~/.config/labwc/autostart:
wlclock --border-size 4 --position top-left --size 150 --layer bottom --background-colour "#22373f" --b    order-colour "#152126" >/dev/null 2>&1 &

INSTALAR GAMESCOPE, EL MICROCOMPOSITOR DE STEAM
===============================================
(NO se puede instalar en Debian 12 porque XWayland no compila contra las versiones de Debian 12 de las librerías de X11 necesarias)

-Instalamos dependencias previas:
apt-get install libx11-dev libx11-xcb-dev libxdamage-dev libxcomposite-dev libxcursor-dev libxxf86vm-dev libxtst-dev libxrender-dev \
libxtst-dev libxres-dev libxmu-dev --no-install-recommends

					########BLOQUE XWAYLAND########

Instalamos dependencia previa, XWayland

--Instalamos dependencia previa: libepoxy. Busca las instrucciones en LINUX_KNOWLEDGE.TXT

git clone --depth 1 https://gitlab.freedesktop.org/xorg/xserver.git

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Dxorg=false -Dxwayland=true -Dxvfb=false \
-Dxnest=false -Dxquartz=false -Dxwin=false -Ddocs=false -Dglx=false ..

					########FIN BLOQUE XWAYLAND########

-Instalamos dependencia previa, hwdata.
--Primero desinstalamos la versión de Debian, ya que le faltan los archivos de pkg-config
y el buildsystem de gamescope no la detecta:
apt-get purge hwdata
apt-get autoremove
--Ahora nos bajamos la última estable de:
https://github.com/vcrhonek/hwdata/releases
Descomprimimos y directamente hacemos:
./config
make install
(NO hay que compilar nada)

VAMOS CON GAMESCOPE EN SÍ:

git clone --depth 1 https://github.com/Plagman/gamescope.git
cd gamescope
git -c submodule."subprojects/openvr".update=none submodule update --init

(^NOTA: el "git submodule update..." lo hacemos así para evitar a toda costa que se descargue el submódulo openvr, que no lo vamos a usar
y ocupa 500 MB...)

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release -Denable_openvr_support=false -Dpipewire=disabled ..

ninja -j4
ninja install

Y ahora podemos lanzar lo que queramos con:
gamescope -- <ejecutable>

O podemos lanzar el gamescope desde la TTY directamente como otro compositor cualquiera con:
gamescope -e -f -- foot

CAMBIAR LA RESOLUCIÓN AL VUELO EN WAYLAND
=========================================

Usamos wlr-randr para ello.

Clonamos su repo:
git clone --depth 1 https://git.sr.ht/~emersion/wlr-randr

Configuramos, compilamos e instalamos con:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
meson setup -Dbuildtype=release ..

ninja -j4
ninja install

Se usa igual que xrandr.

Para poner 720p:
wlr-randr --output HDMI-A-1 --mode 1280x720@60

Para poner un modo de 50Hz:
wlr-randr --output HDMI-A-1 --mode 1920x1080@50

Para RetroArch, de todos modos, no debería hacerse así.
Por ejemplo para que RA nos ponga un modo de 50Hz al lanzar el core de Virtual Boy, activamos la opción video_autoswitch_refresh_rate = "1"
en retroach.cfg, y en los overrides del core (en este caso .config/retroarch/config/Beetle VB/Beetle VB.cfg) ponemos
video_refresh_rate = "50.005001". Esa frecuencia se ha detectado poniendo el modo de vídeo a 50Hz con wlr-ranrd y entrando en RA.
Y al cargar una ROM de ese core, debería cambiarnos el modo de vídeo a 50Hz. (OJO: En Wayland de momento no funciona, sólo en KMS/DRM).


CÓMO SABER SI UN PROGRAMA ESTÁ CORRIENDO EN MODO DIRECT SCANOUT ON WAYLAND
==========================================================================

Lanza el compositor en modo verbose, por SSH, y enseguida lo ves.
Para poder lanzar un compositor por SSH antes debes hacer:

rundir="/run/user/0"
export XDG_RUNTIME_DIR=$rundir

Ahora, lanzamos labwc así:
labwc -d

Ejecutamos RetroArch, o algún juego de SDL2, y enseguida vemos:

00:00:15.025 [types/scene/wlr_scene.c:1709] Direct scan-out enabled

Y al salir el programa en cuestión:

00:00:15.025 [types/scene/wlr_scene.c:1709] Direct scan-out enabled
