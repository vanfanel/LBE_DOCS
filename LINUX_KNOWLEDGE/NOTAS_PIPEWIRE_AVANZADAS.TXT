=================================================================
== COMPILAR E INSTALAR PIPEWIRE + WIREPLUMBER A MANO EN DEBIAN ==
=================================================================
(OJO!!! NO ES NECESARIO PARA NADA, NO APORTA NINGUNA VENTAJA!!!)

Nos bajamos la última release de aquí:
https://gitlab.freedesktop.org/pipewire/pipewire/-/releases

Configuramos y compilamos con meson así:

CFLAGS="-march=native -mtune=native -O2 -fomit-frame-pointer" \
CXXFLAGS="-march=native -mtune=native -O2 -fomit-frame-pointer" \
meson setup -Dgstreamer=disabled -Dbluez5=disabled -Djack=disabled -Dpipewire-jack=disabled \
-Dv4l2=disabled -Dpipewire-v4l2=disabled -Dman=disabled -Draop=disabled -Dopus=disabled ..

ninja -j4
sudo ninja install
sudo ldconfig
(OJO!!! SIEMPRE regenera la caché de librerías después de instalar!!)

--Wireplumber se compila e instala al compilar e instalar pipewire (a no ser que le dijésemos que no lo haga, cosa que NO hemos hecho).
Pero de entrada da unos errores que queremos quitar:
----Para que no nos de errores de BLUEZ y V4L2, editamos /usr/local/share/wireplumber/wireplumber.conf
y buscamos estas líneas y las ponemos a "disabled":
hardware.bluetooth = required
hardware.video-capture = required
----Para que no nos de errores tipo "assertion 'already_registered_dispatcher == self' failed"
editamos /usr/local/share/wireplumber/wireplumber.conf, buscamos "automute-alsa-routes" y comentamos esa sección incluida las llaves,
y justo debajo en la sección "policy.device.routes" quitamos de los wants el "hooks.device.routes.automute-alsa".

--PROBAMOS A LANZAR UN PROGRAMA SDL2 SOBRE PIPEWIRE ASÍ:

pipewire &
wireplumber &

SDL_AUDIODRIVER=pipewire ./prince.bin

pkill wireplumber
pkill pipewire

--Ahora ponemos a punto pipewire-alsa, la capa de emulación de ALSA sobre PIPEWIRE.
----Al ser una compilación nuestra de PIPEWIRE, los plugins que PIPEWIRE le mete a ALSA para que ALSA corra sobre PIPEWIRE
    se instalan en /usr/local/lib/x86_64-linux-gnu/alsa-lib en vez de en /usr/lib/x86_64-linux-gnu/alsa-lib que es donde ALSA
    los busca normalmente. Así que le decimos a ALSA dónde buscar los plugins.
    Para que lo vean los programas gráficos lanzados desde Wayland (ya que esto es leído por "systemd user session",
    cosa que sucede porque hemos lanzado Wayland usando un servicio de SystemD)
    creamos "~/.config/environment.d/pipewire.conf" con el contenido: 
	ALSA_PLUGIN_DIR=/usr/local/lib/x86_64-linux-gnu/alsa-lib
	Para que lo vean los programas lanzados desde la terminal o desde SSH, añadimos a .bashrc:
	export ALSA_PLUGIN_DIR=/usr/local/lib/x86_64-linux-gnu/alsa-lib
----Y para que cargue los plugins, que físicamente son unas librerías .so, creamos /etc/asound.conf con el contenido:    

# Al decirle "type pipewire" ALSA buscará los plugins llamados "libasound_module_ctl_pipewire.so" y "libasound_module_pcm_pipewire.so".
# Si le dijésemos "type pepito" buscaría "libasound_module_ctl_pepito.so" y "libasound_module_pcm_pepito.so")
pcm.pipewire {
    type pipewire
}

ctl.pipewire {
    type pipewire
}

pcm.!default {
    type pipewire
}

ctl.!default {
    type pipewire
}
----Probamos pipewire-alsa con:
pipewire &
wireplumber &
speaker-test -D pipewire
pkill wireplumber
pkill pipeqire
    ...Y debería sonar.

--BLOQUE Para que Pipewire se inicie automáticamente como servicio:

----Creamos ".config/systemd/user/pipewire.service" con el contenido:
[Unit]
Description=PipeWire Multimedia Service
# Un socket en el contexto de systemd es lo que usan los programas
# para comunicarse con un servicio del sistema.
# Nos interesa que Pipewire se lance mediante socket porque así sólo corre
# cuando un programa usa el audio, no está corriendo todo el rato.
Requires=pipewire.socket dbus.service 
ConditionUser=!root

[Service]
LockPersonality=yes
MemoryDenyWriteExecute=yes
NoNewPrivileges=yes
RestrictNamespaces=yes
SystemCallArchitectures=native
SystemCallFilter=@system-service
Type=simple
ExecStart=/usr/local/bin/pipewire
Restart=on-failure
Slice=session.slice

[Install]
Also=pipewire.socket
WantedBy=default.target

----Creamos ".config/systemd/user/pipewire.socket" con el contenido:
[Unit]
Description=PipeWire Multimedia System Sockets
ConditionUser=!root

[Socket]
Priority=6
ListenStream=%t/pipewire-0
ListenStream=%t/pipewire-0-manager

[Install]
WantedBy=sockets.target

----Creamos ".config/systemd/user/wireplumber.service" con el contenido:
[Unit]
Description=Multimedia Service Session Manager
After=pipewire.service
BindsTo=pipewire.service
Conflicts=pipewire-media-session.service

[Service]
LockPersonality=yes
MemoryDenyWriteExecute=yes
NoNewPrivileges=yes
SystemCallArchitectures=native
SystemCallFilter=@system-service
Type=simple
ExecStart=/usr/local/bin/wireplumber
Restart=on-failure
Slice=session.slice
Environment=GIO_USE_VFS=local

[Install]
WantedBy=pipewire.service

----Activamos ambos servicios, lanzamos el servicio de pipewire (ya se encargará la unit de pipewire de lanzar la de wireplumber)
y comprobamos que se está ejecutando correctamente:
systemctl --user enable pipewire
systemctl --user enable wireplumber
systemctl --user start pipewire
systemctl --user status pipewire

--FIN BLOQUE Para que Pipewire se inicie automáticamente como servicio.

--RECUERDA: Podemos ver la prioridad de los hilos creados por Pipewire con:
ps -eLo pid,tid,comm,policy,rtprio,ni | grep $(pidof pipewire)
OJO!!!! El hilo principal "pipewire" NO tendrá prioridad RT ni tiene por qué tenerla,
pero los hilos de audio que crea, SÍ que nos saldrán con FF y 88!!!!
(O el valor de RTPrio que tengamos en el argumento "rt.prio" del módulo "libpipewire-module-rt"
 en /usr/local/share/pipewire/pipewire.conf)
