EXTRAER EL PRG Y CHR DE UN ARCHIVO .NES
=======================================
ALGUNA INFO PROCEDE DE: https://forums.nesdev.org/viewtopic.php?t=5661

Recuerda que cada dos caracteres en Hexedit son un byte.

Un .NES está estructurado así: header + PRG ROM + CHR ROM.
A veces sólo tienen: header + PRG ROM.

La cabecera de un .NES son 16 bytes. Eso fijo.
Podemos ver el tamaño del PRG y CHR de cada .NES concreto abriéndolo con HEXEDIT:
El byte 0x0004, es decir, el byte con la quinta posición, es el tamaño del PRG en bloques de 16K (16384 bytes).
El byte 0x0005, es decir, el byte con la sexta posición, es el tamaño del CHR en bloques de 8K (8192 bytes).
(También podríamos cargarlo con el MESEN y en "Tools -> Log Window" nos dice el tamaño del PRG y el CHR).

Usando "dd" con los parámetros bs, size, count y skip podemos hacer todo lo necesario para extraer y reinsertar las partes de la ROM.

Supongamos un juego con 128 KB de PRG y 128 KB de CHR llamado "kiwi.nes".
Vamos a "despiezarlo":

--Miramos el byte 0x0004 y 0x0005, que son 0x08 y 0x10, lo que nos dice que tenemos 128 KB de PRG y 128 K de CHR. 

--Extraemos la cabecera:
dd if=kiwi.nes of=header bs=1c count=16 skip=0
("Cada bloque es un byte, no me salto ningún bloque y extraemos 16 bytes").

--Extraemos el PRG:
dd if=kiwi.nes of=kiwi.prg bs=1c skip=16 count=128K
("Cada bloque es 1 byte, nos saltamos los primeros 16 bytes, extraemos 128 KB").

--Extraemos el CHR:
dd if=kiwi.nes of=kiwi.chr bs=1c skip=$((16 + 128*1024)) count=128K
("Cada bloque es 1 byte, nos saltamos los primeros 16 bytes y los siguientes 128 KB, y extraemos 128 KB".
  El número de bytes a saltarnos se calcula usando lo que se llama "aritmética del shell". El cálculo en sí es trivial).

AHORA VAMOS A INTENTAR VOLVER A "MONTAR" EL JUEGO
NOTA: Para saltarse bloques en el destino es con "seek" en vez de "skip" que era para saltárselos en el orígen.
NOTA: Al escribir dentro de un fichero ya existente, tenemos que pasarle "conv=notrunc"
      porque si no, nos sobreescribe el fichero existente con lo que deseamos escribir en él.

--Creo un fichero de 262160 bytes que es el tamaño que tiene el juego original
(16 bytes de cabecera + 128 KB = 131072 bytes de PRG + 128 KB = 131072 bytes de CHR)
dd if=/dev/zero of=kiwi2.nes bs=1c count=262160

--Copio la cabecera a su sitio:
dd if=header of=kiwi2.nes bs=1c skip=0 count=16 conv=notrunc

--Metemos el PRG después de los 16 bytes de la cabecera:
dd if=kiwi.prg of=kiwi2.nes bs=1c seek=16 conv=notrunc

--Metemos el CHR después de la cabecera y el PRG:
dd if=kiwi.chr of=kiwi2.nes bs=1c seek=$((16 + 128*1024)) conv=notrunc

NOS PONEMOS SERIOS: EXTRAER LOS GRÁFICOS EN BLOQUE
==================================================

LO PRIMERO: La PPU de la NES sólo puede acceder a 8KB de tiles en un momento dado (los CHR son más grandes porque se usa bank switching).

La cosa ahora es saber qué parte del CHR está puesto en ese momento en el banco accesible por la PPU:
En MESEN, pausamos el juego en el momento en que están en pantalla los gráficos que queremos cambiar,
vamos a Debug -> Memory Viewer, seleccionamos "PPU Memory", nos ponemos con el ratón en el primer byte,
y nos dice la "CHR Address", que es la dirección en el CHR donde empiezan los 8 KB de tiles que están en ese momento
en el banco accesible por la PPU.
Estos 8 KB van de 0x0000 a 0x1FFF.

Supongamos que la PPU Memory en ese momento empieza en 0xB000.

--Si queremos extraer esos 8 KB de tiles del fichero CHR, hacemos:
dd if=kiwi_pal.chr of=tiles_pal bs=1c count=8192 skip=$((0xB000))

--Si queremos insertar estos 8 KB de tiles en la misma dirección de otro CHR:
dd if=tiles_pal of=kiwi_ntsc.chr bs=1c count=8192 seek=$((0xB000)) conv=notrunc

--Si ahora queremos re-insertar el CHR modificado en la ROM:
dd if=tiles_pal of=kiwi_ntsc.chr bs=1c count=8192 seek=$((0xB000)) conv=notrunc

PERO ESA ES SÓLO LA MITAD DEL PROBLEMA: NO SÓLO NOS INTERESA QUÉ TILES HAY, SINO CÓMO SE COLOCAN ESOS TILES.
ESO LO DETERMINA EL TILEMAP-

Para ver dónde empieza el tilemap, nos vamos a Debug->Tilemap Viwer, y si ponemos el cursor en el primer tile vemos que
"Tilemap Address" es $2000.
Ahora, sabiendo eso, si quisiéramos, a modo de juego, nos podríamos ir a Debug->Memory Viewer, PPU Memory,
y si allí cambiamos valores a partir de la dirección $2000, iríamos viendo cómo cambian tiles en pantalla.

Sabemos que el tilemap irá de $2000 a $23FF porque el tilemap que se ve está en una "NAMETABLE", que está formada por
los índices de los 32x30 = 960 tiles (por ahora simplifiquemos a que la NES puede tener 32x30 = 960 tiles en pantalla)
mas los 64 bytes de la "ATTRUBUTE TABLE" de esos tiles.
Para direccionar cada tile en el tilemap se usa 1 byte: por eso, 960 tiles = 960 bytes.
RESUMIENDO:
1 NAMETABLE = 960 bytes de tilemap + 64 bytes = 1024 bytes. 1024 son 0x3FE, pero como contamos desde el primer byte, pues 0x3FF.

Pero lo que estamos viendo es información que está en la memoria de la PPU en ese momento.
LO QUE REALMENTE NOS INTERESA ES SABER EN QUÉ DIRECCIÓN DEL PRG SE ALMACENA EL TILEMAP (LOS TILEMAP VIVEN EN EL PRG).
Una buena manera de encontrarlo es coger una secuencia del tilemap y buscarla con hexedit en el .PRG
Si no está comprimida, esa tilemap debería estar ahí tal cual.
Y está: buscando en el .PRG por una serie de hex en HEXEDIT, encontramos que empieza en 0x57CF.

Extraemos el .PRG del WIKI PAL:
dd if=kiwi_pal.nes of=kiwi_pal.prg bs=1c skip=16 count=128K

Extraemos, del PRG PAL, 960 bytes a partir de esa dirección:
dd if=kiwi_pal.prg of=tilemap_title_pal bs=1c skip=$((0x57CF)) count=960

Insertamos los 960 bytes del tilemap en el .PRG NTSC:
dd if=tilemap_title_pal of=kiwi.prg bs=1c seek=$((0x57CF)) conv=notrunc

Insertamos el .PRG NTSC en la ROM NTSC modificada:
dd if=kiwi.prg of=kiwi2.nes bs=1c seek=16 conv=notrunc

EDITAR GRÁFICOS SENCILLOS (SPRITES)
===================================

Lo más fácil es usar el "Tile Layer Pro", que va con WINE.
Cargamos la ROM, montamos el "personaje" en el "Tile Arranger" ya que lo normal es que un personaje sean varios "tiles",
y cambiamos lo que queramos ahí.
